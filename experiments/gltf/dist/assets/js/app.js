/******/ (function(modules) { // webpackBootstrap
/******/ 	function hotDisposeChunk(chunkId) {
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/ 	var parentHotUpdateCallback = window["webpackHotUpdate"];
/******/ 	window["webpackHotUpdate"] = 
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/ 	
/******/ 	function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.type = "text/javascript";
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		;
/******/ 		head.appendChild(script);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadManifest(requestTimeout) { // eslint-disable-line no-unused-vars
/******/ 		requestTimeout = requestTimeout || 10000;
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if(typeof XMLHttpRequest === "undefined")
/******/ 				return reject(new Error("No browser support"));
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = requestTimeout;
/******/ 				request.send(null);
/******/ 			} catch(err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if(request.readyState !== 4) return;
/******/ 				if(request.status === 0) {
/******/ 					// timeout
/******/ 					reject(new Error("Manifest request to " + requestPath + " timed out."));
/******/ 				} else if(request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if(request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch(e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}
/******/
/******/ 	
/******/ 	
/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "aac4bc7543dc713d4d51"; // eslint-disable-line no-unused-vars
/******/ 	var hotRequestTimeout = 10000;
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = []; // eslint-disable-line no-unused-vars
/******/ 	
/******/ 	function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var me = installedModules[moduleId];
/******/ 		if(!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if(me.hot.active) {
/******/ 				if(installedModules[request]) {
/******/ 					if(installedModules[request].parents.indexOf(moduleId) < 0)
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if(me.children.indexOf(request) < 0)
/******/ 					me.children.push(request);
/******/ 			} else {
/******/ 				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for(var name in __webpack_require__) {
/******/ 			if(Object.prototype.hasOwnProperty.call(__webpack_require__, name) && name !== "e") {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if(hotStatus === "ready")
/******/ 				hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/ 	
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if(hotStatus === "prepare") {
/******/ 					if(!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/ 	
/******/ 	function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/ 	
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfAccepted = true;
/******/ 				else if(typeof dep === "function")
/******/ 					hot._selfAccepted = dep;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else
/******/ 					hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfDeclined = true;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else
/******/ 					hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if(!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/ 	
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/ 	
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for(var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/ 	
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/ 	
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/ 	
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = (+id) + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/ 	
/******/ 	function hotCheck(apply) {
/******/ 		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
/******/ 			if(!update) {
/******/ 				hotSetStatus("idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/ 	
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			var chunkId = 0;
/******/ 			{ // eslint-disable-line no-lone-blocks
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/ 	
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		if(!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for(var moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if(!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if(!deferred) return;
/******/ 		if(hotApplyOnUpdate) {
/******/ 			// Wrap deferred object in Promise to mark it as a well-handled Promise to
/******/ 			// avoid triggering uncaught exception warning in Chrome.
/******/ 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
/******/ 			Promise.resolve().then(function() {
/******/ 				return hotApply(hotApplyOnUpdate);
/******/ 			}).then(
/******/ 				function(result) {
/******/ 					deferred.resolve(result);
/******/ 				},
/******/ 				function(err) {
/******/ 					deferred.reject(err);
/******/ 				}
/******/ 			);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for(var id in hotUpdate) {
/******/ 				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotApply(options) {
/******/ 		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/ 	
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/ 	
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/ 	
/******/ 			var queue = outdatedModules.slice().map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while(queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if(!module || module.hot._selfAccepted)
/******/ 					continue;
/******/ 				if(module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if(module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for(var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if(!parent) continue;
/******/ 					if(parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if(outdatedModules.indexOf(parentId) >= 0) continue;
/******/ 					if(parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if(!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 	
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/ 	
/******/ 		function addAllToSet(a, b) {
/******/ 			for(var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if(a.indexOf(item) < 0)
/******/ 					a.push(item);
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/ 	
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn("[HMR] unexpected require(" + result.moduleId + ") to disposed module");
/******/ 		};
/******/ 	
/******/ 		for(var id in hotUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				var result;
/******/ 				if(hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if(result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch(result.type) {
/******/ 					case "self-declined":
/******/ 						if(options.onDeclined)
/******/ 							options.onDeclined(result);
/******/ 						if(!options.ignoreDeclined)
/******/ 							abortError = new Error("Aborted because of self decline: " + result.moduleId + chainInfo);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if(options.onDeclined)
/******/ 							options.onDeclined(result);
/******/ 						if(!options.ignoreDeclined)
/******/ 							abortError = new Error("Aborted because of declined dependency: " + result.moduleId + " in " + result.parentId + chainInfo);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if(options.onUnaccepted)
/******/ 							options.onUnaccepted(result);
/******/ 						if(!options.ignoreUnaccepted)
/******/ 							abortError = new Error("Aborted because " + moduleId + " is not accepted" + chainInfo);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if(options.onAccepted)
/******/ 							options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if(options.onDisposed)
/******/ 							options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if(abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if(doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for(moduleId in result.outdatedDependencies) {
/******/ 						if(Object.prototype.hasOwnProperty.call(result.outdatedDependencies, moduleId)) {
/******/ 							if(!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(outdatedDependencies[moduleId], result.outdatedDependencies[moduleId]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if(doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for(i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/ 	
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if(hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/ 	
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while(queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if(!module) continue;
/******/ 	
/******/ 			var data = {};
/******/ 	
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for(j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/ 	
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/ 	
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/ 	
/******/ 			// when disposing there is no need to call dispose handler
/******/ 			delete outdatedDependencies[moduleId];
/******/ 	
/******/ 			// remove "parents" references from all children
/******/ 			for(j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if(!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if(idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for(moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				module = installedModules[moduleId];
/******/ 				if(module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for(j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if(idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/ 	
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/ 	
/******/ 		// insert new code
/******/ 		for(moduleId in appliedUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for(moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				module = installedModules[moduleId];
/******/ 				if(module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					var callbacks = [];
/******/ 					for(i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 						dependency = moduleOutdatedDependencies[i];
/******/ 						cb = module.hot._acceptedDependencies[dependency];
/******/ 						if(cb) {
/******/ 							if(callbacks.indexOf(cb) >= 0) continue;
/******/ 							callbacks.push(cb);
/******/ 						}
/******/ 					}
/******/ 					for(i = 0; i < callbacks.length; i++) {
/******/ 						cb = callbacks[i];
/******/ 						try {
/******/ 							cb(moduleOutdatedDependencies);
/******/ 						} catch(err) {
/******/ 							if(options.onErrored) {
/******/ 								options.onErrored({
/******/ 									type: "accept-errored",
/******/ 									moduleId: moduleId,
/******/ 									dependencyId: moduleOutdatedDependencies[i],
/******/ 									error: err
/******/ 								});
/******/ 							}
/******/ 							if(!options.ignoreErrored) {
/******/ 								if(!error)
/******/ 									error = err;
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Load self accepted modules
/******/ 		for(i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch(err) {
/******/ 				if(typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch(err2) {
/******/ 						if(options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								orginalError: err, // TODO remove in webpack 4
/******/ 								originalError: err
/******/ 							});
/******/ 						}
/******/ 						if(!options.ignoreErrored) {
/******/ 							if(!error)
/******/ 								error = err2;
/******/ 						}
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if(options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if(!options.ignoreErrored) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if(error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/ 	
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(101)(__webpack_require__.s = 101);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // GLTool.js

var _glMatrix = __webpack_require__(1);

var _getAndApplyExtension = __webpack_require__(49);

var _getAndApplyExtension2 = _interopRequireDefault(_getAndApplyExtension);

var _exposeAttributes = __webpack_require__(50);

var _exposeAttributes2 = _interopRequireDefault(_exposeAttributes);

var _getFloat = __webpack_require__(51);

var _getFloat2 = _interopRequireDefault(_getFloat);

var _getHalfFloat = __webpack_require__(52);

var _getHalfFloat2 = _interopRequireDefault(_getHalfFloat);

var _getAttribLoc = __webpack_require__(25);

var _getAttribLoc2 = _interopRequireDefault(_getAttribLoc);

var _ExtensionsList = __webpack_require__(53);

var _ExtensionsList2 = _interopRequireDefault(_ExtensionsList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;

var GLTool = function () {
	function GLTool() {
		_classCallCheck(this, GLTool);

		this.canvas;
		this._viewport = [0, 0, 0, 0];
		this._enabledVertexAttribute = [];
		this.identityMatrix = _glMatrix.mat4.create();
		this._normalMatrix = _glMatrix.mat3.create();
		this._inverseModelViewMatrix = _glMatrix.mat3.create();
		this._modelMatrix = _glMatrix.mat4.create();
		this._matrix = _glMatrix.mat4.create();
		this._matrixStacks = [];
		this._lastMesh = null;
		this._useWebGL2 = false;
		this._hasArrayInstance;
		this._extArrayInstance;
		this._hasCheckedExt = false;
		_glMatrix.mat4.identity(this.identityMatrix, this.identityMatrix);

		this.isMobile = false;
		if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
			this.isMobile = true;
		}
	}

	//	INITIALIZE

	_createClass(GLTool, [{
		key: 'init',
		value: function init(mCanvas) {
			var mParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


			if (mCanvas === null || mCanvas === undefined) {
				console.error('Canvas not exist');
				return;
			}

			if (this.canvas !== undefined && this.canvas !== null) {
				this.destroy();
			}

			this.canvas = mCanvas;
			this.setSize(window.innerWidth, window.innerHeight);

			mParameters.useWebgl2 = mParameters.useWebgl2 || false;

			var ctx = void 0;
			if (mParameters.useWebgl2) {
				ctx = this.canvas.getContext('experimental-webgl2', mParameters) || this.canvas.getContext('webgl2', mParameters);

				if (!ctx) {
					ctx = this.canvas.getContext('webgl', mParameters) || this.canvas.getContext('experimental-webgl', mParameters);
					this._useWebGL2 = false;
				} else {
					this._useWebGL2 = true;
				}
			} else {
				// ctx = this.canvas.getContext('experimental-webgl2', mParameters) || this.canvas.getContext('webgl2', mParameters);
				// if(ctx) {
				// 	this._useWebGL2 = true;
				// } else {
				// 	ctx = this.canvas.getContext('webgl', mParameters) || this.canvas.getContext('experimental-webgl', mParameters);
				// }

				ctx = this.canvas.getContext('webgl', mParameters) || this.canvas.getContext('experimental-webgl', mParameters);
				this._useWebGL2 = false;
			}

			console.log('Using WebGL 2 ?', this.webgl2);

			//	extensions
			this.initWithGL(ctx);
		}
	}, {
		key: 'initWithGL',
		value: function initWithGL(ctx) {
			if (!this.canvas) {
				this.canvas = ctx.canvas;
			}
			gl = this.gl = ctx;

			this.extensions = {};
			for (var i = 0; i < _ExtensionsList2.default.length; i++) {
				this.extensions[_ExtensionsList2.default[i]] = gl.getExtension(_ExtensionsList2.default[i]);
			}

			//	Copy gl Attributes
			(0, _exposeAttributes2.default)();
			(0, _getAndApplyExtension2.default)(gl, 'OES_vertex_array_object');
			(0, _getAndApplyExtension2.default)(gl, 'ANGLE_instanced_arrays');
			(0, _getAndApplyExtension2.default)(gl, 'WEBGL_draw_buffers');

			this.enable(this.DEPTH_TEST);
			this.enable(this.CULL_FACE);
			this.enable(this.BLEND);
			this.enableAlphaBlending();
		}

		//	PUBLIC METHODS

	}, {
		key: 'setViewport',
		value: function setViewport(x, y, w, h) {
			var hasChanged = false;
			if (x !== this._viewport[0]) {
				hasChanged = true;
			}
			if (y !== this._viewport[1]) {
				hasChanged = true;
			}
			if (w !== this._viewport[2]) {
				hasChanged = true;
			}
			if (h !== this._viewport[3]) {
				hasChanged = true;
			}

			if (hasChanged) {
				gl.viewport(x, y, w, h);
				this._viewport = [x, y, w, h];
			}
		}
	}, {
		key: 'scissor',
		value: function scissor(x, y, w, h) {
			gl.scissor(x, y, w, h);
		}
	}, {
		key: 'clear',
		value: function clear(r, g, b, a) {
			gl.clearColor(r, g, b, a);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		}
	}, {
		key: 'cullFace',
		value: function cullFace(mValue) {
			gl.cullFace(mValue);
		}
	}, {
		key: 'setMatrices',
		value: function setMatrices(mCamera) {
			this.camera = mCamera;
			this.rotate(this.identityMatrix);
		}
	}, {
		key: 'useShader',
		value: function useShader(mShader) {
			this.shader = mShader;
			this.shaderProgram = this.shader.shaderProgram;
		}
	}, {
		key: 'rotate',
		value: function rotate(mRotation) {
			_glMatrix.mat4.copy(this._modelMatrix, mRotation);
			_glMatrix.mat4.multiply(this._matrix, this.camera.matrix, this._modelMatrix);
			_glMatrix.mat3.fromMat4(this._normalMatrix, this._matrix);
			_glMatrix.mat3.invert(this._normalMatrix, this._normalMatrix);
			_glMatrix.mat3.transpose(this._normalMatrix, this._normalMatrix);

			_glMatrix.mat3.fromMat4(this._inverseModelViewMatrix, this._matrix);
			_glMatrix.mat3.invert(this._inverseModelViewMatrix, this._inverseModelViewMatrix);
		}
	}, {
		key: 'draw',
		value: function draw(mMesh, mDrawingType) {
			if (mMesh.length) {
				for (var i = 0; i < mMesh.length; i++) {
					this.draw(mMesh[i]);
				}
				return;
			}

			mMesh.bind(this.shaderProgram);

			//	DEFAULT UNIFORMS
			if (this.camera !== undefined) {
				this.shader.uniform('uProjectionMatrix', 'mat4', this.camera.projection);
				this.shader.uniform('uViewMatrix', 'mat4', this.camera.matrix);
			}

			this.shader.uniform('uModelMatrix', 'mat4', this._modelMatrix);
			this.shader.uniform('uNormalMatrix', 'mat3', this._normalMatrix);
			this.shader.uniform('uModelViewMatrixInverse', 'mat3', this._inverseModelViewMatrix);

			var drawType = mMesh.drawType;
			if (mDrawingType !== undefined) {
				drawType = mDrawingType;
			}

			if (mMesh.isInstanced) {
				//	DRAWING
				gl.drawElementsInstanced(mMesh.drawType, mMesh.iBuffer.numItems, gl.UNSIGNED_SHORT, 0, mMesh.numInstance);
			} else {
				if (drawType === gl.POINTS) {
					gl.drawArrays(drawType, 0, mMesh.vertexSize);
				} else {
					gl.drawElements(drawType, mMesh.iBuffer.numItems, gl.UNSIGNED_SHORT, 0);
				}
			}

			mMesh.unbind();
		}
	}, {
		key: 'drawTransformFeedback',
		value: function drawTransformFeedback(mTransformObject) {
			var meshSource = mTransformObject.meshSource,
			    meshDestination = mTransformObject.meshDestination,
			    numPoints = mTransformObject.numPoints,
			    transformFeedback = mTransformObject.transformFeedback;

			//	BIND SOURCE BUFFERS -> setupVertexAttr(sourceVAO)

			meshSource.bind(this.shaderProgram);
			meshDestination.generateBuffers(this.shaderProgram);

			//	BIND DESTINATION BUFFERS
			gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedback);

			meshDestination.attributes.forEach(function (attr, i) {
				gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, attr.buffer);
			});

			gl.enable(gl.RASTERIZER_DISCARD);

			gl.beginTransformFeedback(gl.POINTS);
			gl.drawArrays(gl.POINTS, 0, numPoints);
			gl.endTransformFeedback();

			//	reset state
			gl.disable(gl.RASTERIZER_DISCARD);
			gl.useProgram(null);
			gl.bindBuffer(gl.ARRAY_BUFFER, null);
			meshDestination.attributes.forEach(function (attr, i) {
				gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, null);
			});
			gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);

			meshSource.unbind();
		}
	}, {
		key: 'setSize',
		value: function setSize(mWidth, mHeight) {
			this._width = mWidth;
			this._height = mHeight;
			this.canvas.width = this._width;
			this.canvas.height = this._height;
			this._aspectRatio = this._width / this._height;

			if (gl) {
				this.viewport(0, 0, this._width, this._height);
			}
		}
	}, {
		key: 'showExtensions',
		value: function showExtensions() {
			console.log('Extensions : ', this.extensions);
			for (var ext in this.extensions) {
				if (this.extensions[ext]) {
					console.log(ext, ':', this.extensions[ext]);
				}
			}
		}
	}, {
		key: 'checkExtension',
		value: function checkExtension(mExtension) {
			return !!this.extensions[mExtension];
		}
	}, {
		key: 'getExtension',
		value: function getExtension(mExtension) {
			return this.extensions[mExtension];
		}

		//	BLEND MODES

	}, {
		key: 'enableAlphaBlending',
		value: function enableAlphaBlending() {
			gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
		}
	}, {
		key: 'enableAdditiveBlending',
		value: function enableAdditiveBlending() {
			gl.blendFunc(gl.ONE, gl.ONE);
		}

		//	matrices

	}, {
		key: 'pushMatrix',
		value: function pushMatrix() {
			var mtx = _glMatrix.mat4.clone(this._modelMatrix);
			this._matrixStacks.push(mtx);
		}
	}, {
		key: 'popMatrix',
		value: function popMatrix() {
			if (this._matrixStacks.length == 0) {
				return null;
			}
			var mtx = this._matrixStacks.pop();
			this.rotate(mtx);
		}

		//	GL NATIVE FUNCTIONS

	}, {
		key: 'enable',
		value: function enable(mParameter) {
			gl.enable(mParameter);
		}
	}, {
		key: 'disable',
		value: function disable(mParameter) {
			gl.disable(mParameter);
		}
	}, {
		key: 'viewport',
		value: function viewport(x, y, w, h) {
			this.setViewport(x, y, w, h);
		}

		//	GETTER AND SETTERS

	}, {
		key: 'destroy',


		//	DESTROY

		value: function destroy() {

			if (this.canvas.parentNode) {
				try {
					this.canvas.parentNode.removeChild(this.canvas);
				} catch (e) {
					console.log('Error : ', e);
				}
			}

			this.canvas = null;
		}
	}, {
		key: 'FLOAT',
		get: function get() {
			return (0, _getFloat2.default)();
		}
	}, {
		key: 'HALF_FLOAT',
		get: function get() {
			return (0, _getHalfFloat2.default)();
		}
	}, {
		key: 'width',
		get: function get() {
			return this._width;
		}
	}, {
		key: 'height',
		get: function get() {
			return this._height;
		}
	}, {
		key: 'aspectRatio',
		get: function get() {
			return this._aspectRatio;
		}
	}, {
		key: 'webgl2',
		get: function get() {
			return this._useWebGL2;
		}
	}]);

	return GLTool;
}();

var GL = new GLTool();

exports.default = GL;

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__gl_matrix_common__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__gl_matrix_mat2__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__gl_matrix_mat2d__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__gl_matrix_mat3__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__gl_matrix_mat4__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__gl_matrix_quat__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__gl_matrix_vec2__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__gl_matrix_vec3__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__gl_matrix_vec4__ = __webpack_require__(23);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "glMatrix", function() { return __WEBPACK_IMPORTED_MODULE_0__gl_matrix_common__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2", function() { return __WEBPACK_IMPORTED_MODULE_1__gl_matrix_mat2__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2d", function() { return __WEBPACK_IMPORTED_MODULE_2__gl_matrix_mat2d__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat3", function() { return __WEBPACK_IMPORTED_MODULE_3__gl_matrix_mat3__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat4", function() { return __WEBPACK_IMPORTED_MODULE_4__gl_matrix_mat4__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quat", function() { return __WEBPACK_IMPORTED_MODULE_5__gl_matrix_quat__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec2", function() { return __WEBPACK_IMPORTED_MODULE_6__gl_matrix_vec2__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec3", function() { return __WEBPACK_IMPORTED_MODULE_7__gl_matrix_vec3__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec4", function() { return __WEBPACK_IMPORTED_MODULE_8__gl_matrix_vec4__; });
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.4.0
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */
// END HEADER













/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// GLShader.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var glslify = __webpack_require__(54);
var isSame = function isSame(array1, array2) {
	if (array1.length !== array2.length) {
		return false;
	}

	for (var i = 0; i < array1.length; i++) {
		if (array1[i] !== array2[i]) {
			return false;
		}
	}

	return true;
};

var addLineNumbers = function addLineNumbers(string) {
	var lines = string.split('\n');
	for (var i = 0; i < lines.length; i++) {
		lines[i] = i + 1 + ': ' + lines[i];
	}
	return lines.join('\n');
};

var cloneArray = function cloneArray(mArray) {
	if (mArray.slice) {
		return mArray.slice(0);
	} else {
		return new Float32Array(mArray);
	}
};

var gl = void 0;
var defaultVertexShader = __webpack_require__(11);
var defaultFragmentShader = __webpack_require__(55);

var uniformMapping = {
	float: 'uniform1f',
	vec2: 'uniform2fv',
	vec3: 'uniform3fv',
	vec4: 'uniform4fv',
	int: 'uniform1i',
	mat3: 'uniformMatrix3fv',
	mat4: 'uniformMatrix4fv'
};

var GLShader = function () {
	function GLShader() {
		var strVertexShader = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultVertexShader;
		var strFragmentShader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultFragmentShader;
		var mVaryings = arguments[2];

		_classCallCheck(this, GLShader);

		gl = _GLTool2.default.gl;
		this.parameters = [];
		this.uniformTextures = [];
		this._varyings = mVaryings;

		if (!strVertexShader) {
			strVertexShader = defaultVertexShader;
		}
		if (!strFragmentShader) {
			strFragmentShader = defaultVertexShader;
		}

		var vsShader = this._createShaderProgram(strVertexShader, true);
		var fsShader = this._createShaderProgram(strFragmentShader, false);
		this._attachShaderProgram(vsShader, fsShader);
	}

	_createClass(GLShader, [{
		key: 'bind',
		value: function bind() {

			if (_GLTool2.default.shader === this) {
				return;
			}
			gl.useProgram(this.shaderProgram);
			_GLTool2.default.useShader(this);
			this.uniformTextures = [];
		}
	}, {
		key: 'uniform',
		value: function uniform(mName, mType, mValue) {
			if ((typeof mName === 'undefined' ? 'undefined' : _typeof(mName)) === 'object') {
				this.uniformObject(mName);
				return;
			}
			/*
   if(!!mValue === undefined || mValue === null) {
   	console.warn('mValue Error:', mName);
   	return;
   }
   */
			var uniformType = uniformMapping[mType] || mType;

			var hasUniform = false;
			var oUniform = void 0;
			var parameterIndex = -1;

			for (var i = 0; i < this.parameters.length; i++) {
				oUniform = this.parameters[i];
				if (oUniform.name === mName) {
					hasUniform = true;
					parameterIndex = i;
					break;
				}
			}

			var isNumber = false;

			if (!hasUniform) {
				isNumber = uniformType === 'uniform1i' || uniformType === 'uniform1f';
				this.shaderProgram[mName] = gl.getUniformLocation(this.shaderProgram, mName);
				if (isNumber) {
					this.parameters.push({ name: mName, type: uniformType, value: mValue, uniformLoc: this.shaderProgram[mName], isNumber: isNumber });
				} else {
					this.parameters.push({ name: mName, type: uniformType, value: cloneArray(mValue), uniformLoc: this.shaderProgram[mName], isNumber: isNumber });
				}

				parameterIndex = this.parameters.length - 1;
			} else {
				this.shaderProgram[mName] = oUniform.uniformLoc;
				isNumber = oUniform.isNumber;
			}

			if (!this.parameters[parameterIndex].uniformLoc) {
				return;
			}

			if (uniformType.indexOf('Matrix') === -1) {
				if (!isNumber) {
					if (!isSame(this.parameters[parameterIndex].value, mValue) || !hasUniform) {
						gl[uniformType](this.shaderProgram[mName], mValue);
						this.parameters[parameterIndex].value = cloneArray(mValue);
					}
				} else {
					var needUpdate = this.parameters[parameterIndex].value !== mValue || !hasUniform;
					if (needUpdate) {
						gl[uniformType](this.shaderProgram[mName], mValue);
						this.parameters[parameterIndex].value = mValue;
					}
				}
			} else {
				if (!isSame(this.parameters[parameterIndex].value, mValue) || !hasUniform) {
					gl[uniformType](this.shaderProgram[mName], false, mValue);
					this.parameters[parameterIndex].value = cloneArray(mValue);
				}
			}
		}
	}, {
		key: 'uniformObject',
		value: function uniformObject(mUniformObj) {
			for (var uniformName in mUniformObj) {
				var uniformValue = mUniformObj[uniformName];
				var uniformType = GLShader.getUniformType(uniformValue);

				if (uniformValue.concat && uniformValue[0].concat) {
					var tmp = [];
					for (var i = 0; i < uniformValue.length; i++) {
						tmp = tmp.concat(uniformValue[i]);
					}
					uniformValue = tmp;
				}

				this.uniform(uniformName, uniformType, uniformValue);
			}
		}
	}, {
		key: '_createShaderProgram',
		value: function _createShaderProgram(mShaderStr, isVertexShader) {

			var shaderType = isVertexShader ? _GLTool2.default.VERTEX_SHADER : _GLTool2.default.FRAGMENT_SHADER;
			var shader = gl.createShader(shaderType);

			gl.shaderSource(shader, mShaderStr);
			gl.compileShader(shader);

			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				console.warn('Error in Shader : ', gl.getShaderInfoLog(shader));
				console.log(addLineNumbers(mShaderStr));
				return null;
			}

			return shader;
		}
	}, {
		key: '_attachShaderProgram',
		value: function _attachShaderProgram(mVertexShader, mFragmentShader) {

			this.shaderProgram = gl.createProgram();
			gl.attachShader(this.shaderProgram, mVertexShader);
			gl.attachShader(this.shaderProgram, mFragmentShader);

			gl.deleteShader(mVertexShader);
			gl.deleteShader(mFragmentShader);

			if (this._varyings) {
				console.log('Transform feedback setup : ', this._varyings);
				gl.transformFeedbackVaryings(this.shaderProgram, this._varyings, gl.SEPARATE_ATTRIBS);
			}

			gl.linkProgram(this.shaderProgram);
		}
	}]);

	return GLShader;
}();

GLShader.getUniformType = function (mValue) {
	var isArray = !!mValue.concat;

	var getArrayUniformType = function getArrayUniformType(mValue) {
		if (mValue.length === 9) {
			return 'uniformMatrix3fv';
		} else if (mValue.length === 16) {
			return 'uniformMatrix4fv';
		} else {
			return 'vec' + mValue.length;
		}
	};

	if (!isArray) {
		return 'float';
	} else {
		if (!mValue[0].concat) {
			return getArrayUniformType(mValue);
		} else {
			return getArrayUniformType(mValue[0]);
		}
	}
};

exports.default = GLShader;

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARRAY_TYPE", function() { return ARRAY_TYPE; });
/* harmony export (immutable) */ __webpack_exports__["setMatrixArrayType"] = setMatrixArrayType;
/* harmony export (immutable) */ __webpack_exports__["toRadian"] = toRadian;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

/**
 * Common utilities
 * @module glMatrix
 */

// Configuration Constants
const EPSILON = 0.000001;
/* harmony export (immutable) */ __webpack_exports__["EPSILON"] = EPSILON;

let ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
const RANDOM = Math.random;
/* harmony export (immutable) */ __webpack_exports__["RANDOM"] = RANDOM;


/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}

const degree = Math.PI / 180;

/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */
function toRadian(a) {
  return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
function equals(a, b) {
  return Math.abs(a - b) <= EPSILON*Math.max(1.0, Math.abs(a), Math.abs(b));
}


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _glMatrix = __webpack_require__(1);

var _getAttribLoc = __webpack_require__(25);

var _getAttribLoc2 = _interopRequireDefault(_getAttribLoc);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;
var STATIC_DRAW = 35044;

var getBuffer = function getBuffer(attr) {
	var buffer = void 0;

	if (attr.buffer !== undefined) {
		buffer = attr.buffer;
	} else {
		buffer = gl.createBuffer();
		attr.buffer = buffer;
	}

	return buffer;
};

var formBuffer = function formBuffer(mData, mNum) {
	var ary = [];

	for (var i = 0; i < mData.length; i += mNum) {
		var o = [];
		for (var j = 0; j < mNum; j++) {
			o.push(mData[i + j]);
		}

		ary.push(o);
	}

	return ary;
};

var Mesh = function () {
	function Mesh() {
		var mDrawingType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;
		var mUseVao = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

		_classCallCheck(this, Mesh);

		gl = _GLTool2.default.gl;
		this.drawType = mDrawingType;
		this._attributes = [];
		this._numInstance = -1;
		this._enabledVertexAttribute = [];

		this._indices = [];
		this._faces = [];
		this._bufferChanged = [];
		this._hasIndexBufferChanged = false;
		this._hasVAO = false;
		this._isInstanced = false;

		this._extVAO = !!_GLTool2.default.gl.createVertexArray;
		this._useVAO = !!this._extVAO && mUseVao;
		// this._useVAO = false;
	}

	_createClass(Mesh, [{
		key: 'bufferVertex',
		value: function bufferVertex(mArrayVertices) {
			var mDrawType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : STATIC_DRAW;


			this.bufferData(mArrayVertices, 'aVertexPosition', 3, mDrawType);

			if (this.normals.length < this.vertices.length) {
				this.bufferNormal(mArrayVertices, mDrawType);
			}

			return this;
		}
	}, {
		key: 'bufferTexCoord',
		value: function bufferTexCoord(mArrayTexCoords) {
			var mDrawType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : STATIC_DRAW;


			this.bufferData(mArrayTexCoords, 'aTextureCoord', 2, mDrawType);
			return this;
		}
	}, {
		key: 'bufferNormal',
		value: function bufferNormal(mNormals) {
			var mDrawType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : STATIC_DRAW;


			this.bufferData(mNormals, 'aNormal', 3, mDrawType);
			return this;
		}
	}, {
		key: 'bufferIndex',
		value: function bufferIndex(mArrayIndices) {
			var isDynamic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

			this._drawType = isDynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
			if (mArrayIndices instanceof Array) {
				this._indices = new Uint16Array(mArrayIndices);
			} else {
				this._indices = mArrayIndices;
			}

			this._numItems = this._indices.length;
			return this;
		}
	}, {
		key: 'bufferFlattenData',
		value: function bufferFlattenData(mData, mName, mItemSize) {
			var mDrawType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : STATIC_DRAW;
			var isInstanced = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;


			var data = formBuffer(mData, mItemSize);
			this.bufferData(data, mName, mItemSize, mDrawType = STATIC_DRAW, isInstanced = false);
			return this;
		}
	}, {
		key: 'bufferData',
		value: function bufferData(mData, mName, mItemSize) {
			var mDrawType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : STATIC_DRAW;
			var isInstanced = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

			var i = 0;
			var drawType = mDrawType;
			if (!drawType) debugger;

			var bufferData = [];
			if (!mItemSize) {
				mItemSize = mData[0].length;
			}
			this._isInstanced = isInstanced || this._isInstanced;

			//	flatten buffer data		
			for (i = 0; i < mData.length; i++) {
				for (var j = 0; j < mData[i].length; j++) {
					bufferData.push(mData[i][j]);
				}
			}
			var dataArray = new Float32Array(bufferData);
			var attribute = this.getAttribute(mName);

			if (attribute) {
				//	attribute existed, replace with new data
				attribute.itemSize = mItemSize;
				attribute.dataArray = dataArray;
				attribute.source = mData;
			} else {
				//	attribute not exist yet, create new attribute object
				this._attributes.push({ name: mName, source: mData, itemSize: mItemSize, drawType: drawType, dataArray: dataArray, isInstanced: isInstanced });
			}

			this._bufferChanged.push(mName);
			return this;
		}
	}, {
		key: 'bufferInstance',
		value: function bufferInstance(mData, mName) {
			if (!_GLTool2.default.gl.vertexAttribDivisor) {
				console.error('Extension : ANGLE_instanced_arrays is not supported with this device !');
				return;
			}

			var itemSize = mData[0].length;
			this._numInstance = mData.length;
			this.bufferData(mData, mName, itemSize, STATIC_DRAW, true);
		}
	}, {
		key: 'bind',
		value: function bind(mShaderProgram) {
			this.generateBuffers(mShaderProgram);

			if (this.hasVAO) {
				gl.bindVertexArray(this.vao);
			} else {
				this.attributes.forEach(function (attribute) {
					gl.bindBuffer(gl.ARRAY_BUFFER, attribute.buffer);
					var attrPosition = attribute.attrPosition;
					gl.vertexAttribPointer(attrPosition, attribute.itemSize, gl.FLOAT, false, 0, 0);

					if (attribute.isInstanced) {
						gl.vertexAttribDivisor(attrPosition, 1);
					}
				});

				//	BIND INDEX BUFFER
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.iBuffer);
			}
		}
	}, {
		key: 'generateBuffers',
		value: function generateBuffers(mShaderProgram) {
			var _this = this;

			if (this._bufferChanged.length == 0) {
				return;
			}

			if (this._useVAO) {
				//	IF SUPPORTED, CREATE VAO

				//	CREATE & BIND VAO
				if (!this._vao) {
					this._vao = gl.createVertexArray();
				}

				gl.bindVertexArray(this._vao);

				//	UPDATE BUFFERS
				this._attributes.forEach(function (attrObj) {

					if (_this._bufferChanged.indexOf(attrObj.name) !== -1) {
						var buffer = getBuffer(attrObj);
						gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
						gl.bufferData(gl.ARRAY_BUFFER, attrObj.dataArray, attrObj.drawType);

						var attrPosition = (0, _getAttribLoc2.default)(gl, mShaderProgram, attrObj.name);
						gl.enableVertexAttribArray(attrPosition);
						gl.vertexAttribPointer(attrPosition, attrObj.itemSize, gl.FLOAT, false, 0, 0);
						attrObj.attrPosition = attrPosition;

						if (attrObj.isInstanced) {
							gl.vertexAttribDivisor(attrPosition, 1);
						}
					}
				});

				//	check index buffer
				this._updateIndexBuffer();

				//	UNBIND VAO
				gl.bindVertexArray(null);

				this._hasVAO = true;
			} else {
				//	ELSE, USE TRADITIONAL METHOD

				this._attributes.forEach(function (attrObj) {
					//	SKIP IF BUFFER HASN'T CHANGED
					if (_this._bufferChanged.indexOf(attrObj.name) !== -1) {
						var buffer = getBuffer(attrObj);
						gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
						gl.bufferData(gl.ARRAY_BUFFER, attrObj.dataArray, attrObj.drawType);

						var attrPosition = (0, _getAttribLoc2.default)(gl, mShaderProgram, attrObj.name);
						gl.enableVertexAttribArray(attrPosition);
						gl.vertexAttribPointer(attrPosition, attrObj.itemSize, gl.FLOAT, false, 0, 0);
						attrObj.attrPosition = attrPosition;

						if (attrObj.isInstanced) {
							gl.vertexAttribDivisor(attrPosition, 1);
						}
					}
				});

				this._updateIndexBuffer();
			}

			this._hasIndexBufferChanged = false;
			this._bufferChanged = [];
		}
	}, {
		key: 'unbind',
		value: function unbind() {
			if (this._useVAO) {
				gl.bindVertexArray(null);
			}

			this._attributes.forEach(function (attribute) {
				if (attribute.isInstanced) {
					gl.vertexAttribDivisor(attribute.attrPosition, 0);
				}
			});
		}
	}, {
		key: '_updateIndexBuffer',
		value: function _updateIndexBuffer() {
			if (!this._hasIndexBufferChanged) {
				if (!this.iBuffer) {
					this.iBuffer = gl.createBuffer();
				}
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.iBuffer);
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indices, this._drawType);
				this.iBuffer.itemSize = 1;
				this.iBuffer.numItems = this._numItems;
			}
		}
	}, {
		key: 'computeNormals',
		value: function computeNormals() {
			var usingFaceNormals = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;


			this.generateFaces();

			if (usingFaceNormals) {
				this._computeFaceNormals();
			} else {
				this._computeVertexNormals();
			}
		}

		//	PRIVATE METHODS

	}, {
		key: '_computeFaceNormals',
		value: function _computeFaceNormals() {

			var faceIndex = void 0;
			var face = void 0;
			var normals = [];

			for (var i = 0; i < this._indices.length; i += 3) {
				faceIndex = i / 3;
				face = this._faces[faceIndex];
				var N = face.normal;

				normals[face.indices[0]] = N;
				normals[face.indices[1]] = N;
				normals[face.indices[2]] = N;
			}

			this.bufferNormal(normals);
		}
	}, {
		key: '_computeVertexNormals',
		value: function _computeVertexNormals() {
			//	loop through all vertices
			var face = void 0;
			var sumNormal = _glMatrix.vec3.create();
			var normals = [];
			var vertices = this.vertices;


			for (var i = 0; i < vertices.length; i++) {

				_glMatrix.vec3.set(sumNormal, 0, 0, 0);

				for (var j = 0; j < this._faces.length; j++) {
					face = this._faces[j];

					//	if vertex exist in the face, add the normal to sum normal
					if (face.indices.indexOf(i) >= 0) {

						sumNormal[0] += face.normal[0];
						sumNormal[1] += face.normal[1];
						sumNormal[2] += face.normal[2];
					}
				}

				_glMatrix.vec3.normalize(sumNormal, sumNormal);
				normals.push([sumNormal[0], sumNormal[1], sumNormal[2]]);
			}

			this.bufferNormal(normals);
		}
	}, {
		key: 'generateFaces',
		value: function generateFaces() {
			var ia = void 0,
			    ib = void 0,
			    ic = void 0;
			var a = void 0,
			    b = void 0,
			    c = void 0;
			var vba = _glMatrix.vec3.create(),
			    vca = _glMatrix.vec3.create(),
			    vNormal = _glMatrix.vec3.create();
			var vertices = this.vertices;


			for (var i = 0; i < this._indices.length; i += 3) {

				ia = this._indices[i];
				ib = this._indices[i + 1];
				ic = this._indices[i + 2];

				a = vertices[ia];
				b = vertices[ib];
				c = vertices[ic];

				var face = {
					indices: [ia, ib, ic],
					vertices: [a, b, c]
				};

				this._faces.push(face);
			}
		}
	}, {
		key: 'getAttribute',
		value: function getAttribute(mName) {
			return this._attributes.find(function (a) {
				return a.name === mName;
			});
		}
	}, {
		key: 'getSource',
		value: function getSource(mName) {
			var attr = this.getAttribute(mName);
			return attr ? attr.source : [];
		}

		//	GETTER AND SETTERS

	}, {
		key: 'vertices',
		get: function get() {
			return this.getSource('aVertexPosition');
		}
	}, {
		key: 'normals',
		get: function get() {
			return this.getSource('aNormal');
		}
	}, {
		key: 'coords',
		get: function get() {
			return this.getSource('aTextureCoord');
		}
	}, {
		key: 'indices',
		get: function get() {
			return this._indices;
		}
	}, {
		key: 'vertexSize',
		get: function get() {
			return this.vertices.length;
		}
	}, {
		key: 'faces',
		get: function get() {
			return this._faces;
		}
	}, {
		key: 'attributes',
		get: function get() {
			return this._attributes;
		}
	}, {
		key: 'hasVAO',
		get: function get() {
			return this._hasVAO;
		}
	}, {
		key: 'vao',
		get: function get() {
			return this._vao;
		}
	}, {
		key: 'numInstance',
		get: function get() {
			return this._numInstance;
		}
	}, {
		key: 'isInstanced',
		get: function get() {
			return this._isInstanced;
		}
	}]);

	return Mesh;
}();

exports.default = Mesh;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Batch.js

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Batch = function () {
	function Batch(mMesh, mShader) {
		_classCallCheck(this, Batch);

		this._mesh = mMesh;
		this._shader = mShader;
	}

	//	PUBLIC METHODS

	_createClass(Batch, [{
		key: 'draw',
		value: function draw() {
			this._shader.bind();
			_GLTool2.default.draw(this.mesh);
		}

		//	GETTER AND SETTER

	}, {
		key: 'mesh',
		get: function get() {
			return this._mesh;
		}
	}, {
		key: 'shader',
		get: function get() {
			return this._shader;
		}
	}]);

	return Batch;
}();

exports.default = Batch;

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
// Scheduler.js


class Scheduler {

	constructor() {
		this._delayTasks = [];
		this._nextTasks = [];
		this._deferTasks = [];
		this._highTasks = [];
		this._usurpTask = [];
		this._enterframeTasks = [];
		this._idTable = 0;
		this.frameRate = 60;
		this._startTime = new Date().getTime();

		this._deltaTime = 0;

		this._loop();
	}


	//  PUBLIC METHODS

	addEF(func, params) {
		params = params || [];
		const id = this._idTable;
		this._enterframeTasks[id] = { func, params };
		this._idTable ++;
		return id;
	}

	removeEF(id) {
		if (this._enterframeTasks[id] !== undefined) {
			this._enterframeTasks[id] = null;
		}
		return -1;
	}

	delay(func, params, delay) {
		const time = new Date().getTime();
		const t = { func, params, delay, time };
		this._delayTasks.push(t);
	}

	defer(func, params) {
		const t = { func, params };
		this._deferTasks.push(t);
	}

	next(func, params) {
		const t = { func, params };
		this._nextTasks.push(t);
	}

	usurp(func, params) {
		const t = { func, params };
		this._usurpTask.push(t);
	}


	//  PRIVATE METHODS

	_process() {
		let i = 0;
		let task;
		let interval;
		let current;
		for (i = 0; i < this._enterframeTasks.length; i++) {
			task = this._enterframeTasks[i];
			if (task !== null && task !== undefined) {
				task.func(task.params);
			}
		}

		while (this._highTasks.length > 0) {
			task = this._highTasks.pop();
			task.func(task.params);
		}


		let startTime = new Date().getTime();
		this._deltaTime = (startTime - this._startTime)/1000;

		for (i = 0; i < this._delayTasks.length; i++) {
			task = this._delayTasks[i];
			if (startTime - task.time > task.delay) {
				task.func(task.params);
				this._delayTasks.splice(i, 1);
			}
		}

		startTime = new Date().getTime();
		this._deltaTime = (startTime - this._startTime)/1000;
		interval = 1000 / this.frameRate;
		while (this._deferTasks.length > 0) {
			task = this._deferTasks.shift();
			current = new Date().getTime();
			if (current - startTime < interval) {
				task.func(task.params);
			} else {
				this._deferTasks.unshift(task);
				break;
			}
		}


		startTime = new Date().getTime();
		this._deltaTime = (startTime - this._startTime)/1000;
		interval = 1000 / this.frameRate;
		while (this._usurpTask.length > 0) {
			task = this._usurpTask.shift();
			current = new Date().getTime();
			if (current - startTime < interval) {
				task.func(task.params);
			}
		}

		this._highTasks = this._highTasks.concat(this._nextTasks);
		this._nextTasks = [];
		this._usurpTask = [];
	}


	_loop() {
		this._process();
		window.requestAnimationFrame(() => this._loop());
	}

	get deltaTime() {
		return this._deltaTime;
	}
}

const scheduler = new Scheduler();

/* harmony default export */ __webpack_exports__["default"] = (scheduler);


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Geom.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Mesh = __webpack_require__(4);

var _Mesh2 = _interopRequireDefault(_Mesh);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Geom = {};
var meshTri = void 0;

Geom.plane = function plane(width, height, numSegments) {
	var axis = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'xy';
	var drawType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 4;

	var positions = [];
	var coords = [];
	var indices = [];
	var normals = [];

	var gapX = width / numSegments;
	var gapY = height / numSegments;
	var gapUV = 1 / numSegments;
	var sx = -width * 0.5;
	var sy = -height * 0.5;
	var index = 0;

	for (var i = 0; i < numSegments; i++) {
		for (var j = 0; j < numSegments; j++) {
			var tx = gapX * i + sx;
			var ty = gapY * j + sy;

			var u = i / numSegments;
			var v = j / numSegments;

			if (axis === 'xz') {
				positions.push([tx, 0, ty + gapY]);
				positions.push([tx + gapX, 0, ty + gapY]);
				positions.push([tx + gapX, 0, ty]);
				positions.push([tx, 0, ty]);

				coords.push([u, 1.0 - (v + gapUV)]);
				coords.push([u + gapUV, 1.0 - (v + gapUV)]);
				coords.push([u + gapUV, 1.0 - v]);
				coords.push([u, 1.0 - v]);

				normals.push([0, 1, 0]);
				normals.push([0, 1, 0]);
				normals.push([0, 1, 0]);
				normals.push([0, 1, 0]);
			} else if (axis === 'yz') {
				positions.push([0, ty, tx]);
				positions.push([0, ty, tx + gapX]);
				positions.push([0, ty + gapY, tx + gapX]);
				positions.push([0, ty + gapY, tx]);

				coords.push([u, v]);
				coords.push([u + gapUV, v]);
				coords.push([u + gapUV, v + gapUV]);
				coords.push([u, v + gapUV]);

				normals.push([1, 0, 0]);
				normals.push([1, 0, 0]);
				normals.push([1, 0, 0]);
				normals.push([1, 0, 0]);
			} else {
				positions.push([tx, ty, 0]);
				positions.push([tx + gapX, ty, 0]);
				positions.push([tx + gapX, ty + gapY, 0]);
				positions.push([tx, ty + gapY, 0]);

				coords.push([u, v]);
				coords.push([u + gapUV, v]);
				coords.push([u + gapUV, v + gapUV]);
				coords.push([u, v + gapUV]);

				normals.push([0, 0, 1]);
				normals.push([0, 0, 1]);
				normals.push([0, 0, 1]);
				normals.push([0, 0, 1]);
			}

			indices.push(index * 4 + 0);
			indices.push(index * 4 + 1);
			indices.push(index * 4 + 2);
			indices.push(index * 4 + 0);
			indices.push(index * 4 + 2);
			indices.push(index * 4 + 3);

			index++;
		}
	}

	var mesh = new _Mesh2.default(drawType);
	mesh.bufferVertex(positions);
	mesh.bufferTexCoord(coords);
	mesh.bufferIndex(indices);
	mesh.bufferNormal(normals);

	return mesh;
};

Geom.sphere = function sphere(size, numSegments) {
	var isInvert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	var drawType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 4;

	var positions = [];
	var coords = [];
	var indices = [];
	var normals = [];
	var gapUV = 1 / numSegments;
	var index = 0;

	function getPosition(i, j) {
		var isNormal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
		//	rx : -90 ~ 90 , ry : 0 ~ 360
		var rx = i / numSegments * Math.PI - Math.PI * 0.5;
		var ry = j / numSegments * Math.PI * 2;
		var r = isNormal ? 1 : size;
		var pos = [];
		pos[1] = Math.sin(rx) * r;
		var t = Math.cos(rx) * r;
		pos[0] = Math.cos(ry) * t;
		pos[2] = Math.sin(ry) * t;

		var precision = 10000;
		pos[0] = Math.floor(pos[0] * precision) / precision;
		pos[1] = Math.floor(pos[1] * precision) / precision;
		pos[2] = Math.floor(pos[2] * precision) / precision;

		return pos;
	};

	for (var i = 0; i < numSegments; i++) {
		for (var j = 0; j < numSegments; j++) {
			positions.push(getPosition(i, j));
			positions.push(getPosition(i + 1, j));
			positions.push(getPosition(i + 1, j + 1));
			positions.push(getPosition(i, j + 1));

			normals.push(getPosition(i, j, true));
			normals.push(getPosition(i + 1, j, true));
			normals.push(getPosition(i + 1, j + 1, true));
			normals.push(getPosition(i, j + 1, true));

			var u = j / numSegments;
			var v = i / numSegments;

			coords.push([1.0 - u, v]);
			coords.push([1.0 - u, v + gapUV]);
			coords.push([1.0 - u - gapUV, v + gapUV]);
			coords.push([1.0 - u - gapUV, v]);

			indices.push(index * 4 + 0);
			indices.push(index * 4 + 1);
			indices.push(index * 4 + 2);
			indices.push(index * 4 + 0);
			indices.push(index * 4 + 2);
			indices.push(index * 4 + 3);

			index++;
		}
	}

	if (isInvert) {
		indices.reverse();
	}

	var mesh = new _Mesh2.default(drawType);
	mesh.bufferVertex(positions);
	mesh.bufferTexCoord(coords);
	mesh.bufferIndex(indices);
	mesh.bufferNormal(normals);

	return mesh;
};

Geom.cube = function cube(w, h, d) {
	var drawType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 4;

	h = h || w;
	d = d || w;

	var x = w / 2;
	var y = h / 2;
	var z = d / 2;

	var positions = [];
	var coords = [];
	var indices = [];
	var normals = [];
	var count = 0;

	// BACK
	positions.push([-x, y, -z]);
	positions.push([x, y, -z]);
	positions.push([x, -y, -z]);
	positions.push([-x, -y, -z]);

	normals.push([0, 0, -1]);
	normals.push([0, 0, -1]);
	normals.push([0, 0, -1]);
	normals.push([0, 0, -1]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// RIGHT
	positions.push([x, y, -z]);
	positions.push([x, y, z]);
	positions.push([x, -y, z]);
	positions.push([x, -y, -z]);

	normals.push([1, 0, 0]);
	normals.push([1, 0, 0]);
	normals.push([1, 0, 0]);
	normals.push([1, 0, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// FRONT
	positions.push([x, y, z]);
	positions.push([-x, y, z]);
	positions.push([-x, -y, z]);
	positions.push([x, -y, z]);

	normals.push([0, 0, 1]);
	normals.push([0, 0, 1]);
	normals.push([0, 0, 1]);
	normals.push([0, 0, 1]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// LEFT
	positions.push([-x, y, z]);
	positions.push([-x, y, -z]);
	positions.push([-x, -y, -z]);
	positions.push([-x, -y, z]);

	normals.push([-1, 0, 0]);
	normals.push([-1, 0, 0]);
	normals.push([-1, 0, 0]);
	normals.push([-1, 0, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// TOP
	positions.push([x, y, -z]);
	positions.push([-x, y, -z]);
	positions.push([-x, y, z]);
	positions.push([x, y, z]);

	normals.push([0, 1, 0]);
	normals.push([0, 1, 0]);
	normals.push([0, 1, 0]);
	normals.push([0, 1, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// BOTTOM
	positions.push([x, -y, z]);
	positions.push([-x, -y, z]);
	positions.push([-x, -y, -z]);
	positions.push([x, -y, -z]);

	normals.push([0, -1, 0]);
	normals.push([0, -1, 0]);
	normals.push([0, -1, 0]);
	normals.push([0, -1, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	var mesh = new _Mesh2.default(drawType);
	mesh.bufferVertex(positions);
	mesh.bufferTexCoord(coords);
	mesh.bufferIndex(indices);
	mesh.bufferNormal(normals);

	return mesh;
};

Geom.skybox = function skybox(size) {
	var drawType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;

	var positions = [];
	var coords = [];
	var indices = [];
	var normals = [];
	var count = 0;

	// BACK
	positions.push([size, size, -size]);
	positions.push([-size, size, -size]);
	positions.push([-size, -size, -size]);
	positions.push([size, -size, -size]);

	normals.push([0, 0, -1]);
	normals.push([0, 0, -1]);
	normals.push([0, 0, -1]);
	normals.push([0, 0, -1]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// RIGHT
	positions.push([size, -size, -size]);
	positions.push([size, -size, size]);
	positions.push([size, size, size]);
	positions.push([size, size, -size]);

	normals.push([1, 0, 0]);
	normals.push([1, 0, 0]);
	normals.push([1, 0, 0]);
	normals.push([1, 0, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// FRONT
	positions.push([-size, size, size]);
	positions.push([size, size, size]);
	positions.push([size, -size, size]);
	positions.push([-size, -size, size]);

	normals.push([0, 0, 1]);
	normals.push([0, 0, 1]);
	normals.push([0, 0, 1]);
	normals.push([0, 0, 1]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// LEFT
	positions.push([-size, -size, size]);
	positions.push([-size, -size, -size]);
	positions.push([-size, size, -size]);
	positions.push([-size, size, size]);

	normals.push([-1, 0, 0]);
	normals.push([-1, 0, 0]);
	normals.push([-1, 0, 0]);
	normals.push([-1, 0, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// TOP
	positions.push([size, size, size]);
	positions.push([-size, size, size]);
	positions.push([-size, size, -size]);
	positions.push([size, size, -size]);

	normals.push([0, 1, 0]);
	normals.push([0, 1, 0]);
	normals.push([0, 1, 0]);
	normals.push([0, 1, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// BOTTOM
	positions.push([size, -size, -size]);
	positions.push([-size, -size, -size]);
	positions.push([-size, -size, size]);
	positions.push([size, -size, size]);

	normals.push([0, -1, 0]);
	normals.push([0, -1, 0]);
	normals.push([0, -1, 0]);
	normals.push([0, -1, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	var mesh = new _Mesh2.default(drawType);
	mesh.bufferVertex(positions);
	mesh.bufferTexCoord(coords);
	mesh.bufferIndex(indices);
	mesh.bufferNormal(normals);

	return mesh;
};

Geom.bigTriangle = function bigTriangle() {

	if (!meshTri) {
		var indices = [2, 1, 0];
		var positions = [[-1, -1], [-1, 4], [4, -1]];

		meshTri = new _Mesh2.default();
		meshTri.bufferData(positions, 'aPosition', 2);
		meshTri.bufferIndex(indices);
	}

	return meshTri;
};

exports.default = Geom;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// stolen there https://github.com/mattdesl/gl-constants thanks @mattdesl ^^
module.exports = {
	0: 'NONE',
	1: 'ONE',
	2: 'LINE_LOOP',
	3: 'LINE_STRIP',
	4: 'TRIANGLES',
	5: 'TRIANGLE_STRIP',
	6: 'TRIANGLE_FAN',
	256: 'DEPTH_BUFFER_BIT',
	512: 'NEVER',
	513: 'LESS',
	514: 'EQUAL',
	515: 'LEQUAL',
	516: 'GREATER',
	517: 'NOTEQUAL',
	518: 'GEQUAL',
	519: 'ALWAYS',
	768: 'SRC_COLOR',
	769: 'ONE_MINUS_SRC_COLOR',
	770: 'SRC_ALPHA',
	771: 'ONE_MINUS_SRC_ALPHA',
	772: 'DST_ALPHA',
	773: 'ONE_MINUS_DST_ALPHA',
	774: 'DST_COLOR',
	775: 'ONE_MINUS_DST_COLOR',
	776: 'SRC_ALPHA_SATURATE',
	1024: 'STENCIL_BUFFER_BIT',
	1028: 'FRONT',
	1029: 'BACK',
	1032: 'FRONT_AND_BACK',
	1280: 'INVALID_ENUM',
	1281: 'INVALID_VALUE',
	1282: 'INVALID_OPERATION',
	1285: 'OUT_OF_MEMORY',
	1286: 'INVALID_FRAMEBUFFER_OPERATION',
	2304: 'CW',
	2305: 'CCW',
	2849: 'LINE_WIDTH',
	2884: 'CULL_FACE',
	2885: 'CULL_FACE_MODE',
	2886: 'FRONT_FACE',
	2928: 'DEPTH_RANGE',
	2929: 'DEPTH_TEST',
	2930: 'DEPTH_WRITEMASK',
	2931: 'DEPTH_CLEAR_VALUE',
	2932: 'DEPTH_FUNC',
	2960: 'STENCIL_TEST',
	2961: 'STENCIL_CLEAR_VALUE',
	2962: 'STENCIL_FUNC',
	2963: 'STENCIL_VALUE_MASK',
	2964: 'STENCIL_FAIL',
	2965: 'STENCIL_PASS_DEPTH_FAIL',
	2966: 'STENCIL_PASS_DEPTH_PASS',
	2967: 'STENCIL_REF',
	2968: 'STENCIL_WRITEMASK',
	2978: 'VIEWPORT',
	3024: 'DITHER',
	3042: 'BLEND',
	3088: 'SCISSOR_BOX',
	3089: 'SCISSOR_TEST',
	3106: 'COLOR_CLEAR_VALUE',
	3107: 'COLOR_WRITEMASK',
	3317: 'UNPACK_ALIGNMENT',
	3333: 'PACK_ALIGNMENT',
	3379: 'MAX_TEXTURE_SIZE',
	3386: 'MAX_VIEWPORT_DIMS',
	3408: 'SUBPIXEL_BITS',
	3410: 'RED_BITS',
	3411: 'GREEN_BITS',
	3412: 'BLUE_BITS',
	3413: 'ALPHA_BITS',
	3414: 'DEPTH_BITS',
	3415: 'STENCIL_BITS',
	3553: 'TEXTURE_2D',
	4352: 'DONT_CARE',
	4353: 'FASTEST',
	4354: 'NICEST',
	5120: 'BYTE',
	5121: 'UNSIGNED_BYTE',
	5122: 'SHORT',
	5123: 'UNSIGNED_SHORT',
	5124: 'INT',
	5125: 'UNSIGNED_INT',
	5126: 'FLOAT',
	5386: 'INVERT',
	5890: 'TEXTURE',
	6401: 'STENCIL_INDEX',
	6402: 'DEPTH_COMPONENT',
	6403: 'RED',
	6406: 'ALPHA',
	6407: 'RGB',
	6408: 'RGBA',
	6409: 'LUMINANCE',
	6410: 'LUMINANCE_ALPHA',
	7680: 'KEEP',
	7681: 'REPLACE',
	7682: 'INCR',
	7683: 'DECR',
	7936: 'VENDOR',
	7937: 'RENDERER',
	7938: 'VERSION',
	9728: 'NEAREST',
	9729: 'LINEAR',
	9984: 'NEAREST_MIPMAP_NEAREST',
	9985: 'LINEAR_MIPMAP_NEAREST',
	9986: 'NEAREST_MIPMAP_LINEAR',
	9987: 'LINEAR_MIPMAP_LINEAR',
	10240: 'TEXTURE_MAG_FILTER',
	10241: 'TEXTURE_MIN_FILTER',
	10242: 'TEXTURE_WRAP_S',
	10243: 'TEXTURE_WRAP_T',
	10497: 'REPEAT',
	10752: 'POLYGON_OFFSET_UNITS',
	16384: 'COLOR_BUFFER_BIT',
	32769: 'CONSTANT_COLOR',
	32770: 'ONE_MINUS_CONSTANT_COLOR',
	32771: 'CONSTANT_ALPHA',
	32772: 'ONE_MINUS_CONSTANT_ALPHA',
	32773: 'BLEND_COLOR',
	32774: 'FUNC_ADD',
	32777: 'BLEND_EQUATION_RGB',
	32778: 'FUNC_SUBTRACT',
	32779: 'FUNC_REVERSE_SUBTRACT',
	32819: 'UNSIGNED_SHORT_4_4_4_4',
	32820: 'UNSIGNED_SHORT_5_5_5_1',
	32823: 'POLYGON_OFFSET_FILL',
	32824: 'POLYGON_OFFSET_FACTOR',
	32854: 'RGBA4',
	32855: 'RGB5_A1',
	32873: 'TEXTURE_BINDING_2D',
	32926: 'SAMPLE_ALPHA_TO_COVERAGE',
	32928: 'SAMPLE_COVERAGE',
	32936: 'SAMPLE_BUFFERS',
	32937: 'SAMPLES',
	32938: 'SAMPLE_COVERAGE_VALUE',
	32939: 'SAMPLE_COVERAGE_INVERT',
	32968: 'BLEND_DST_RGB',
	32969: 'BLEND_SRC_RGB',
	32970: 'BLEND_DST_ALPHA',
	32971: 'BLEND_SRC_ALPHA',
	33071: 'CLAMP_TO_EDGE',
	33170: 'GENERATE_MIPMAP_HINT',
	33189: 'DEPTH_COMPONENT16',
	33306: 'DEPTH_STENCIL_ATTACHMENT',
	33321: 'R8',
	33635: 'UNSIGNED_SHORT_5_6_5',
	33648: 'MIRRORED_REPEAT',
	33901: 'ALIASED_POINT_SIZE_RANGE',
	33902: 'ALIASED_LINE_WIDTH_RANGE',
	33984: 'TEXTURE0',
	33985: 'TEXTURE1',
	33986: 'TEXTURE2',
	33987: 'TEXTURE3',
	33988: 'TEXTURE4',
	33989: 'TEXTURE5',
	33990: 'TEXTURE6',
	33991: 'TEXTURE7',
	33992: 'TEXTURE8',
	33993: 'TEXTURE9',
	33994: 'TEXTURE10',
	33995: 'TEXTURE11',
	33996: 'TEXTURE12',
	33997: 'TEXTURE13',
	33998: 'TEXTURE14',
	33999: 'TEXTURE15',
	34000: 'TEXTURE16',
	34001: 'TEXTURE17',
	34002: 'TEXTURE18',
	34003: 'TEXTURE19',
	34004: 'TEXTURE20',
	34005: 'TEXTURE21',
	34006: 'TEXTURE22',
	34007: 'TEXTURE23',
	34008: 'TEXTURE24',
	34009: 'TEXTURE25',
	34010: 'TEXTURE26',
	34011: 'TEXTURE27',
	34012: 'TEXTURE28',
	34013: 'TEXTURE29',
	34014: 'TEXTURE30',
	34015: 'TEXTURE31',
	34016: 'ACTIVE_TEXTURE',
	34024: 'MAX_RENDERBUFFER_SIZE',
	34041: 'DEPTH_STENCIL',
	34055: 'INCR_WRAP',
	34056: 'DECR_WRAP',
	34067: 'TEXTURE_CUBE_MAP',
	34068: 'TEXTURE_BINDING_CUBE_MAP',
	34069: 'TEXTURE_CUBE_MAP_POSITIVE_X',
	34070: 'TEXTURE_CUBE_MAP_NEGATIVE_X',
	34071: 'TEXTURE_CUBE_MAP_POSITIVE_Y',
	34072: 'TEXTURE_CUBE_MAP_NEGATIVE_Y',
	34073: 'TEXTURE_CUBE_MAP_POSITIVE_Z',
	34074: 'TEXTURE_CUBE_MAP_NEGATIVE_Z',
	34076: 'MAX_CUBE_MAP_TEXTURE_SIZE',
	34338: 'VERTEX_ATTRIB_ARRAY_ENABLED',
	34339: 'VERTEX_ATTRIB_ARRAY_SIZE',
	34340: 'VERTEX_ATTRIB_ARRAY_STRIDE',
	34341: 'VERTEX_ATTRIB_ARRAY_TYPE',
	34342: 'CURRENT_VERTEX_ATTRIB',
	34373: 'VERTEX_ATTRIB_ARRAY_POINTER',
	34466: 'NUM_COMPRESSED_TEXTURE_FORMATS',
	34467: 'COMPRESSED_TEXTURE_FORMATS',
	34660: 'BUFFER_SIZE',
	34661: 'BUFFER_USAGE',
	34816: 'STENCIL_BACK_FUNC',
	34817: 'STENCIL_BACK_FAIL',
	34818: 'STENCIL_BACK_PASS_DEPTH_FAIL',
	34819: 'STENCIL_BACK_PASS_DEPTH_PASS',
	34877: 'BLEND_EQUATION_ALPHA',
	34921: 'MAX_VERTEX_ATTRIBS',
	34922: 'VERTEX_ATTRIB_ARRAY_NORMALIZED',
	34930: 'MAX_TEXTURE_IMAGE_UNITS',
	34962: 'ARRAY_BUFFER',
	34963: 'ELEMENT_ARRAY_BUFFER',
	34964: 'ARRAY_BUFFER_BINDING',
	34965: 'ELEMENT_ARRAY_BUFFER_BINDING',
	34975: 'VERTEX_ATTRIB_ARRAY_BUFFER_BINDING',
	35040: 'STREAM_DRAW',
	35044: 'STATIC_DRAW',
	35048: 'DYNAMIC_DRAW',
	35632: 'FRAGMENT_SHADER',
	35633: 'VERTEX_SHADER',
	35660: 'MAX_VERTEX_TEXTURE_IMAGE_UNITS',
	35661: 'MAX_COMBINED_TEXTURE_IMAGE_UNITS',
	35663: 'SHADER_TYPE',
	35664: 'FLOAT_VEC2',
	35665: 'FLOAT_VEC3',
	35666: 'FLOAT_VEC4',
	35667: 'INT_VEC2',
	35668: 'INT_VEC3',
	35669: 'INT_VEC4',
	35670: 'BOOL',
	35671: 'BOOL_VEC2',
	35672: 'BOOL_VEC3',
	35673: 'BOOL_VEC4',
	35674: 'FLOAT_MAT2',
	35675: 'FLOAT_MAT3',
	35676: 'FLOAT_MAT4',
	35678: 'SAMPLER_2D',
	35680: 'SAMPLER_CUBE',
	35712: 'DELETE_STATUS',
	35713: 'COMPILE_STATUS',
	35714: 'LINK_STATUS',
	35715: 'VALIDATE_STATUS',
	35716: 'INFO_LOG_LENGTH',
	35717: 'ATTACHED_SHADERS',
	35718: 'ACTIVE_UNIFORMS',
	35719: 'ACTIVE_UNIFORM_MAX_LENGTH',
	35720: 'SHADER_SOURCE_LENGTH',
	35721: 'ACTIVE_ATTRIBUTES',
	35722: 'ACTIVE_ATTRIBUTE_MAX_LENGTH',
	35724: 'SHADING_LANGUAGE_VERSION',
	35725: 'CURRENT_PROGRAM',
	36003: 'STENCIL_BACK_REF',
	36004: 'STENCIL_BACK_VALUE_MASK',
	36005: 'STENCIL_BACK_WRITEMASK',
	36006: 'FRAMEBUFFER_BINDING',
	36007: 'RENDERBUFFER_BINDING',
	36048: 'FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE',
	36049: 'FRAMEBUFFER_ATTACHMENT_OBJECT_NAME',
	36050: 'FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL',
	36051: 'FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE',
	36053: 'FRAMEBUFFER_COMPLETE',
	36054: 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT',
	36055: 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT',
	36057: 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS',
	36061: 'FRAMEBUFFER_UNSUPPORTED',
	36064: 'COLOR_ATTACHMENT0',
	36096: 'DEPTH_ATTACHMENT',
	36128: 'STENCIL_ATTACHMENT',
	36160: 'FRAMEBUFFER',
	36161: 'RENDERBUFFER',
	36162: 'RENDERBUFFER_WIDTH',
	36163: 'RENDERBUFFER_HEIGHT',
	36164: 'RENDERBUFFER_INTERNAL_FORMAT',
	36168: 'STENCIL_INDEX8',
	36176: 'RENDERBUFFER_RED_SIZE',
	36177: 'RENDERBUFFER_GREEN_SIZE',
	36178: 'RENDERBUFFER_BLUE_SIZE',
	36179: 'RENDERBUFFER_ALPHA_SIZE',
	36180: 'RENDERBUFFER_DEPTH_SIZE',
	36181: 'RENDERBUFFER_STENCIL_SIZE',
	36194: 'RGB565',
	36336: 'LOW_FLOAT',
	36337: 'MEDIUM_FLOAT',
	36338: 'HIGH_FLOAT',
	36339: 'LOW_INT',
	36340: 'MEDIUM_INT',
	36341: 'HIGH_INT',
	36346: 'SHADER_COMPILER',
	36347: 'MAX_VERTEX_UNIFORM_VECTORS',
	36348: 'MAX_VARYING_VECTORS',
	36349: 'MAX_FRAGMENT_UNIFORM_VECTORS',
	37440: 'UNPACK_FLIP_Y_WEBGL',
	37441: 'UNPACK_PREMULTIPLY_ALPHA_WEBGL',
	37442: 'CONTEXT_LOST_WEBGL',
	37443: 'UNPACK_COLORSPACE_CONVERSION_WEBGL',
	37444: 'BROWSER_DEFAULT_WEBGL'
};

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Pass.js

var _GLShader = __webpack_require__(2);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _FrameBuffer = __webpack_require__(12);

var _FrameBuffer2 = _interopRequireDefault(_FrameBuffer);

var _ShaderLibs = __webpack_require__(33);

var _ShaderLibs2 = _interopRequireDefault(_ShaderLibs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Pass = function () {
	function Pass(mSource) {
		var mWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
		var mHeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
		var mParams = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

		_classCallCheck(this, Pass);

		this.shader = new _GLShader2.default(_ShaderLibs2.default.bigTriangleVert, mSource);

		this._width = mWidth;
		this._height = mHeight;
		this._uniforms = {};
		this._hasOwnFbo = this._width > 0 && this._width > 0;
		this._uniforms = {};

		if (this._hasOwnFbo) {
			this._fbo = new _FrameBuffer2.default(this._width, this.height, mParmas);
		}
	}

	_createClass(Pass, [{
		key: 'uniform',
		value: function uniform(mName, mValue) {
			this._uniforms[mName] = mValue;
		}
	}, {
		key: 'render',
		value: function render(texture) {
			this.shader.bind();
			this.shader.uniform('texture', 'uniform1i', 0);
			texture.bind(0);

			this.shader.uniform(this._uniforms);
		}
	}, {
		key: 'width',
		get: function get() {
			return this._width;
		}
	}, {
		key: 'height',
		get: function get() {
			return this._height;
		}
	}, {
		key: 'fbo',
		get: function get() {
			return this._fbo;
		}
	}, {
		key: 'hasFbo',
		get: function get() {
			return this._hasOwnFbo;
		}
	}]);

	return Pass;
}();

exports.default = Pass;

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = "// simpleColor.frag\n\n#define SHADER_NAME SIMPLE_COLOR\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform vec3 color;\nuniform float opacity;\n\nvoid main(void) {\n    gl_FragColor = vec4(color, opacity);\n}"

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = "// basic.vert\n\n#define SHADER_NAME BASIC_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);\n    vTextureCoord = aTextureCoord;\n    vNormal = aNormal;\n}"

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // FrameBuffer.js

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _GLTexture = __webpack_require__(27);

var _GLTexture2 = _interopRequireDefault(_GLTexture);

var _WebglNumber = __webpack_require__(8);

var _WebglNumber2 = _interopRequireDefault(_WebglNumber);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;
var webglDepthTexture = void 0;
var hasCheckedMultiRenderSupport = false;
var extDrawBuffer = void 0;

var checkMultiRender = function checkMultiRender() {
	if (_GLTool2.default.webgl2) {
		return true;
	} else {
		extDrawBuffer = _GLTool2.default.getExtension('WEBGL_draw_buffers');
		return !!extDrawBuffer;
	}

	hasCheckedMultiRenderSupport = true;
};

var FrameBuffer = function () {
	function FrameBuffer(mWidth, mHeight) {
		var mParameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
		var mNumTargets = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

		_classCallCheck(this, FrameBuffer);

		gl = _GLTool2.default.gl;
		webglDepthTexture = _GLTool2.default.checkExtension('WEBGL_depth_texture');

		this.width = mWidth;
		this.height = mHeight;
		this._numTargets = mNumTargets;
		this._multipleTargets = mNumTargets > 1;
		this._parameters = mParameters;

		if (!hasCheckedMultiRenderSupport) {
			checkMultiRender();
		}

		if (this._multipleTargets) {
			this._checkMaxNumRenderTarget();
		}

		this._init();
	}

	_createClass(FrameBuffer, [{
		key: '_init',
		value: function _init() {
			this._initTextures();

			this.frameBuffer = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);

			if (_GLTool2.default.webgl2) {
				// this.renderBufferDepth = gl.createRenderbuffer();
				// gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBufferDepth);
				// gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.width, this.height);
				// gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.renderBufferDepth);

				var buffers = [];
				for (var i = 0; i < this._numTargets; i++) {
					gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, this._textures[i].texture, 0);
					buffers.push(gl['COLOR_ATTACHMENT' + i]);
				}

				gl.drawBuffers(buffers);

				gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.glDepthTexture.texture, 0);
			} else {
				for (var _i = 0; _i < this._numTargets; _i++) {
					gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + _i, gl.TEXTURE_2D, this._textures[_i].texture, 0);
				}

				if (this._multipleTargets) {
					var drawBuffers = [];
					for (var _i2 = 0; _i2 < this._numTargets; _i2++) {
						drawBuffers.push(extDrawBuffer['COLOR_ATTACHMENT' + _i2 + '_WEBGL']);
					}

					extDrawBuffer.drawBuffersWEBGL(drawBuffers);
				}

				if (webglDepthTexture) {
					gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.glDepthTexture.texture, 0);
				}
			}

			//	CHECKING FBO
			var FBOstatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
			if (FBOstatus != gl.FRAMEBUFFER_COMPLETE) {
				console.error('GL_FRAMEBUFFER_COMPLETE failed, CANNOT use Framebuffer', _WebglNumber2.default[FBOstatus]);
			}

			//	UNBIND

			gl.bindTexture(gl.TEXTURE_2D, null);
			gl.bindRenderbuffer(gl.RENDERBUFFER, null);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			//	CLEAR FRAMEBUFFER 

			this.clear();
		}
	}, {
		key: '_checkMaxNumRenderTarget',
		value: function _checkMaxNumRenderTarget() {
			var maxNumDrawBuffers = _GLTool2.default.gl.getParameter(extDrawBuffer.MAX_DRAW_BUFFERS_WEBGL);
			if (this._numTargets > maxNumDrawBuffers) {
				console.error('Over max number of draw buffers supported : ', maxNumDrawBuffers);
				this._numTargets = maxNumDrawBuffers;
			}
		}
	}, {
		key: '_initTextures',
		value: function _initTextures() {
			this._textures = [];
			for (var i = 0; i < this._numTargets; i++) {
				var glt = this._createTexture();
				this._textures.push(glt);
			}

			if (_GLTool2.default.webgl2) {
				this.glDepthTexture = this._createTexture(gl.DEPTH_COMPONENT16, gl.UNSIGNED_SHORT, gl.DEPTH_COMPONENT, true);
			} else {
				this.glDepthTexture = this._createTexture(gl.DEPTH_COMPONENT, gl.UNSIGNED_SHORT, gl.DEPTH_COMPONENT, { minFilter: _GLTool2.default.LINEAR });
			}
		}
	}, {
		key: '_createTexture',
		value: function _createTexture(mInternalformat, mTexelType, mFormat) {
			var mParameters = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

			var parameters = Object.assign({}, this._parameters);
			if (!mFormat) {
				mFormat = mInternalformat;
			}

			parameters.internalFormat = mInternalformat || gl.RGBA;
			parameters.format = mFormat;
			parameters.type = mTexelType || parameters.type || _GLTool2.default.UNSIGNED_BYTE;
			for (var s in mParameters) {
				parameters[s] = mParameters[s];
			}

			var texture = new _GLTexture2.default(null, parameters, this.width, this.height);
			return texture;
		}

		//	PUBLIC METHODS

	}, {
		key: 'bind',
		value: function bind() {
			var mAutoSetViewport = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			if (mAutoSetViewport) {
				_GLTool2.default.viewport(0, 0, this.width, this.height);
			}
			gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
		}
	}, {
		key: 'unbind',
		value: function unbind() {
			var mAutoSetViewport = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			if (mAutoSetViewport) {
				_GLTool2.default.viewport(0, 0, _GLTool2.default.width, _GLTool2.default.height);
			}
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			this._textures.forEach(function (texture) {
				texture.generateMipmap();
			});
		}
	}, {
		key: 'clear',
		value: function clear() {
			var r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
			var g = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
			var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
			var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

			this.bind();
			_GLTool2.default.clear(r, g, b, a);
			this.unbind();
		}

		//	TEXTURES

	}, {
		key: 'getTexture',
		value: function getTexture() {
			var mIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

			return this._textures[mIndex];
		}
	}, {
		key: 'getDepthTexture',
		value: function getDepthTexture() {
			return this.glDepthTexture;
		}

		//	TOUGHTS : Should I remove these from frame buffer ? 
		//	Shouldn't these be set individually to each texture ? 
		//	e.g. fbo.getTexture(0).minFilter = GL.NEAREST;
		//		 fbo.getTexture(1).minFilter = GL.LINEAR; ... etc ? 

		//	MIPMAP FILTER

	}, {
		key: 'showParameters',


		//	UTILS

		value: function showParameters() {
			this._textures[0].showParameters();
		}
	}, {
		key: 'minFilter',
		get: function get() {
			return this._textures[0].minFilter;
		},
		set: function set(mValue) {
			this._textures.forEach(function (texture) {
				texture.minFilter = mValue;
			});
		}
	}, {
		key: 'magFilter',
		get: function get() {
			return this._textures[0].magFilter;
		},
		set: function set(mValue) {
			this._textures.forEach(function (texture) {
				texture.magFilter = mValue;
			});
		}

		//	WRAPPING

	}, {
		key: 'wrapS',
		get: function get() {
			return this._textures[0].wrapS;
		},
		set: function set(mValue) {
			this._textures.forEach(function (texture) {
				texture.wrapS = mValue;
			});
		}
	}, {
		key: 'wrapT',
		get: function get() {
			return this._textures[0].wrapT;
		},
		set: function set(mValue) {
			this._textures.forEach(function (texture) {
				texture.wrapT = mValue;
			});
		}
	}, {
		key: 'numTargets',
		get: function get() {
			return this._numTargets;
		}
	}]);

	return FrameBuffer;
}();

exports.default = FrameBuffer;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // EaseNumber.js

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EaseNumber = function () {
	function EaseNumber(mValue) {
		var _this = this;

		var mEasing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;

		_classCallCheck(this, EaseNumber);

		this.easing = mEasing;
		this._value = mValue;
		this._targetValue = mValue;
		this._efIndex = _scheduling2.default.addEF(function () {
			return _this._update();
		});
	}

	_createClass(EaseNumber, [{
		key: '_update',
		value: function _update() {
			var MIN_DIFF = 0.0001;
			this._checkLimit();
			this._value += (this._targetValue - this._value) * this.easing;
			if (Math.abs(this._targetValue - this._value) < MIN_DIFF) {
				this._value = this._targetValue;
			}
		}
	}, {
		key: 'setTo',
		value: function setTo(mValue) {
			this._targetValue = this._value = mValue;
		}
	}, {
		key: 'add',
		value: function add(mAdd) {
			this._targetValue += mAdd;
		}
	}, {
		key: 'limit',
		value: function limit(mMin, mMax) {
			if (mMin > mMax) {
				this.limit(mMax, mMin);
				return;
			}

			this._min = mMin;
			this._max = mMax;

			this._checkLimit();
		}
	}, {
		key: '_checkLimit',
		value: function _checkLimit() {
			if (this._min !== undefined && this._targetValue < this._min) {
				this._targetValue = this._min;
			}

			if (this._max !== undefined && this._targetValue > this._max) {
				this._targetValue = this._max;
			}
		}
	}, {
		key: 'destroy',
		value: function destroy() {
			_scheduling2.default.removeEF(this._efIndex);
		}

		//	GETTERS / SETTERS

	}, {
		key: 'value',
		set: function set(mValue) {
			this._targetValue = mValue;
		},
		get: function get() {
			return this._value;
		}
	}, {
		key: 'targetValue',
		get: function get() {
			return this._targetValue;
		}
	}]);

	return EaseNumber;
}();

exports.default = EaseNumber;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Ray.js

var _glMatrix = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var a = _glMatrix.vec3.create();
var b = _glMatrix.vec3.create();
var c = _glMatrix.vec3.create();
var target = _glMatrix.vec3.create();
var edge1 = _glMatrix.vec3.create();
var edge2 = _glMatrix.vec3.create();
var normal = _glMatrix.vec3.create();
var diff = _glMatrix.vec3.create();

var Ray = function () {
	function Ray(mOrigin, mDirection) {
		_classCallCheck(this, Ray);

		this.origin = _glMatrix.vec3.clone(mOrigin);
		this.direction = _glMatrix.vec3.clone(mDirection);
	}

	_createClass(Ray, [{
		key: 'at',
		value: function at(t) {
			_glMatrix.vec3.copy(target, this.direction);
			_glMatrix.vec3.scale(target, target, t);
			_glMatrix.vec3.add(target, target, this.origin);

			return target;
		}
	}, {
		key: 'lookAt',
		value: function lookAt(mTarget) {
			_glMatrix.vec3.sub(this.direction, mTarget, this.origin);
			_glMatrix.vec3.normalize(this.origin, this.origin);
		}
	}, {
		key: 'closestPointToPoint',
		value: function closestPointToPoint(mPoint) {
			var result = _glMatrix.vec3.create();
			_glMatrix.vec3.sub(mPoint, this.origin);
			var directionDistance = _glMatrix.vec3.dot(result, this.direction);

			if (directionDistance < 0) {
				return _glMatrix.vec3.clone(this.origin);
			}

			_glMatrix.vec3.copy(result, this.direction);
			_glMatrix.vec3.scale(result, result, directionDistance);
			_glMatrix.vec3.add(result, result, this.origin);

			return result;
		}
	}, {
		key: 'distanceToPoint',
		value: function distanceToPoint(mPoint) {
			return Math.sqrt(this.distanceSqToPoint(mPoint));
		}
	}, {
		key: 'distanceSqToPoint',
		value: function distanceSqToPoint(mPoint) {
			var v1 = _glMatrix.vec3.create();

			_glMatrix.vec3.sub(v1, mPoint, this.origin);
			var directionDistance = _glMatrix.vec3.dot(v1, this.direction);

			if (directionDistance < 0) {
				return _glMatrix.vec3.squaredDistance(this.origin, mPoint);
			}

			_glMatrix.vec3.copy(v1, this.direction);
			_glMatrix.vec3.scale(v1, v1, directionDistance);
			_glMatrix.vec3.add(v1, v1, this.origin);
			return _glMatrix.vec3.squaredDistance(v1, mPoint);
		}
	}, {
		key: 'intersectsSphere',
		value: function intersectsSphere(mCenter, mRadius) {
			return this.distanceToPoint(mCenter) <= mRadius;
		}
	}, {
		key: 'intersectSphere',
		value: function intersectSphere(mCenter, mRadius) {
			var v1 = _glMatrix.vec3.create();
			_glMatrix.vec3.sub(v1, mCenter, this.origin);
			var tca = _glMatrix.vec3.dot(v1, this.direction);
			var d2 = _glMatrix.vec3.dot(v1, v1) - tca * tca;
			var radius2 = mRadius * mRadius;

			if (d2 > radius2) return null;

			var thc = Math.sqrt(radius2 - d2);

			var t0 = tca - thc;

			var t1 = tca + thc;

			if (t0 < 0 && t1 < 0) return null;

			if (t0 < 0) return this.at(t1);

			return this.at(t0);
		}
	}, {
		key: 'distanceToPlane',
		value: function distanceToPlane(mPlaneCenter, mNormal) {
			var denominator = _glMatrix.vec3.dot(mNormal, this.direction);

			if (denominator === 0) {}
		}
	}, {
		key: 'intersectTriangle',
		value: function intersectTriangle(mPA, mPB, mPC) {
			var backfaceCulling = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

			_glMatrix.vec3.copy(a, mPA);
			_glMatrix.vec3.copy(b, mPB);
			_glMatrix.vec3.copy(c, mPC);

			// const edge1 = vec3.create();
			// const edge2 = vec3.create();
			// const normal = vec3.create();
			// const diff = vec3.create();

			_glMatrix.vec3.sub(edge1, b, a);
			_glMatrix.vec3.sub(edge2, c, a);
			_glMatrix.vec3.cross(normal, edge1, edge2);

			var DdN = _glMatrix.vec3.dot(this.direction, normal);
			var sign = void 0;

			if (DdN > 0) {
				if (backfaceCulling) {
					return null;
				}
				sign = 1;
			} else if (DdN < 0) {
				sign = -1;
				DdN = -DdN;
			} else {
				return null;
			}

			_glMatrix.vec3.sub(diff, this.origin, a);

			_glMatrix.vec3.cross(edge2, diff, edge2);
			var DdQxE2 = sign * _glMatrix.vec3.dot(this.direction, edge2);
			if (DdQxE2 < 0) {
				return null;
			}

			_glMatrix.vec3.cross(edge1, edge1, diff);
			var DdE1xQ = sign * _glMatrix.vec3.dot(this.direction, edge1);
			if (DdE1xQ < 0) {
				return null;
			}

			if (DdQxE2 + DdE1xQ > DdN) {
				return null;
			}

			var Qdn = -sign * _glMatrix.vec3.dot(diff, normal);
			if (Qdn < 0) {
				return null;
			}

			return this.at(Qdn / DdN);
		}
	}]);

	return Ray;
}();

exports.default = Ray;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Camera.js

var _glMatrix = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Camera = function () {
	function Camera() {
		_classCallCheck(this, Camera);

		//	VIEW MATRIX
		this._matrix = _glMatrix.mat4.create();

		//	FOR TRANSFORM FROM ORIENTATION
		this._quat = _glMatrix.quat.create();
		this._orientation = _glMatrix.mat4.create();

		//	PROJECTION MATRIX
		this._projection = _glMatrix.mat4.create();

		//	POSITION OF CAMERA
		this.position = vec3.create();
	}

	_createClass(Camera, [{
		key: 'lookAt',
		value: function lookAt(aEye, aCenter) {
			var aUp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 1, 0];

			this._eye = vec3.clone(aEye);
			this._center = vec3.clone(aCenter);

			vec3.copy(this.position, aEye);
			_glMatrix.mat4.identity(this._matrix);
			_glMatrix.mat4.lookAt(this._matrix, aEye, aCenter, aUp);
		}
	}, {
		key: 'setFromOrientation',
		value: function setFromOrientation(x, y, z, w) {
			_glMatrix.quat.set(this._quat, x, y, z, w);
			_glMatrix.mat4.fromQuat(this._orientation, this._quat);
			_glMatrix.mat4.translate(this._matrix, this._orientation, this.positionOffset);
		}
	}, {
		key: 'setProjection',
		value: function setProjection(mProj) {
			this._projection = _glMatrix.mat4.clone(mProj);
		}
	}, {
		key: 'setView',
		value: function setView(mView) {
			this._matrix = _glMatrix.mat4.clone(mView);
		}
	}, {
		key: 'setFromViewProj',
		value: function setFromViewProj(mView, mProj) {
			this.setView(mView);
			this.setProjection(mProj);
		}

		//	GETTERS 

	}, {
		key: 'matrix',
		get: function get() {
			return this._matrix;
		}
	}, {
		key: 'viewMatrix',
		get: function get() {
			return this._matrix;
		}
	}, {
		key: 'projection',
		get: function get() {
			return this._projection;
		}
	}, {
		key: 'projectionMatrix',
		get: function get() {
			return this._projection;
		}
	}, {
		key: 'eye',
		get: function get() {
			return this._eye;
		}
	}, {
		key: 'center',
		get: function get() {
			return this._center;
		}
	}]);

	return Camera;
}();

exports.default = Camera;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Camera2 = __webpack_require__(15);

var _Camera3 = _interopRequireDefault(_Camera2);

var _Ray = __webpack_require__(14);

var _Ray2 = _interopRequireDefault(_Ray);

var _glMatrix = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // CameraPerspective.js

var mInverseViewProj = _glMatrix.mat4.create();
var cameraDir = _glMatrix.vec3.create();

var CameraPerspective = function (_Camera) {
	_inherits(CameraPerspective, _Camera);

	function CameraPerspective() {
		_classCallCheck(this, CameraPerspective);

		return _possibleConstructorReturn(this, (CameraPerspective.__proto__ || Object.getPrototypeOf(CameraPerspective)).apply(this, arguments));
	}

	_createClass(CameraPerspective, [{
		key: 'setPerspective',
		value: function setPerspective(mFov, mAspectRatio, mNear, mFar) {

			this._fov = mFov;
			this._near = mNear;
			this._far = mFar;
			this._aspectRatio = mAspectRatio;
			_glMatrix.mat4.perspective(this._projection, mFov, mAspectRatio, mNear, mFar);

			// this._frustumTop = this._near * Math.tan(this._fov * 0.5);
			// this._frustumButtom = -this._frustumTop;
			// this._frustumRight = this._frustumTop * this._aspectRatio;
			// this._frustumLeft = -this._frustumRight;
		}
	}, {
		key: 'setAspectRatio',
		value: function setAspectRatio(mAspectRatio) {
			this._aspectRatio = mAspectRatio;
			_glMatrix.mat4.perspective(this.projection, this._fov, mAspectRatio, this._near, this._far);
		}
	}, {
		key: 'generateRay',
		value: function generateRay(mScreenPosition, mRay) {
			var proj = this.projectionMatrix;
			var view = this.viewMatrix;

			_glMatrix.mat4.multiply(mInverseViewProj, proj, view);
			_glMatrix.mat4.invert(mInverseViewProj, mInverseViewProj);

			_glMatrix.vec3.transformMat4(cameraDir, mScreenPosition, mInverseViewProj);
			_glMatrix.vec3.sub(cameraDir, cameraDir, this.position);
			_glMatrix.vec3.normalize(cameraDir, cameraDir);

			if (!mRay) {
				mRay = new _Ray2.default(this.position, cameraDir);
			} else {
				mRay.origin = this.position;
				mRay.direction = cameraDir;
			}

			return mRay;
		}
	}]);

	return CameraPerspective;
}(_Camera3.default);

exports.default = CameraPerspective;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// BinaryLoader.js

var BinaryLoader = function () {
	function BinaryLoader() {
		var _this = this;

		var isArrayBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

		_classCallCheck(this, BinaryLoader);

		this._req = new XMLHttpRequest();
		this._req.addEventListener('load', function (e) {
			return _this._onLoaded(e);
		});
		this._req.addEventListener('progress', function (e) {
			return _this._onProgress(e);
		});
		if (isArrayBuffer) {
			this._req.responseType = 'arraybuffer';
		}
	}

	_createClass(BinaryLoader, [{
		key: 'load',
		value: function load(url, callback) {
			console.log('Loading : ', url);
			this._callback = callback;

			this._req.open('GET', url);
			this._req.send();
		}
	}, {
		key: '_onLoaded',
		value: function _onLoaded() {
			this._callback(this._req.response);
		}
	}, {
		key: '_onProgress',
		value: function _onProgress() /* e*/{
			// console.log('on Progress:', (e.loaded/e.total*100).toFixed(2));
		}
	}]);

	return BinaryLoader;
}();

exports.default = BinaryLoader;

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = "// bigTriangle.vert\n\n#define SHADER_NAME BIG_TRIANGLE_VERTEX\n\nprecision mediump float;\n#define GLSLIFY 1\nattribute vec2 aPosition;\nvarying vec2 vTextureCoord;\n\nvoid main(void) {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n    vTextureCoord = aPosition * .5 + .5;\n}"

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = "// copy.frag\n\n#define SHADER_NAME COPY_FRAGMENT\n\nprecision mediump float;\n#define GLSLIFY 1\n\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\n\nvoid main(void) {\n    gl_FragColor = texture2D(texture, vTextureCoord);\n}"

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.ShaderLibs = exports.View3D = exports.View = exports.Scene = exports.BatchFXAA = exports.BatchSky = exports.BatchSkybox = exports.BatchLine = exports.BatchDotsPlane = exports.BatchBall = exports.BatchAxis = exports.BatchCopy = exports.PassFxaa = exports.PassHBlur = exports.PassVBlur = exports.PassBlur = exports.PassMacro = exports.Pass = exports.EffectComposer = exports.ColladaParser = exports.GLTFLoader = exports.HDRLoader = exports.ObjLoader = exports.BinaryLoader = exports.Object3D = exports.Ray = exports.CameraCube = exports.CameraPerspective = exports.CameraOrtho = exports.Camera = exports.TouchDetector = exports.QuatRotation = exports.WebglNumber = exports.OrbitalControl = exports.TweenNumber = exports.EaseNumber = exports.EventDispatcher = exports.Scheduler = exports.TransformFeedbackObject = exports.MultisampleFrameBuffer = exports.CubeFrameBuffer = exports.FrameBuffer = exports.Batch = exports.Geom = exports.Mesh = exports.GLCubeTexture = exports.GLTextureOld = exports.GLTexture = exports.GLShader = exports.GL = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // alfrid.js

//	WEBGL 2


//	TOOLS


//	CAMERAS


//	MATH


//	OBJECT


//	LOADERS


//	POST EFFECT


//	HELPERS


var _glMatrix = __webpack_require__(1);

var GLM = _interopRequireWildcard(_glMatrix);

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _GLShader = __webpack_require__(2);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _GLTexture = __webpack_require__(26);

var _GLTexture2 = _interopRequireDefault(_GLTexture);

var _GLTexture3 = __webpack_require__(27);

var _GLTexture4 = _interopRequireDefault(_GLTexture3);

var _GLCubeTexture = __webpack_require__(28);

var _GLCubeTexture2 = _interopRequireDefault(_GLCubeTexture);

var _Mesh = __webpack_require__(4);

var _Mesh2 = _interopRequireDefault(_Mesh);

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _Batch = __webpack_require__(5);

var _Batch2 = _interopRequireDefault(_Batch);

var _FrameBuffer = __webpack_require__(12);

var _FrameBuffer2 = _interopRequireDefault(_FrameBuffer);

var _CubeFrameBuffer = __webpack_require__(58);

var _CubeFrameBuffer2 = _interopRequireDefault(_CubeFrameBuffer);

var _MultisampleFrameBuffer = __webpack_require__(59);

var _MultisampleFrameBuffer2 = _interopRequireDefault(_MultisampleFrameBuffer);

var _TransformFeedbackObject = __webpack_require__(60);

var _TransformFeedbackObject2 = _interopRequireDefault(_TransformFeedbackObject);

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

var _EventDispatcher = __webpack_require__(29);

var _EventDispatcher2 = _interopRequireDefault(_EventDispatcher);

var _EaseNumber = __webpack_require__(13);

var _EaseNumber2 = _interopRequireDefault(_EaseNumber);

var _TweenNumber = __webpack_require__(61);

var _TweenNumber2 = _interopRequireDefault(_TweenNumber);

var _OrbitalControl = __webpack_require__(30);

var _OrbitalControl2 = _interopRequireDefault(_OrbitalControl);

var _QuatRotation = __webpack_require__(62);

var _QuatRotation2 = _interopRequireDefault(_QuatRotation);

var _TouchDetector = __webpack_require__(63);

var _TouchDetector2 = _interopRequireDefault(_TouchDetector);

var _WebglNumber = __webpack_require__(8);

var _WebglNumber2 = _interopRequireDefault(_WebglNumber);

var _WebglConst = __webpack_require__(24);

var _WebglConst2 = _interopRequireDefault(_WebglConst);

var _Camera = __webpack_require__(15);

var _Camera2 = _interopRequireDefault(_Camera);

var _CameraOrtho = __webpack_require__(31);

var _CameraOrtho2 = _interopRequireDefault(_CameraOrtho);

var _CameraPerspective = __webpack_require__(16);

var _CameraPerspective2 = _interopRequireDefault(_CameraPerspective);

var _CameraCube = __webpack_require__(65);

var _CameraCube2 = _interopRequireDefault(_CameraCube);

var _Ray = __webpack_require__(14);

var _Ray2 = _interopRequireDefault(_Ray);

var _Object3D = __webpack_require__(32);

var _Object3D2 = _interopRequireDefault(_Object3D);

var _BinaryLoader = __webpack_require__(17);

var _BinaryLoader2 = _interopRequireDefault(_BinaryLoader);

var _ObjLoader = __webpack_require__(66);

var _ObjLoader2 = _interopRequireDefault(_ObjLoader);

var _HDRLoader = __webpack_require__(67);

var _HDRLoader2 = _interopRequireDefault(_HDRLoader);

var _ColladaParser = __webpack_require__(69);

var _ColladaParser2 = _interopRequireDefault(_ColladaParser);

var _GltfLoader = __webpack_require__(72);

var _GltfLoader2 = _interopRequireDefault(_GltfLoader);

var _EffectComposer = __webpack_require__(74);

var _EffectComposer2 = _interopRequireDefault(_EffectComposer);

var _Pass = __webpack_require__(9);

var _Pass2 = _interopRequireDefault(_Pass);

var _PassMacro = __webpack_require__(37);

var _PassMacro2 = _interopRequireDefault(_PassMacro);

var _PassBlur = __webpack_require__(75);

var _PassBlur2 = _interopRequireDefault(_PassBlur);

var _PassVBlur = __webpack_require__(38);

var _PassVBlur2 = _interopRequireDefault(_PassVBlur);

var _PassHBlur = __webpack_require__(40);

var _PassHBlur2 = _interopRequireDefault(_PassHBlur);

var _PassFxaa = __webpack_require__(79);

var _PassFxaa2 = _interopRequireDefault(_PassFxaa);

var _BatchCopy = __webpack_require__(80);

var _BatchCopy2 = _interopRequireDefault(_BatchCopy);

var _BatchAxis = __webpack_require__(81);

var _BatchAxis2 = _interopRequireDefault(_BatchAxis);

var _BatchBall = __webpack_require__(84);

var _BatchBall2 = _interopRequireDefault(_BatchBall);

var _BatchDotsPlane = __webpack_require__(85);

var _BatchDotsPlane2 = _interopRequireDefault(_BatchDotsPlane);

var _BatchLine = __webpack_require__(87);

var _BatchLine2 = _interopRequireDefault(_BatchLine);

var _BatchSkybox = __webpack_require__(88);

var _BatchSkybox2 = _interopRequireDefault(_BatchSkybox);

var _BatchSky = __webpack_require__(89);

var _BatchSky2 = _interopRequireDefault(_BatchSky);

var _BatchFXAA = __webpack_require__(91);

var _BatchFXAA2 = _interopRequireDefault(_BatchFXAA);

var _Scene = __webpack_require__(92);

var _Scene2 = _interopRequireDefault(_Scene);

var _View = __webpack_require__(93);

var _View2 = _interopRequireDefault(_View);

var _View3D = __webpack_require__(94);

var _View3D2 = _interopRequireDefault(_View3D);

var _ShaderLibs = __webpack_require__(33);

var _ShaderLibs2 = _interopRequireDefault(_ShaderLibs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var VERSION = '0.2.0';

var Alfrid = function () {
	function Alfrid() {
		_classCallCheck(this, Alfrid);

		this.glm = GLM;
		this.GL = _GLTool2.default;
		this.GLTool = _GLTool2.default;
		this.GLShader = _GLShader2.default;
		this.GLTexture = _GLTexture4.default;
		this.GLTextureOld = _GLTexture2.default;
		this.GLCubeTexture = _GLCubeTexture2.default;
		this.Mesh = _Mesh2.default;
		this.Geom = _Geom2.default;
		this.Batch = _Batch2.default;
		this.FrameBuffer = _FrameBuffer2.default;
		this.CubeFrameBuffer = _CubeFrameBuffer2.default;
		this.Scheduler = _scheduling2.default;
		this.EventDispatcher = _EventDispatcher2.default;
		this.EaseNumber = _EaseNumber2.default;
		this.TweenNumber = _TweenNumber2.default;
		this.Camera = _Camera2.default;
		this.CameraOrtho = _CameraOrtho2.default;
		this.CameraPerspective = _CameraPerspective2.default;
		this.Ray = _Ray2.default;
		this.CameraCube = _CameraCube2.default;
		this.OrbitalControl = _OrbitalControl2.default;
		this.QuatRotation = _QuatRotation2.default;
		this.BinaryLoader = _BinaryLoader2.default;
		this.ObjLoader = _ObjLoader2.default;
		this.ColladaParser = _ColladaParser2.default;
		this.HDRLoader = _HDRLoader2.default;
		this.GLTFLoader = _GltfLoader2.default;
		this.BatchCopy = _BatchCopy2.default;
		this.BatchAxis = _BatchAxis2.default;
		this.BatchBall = _BatchBall2.default;
		this.BatchBall = _BatchBall2.default;
		this.BatchLine = _BatchLine2.default;
		this.BatchSkybox = _BatchSkybox2.default;
		this.BatchSky = _BatchSky2.default;
		this.BatchFXAA = _BatchFXAA2.default;
		this.BatchDotsPlane = _BatchDotsPlane2.default;
		this.Scene = _Scene2.default;
		this.View = _View2.default;
		this.View3D = _View3D2.default;
		this.Object3D = _Object3D2.default;
		this.ShaderLibs = _ShaderLibs2.default;
		this.WebglNumber = _WebglNumber2.default;

		this.EffectComposer = _EffectComposer2.default;
		this.Pass = _Pass2.default;
		this.PassMacro = _PassMacro2.default;
		this.PassBlur = _PassBlur2.default;
		this.PassVBlur = _PassVBlur2.default;
		this.PassHBlur = _PassHBlur2.default;
		this.PassFxaa = _PassFxaa2.default;

		this.MultisampleFrameBuffer = _MultisampleFrameBuffer2.default;
		this.TransformFeedbackObject = _TransformFeedbackObject2.default;

		//	NOT SUPER SURE I'VE DONE THIS IS A GOOD WAY

		for (var s in GLM) {
			if (GLM[s]) {
				window[s] = GLM[s];
			}
		}
	}

	_createClass(Alfrid, [{
		key: 'log',
		value: function log() {
			if (navigator.userAgent.indexOf('Chrome') > -1) {
				console.log('%clib alfrid : VERSION ' + VERSION, 'background: #193441; color: #FCFFF5');
			} else {
				console.log('lib alfrid : VERSION ', VERSION);
			}
			console.log('%cClasses : ', 'color: #193441');

			for (var s in this) {
				if (this[s]) {
					console.log('%c - ' + s, 'color: #3E606F');
				}
			}
		}
	}]);

	return Alfrid;
}();

var al = new Alfrid();

exports.default = al;
exports.GL = _GLTool2.default;
exports.GLShader = _GLShader2.default;
exports.GLTexture = _GLTexture4.default;
exports.GLTextureOld = _GLTexture2.default;
exports.GLCubeTexture = _GLCubeTexture2.default;
exports.Mesh = _Mesh2.default;
exports.Geom = _Geom2.default;
exports.Batch = _Batch2.default;
exports.FrameBuffer = _FrameBuffer2.default;
exports.CubeFrameBuffer = _CubeFrameBuffer2.default;
exports.MultisampleFrameBuffer = _MultisampleFrameBuffer2.default;
exports.TransformFeedbackObject = _TransformFeedbackObject2.default;
exports.Scheduler = _scheduling2.default;
exports.EventDispatcher = _EventDispatcher2.default;
exports.EaseNumber = _EaseNumber2.default;
exports.TweenNumber = _TweenNumber2.default;
exports.OrbitalControl = _OrbitalControl2.default;
exports.WebglNumber = _WebglNumber2.default;
exports.QuatRotation = _QuatRotation2.default;
exports.TouchDetector = _TouchDetector2.default;
exports.Camera = _Camera2.default;
exports.CameraOrtho = _CameraOrtho2.default;
exports.CameraPerspective = _CameraPerspective2.default;
exports.CameraCube = _CameraCube2.default;
exports.Ray = _Ray2.default;
exports.Object3D = _Object3D2.default;
exports.BinaryLoader = _BinaryLoader2.default;
exports.ObjLoader = _ObjLoader2.default;
exports.HDRLoader = _HDRLoader2.default;
exports.GLTFLoader = _GltfLoader2.default;
exports.ColladaParser = _ColladaParser2.default;
exports.EffectComposer = _EffectComposer2.default;
exports.Pass = _Pass2.default;
exports.PassMacro = _PassMacro2.default;
exports.PassBlur = _PassBlur2.default;
exports.PassVBlur = _PassVBlur2.default;
exports.PassHBlur = _PassHBlur2.default;
exports.PassFxaa = _PassFxaa2.default;
exports.BatchCopy = _BatchCopy2.default;
exports.BatchAxis = _BatchAxis2.default;
exports.BatchBall = _BatchBall2.default;
exports.BatchDotsPlane = _BatchDotsPlane2.default;
exports.BatchLine = _BatchLine2.default;
exports.BatchSkybox = _BatchSkybox2.default;
exports.BatchSky = _BatchSky2.default;
exports.BatchFXAA = _BatchFXAA2.default;
exports.Scene = _Scene2.default;
exports.View = _View2.default;
exports.View3D = _View3D2.default;
exports.ShaderLibs = _ShaderLibs2.default;

/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["fromMat4"] = fromMat4;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["transpose"] = transpose;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["adjoint"] = adjoint;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["translate"] = translate;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["fromTranslation"] = fromTranslation;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["fromMat2d"] = fromMat2d;
/* harmony export (immutable) */ __webpack_exports__["fromQuat"] = fromQuat;
/* harmony export (immutable) */ __webpack_exports__["normalFromMat4"] = normalFromMat4;
/* harmony export (immutable) */ __webpack_exports__["projection"] = projection;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(3);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](9);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    let a01 = a[1], a02 = a[2], a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function invert(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  let b01 = a22 * a11 - a12 * a21;
  let b11 = -a22 * a10 + a12 * a20;
  let b21 = a21 * a10 - a11 * a20;

  // Calculate the determinant
  let det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function adjoint(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  out[0] = (a11 * a22 - a12 * a21);
  out[1] = (a02 * a21 - a01 * a22);
  out[2] = (a01 * a12 - a02 * a11);
  out[3] = (a12 * a20 - a10 * a22);
  out[4] = (a00 * a22 - a02 * a20);
  out[5] = (a02 * a10 - a00 * a12);
  out[6] = (a10 * a21 - a11 * a20);
  out[7] = (a01 * a20 - a00 * a21);
  out[8] = (a00 * a11 - a01 * a10);
  return out;
}

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function multiply(out, a, b) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  let b00 = b[0], b01 = b[1], b02 = b[2];
  let b10 = b[3], b11 = b[4], b12 = b[5];
  let b20 = b[6], b21 = b[7], b22 = b[8];

  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;

  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;

  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
function translate(out, a, v) {
  let a00 = a[0], a01 = a[1], a02 = a[2],
    a10 = a[3], a11 = a[4], a12 = a[5],
    a20 = a[6], a21 = a[7], a22 = a[8],
    x = v[0], y = v[1];

  out[0] = a00;
  out[1] = a01;
  out[2] = a02;

  out[3] = a10;
  out[4] = a11;
  out[5] = a12;

  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function rotate(out, a, rad) {
  let a00 = a[0], a01 = a[1], a02 = a[2],
    a10 = a[3], a11 = a[4], a12 = a[5],
    a20 = a[6], a21 = a[7], a22 = a[8],

    s = Math.sin(rad),
    c = Math.cos(rad);

  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;

  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;

  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
function scale(out, a, v) {
  let x = v[0], y = v[1];

  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];

  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];

  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function fromRotation(out, rad) {
  let s = Math.sin(rad), c = Math.cos(rad);

  out[0] = c;
  out[1] = s;
  out[2] = 0;

  out[3] = -s;
  out[4] = c;
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;

  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;

  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;

  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
function fromQuat(out, q) {
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let yx = y * x2;
  let yy = y * y2;
  let zx = z * x2;
  let zy = z * y2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;

  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;

  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;

  return out;
}

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
function normalFromMat4(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

  return out;
}

/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */
function projection(out, width, height) {
    out[0] = 2 / width;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = -2 / height;
    out[5] = 0;
    out[6] = -1;
    out[7] = 1;
    out[8] = 1;
    return out;
}

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
          a[3] + ', ' + a[4] + ', ' + a[5] + ', ' +
          a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
}

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}



/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  out[4] = a[4] + (b[4] * scale);
  out[5] = a[5] + (b[5] * scale);
  out[6] = a[6] + (b[6] * scale);
  out[7] = a[7] + (b[7] * scale);
  out[8] = a[8] + (b[8] * scale);
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] &&
         a[3] === b[3] && a[4] === b[4] && a[5] === b[5] &&
         a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
          Math.abs(a4 - b4) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
          Math.abs(a5 - b5) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
          Math.abs(a6 - b6) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
          Math.abs(a7 - b7) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
          Math.abs(a8 - b8) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a8), Math.abs(b8)));
}

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat3.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["length"] = length;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["divide"] = divide;
/* harmony export (immutable) */ __webpack_exports__["ceil"] = ceil;
/* harmony export (immutable) */ __webpack_exports__["floor"] = floor;
/* harmony export (immutable) */ __webpack_exports__["min"] = min;
/* harmony export (immutable) */ __webpack_exports__["max"] = max;
/* harmony export (immutable) */ __webpack_exports__["round"] = round;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["scaleAndAdd"] = scaleAndAdd;
/* harmony export (immutable) */ __webpack_exports__["distance"] = distance;
/* harmony export (immutable) */ __webpack_exports__["squaredDistance"] = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["negate"] = negate;
/* harmony export (immutable) */ __webpack_exports__["inverse"] = inverse;
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;
/* harmony export (immutable) */ __webpack_exports__["cross"] = cross;
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;
/* harmony export (immutable) */ __webpack_exports__["hermite"] = hermite;
/* harmony export (immutable) */ __webpack_exports__["bezier"] = bezier;
/* harmony export (immutable) */ __webpack_exports__["random"] = random;
/* harmony export (immutable) */ __webpack_exports__["transformMat4"] = transformMat4;
/* harmony export (immutable) */ __webpack_exports__["transformMat3"] = transformMat3;
/* harmony export (immutable) */ __webpack_exports__["transformQuat"] = transformQuat;
/* harmony export (immutable) */ __webpack_exports__["rotateX"] = rotateX;
/* harmony export (immutable) */ __webpack_exports__["rotateY"] = rotateY;
/* harmony export (immutable) */ __webpack_exports__["rotateZ"] = rotateZ;
/* harmony export (immutable) */ __webpack_exports__["angle"] = angle;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(3);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](3);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
function clone(a) {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  return Math.sqrt(x*x + y*y + z*z);
}

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
function fromValues(x, y, z) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  return out;
}

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  return Math.sqrt(x*x + y*y + z*z);
}

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  return x*x + y*y + z*z;
}

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  return x*x + y*y + z*z;
}

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
function normalize(out, a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let len = x*x + y*y + z*z;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  let ax = a[0], ay = a[1], az = a[2];
  let bx = b[0], by = b[1], bz = b[2];

  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function lerp(out, a, b, t) {
  let ax = a[0];
  let ay = a[1];
  let az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function hermite(out, a, b, c, d, t) {
  let factorTimes2 = t * t;
  let factor1 = factorTimes2 * (2 * t - 3) + 1;
  let factor2 = factorTimes2 * (t - 2) + t;
  let factor3 = factorTimes2 * (t - 1);
  let factor4 = factorTimes2 * (3 - 2 * t);

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function bezier(out, a, b, c, d, t) {
  let inverseFactor = 1 - t;
  let inverseFactorTimesTwo = inverseFactor * inverseFactor;
  let factorTimes2 = t * t;
  let factor1 = inverseFactorTimesTwo * inverseFactor;
  let factor2 = 3 * t * inverseFactorTimesTwo;
  let factor3 = 3 * factorTimes2 * inverseFactor;
  let factor4 = factorTimes2 * t;

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
function random(out, scale) {
  scale = scale || 1.0;

  let r = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]() * 2.0 * Math.PI;
  let z = (__WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]() * 2.0) - 1.0;
  let zScale = Math.sqrt(1.0-z*z) * scale;

  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
function transformMat4(out, a, m) {
  let x = a[0], y = a[1], z = a[2];
  let w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
function transformMat3(out, a, m) {
  let x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
function transformQuat(out, a, q) {
  // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

  let x = a[0], y = a[1], z = a[2];
  let qx = q[0], qy = q[1], qz = q[2], qw = q[3];

  // calculate quat * vec
  let ix = qw * x + qy * z - qz * y;
  let iy = qw * y + qz * x - qx * z;
  let iz = qw * z + qx * y - qy * x;
  let iw = -qx * x - qy * y - qz * z;

  // calculate result * inverse quat
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  return out;
}

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateX(out, a, b, c){
  let p = [], r=[];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0];
  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateY(out, a, b, c){
  let p = [], r=[];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  r[1] = p[1];
  r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateZ(out, a, b, c){
  let p = [], r=[];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  r[2] = p[2];

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
  let tempA = fromValues(a[0], a[1], a[2]);
  let tempB = fromValues(b[0], b[1], b[2]);

  normalize(tempA, tempA);
  normalize(tempB, tempB);

  let cosine = dot(tempA, tempB);

  if(cosine > 1.0) {
    return 0;
  }
  else if(cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2];
  let b0 = b[0], b1 = b[1], b2 = b[2];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)));
}

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;


/**
 * Alias for {@link vec3.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link vec3.divide}
 * @function
 */
const div = divide;
/* harmony export (immutable) */ __webpack_exports__["div"] = div;


/**
 * Alias for {@link vec3.distance}
 * @function
 */
const dist = distance;
/* harmony export (immutable) */ __webpack_exports__["dist"] = dist;


/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
const sqrDist = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["sqrDist"] = sqrDist;


/**
 * Alias for {@link vec3.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
const forEach = (function() {
  let vec = create();

  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if(!stride) {
      stride = 3;
    }

    if(!offset) {
      offset = 0;
    }

    if(count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for(i = offset; i < l; i += stride) {
      vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
      fn(vec, vec, arg);
      a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
    }

    return a;
  };
})();
/* harmony export (immutable) */ __webpack_exports__["forEach"] = forEach;



/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["divide"] = divide;
/* harmony export (immutable) */ __webpack_exports__["ceil"] = ceil;
/* harmony export (immutable) */ __webpack_exports__["floor"] = floor;
/* harmony export (immutable) */ __webpack_exports__["min"] = min;
/* harmony export (immutable) */ __webpack_exports__["max"] = max;
/* harmony export (immutable) */ __webpack_exports__["round"] = round;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["scaleAndAdd"] = scaleAndAdd;
/* harmony export (immutable) */ __webpack_exports__["distance"] = distance;
/* harmony export (immutable) */ __webpack_exports__["squaredDistance"] = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["length"] = length;
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["negate"] = negate;
/* harmony export (immutable) */ __webpack_exports__["inverse"] = inverse;
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;
/* harmony export (immutable) */ __webpack_exports__["random"] = random;
/* harmony export (immutable) */ __webpack_exports__["transformMat4"] = transformMat4;
/* harmony export (immutable) */ __webpack_exports__["transformQuat"] = transformQuat;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(3);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
function fromValues(x, y, z, w) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}

/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}

/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}

/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  return out;
}

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  let w = b[3] - a[3];
  return Math.sqrt(x*x + y*y + z*z + w*w);
}

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  let w = b[3] - a[3];
  return x*x + y*y + z*z + w*w;
}

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  return Math.sqrt(x*x + y*y + z*z + w*w);
}

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  return x*x + y*y + z*z + w*w;
}

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
function normalize(out, a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  let len = x*x + y*y + z*z + w*w;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    out[0] = x * len;
    out[1] = y * len;
    out[2] = z * len;
    out[3] = w * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
function lerp(out, a, b, t) {
  let ax = a[0];
  let ay = a[1];
  let az = a[2];
  let aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
function random(out, vectorScale) {
  vectorScale = vectorScale || 1.0;

  //TODO: This is a pretty awful way of doing this. Find something better.
  out[0] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  out[1] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  out[2] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  out[3] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  normalize(out, out);
  scale(out, out, vectorScale);
  return out;
}

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
function transformMat4(out, a, m) {
  let x = a[0], y = a[1], z = a[2], w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
function transformQuat(out, a, q) {
  let x = a[0], y = a[1], z = a[2];
  let qx = q[0], qy = q[1], qz = q[2], qw = q[3];

  // calculate quat * vec
  let ix = qw * x + qy * z - qz * y;
  let iy = qw * y + qz * x - qx * z;
  let iz = qw * z + qx * y - qy * x;
  let iw = -qx * x - qy * y - qz * z;

  // calculate result * inverse quat
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
}

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;


/**
 * Alias for {@link vec4.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link vec4.divide}
 * @function
 */
const div = divide;
/* harmony export (immutable) */ __webpack_exports__["div"] = div;


/**
 * Alias for {@link vec4.distance}
 * @function
 */
const dist = distance;
/* harmony export (immutable) */ __webpack_exports__["dist"] = dist;


/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
const sqrDist = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["sqrDist"] = sqrDist;


/**
 * Alias for {@link vec4.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
const forEach = (function() {
  let vec = create();

  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if(!stride) {
      stride = 4;
    }

    if(!offset) {
      offset = 0;
    }

    if(count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for(i = offset; i < l; i += stride) {
      vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
      fn(vec, vec, arg);
      a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
    }

    return a;
  };
})();
/* harmony export (immutable) */ __webpack_exports__["forEach"] = forEach;



/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// WebglConst.js

// stolen there https://github.com/mattdesl/gl-constants thanks @mattdesl ^^

module.exports = {
	ACTIVE_ATTRIBUTES: 35721,
	ACTIVE_ATTRIBUTE_MAX_LENGTH: 35722,
	ACTIVE_TEXTURE: 34016,
	ACTIVE_UNIFORMS: 35718,
	ACTIVE_UNIFORM_MAX_LENGTH: 35719,
	ALIASED_LINE_WIDTH_RANGE: 33902,
	ALIASED_POINT_SIZE_RANGE: 33901,
	ALPHA: 6406,
	ALPHA_BITS: 3413,
	ALWAYS: 519,
	ARRAY_BUFFER: 34962,
	ARRAY_BUFFER_BINDING: 34964,
	ATTACHED_SHADERS: 35717,
	BACK: 1029,
	BLEND: 3042,
	BLEND_COLOR: 32773,
	BLEND_DST_ALPHA: 32970,
	BLEND_DST_RGB: 32968,
	BLEND_EQUATION: 32777,
	BLEND_EQUATION_ALPHA: 34877,
	BLEND_EQUATION_RGB: 32777,
	BLEND_SRC_ALPHA: 32971,
	BLEND_SRC_RGB: 32969,
	BLUE_BITS: 3412,
	BOOL: 35670,
	BOOL_VEC2: 35671,
	BOOL_VEC3: 35672,
	BOOL_VEC4: 35673,
	BROWSER_DEFAULT_WEBGL: 37444,
	BUFFER_SIZE: 34660,
	BUFFER_USAGE: 34661,
	BYTE: 5120,
	CCW: 2305,
	CLAMP_TO_EDGE: 33071,
	COLOR_ATTACHMENT0: 36064,
	COLOR_BUFFER_BIT: 16384,
	COLOR_CLEAR_VALUE: 3106,
	COLOR_WRITEMASK: 3107,
	COMPILE_STATUS: 35713,
	COMPRESSED_TEXTURE_FORMATS: 34467,
	CONSTANT_ALPHA: 32771,
	CONSTANT_COLOR: 32769,
	CONTEXT_LOST_WEBGL: 37442,
	CULL_FACE: 2884,
	CULL_FACE_MODE: 2885,
	CURRENT_PROGRAM: 35725,
	CURRENT_VERTEX_ATTRIB: 34342,
	CW: 2304,
	DECR: 7683,
	DECR_WRAP: 34056,
	DELETE_STATUS: 35712,
	DEPTH_ATTACHMENT: 36096,
	DEPTH_BITS: 3414,
	DEPTH_BUFFER_BIT: 256,
	DEPTH_CLEAR_VALUE: 2931,
	DEPTH_COMPONENT: 6402,
	RED: 6403,
	DEPTH_COMPONENT16: 33189,
	DEPTH_FUNC: 2932,
	DEPTH_RANGE: 2928,
	DEPTH_STENCIL: 34041,
	DEPTH_STENCIL_ATTACHMENT: 33306,
	DEPTH_TEST: 2929,
	DEPTH_WRITEMASK: 2930,
	DITHER: 3024,
	DONT_CARE: 4352,
	DST_ALPHA: 772,
	DST_COLOR: 774,
	DYNAMIC_DRAW: 35048,
	ELEMENT_ARRAY_BUFFER: 34963,
	ELEMENT_ARRAY_BUFFER_BINDING: 34965,
	EQUAL: 514,
	FASTEST: 4353,
	FLOAT: 5126,
	FLOAT_MAT2: 35674,
	FLOAT_MAT3: 35675,
	FLOAT_MAT4: 35676,
	FLOAT_VEC2: 35664,
	FLOAT_VEC3: 35665,
	FLOAT_VEC4: 35666,
	FRAGMENT_SHADER: 35632,
	FRAMEBUFFER: 36160,
	FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 36049,
	FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 36048,
	FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 36051,
	FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 36050,
	FRAMEBUFFER_BINDING: 36006,
	FRAMEBUFFER_COMPLETE: 36053,
	FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 36054,
	FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 36057,
	FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 36055,
	FRAMEBUFFER_UNSUPPORTED: 36061,
	FRONT: 1028,
	FRONT_AND_BACK: 1032,
	FRONT_FACE: 2886,
	FUNC_ADD: 32774,
	FUNC_REVERSE_SUBTRACT: 32779,
	FUNC_SUBTRACT: 32778,
	GENERATE_MIPMAP_HINT: 33170,
	GEQUAL: 518,
	GREATER: 516,
	GREEN_BITS: 3411,
	HIGH_FLOAT: 36338,
	HIGH_INT: 36341,
	INCR: 7682,
	INCR_WRAP: 34055,
	INFO_LOG_LENGTH: 35716,
	INT: 5124,
	INT_VEC2: 35667,
	INT_VEC3: 35668,
	INT_VEC4: 35669,
	INVALID_ENUM: 1280,
	INVALID_FRAMEBUFFER_OPERATION: 1286,
	INVALID_OPERATION: 1282,
	INVALID_VALUE: 1281,
	INVERT: 5386,
	KEEP: 7680,
	LEQUAL: 515,
	LESS: 513,
	LINEAR: 9729,
	LINEAR_MIPMAP_LINEAR: 9987,
	LINEAR_MIPMAP_NEAREST: 9985,
	LINES: 1,
	LINE_LOOP: 2,
	LINE_STRIP: 3,
	LINE_WIDTH: 2849,
	LINK_STATUS: 35714,
	LOW_FLOAT: 36336,
	LOW_INT: 36339,
	LUMINANCE: 6409,
	LUMINANCE_ALPHA: 6410,
	MAX_COMBINED_TEXTURE_IMAGE_UNITS: 35661,
	MAX_CUBE_MAP_TEXTURE_SIZE: 34076,
	MAX_FRAGMENT_UNIFORM_VECTORS: 36349,
	MAX_RENDERBUFFER_SIZE: 34024,
	MAX_TEXTURE_IMAGE_UNITS: 34930,
	MAX_TEXTURE_SIZE: 3379,
	MAX_VARYING_VECTORS: 36348,
	MAX_VERTEX_ATTRIBS: 34921,
	MAX_VERTEX_TEXTURE_IMAGE_UNITS: 35660,
	MAX_VERTEX_UNIFORM_VECTORS: 36347,
	MAX_VIEWPORT_DIMS: 3386,
	MEDIUM_FLOAT: 36337,
	MEDIUM_INT: 36340,
	MIRRORED_REPEAT: 33648,
	NEAREST: 9728,
	NEAREST_MIPMAP_LINEAR: 9986,
	NEAREST_MIPMAP_NEAREST: 9984,
	NEVER: 512,
	NICEST: 4354,
	NONE: 0,
	NOTEQUAL: 517,
	NO_ERROR: 0,
	NUM_COMPRESSED_TEXTURE_FORMATS: 34466,
	ONE: 1,
	ONE_MINUS_CONSTANT_ALPHA: 32772,
	ONE_MINUS_CONSTANT_COLOR: 32770,
	ONE_MINUS_DST_ALPHA: 773,
	ONE_MINUS_DST_COLOR: 775,
	ONE_MINUS_SRC_ALPHA: 771,
	ONE_MINUS_SRC_COLOR: 769,
	OUT_OF_MEMORY: 1285,
	PACK_ALIGNMENT: 3333,
	POINTS: 0,
	POLYGON_OFFSET_FACTOR: 32824,
	POLYGON_OFFSET_FILL: 32823,
	POLYGON_OFFSET_UNITS: 10752,
	RED_BITS: 3410,
	RENDERBUFFER: 36161,
	RENDERBUFFER_ALPHA_SIZE: 36179,
	RENDERBUFFER_BINDING: 36007,
	RENDERBUFFER_BLUE_SIZE: 36178,
	RENDERBUFFER_DEPTH_SIZE: 36180,
	RENDERBUFFER_GREEN_SIZE: 36177,
	RENDERBUFFER_HEIGHT: 36163,
	RENDERBUFFER_INTERNAL_FORMAT: 36164,
	RENDERBUFFER_RED_SIZE: 36176,
	RENDERBUFFER_STENCIL_SIZE: 36181,
	RENDERBUFFER_WIDTH: 36162,
	RENDERER: 7937,
	REPEAT: 10497,
	REPLACE: 7681,
	RGB: 6407,
	RGB5_A1: 32855,
	RGB565: 36194,
	RGBA: 6408,
	RGBA4: 32854,
	SAMPLER_2D: 35678,
	SAMPLER_CUBE: 35680,
	SAMPLES: 32937,
	SAMPLE_ALPHA_TO_COVERAGE: 32926,
	SAMPLE_BUFFERS: 32936,
	SAMPLE_COVERAGE: 32928,
	SAMPLE_COVERAGE_INVERT: 32939,
	SAMPLE_COVERAGE_VALUE: 32938,
	SCISSOR_BOX: 3088,
	SCISSOR_TEST: 3089,
	SHADER_COMPILER: 36346,
	SHADER_SOURCE_LENGTH: 35720,
	SHADER_TYPE: 35663,
	SHADING_LANGUAGE_VERSION: 35724,
	SHORT: 5122,
	SRC_ALPHA: 770,
	SRC_ALPHA_SATURATE: 776,
	SRC_COLOR: 768,
	STATIC_DRAW: 35044,
	STENCIL_ATTACHMENT: 36128,
	STENCIL_BACK_FAIL: 34817,
	STENCIL_BACK_FUNC: 34816,
	STENCIL_BACK_PASS_DEPTH_FAIL: 34818,
	STENCIL_BACK_PASS_DEPTH_PASS: 34819,
	STENCIL_BACK_REF: 36003,
	STENCIL_BACK_VALUE_MASK: 36004,
	STENCIL_BACK_WRITEMASK: 36005,
	STENCIL_BITS: 3415,
	STENCIL_BUFFER_BIT: 1024,
	STENCIL_CLEAR_VALUE: 2961,
	STENCIL_FAIL: 2964,
	STENCIL_FUNC: 2962,
	STENCIL_INDEX: 6401,
	STENCIL_INDEX8: 36168,
	STENCIL_PASS_DEPTH_FAIL: 2965,
	STENCIL_PASS_DEPTH_PASS: 2966,
	STENCIL_REF: 2967,
	STENCIL_TEST: 2960,
	STENCIL_VALUE_MASK: 2963,
	STENCIL_WRITEMASK: 2968,
	STREAM_DRAW: 35040,
	SUBPIXEL_BITS: 3408,
	TEXTURE: 5890,
	TEXTURE0: 33984,
	TEXTURE1: 33985,
	TEXTURE2: 33986,
	TEXTURE3: 33987,
	TEXTURE4: 33988,
	TEXTURE5: 33989,
	TEXTURE6: 33990,
	TEXTURE7: 33991,
	TEXTURE8: 33992,
	TEXTURE9: 33993,
	TEXTURE10: 33994,
	TEXTURE11: 33995,
	TEXTURE12: 33996,
	TEXTURE13: 33997,
	TEXTURE14: 33998,
	TEXTURE15: 33999,
	TEXTURE16: 34000,
	TEXTURE17: 34001,
	TEXTURE18: 34002,
	TEXTURE19: 34003,
	TEXTURE20: 34004,
	TEXTURE21: 34005,
	TEXTURE22: 34006,
	TEXTURE23: 34007,
	TEXTURE24: 34008,
	TEXTURE25: 34009,
	TEXTURE26: 34010,
	TEXTURE27: 34011,
	TEXTURE28: 34012,
	TEXTURE29: 34013,
	TEXTURE30: 34014,
	TEXTURE31: 34015,
	TEXTURE_2D: 3553,
	TEXTURE_BINDING_2D: 32873,
	TEXTURE_BINDING_CUBE_MAP: 34068,
	TEXTURE_CUBE_MAP: 34067,
	TEXTURE_CUBE_MAP_NEGATIVE_X: 34070,
	TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072,
	TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074,
	TEXTURE_CUBE_MAP_POSITIVE_X: 34069,
	TEXTURE_CUBE_MAP_POSITIVE_Y: 34071,
	TEXTURE_CUBE_MAP_POSITIVE_Z: 34073,
	TEXTURE_MAG_FILTER: 10240,
	TEXTURE_MIN_FILTER: 10241,
	TEXTURE_WRAP_S: 10242,
	TEXTURE_WRAP_T: 10243,
	TRIANGLES: 4,
	TRIANGLE_FAN: 6,
	TRIANGLE_STRIP: 5,
	UNPACK_ALIGNMENT: 3317,
	UNPACK_COLORSPACE_CONVERSION_WEBGL: 37443,
	UNPACK_FLIP_Y_WEBGL: 37440,
	UNPACK_PREMULTIPLY_ALPHA_WEBGL: 37441,
	UNSIGNED_BYTE: 5121,
	UNSIGNED_INT: 5125,
	UNSIGNED_SHORT: 5123,
	UNSIGNED_SHORT_4_4_4_4: 32819,
	UNSIGNED_SHORT_5_5_5_1: 32820,
	UNSIGNED_SHORT_5_6_5: 33635,
	VALIDATE_STATUS: 35715,
	VENDOR: 7936,
	VERSION: 7938,
	VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 34975,
	VERTEX_ATTRIB_ARRAY_ENABLED: 34338,
	VERTEX_ATTRIB_ARRAY_NORMALIZED: 34922,
	VERTEX_ATTRIB_ARRAY_POINTER: 34373,
	VERTEX_ATTRIB_ARRAY_SIZE: 34339,
	VERTEX_ATTRIB_ARRAY_STRIDE: 34340,
	VERTEX_ATTRIB_ARRAY_TYPE: 34341,
	VERTEX_SHADER: 35633,
	VIEWPORT: 2978,
	ZERO: 0,
	R8: 33321
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function (gl, shaderProgram, name) {
	if (shaderProgram.cacheAttribLoc === undefined) {
		shaderProgram.cacheAttribLoc = {};
	}
	if (shaderProgram.cacheAttribLoc[name] === undefined) {
		shaderProgram.cacheAttribLoc[name] = gl.getAttribLocation(shaderProgram, name);
	}

	return shaderProgram.cacheAttribLoc[name];
};

; // getAttribLoc.js

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // GLTexture.js

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _WebglNumber = __webpack_require__(8);

var _WebglNumber2 = _interopRequireDefault(_WebglNumber);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function isPowerOfTwo(x) {
	return x !== 0 && !(x & x - 1);
};

function isSourcePowerOfTwo(obj) {
	var w = obj.width || obj.videoWidth;
	var h = obj.height || obj.videoHeight;

	if (!w || !h) {
		return false;
	}

	return isPowerOfTwo(w) && isPowerOfTwo(h);
};

var gl = void 0;

var GLTexture = function () {
	function GLTexture(mSource) {
		var isTexture = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
		var mParameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

		_classCallCheck(this, GLTexture);

		gl = _GLTool2.default.gl;

		if (isTexture) {
			this._texture = mSource;
		} else {
			this._mSource = mSource;
			this._texture = gl.createTexture();
			this._isVideo = mSource.tagName === 'VIDEO';
			this._premultiplyAlpha = true;
			this._magFilter = mParameters.magFilter || gl.LINEAR;
			this._minFilter = mParameters.minFilter || gl.NEAREST_MIPMAP_LINEAR;

			this._wrapS = mParameters.wrapS || gl.MIRRORED_REPEAT;
			this._wrapT = mParameters.wrapT || gl.MIRRORED_REPEAT;
			var width = mSource.width || mSource.videoWidth;

			if (width) {
				if (!isSourcePowerOfTwo(mSource)) {
					this._wrapS = this._wrapT = gl.CLAMP_TO_EDGE;
					if (this._minFilter === gl.NEAREST_MIPMAP_LINEAR) {
						this._minFilter = gl.LINEAR;
					}
				}
			} else {
				this._wrapS = this._wrapT = gl.CLAMP_TO_EDGE;
				if (this._minFilter === gl.NEAREST_MIPMAP_LINEAR) {
					this._minFilter = gl.LINEAR;
				}
			}

			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

			if (mSource.exposure) {
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, mSource.shape[0], mSource.shape[1], 0, gl.RGBA, gl.FLOAT, mSource.data);
			} else {
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, mSource);
				// gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
			}

			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this._magFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._minFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._wrapS);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._wrapT);

			// console.log('Texture Min :', WebglNumber[this._minFilter]);
			// console.log('Texture Mag :', WebglNumber[this._magFilter]);

			var ext = _GLTool2.default.getExtension('EXT_texture_filter_anisotropic');
			if (ext) {
				var max = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
				gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, max);
			}

			if (this._canGenerateMipmap()) {
				gl.generateMipmap(gl.TEXTURE_2D);
			}

			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}

	_createClass(GLTexture, [{
		key: 'generateMipmap',
		value: function generateMipmap() {
			if (!this._canGenerateMipmap()) {
				return;
			}
			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.generateMipmap(gl.TEXTURE_2D);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}

		//	MIPMAP FILTER

	}, {
		key: 'updateTexture',


		//	UPDATE TEXTURE

		value: function updateTexture(mSource) {
			if (mSource) {
				this._mSource = mSource;
			}
			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._mSource);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this._magFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._minFilter);
			if (this._canGenerateMipmap()) {
				gl.generateMipmap(gl.TEXTURE_2D);
			}

			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: 'bind',
		value: function bind(index) {
			if (index === undefined) {
				index = 0;
			}
			if (!_GLTool2.default.shader) {
				return;
			}

			gl.activeTexture(gl.TEXTURE0 + index);
			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			this._bindIndex = index;
		}
	}, {
		key: '_canGenerateMipmap',
		value: function _canGenerateMipmap() {
			return this._minFilter === gl.LINEAR_MIPMAP_NEAREST || this._minFilter === gl.NEAREST_MIPMAP_LINEAR || this._minFilter === gl.LINEAR_MIPMAP_LINEAR || this._minFilter === gl.NEAREST_MIPMAP_NEAREST;
		}

		//	GETTER

	}, {
		key: 'minFilter',
		set: function set(mValue) {
			if (mValue !== gl.LINEAR && mValue !== gl.NEAREST && mValue !== gl.NEAREST_MIPMAP_LINEAR && mValue !== gl.NEAREST_MIPMAP_LINEAR && mValue !== gl.LINEAR_MIPMAP_LINEAR && mValue !== gl.NEAREST_MIPMAP_NEAREST) {
				return this;
			}
			this._minFilter = mValue;
			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._minFilter);
			gl.bindTexture(gl.TEXTURE_2D, null);
		},
		get: function get() {
			return this._minFilter;
		}
	}, {
		key: 'magFilter',
		set: function set(mValue) {
			if (mValue !== gl.LINEAR && mValue !== gl.NEAREST) {
				return this;
			}
			this._magFilter = mValue;
			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this._magFilter);
			gl.bindTexture(gl.TEXTURE_2D, null);
		},
		get: function get() {
			return this._magFilter;
		}

		//	WRAP

	}, {
		key: 'wrapS',
		set: function set(mValue) {
			if (mValue !== gl.CLAMP_TO_EDGE && mValue !== gl.REPEAT && mValue !== gl.MIRRORED_REPEAT) {
				return this;
			}
			this._wrapS = mValue;
			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._wrapS);
			gl.bindTexture(gl.TEXTURE_2D, null);
		},
		get: function get() {
			return this._wrapS;
		}
	}, {
		key: 'wrapT',
		set: function set(mValue) {
			if (mValue !== gl.CLAMP_TO_EDGE && mValue !== gl.REPEAT && mValue !== gl.MIRRORED_REPEAT) {
				return this;
			}
			this._wrapT = mValue;
			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._wrapT);
			gl.bindTexture(gl.TEXTURE_2D, null);
		},
		get: function get() {
			return this._wrapT;
		}

		//	PREMULTIPLY ALPHA

	}, {
		key: 'premultiplyAlpha',
		set: function set(mValue) {
			this._premultiplyAlpha = mValue;
			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			console.log('premultiplyAlpha:', mValue);
			gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha);
			gl.bindTexture(gl.TEXTURE_2D, null);
		},
		get: function get() {
			return this._premultiplyAlpha;
		}
	}, {
		key: 'texture',
		get: function get() {
			return this._texture;
		}
	}]);

	return GLTexture;
}();

var _whiteTexture = void 0,
    _greyTexture = void 0,
    _blackTexture = void 0;

GLTexture.whiteTexture = function whiteTexture() {
	if (_whiteTexture === undefined) {
		var canvas = document.createElement('canvas');
		canvas.width = canvas.height = 4;
		var ctx = canvas.getContext('2d');
		ctx.fillStyle = '#fff';
		ctx.fillRect(0, 0, 4, 4);
		_whiteTexture = new GLTexture(canvas);
	}

	return _whiteTexture;
};

GLTexture.greyTexture = function greyTexture() {
	if (_greyTexture === undefined) {
		var canvas = document.createElement('canvas');
		canvas.width = canvas.height = 4;
		var ctx = canvas.getContext('2d');
		ctx.fillStyle = 'rgb(127, 127, 127)';
		ctx.fillRect(0, 0, 4, 4);
		_greyTexture = new GLTexture(canvas);
	}
	return _greyTexture;
};

GLTexture.blackTexture = function blackTexture() {
	if (_blackTexture === undefined) {
		var canvas = document.createElement('canvas');
		canvas.width = canvas.height = 4;
		var ctx = canvas.getContext('2d');
		ctx.fillStyle = 'rgb(127, 127, 127)';
		ctx.fillRect(0, 0, 4, 4);
		_blackTexture = new GLTexture(canvas);
	}
	return _blackTexture;
};

exports.default = GLTexture;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // GLTexture2.js

var _getTextureParameters = __webpack_require__(56);

var _getTextureParameters2 = _interopRequireDefault(_getTextureParameters);

var _WebglNumber = __webpack_require__(8);

var _WebglNumber2 = _interopRequireDefault(_WebglNumber);

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;

var GLTexture = function () {
	function GLTexture(mSource) {
		var mParam = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		var _this = this;

		var mWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
		var mHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

		_classCallCheck(this, GLTexture);

		gl = _GLTool2.default.gl;

		this._source = mSource;
		this._getDimension(mSource, mWidth, mHeight);
		this._sourceType = mParam.type || getSourceType(mSource);
		this._checkSource();
		this._texelType = this._getTexelType();
		this._isTextureReady = true;

		this._params = (0, _getTextureParameters2.default)(mParam, mSource, this._width, this._height);
		this._checkMipmap();
		this._checkWrapping();

		//	setup texture
		this._texture = gl.createTexture();

		if (this._sourceType === 'video') {
			this._isTextureReady = false;
			_scheduling2.default.addEF(function () {
				return _this._loop();
			});
		} else {
			this._uploadTexture();
		}
	}

	_createClass(GLTexture, [{
		key: '_loop',
		value: function _loop() {
			if (this._source.readyState == 4) {
				this._isTextureReady = true;
				this._uploadTexture();
			}
		}
	}, {
		key: '_uploadTexture',
		value: function _uploadTexture() {
			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

			if (this._isSourceHtmlElement()) {
				gl.texImage2D(gl.TEXTURE_2D, 0, this._params.internalFormat, this._params.format, this._texelType, this._source);
			} else {
				gl.texImage2D(gl.TEXTURE_2D, 0, this._params.internalFormat, this._width, this._height, 0, this._params.format, this._texelType, this._source);
			}

			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this._params.magFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._params.minFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._params.wrapS);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._params.wrapT);
			gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._params.premultiplyAlpha);

			if (this._params.anisotropy > 0) {
				var ext = _GLTool2.default.getExtension('EXT_texture_filter_anisotropic');
				if (ext) {
					var max = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
					var level = Math.min(max, this._params.anisotropy);
					gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, level);
				}
			}

			if (this._generateMipmap) {
				gl.generateMipmap(gl.TEXTURE_2D);
			}

			//	unbind texture
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: 'bind',
		value: function bind(index) {
			if (index === undefined) {
				index = 0;
			}
			if (!_GLTool2.default.shader) {
				return;
			}

			gl.activeTexture(gl.TEXTURE0 + index);
			if (this._isTextureReady) {
				gl.bindTexture(gl.TEXTURE_2D, this._texture);
			} else {
				gl.bindTexture(gl.TEXTURE_2D, GLTexture.blackTexture().texture);
			}

			this._bindIndex = index;
		}
	}, {
		key: 'updateTexture',
		value: function updateTexture(mSource) {
			this._source = mSource;
			this._checkSource();
			this._uploadTexture();
		}
	}, {
		key: 'generateMipmap',
		value: function generateMipmap() {
			if (!this._generateMipmap) {
				return;
			}
			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.generateMipmap(gl.TEXTURE_2D);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: 'showParameters',
		value: function showParameters() {
			console.log('Source type : ', _WebglNumber2.default[this._sourceType] || this._sourceType);
			console.log('Texel type:', _WebglNumber2.default[this.texelType]);
			console.log('Dimension :', this._width, this._height);
			for (var s in this._params) {
				console.log(s, _WebglNumber2.default[this._params[s]] || this._params[s]);
			}

			console.log('Mipmapping :', this._generateMipmap);
		}
	}, {
		key: '_getDimension',
		value: function _getDimension(mSource, mWidth, mHeight) {
			if (mSource) {
				//	for html image / video element
				this._width = mSource.width || mSource.videoWidth;
				this._height = mSource.height || mSource.videoWidth;

				//	for manual width / height settings
				this._width = this._width || mWidth;
				this._height = this._height || mHeight;

				//	auto detect ( data array) ? not sure is good idea ? 
				//	todo : check HDR 
				if (!this._width || !this._height) {
					this._width = this._height = Math.sqrt(mSource.length / 4);
					// console.log('Auto detect, data dimension : ', this._width, this._height);	
				}
			} else {
				this._width = mWidth;
				this._height = mHeight;
			}
		}
	}, {
		key: '_checkSource',
		value: function _checkSource() {
			if (!this._source) {
				return;
			}

			if (this._sourceType === _GLTool2.default.UNSIGNED_BYTE) {
				if (!(this._source instanceof Uint8Array)) {
					// console.log('Converting to Uint8Array');
					this._source = new Uint8Array(this._source);
				}
			} else if (this._sourceType === _GLTool2.default.FLOAT) {
				if (!(this._source instanceof Float32Array)) {
					// console.log('Converting to Float32Array');
					this._source = new Float32Array(this._source);
				}
			}
		}
	}, {
		key: '_getTexelType',
		value: function _getTexelType() {
			if (this._isSourceHtmlElement()) {
				return _GLTool2.default.UNSIGNED_BYTE;
			}

			//	bad code here, if the type is not on the webglNumber list, it doesn't work
			return _GLTool2.default[_WebglNumber2.default[this._sourceType]] || this._sourceType;
		}
	}, {
		key: '_checkMipmap',
		value: function _checkMipmap() {
			this._generateMipmap = this._params.mipmap;

			if (!(isPowerOfTwo(this._width) && isPowerOfTwo(this._height))) {
				this._generateMipmap = false;
			}

			var minFilter = _WebglNumber2.default[this._params.minFilter];
			if (minFilter.indexOf('MIPMAP') == -1) {
				this._generateMipmap = false;
			}
		}
	}, {
		key: '_checkWrapping',
		value: function _checkWrapping() {
			if (!this._generateMipmap) {
				this._params.wrapS = _GLTool2.default.CLAMP_TO_EDGE;
				this._params.wrapT = _GLTool2.default.CLAMP_TO_EDGE;
			}
		}
	}, {
		key: '_isSourceHtmlElement',
		value: function _isSourceHtmlElement() {
			return this._sourceType === 'image' || this._sourceType === 'video' || this._sourceType === 'canvas';
		}
	}, {
		key: 'minFilter',
		get: function get() {
			return this._params.minFilter;
		},
		set: function set(mValue) {
			this._params.minFilter = mValue;
			this._checkMipmap();

			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._params.minFilter);
			gl.bindTexture(gl.TEXTURE_2D, null);

			this.generateMipmap();
		}
	}, {
		key: 'magFilter',
		get: function get() {
			return this._params.minFilter;
		},
		set: function set(mValue) {
			this._params.magFilter = mValue;

			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this._params.magFilter);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: 'wrapS',
		get: function get() {
			return this._params.wrapS;
		},
		set: function set(mValue) {
			this._params.wrapS = mValue;
			this._checkWrapping();

			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._params.wrapS);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: 'wrapT',
		get: function get() {
			return this._params.wrapT;
		},
		set: function set(mValue) {
			this._params.wrapT = mValue;
			this._checkWrapping();

			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._params.wrapT);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: 'texelType',
		get: function get() {
			return this._texelType;
		}
	}, {
		key: 'width',
		get: function get() {
			return this._width;
		}
	}, {
		key: 'height',
		get: function get() {
			return this._height;
		}
	}, {
		key: 'texture',
		get: function get() {
			return this._texture;
		}
	}, {
		key: 'isTextureReady',
		get: function get() {
			return this._isTextureReady;
		}
	}]);

	return GLTexture;
}();

function isPowerOfTwo(x) {
	return x !== 0 && !(x & x - 1);
};

function getSourceType(mSource) {
	//	possible source type : Image / Video / Unit8Array / Float32Array
	//	this list must be flexible

	var type = _GLTool2.default.UNSIGNED_BYTE;

	if (mSource instanceof Array) {
		type = _GLTool2.default.UNSIGNED_BYTE;
	} else if (mSource instanceof Uint8Array) {
		type = _GLTool2.default.UNSIGNED_BYTE;
	} else if (mSource instanceof Float32Array) {
		type = _GLTool2.default.FLOAT;
	} else if (mSource instanceof HTMLImageElement) {
		type = 'image';
	} else if (mSource instanceof HTMLCanvasElement) {
		type = 'canvas';
	} else if (mSource instanceof HTMLVideoElement) {
		type = 'video';
	}
	return type;
}

var _whiteTexture = void 0,
    _greyTexture = void 0,
    _blackTexture = void 0;

GLTexture.whiteTexture = function whiteTexture() {
	if (_whiteTexture === undefined) {
		var canvas = document.createElement('canvas');
		canvas.width = canvas.height = 2;
		var ctx = canvas.getContext('2d');
		ctx.fillStyle = '#fff';
		ctx.fillRect(0, 0, 2, 2);
		_whiteTexture = new GLTexture(canvas);
	}

	return _whiteTexture;
};

GLTexture.greyTexture = function greyTexture() {
	if (_greyTexture === undefined) {
		var canvas = document.createElement('canvas');
		canvas.width = canvas.height = 2;
		var ctx = canvas.getContext('2d');
		ctx.fillStyle = 'rgb(127, 127, 127)';
		ctx.fillRect(0, 0, 2, 2);
		_greyTexture = new GLTexture(canvas);
	}
	return _greyTexture;
};

GLTexture.blackTexture = function blackTexture() {
	if (_blackTexture === undefined) {
		var canvas = document.createElement('canvas');
		canvas.width = canvas.height = 2;
		var ctx = canvas.getContext('2d');
		ctx.fillStyle = 'rgb(0, 0, 0)';
		ctx.fillRect(0, 0, 2, 2);
		_blackTexture = new GLTexture(canvas);
	}
	return _blackTexture;
};

exports.default = GLTexture;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// GLCubeTexture.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _parseDds = __webpack_require__(57);

var _parseDds2 = _interopRequireDefault(_parseDds);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;
var DDSD_MIPMAPCOUNT = 0x20000;
var OFF_MIPMAPCOUNT = 7;
var headerLengthInt = 31;

var GLCubeTexture = function () {
	function GLCubeTexture(mSource) {
		var mParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		var isCubeTexture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

		_classCallCheck(this, GLCubeTexture);

		gl = _GLTool2.default.gl;

		if (isCubeTexture) {
			this.texture = mSource;
			return;
		}

		var hasMipmaps = mSource.length > 6;
		if (mSource[0].mipmapCount) {
			hasMipmaps = mSource[0].mipmapCount > 1;
		}

		this.texture = gl.createTexture();
		this.magFilter = mParameters.magFilter || gl.LINEAR;
		this.minFilter = mParameters.minFilter || gl.LINEAR_MIPMAP_LINEAR;
		this.wrapS = mParameters.wrapS || gl.CLAMP_TO_EDGE;
		this.wrapT = mParameters.wrapT || gl.CLAMP_TO_EDGE;

		if (!hasMipmaps && this.minFilter == gl.LINEAR_MIPMAP_LINEAR) {
			this.minFilter = gl.LINEAR;
		}

		gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
		var targets = [gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];

		var numLevels = 1;
		var index = 0;
		numLevels = mSource.length / 6;
		this.numLevels = numLevels;

		if (hasMipmaps) {
			for (var j = 0; j < 6; j++) {
				for (var i = 0; i < numLevels; i++) {
					gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

					index = j * numLevels + i;
					if (mSource[index].shape) {
						gl.texImage2D(targets[j], i, gl.RGBA, mSource[index].shape[0], mSource[index].shape[1], 0, gl.RGBA, gl.FLOAT, mSource[index].data);
					} else {
						gl.texImage2D(targets[j], i, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, mSource[index]);
					}

					gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, this.wrapS);
					gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, this.wrapT);
					gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, this.magFilter);
					gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, this.minFilter);
				}
			}
		} else {
			var _index = 0;
			for (var _j = 0; _j < 6; _j++) {
				_index = _j * numLevels;
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
				if (mSource[_index].shape) {
					gl.texImage2D(targets[_j], 0, gl.RGBA, mSource[_index].shape[0], mSource[_index].shape[1], 0, gl.RGBA, gl.FLOAT, mSource[_index].data);
				} else {
					gl.texImage2D(targets[_j], 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, mSource[_index]);
				}
				gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, this.wrapS);
				gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, this.wrapT);
				gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, this.magFilter);
				gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, this.minFilter);
			}

			gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
		}

		gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
	}

	//	PUBLIC METHOD

	_createClass(GLCubeTexture, [{
		key: 'bind',
		value: function bind() {
			var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

			if (!_GLTool2.default.shader) {
				return;
			}

			gl.activeTexture(gl.TEXTURE0 + index);
			gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
			gl.uniform1i(_GLTool2.default.shader.uniformTextures[index], index);
			this._bindIndex = index;
		}
	}, {
		key: 'unbind',
		value: function unbind() {
			gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
		}
	}]);

	return GLCubeTexture;
}();

GLCubeTexture.parseDDS = function parseDDS(mArrayBuffer) {

	function clamp(value, min, max) {
		if (min > max) {
			return clamp(value, max, min);
		}

		if (value < min) return min;else if (value > max) return max;else return value;
	}

	//	CHECKING MIP MAP LEVELS
	var ddsInfos = (0, _parseDds2.default)(mArrayBuffer);
	var flags = ddsInfos.flags;

	var header = new Int32Array(mArrayBuffer, 0, headerLengthInt);
	var mipmapCount = 1;
	if (flags & DDSD_MIPMAPCOUNT) {
		mipmapCount = Math.max(1, header[OFF_MIPMAPCOUNT]);
	}
	var sources = ddsInfos.images.map(function (img) {
		var faceData = new Float32Array(mArrayBuffer.slice(img.offset, img.offset + img.length));
		return {
			data: faceData,
			shape: img.shape,
			mipmapCount: mipmapCount
		};
	});

	return new GLCubeTexture(sources);
};

exports.default = GLCubeTexture;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// EventDispatcher.js

var supportsCustomEvents = true;
try {
	var newTestCustomEvent = document.createEvent('CustomEvent');
	newTestCustomEvent = null;
} catch (e) {
	supportsCustomEvents = false;
}

var EventDispatcher = function () {
	function EventDispatcher() {
		_classCallCheck(this, EventDispatcher);

		this._eventListeners = {};
	}

	_createClass(EventDispatcher, [{
		key: 'addEventListener',
		value: function addEventListener(aEventType, aFunction) {

			if (this._eventListeners === null || this._eventListeners === undefined) {
				this._eventListeners = {};
			}

			if (!this._eventListeners[aEventType]) {
				this._eventListeners[aEventType] = [];
			}
			this._eventListeners[aEventType].push(aFunction);

			return this;
		}
	}, {
		key: 'on',
		value: function on(aEventType, aFunction) {
			return this.addEventListener(aEventType, aFunction);
		}
	}, {
		key: 'removeEventListener',
		value: function removeEventListener(aEventType, aFunction) {
			if (this._eventListeners === null || this._eventListeners === undefined) {
				this._eventListeners = {};
			}
			var currentArray = this._eventListeners[aEventType];

			if (typeof currentArray === 'undefined') {
				return this;
			}

			var currentArrayLength = currentArray.length;
			for (var i = 0; i < currentArrayLength; i++) {
				if (currentArray[i] === aFunction) {
					currentArray.splice(i, 1);
					i--;
					currentArrayLength--;
				}
			}
			return this;
		}
	}, {
		key: 'off',
		value: function off(aEventType, aFunction) {
			return this.removeEventListener(aEventType, aFunction);
		}
	}, {
		key: 'dispatchEvent',
		value: function dispatchEvent(aEvent) {
			if (this._eventListeners === null || this._eventListeners === undefined) {
				this._eventListeners = {};
			}
			var eventType = aEvent.type;

			try {
				if (aEvent.target === null) {
					aEvent.target = this;
				}
				aEvent.currentTarget = this;
			} catch (theError) {
				var newEvent = { type: eventType, detail: aEvent.detail, dispatcher: this };
				return this.dispatchEvent(newEvent);
			}

			var currentEventListeners = this._eventListeners[eventType];
			if (currentEventListeners !== null && currentEventListeners !== undefined) {
				var currentArray = this._copyArray(currentEventListeners);
				var currentArrayLength = currentArray.length;
				for (var i = 0; i < currentArrayLength; i++) {
					var currentFunction = currentArray[i];
					currentFunction.call(this, aEvent);
				}
			}
			return this;
		}
	}, {
		key: 'dispatchCustomEvent',
		value: function dispatchCustomEvent(aEventType, aDetail) {
			var newEvent = void 0;
			if (supportsCustomEvents) {
				newEvent = document.createEvent('CustomEvent');
				newEvent.dispatcher = this;
				newEvent.initCustomEvent(aEventType, false, false, aDetail);
			} else {
				newEvent = { type: aEventType, detail: aDetail, dispatcher: this };
			}
			return this.dispatchEvent(newEvent);
		}
	}, {
		key: 'trigger',
		value: function trigger(aEventType, aDetail) {
			return this.dispatchCustomEvent(aEventType, aDetail);
		}
	}, {
		key: '_destroy',
		value: function _destroy() {
			if (this._eventListeners !== null) {
				for (var objectName in this._eventListeners) {
					if (this._eventListeners.hasOwnProperty(objectName)) {
						var currentArray = this._eventListeners[objectName];
						var currentArrayLength = currentArray.length;
						for (var i = 0; i < currentArrayLength; i++) {
							currentArray[i] = null;
						}
						delete this._eventListeners[objectName];
					}
				}
				this._eventListeners = null;
			}
		}
	}, {
		key: '_copyArray',
		value: function _copyArray(aArray) {
			var currentArray = new Array(aArray.length);
			var currentArrayLength = currentArray.length;
			for (var i = 0; i < currentArrayLength; i++) {
				currentArray[i] = aArray[i];
			}
			return currentArray;
		}
	}]);

	return EventDispatcher;
}();

exports.default = EventDispatcher;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OrbitalControl.js


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _EaseNumber = __webpack_require__(13);

var _EaseNumber2 = _interopRequireDefault(_EaseNumber);

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

var _glMatrix = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var getMouse = function getMouse(mEvent, mTarget) {

	var o = mTarget || {};
	if (mEvent.touches) {
		o.x = mEvent.touches[0].pageX;
		o.y = mEvent.touches[0].pageY;
	} else {
		o.x = mEvent.clientX;
		o.y = mEvent.clientY;
	}

	return o;
};

var OrbitalControl = function () {
	function OrbitalControl(mTarget) {
		var _this = this;

		var mListenerTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;
		var mRadius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 500;

		_classCallCheck(this, OrbitalControl);

		this._target = mTarget;
		this._listenerTarget = mListenerTarget;
		this._mouse = {};
		this._preMouse = {};
		this.center = _glMatrix.vec3.create();
		this._up = _glMatrix.vec3.fromValues(0, 1, 0);
		this.radius = new _EaseNumber2.default(mRadius);
		this.position = _glMatrix.vec3.fromValues(0, 0, this.radius.value);
		this.positionOffset = _glMatrix.vec3.create();
		this._rx = new _EaseNumber2.default(0);
		this._rx.limit(-Math.PI / 2, Math.PI / 2);
		this._ry = new _EaseNumber2.default(0);
		this._preRX = 0;
		this._preRY = 0;

		this._isLockZoom = false;
		this._isLockRotation = false;
		this._isInvert = false;
		this.sensitivity = 1.0;

		this._wheelBind = function (e) {
			return _this._onWheel(e);
		};
		this._downBind = function (e) {
			return _this._onDown(e);
		};
		this._moveBind = function (e) {
			return _this._onMove(e);
		};
		this._upBind = function () {
			return _this._onUp();
		};

		this.connect();
		_scheduling2.default.addEF(function () {
			return _this._loop();
		});
	}

	_createClass(OrbitalControl, [{
		key: 'connect',
		value: function connect() {
			this.disconnect();

			this._listenerTarget.addEventListener('mousewheel', this._wheelBind);
			this._listenerTarget.addEventListener('DOMMouseScroll', this._wheelBind);

			this._listenerTarget.addEventListener('mousedown', this._downBind);
			this._listenerTarget.addEventListener('touchstart', this._downBind);
			this._listenerTarget.addEventListener('mousemove', this._moveBind);
			this._listenerTarget.addEventListener('touchmove', this._moveBind);
			window.addEventListener('touchend', this._upBind);
			window.addEventListener('mouseup', this._upBind);
		}
	}, {
		key: 'disconnect',
		value: function disconnect() {
			this._listenerTarget.removeEventListener('mousewheel', this._wheelBind);
			this._listenerTarget.removeEventListener('DOMMouseScroll', this._wheelBind);

			this._listenerTarget.removeEventListener('mousedown', this._downBind);
			this._listenerTarget.removeEventListener('touchstart', this._downBind);
			this._listenerTarget.removeEventListener('mousemove', this._moveBind);
			this._listenerTarget.removeEventListener('touchmove', this._moveBind);
			window.removeEventListener('touchend', this._upBind);
			window.removeEventListener('mouseup', this._upBind);
		}

		//	PUBLIC METHODS

	}, {
		key: 'lock',
		value: function lock() {
			var mValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			this._isLockZoom = mValue;
			this._isLockRotation = mValue;
			this._isMouseDown = false;
		}
	}, {
		key: 'lockZoom',
		value: function lockZoom() {
			var mValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			this._isLockZoom = mValue;
		}
	}, {
		key: 'lockRotation',
		value: function lockRotation() {
			var mValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			this._isLockRotation = mValue;
		}
	}, {
		key: 'inverseControl',
		value: function inverseControl() {
			var isInvert = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			this._isInvert = isInvert;
		}

		//	EVENT HANDLERES

	}, {
		key: '_onDown',
		value: function _onDown(mEvent) {
			if (this._isLockRotation) {
				return;
			}
			this._isMouseDown = true;
			getMouse(mEvent, this._mouse);
			getMouse(mEvent, this._preMouse);
			this._preRX = this._rx.targetValue;
			this._preRY = this._ry.targetValue;
		}
	}, {
		key: '_onMove',
		value: function _onMove(mEvent) {
			if (this._isLockRotation) {
				return;
			}
			getMouse(mEvent, this._mouse);
			if (mEvent.touches) {
				mEvent.preventDefault();
			}

			if (this._isMouseDown) {
				var diffX = -(this._mouse.x - this._preMouse.x);
				if (this._isInvert) {
					diffX *= -1;
				}
				this._ry.value = this._preRY - diffX * 0.01 * this.sensitivity;

				var diffY = -(this._mouse.y - this._preMouse.y);
				if (this._isInvert) {
					diffY *= -1;
				}
				this._rx.value = this._preRX - diffY * 0.01 * this.sensitivity;
			}
		}
	}, {
		key: '_onUp',
		value: function _onUp() {
			if (this._isLockRotation) {
				return;
			}
			this._isMouseDown = false;
		}
	}, {
		key: '_onWheel',
		value: function _onWheel(mEvent) {
			if (this._isLockZoom) {
				return;
			}
			var w = mEvent.wheelDelta;
			var d = mEvent.detail;
			var value = 0;
			if (d) {
				if (w) {
					value = w / d / 40 * d > 0 ? 1 : -1; // Opera
				} else {
					value = -d / 3; // Firefox;         TODO: do not /3 for OS X
				}
			} else {
				value = w / 120;
			}

			this.radius.add(-value * 2);
		}

		//	PRIVATE METHODS

	}, {
		key: '_loop',
		value: function _loop() {

			this._updatePosition();

			if (this._target) {
				this._updateCamera();
			}
		}
	}, {
		key: '_updatePosition',
		value: function _updatePosition() {
			this.position[1] = Math.sin(this._rx.value) * this.radius.value;
			var tr = Math.cos(this._rx.value) * this.radius.value;
			this.position[0] = Math.cos(this._ry.value + Math.PI * 0.5) * tr;
			this.position[2] = Math.sin(this._ry.value + Math.PI * 0.5) * tr;
			_glMatrix.vec3.add(this.position, this.position, this.positionOffset);
		}
	}, {
		key: '_updateCamera',
		value: function _updateCamera() {
			this._target.lookAt(this.position, this.center, this._up);
		}

		//	GETTER / SETTER


	}, {
		key: 'rx',
		get: function get() {
			return this._rx;
		}
	}, {
		key: 'ry',
		get: function get() {
			return this._ry;
		}
	}]);

	return OrbitalControl;
}();

exports.default = OrbitalControl;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Camera2 = __webpack_require__(15);

var _Camera3 = _interopRequireDefault(_Camera2);

var _glMatrix = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // CameraOrtho.js

var CameraOrtho = function (_Camera) {
	_inherits(CameraOrtho, _Camera);

	function CameraOrtho() {
		_classCallCheck(this, CameraOrtho);

		var _this = _possibleConstructorReturn(this, (CameraOrtho.__proto__ || Object.getPrototypeOf(CameraOrtho)).call(this));

		var eye = _glMatrix.vec3.clone([0, 0, 15]);
		var center = _glMatrix.vec3.create();
		var up = _glMatrix.vec3.clone([0, -1, 0]);
		_this.lookAt(eye, center, up);
		_this.ortho(1, -1, 1, -1);
		return _this;
	}

	_createClass(CameraOrtho, [{
		key: 'setBoundary',
		value: function setBoundary(left, right, top, bottom) {
			var near = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.1;
			var far = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 100;

			this.ortho(left, right, top, bottom, near, far);
		}
	}, {
		key: 'ortho',
		value: function ortho(left, right, top, bottom) {
			var near = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.1;
			var far = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 100;

			this.left = left;
			this.right = right;
			this.top = top;
			this.bottom = bottom;
			mat4.ortho(this._projection, left, right, top, bottom, near, far);
		}
	}]);

	return CameraOrtho;
}(_Camera3.default);

exports.default = CameraOrtho;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Object3D.js

var _glMatrix = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Object3D = function () {
	function Object3D() {
		_classCallCheck(this, Object3D);

		this._needUpdate = true;

		this._x = 0;
		this._y = 0;
		this._z = 0;

		this._sx = 1;
		this._sy = 1;
		this._sz = 1;

		this._rx = 0;
		this._ry = 0;
		this._rz = 0;

		this._position = _glMatrix.vec3.create();
		this._scale = _glMatrix.vec3.fromValues(1, 1, 1);
		this._rotation = _glMatrix.vec3.create();

		this._matrix = _glMatrix.mat4.create();
		this._matrixRotation = _glMatrix.mat4.create();
		this._matrixScale = _glMatrix.mat4.create();
		this._matrixTranslation = _glMatrix.mat4.create();
		this._matrixQuaternion = _glMatrix.mat4.create();
		this._quat = _glMatrix.quat.create();
	}

	_createClass(Object3D, [{
		key: '_update',
		value: function _update() {
			_glMatrix.vec3.set(this._scale, this._sx, this._sy, this._sz);
			_glMatrix.vec3.set(this._rotation, this._rx, this._ry, this._rz);
			_glMatrix.vec3.set(this._position, this._x, this._y, this._z);

			_glMatrix.mat4.identity(this._matrixTranslation, this._matrixTranslation);
			_glMatrix.mat4.identity(this._matrixScale, this._matrixScale);
			_glMatrix.mat4.identity(this._matrixRotation, this._matrixRotation);

			_glMatrix.mat4.rotateX(this._matrixRotation, this._matrixRotation, this._rx);
			_glMatrix.mat4.rotateY(this._matrixRotation, this._matrixRotation, this._ry);
			_glMatrix.mat4.rotateZ(this._matrixRotation, this._matrixRotation, this._rz);

			_glMatrix.mat4.fromQuat(this._matrixQuaternion, this._quat);
			_glMatrix.mat4.mul(this._matrixRotation, this._matrixQuaternion, this._matrixRotation);

			_glMatrix.mat4.scale(this._matrixScale, this._matrixScale, this._scale);
			_glMatrix.mat4.translate(this._matrixTranslation, this._matrixTranslation, this._position);

			_glMatrix.mat4.mul(this._matrix, this._matrixTranslation, this._matrixRotation);
			_glMatrix.mat4.mul(this._matrix, this._matrix, this._matrixScale);

			this._needUpdate = false;
		}
	}, {
		key: 'setRotationFromQuaternion',
		value: function setRotationFromQuaternion(mQuat) {
			_glMatrix.quat.copy(this._quat, mQuat);
			this._needUpdate = true;
		}
	}, {
		key: 'matrix',
		get: function get() {
			if (this._needUpdate) {
				this._update();
			}
			return this._matrix;
		}
	}, {
		key: 'x',
		get: function get() {
			return this._x;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._x = mValue;
		}
	}, {
		key: 'y',
		get: function get() {
			return this._y;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._y = mValue;
		}
	}, {
		key: 'z',
		get: function get() {
			return this._z;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._z = mValue;
		}
	}, {
		key: 'scaleX',
		get: function get() {
			return this._sx;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._sx = mValue;
		}
	}, {
		key: 'scaleY',
		get: function get() {
			return this._sy;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._sy = mValue;
		}
	}, {
		key: 'scaleZ',
		get: function get() {
			return this._sz;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._sz = mValue;
		}
	}, {
		key: 'rotationX',
		get: function get() {
			return this._rx;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._rx = mValue;
		}
	}, {
		key: 'rotationY',
		get: function get() {
			return this._ry;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._ry = mValue;
		}
	}, {
		key: 'rotationZ',
		get: function get() {
			return this._rz;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._rz = mValue;
		}
	}]);

	return Object3D;
}();

exports.default = Object3D;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// ShaderLbs.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _simpleColor = __webpack_require__(10);

var _simpleColor2 = _interopRequireDefault(_simpleColor);

var _bigTriangle = __webpack_require__(18);

var _bigTriangle2 = _interopRequireDefault(_bigTriangle);

var _general = __webpack_require__(34);

var _general2 = _interopRequireDefault(_general);

var _copy = __webpack_require__(19);

var _copy2 = _interopRequireDefault(_copy);

var _basic = __webpack_require__(11);

var _basic2 = _interopRequireDefault(_basic);

var _skybox = __webpack_require__(35);

var _skybox2 = _interopRequireDefault(_skybox);

var _skybox3 = __webpack_require__(36);

var _skybox4 = _interopRequireDefault(_skybox3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ShaderLibs = {
	simpleColorFrag: _simpleColor2.default,
	bigTriangleVert: _bigTriangle2.default,
	generalVert: _general2.default,
	copyFrag: _copy2.default,
	basicVert: _basic2.default,
	skyboxVert: _skybox2.default,
	skyboxFrag: _skybox4.default
};

exports.default = ShaderLibs;

/***/ }),
/* 34 */
/***/ (function(module, exports) {

module.exports = "// generalWithNormal.vert\n\n#define SHADER_NAME GENERAL_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\n\nuniform vec3 position;\nuniform vec3 scale;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\n\nvoid main(void) {\n\tvec3 pos      = aVertexPosition * scale;\n\tpos           += position;\n\tgl_Position   = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(pos, 1.0);\n\t\n\tvTextureCoord = aTextureCoord;\n\tvNormal       = normalize(uNormalMatrix * aNormal);\n}"

/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = "// basic.vert\n\n#define SHADER_NAME SKYBOX_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vVertex;\nvarying vec3 vNormal;\n\nvoid main(void) {\n\tmat4 matView = uViewMatrix;\n\tmatView[3][0] = 0.0;\n\tmatView[3][1] = 0.0;\n\tmatView[3][2] = 0.0;\n\t\n\tgl_Position = uProjectionMatrix * matView * uModelMatrix * vec4(aVertexPosition, 1.0);\n\tvTextureCoord = aTextureCoord;\n\t\n\tvVertex = aVertexPosition;\n\tvNormal = aNormal;\n}"

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = "// basic.frag\n\n#define SHADER_NAME SKYBOX_FRAGMENT\n\nprecision mediump float;\n#define GLSLIFY 1\nuniform samplerCube texture;\nvarying vec2 vTextureCoord;\nvarying vec3 vVertex;\n\nvoid main(void) {\n    gl_FragColor = textureCube(texture, vVertex);\n}"

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// PassMacro.js

var PassMacro = function () {
	function PassMacro() {
		_classCallCheck(this, PassMacro);

		this._passes = [];
	}

	_createClass(PassMacro, [{
		key: "addPass",
		value: function addPass(pass) {
			this._passes.push(pass);
		}
	}, {
		key: "passes",
		get: function get() {
			return this._passes;
		}
	}]);

	return PassMacro;
}();

exports.default = PassMacro;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _PassBlurBase2 = __webpack_require__(39);

var _PassBlurBase3 = _interopRequireDefault(_PassBlurBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // PassVBlur.js

var PassVBlur = function (_PassBlurBase) {
	_inherits(PassVBlur, _PassBlurBase);

	function PassVBlur() {
		var mQuality = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 9;
		var mWidth = arguments[1];
		var mHeight = arguments[2];
		var mParams = arguments[3];

		_classCallCheck(this, PassVBlur);

		return _possibleConstructorReturn(this, (PassVBlur.__proto__ || Object.getPrototypeOf(PassVBlur)).call(this, mQuality, [0, 1], mWidth, mHeight, mParams));
	}

	return PassVBlur;
}(_PassBlurBase3.default);

exports.default = PassVBlur;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Pass2 = __webpack_require__(9);

var _Pass3 = _interopRequireDefault(_Pass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // PassBlurBase.js

var fsBlur5 = __webpack_require__(76);
var fsBlur9 = __webpack_require__(77);
var fsBlur13 = __webpack_require__(78);

var PassBlurBase = function (_Pass) {
	_inherits(PassBlurBase, _Pass);

	function PassBlurBase() {
		var mQuality = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 9;
		var mDirection = arguments[1];
		var mWidth = arguments[2];
		var mHeight = arguments[3];
		var mParams = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

		_classCallCheck(this, PassBlurBase);

		var fs = void 0;
		switch (mQuality) {
			case 5:
			default:
				fs = fsBlur5;
				break;
			case 9:
				fs = fsBlur9;
				break;
			case 13:
				fs = fsBlur13;
				break;

		}

		var _this = _possibleConstructorReturn(this, (PassBlurBase.__proto__ || Object.getPrototypeOf(PassBlurBase)).call(this, fs, mWidth, mHeight, mParams));

		_this.uniform('uDirection', mDirection);
		_this.uniform('uResolution', [_GLTool2.default.width, _GLTool2.default.height]);
		return _this;
	}

	return PassBlurBase;
}(_Pass3.default);

exports.default = PassBlurBase;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _PassBlurBase2 = __webpack_require__(39);

var _PassBlurBase3 = _interopRequireDefault(_PassBlurBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // PassHBlur.js

var PassHBlur = function (_PassBlurBase) {
	_inherits(PassHBlur, _PassBlurBase);

	function PassHBlur() {
		var mQuality = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 9;
		var mWidth = arguments[1];
		var mHeight = arguments[2];
		var mParams = arguments[3];

		_classCallCheck(this, PassHBlur);

		return _possibleConstructorReturn(this, (PassHBlur.__proto__ || Object.getPrototypeOf(PassHBlur)).call(this, mQuality, [1, 0], mWidth, mHeight, mParams));
	}

	return PassHBlur;
}(_PassBlurBase3.default);

exports.default = PassHBlur;

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = "// fxaa.frag\n\n#define SHADER_NAME FXAA\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\nuniform vec2 uResolution;\n\n\nfloat FXAA_SUBPIX_SHIFT = 1.0/4.0;\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#define FXAA_SPAN_MAX     8.0\n\n\nvec4 applyFXAA(sampler2D tex) {\n    vec4 color;\n    vec2 fragCoord = gl_FragCoord.xy;\n    vec3 rgbNW = texture2D(tex, (fragCoord + vec2(-1.0, -1.0)) * uResolution).xyz;\n    vec3 rgbNE = texture2D(tex, (fragCoord + vec2(1.0, -1.0)) * uResolution).xyz;\n    vec3 rgbSW = texture2D(tex, (fragCoord + vec2(-1.0, 1.0)) * uResolution).xyz;\n    vec3 rgbSE = texture2D(tex, (fragCoord + vec2(1.0, 1.0)) * uResolution).xyz;\n    vec3 rgbM  = texture2D(tex, fragCoord  * uResolution).xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n              dir * rcpDirMin)) * uResolution;\n\n    vec3 rgbA = 0.5 * (\n        texture2D(tex, fragCoord * uResolution + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture2D(tex, fragCoord * uResolution + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture2D(tex, fragCoord * uResolution + dir * -0.5).xyz +\n        texture2D(tex, fragCoord * uResolution + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, 1.0);\n    else\n        color = vec4(rgbB, 1.0);\n    return color;\n}\n\nvoid main(void) {\n \tvec4 color = applyFXAA(texture);\n    gl_FragColor = color;\n}"

/***/ }),
/* 42 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(103)(undefined);
// imports


// module
exports.push([module.i, "html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  overflow: hidden;\n  position: static;\n  /* Permalink - use to edit and share this gradient: http://colorzilla.com/gradient-editor/#6d6d6d+0,000000+100 */\n  background: #333333;\n  /* Old browsers */\n  background: -moz-radial-gradient(center, ellipse cover, #333333 0%, #000000 100%);\n  /* FF3.6-15 */\n  background: -webkit-radial-gradient(center, ellipse cover, #333333 0%, #000000 100%);\n  /* Chrome10-25,Safari5.1-6 */\n  background: radial-gradient(ellipse at center, #333333 0%, #000000 100%);\n  /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */ }\n\nhtml {\n  -webkit-text-size-adjust: none;\n  -moz-text-size-adjust: none;\n  text-size-adjust: none; }\n\nh1, h2, h3, h4, text, p {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-webkit-font-smoothing: antialiased;\n  font-family: 'Open Sans', sans-serif; }\n\n.Main-Canvas {\n  width: 100%;\n  height: 100%;\n  top: 0px;\n  left: 0px;\n  position: absolute;\n  user-select: none;\n  opacity: 1;\n  transition: opacity .5s ease-out .25s; }\n  .isLoading .Main-Canvas {\n    opacity: 0; }\n\n.Message {\n  position: absolute;\n  z-index: 999;\n  width: 100%;\n  top: calc(50% - 50px);\n  text-align: center;\n  letter-spacing: 11px;\n  color: white;\n  opacity: 0;\n  transition: opacity .5s ease-out, letter-spacing .5s ease-out; }\n  .isLoading .Message {\n    letter-spacing: 10px;\n    opacity: 1; }\n\n.Loading-Bar {\n  position: absolute;\n  z-index: 998;\n  width: 0%;\n  height: 1px;\n  top: 50%;\n  background: rgba(255, 255, 255, 0.5);\n  opacity: 0;\n  transition: width .5s ease-out, opacity .5s ease-out; }\n  .isLoading .Loading-Bar {\n    opacity: 1; }\n", ""]);

// exports


/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["transpose"] = transpose;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["adjoint"] = adjoint;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["LDU"] = LDU;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(3);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */
function fromValues(m00, m01, m10, m11) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */
function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    let a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function invert(out, a) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];

  // Calculate the determinant
  let det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] =  a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] =  a0 * det;

  return out;
}

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  let a0 = a[0];
  out[0] =  a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] =  a0;

  return out;
}

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function multiply(out, a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function rotate(out, a, rad) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  out[0] = a0 *  c + a2 * s;
  out[1] = a1 *  c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
function scale(out, a, v) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let v0 = v[0], v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function fromRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
}

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2]/a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}

/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  return out;
}

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat2.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["translate"] = translate;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["fromTranslation"] = fromTranslation;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(3);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 2x3 Matrix
 * @module mat2d
 *
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](6);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */
function fromValues(a, b, c, d, tx, ty) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}

/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */
function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
function invert(out, a) {
  let aa = a[0], ab = a[1], ac = a[2], ad = a[3];
  let atx = a[4], aty = a[5];

  let det = aa * ad - ab * ac;
  if(!det){
    return null;
  }
  det = 1.0 / det;

  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function multiply(out, a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}

/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
function rotate(out, a, rad) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  out[0] = a0 *  c + a2 * s;
  out[1] = a1 *  c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
function scale(out, a, v) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let v0 = v[0], v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
function translate(out, a, v) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let v0 = v[0], v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
function fromRotation(out, rad) {
  let s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
          a[3] + ', ' + a[4] + ', ' + a[5] + ')';
}

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}

/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}

/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  out[4] = a[4] + (b[4] * scale);
  out[5] = a[5] + (b[5] * scale);
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
          Math.abs(a4 - b4) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
          Math.abs(a5 - b5) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a5), Math.abs(b5)));
}

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat2d.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["transpose"] = transpose;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["adjoint"] = adjoint;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["translate"] = translate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["rotateX"] = rotateX;
/* harmony export (immutable) */ __webpack_exports__["rotateY"] = rotateY;
/* harmony export (immutable) */ __webpack_exports__["rotateZ"] = rotateZ;
/* harmony export (immutable) */ __webpack_exports__["fromTranslation"] = fromTranslation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromXRotation"] = fromXRotation;
/* harmony export (immutable) */ __webpack_exports__["fromYRotation"] = fromYRotation;
/* harmony export (immutable) */ __webpack_exports__["fromZRotation"] = fromZRotation;
/* harmony export (immutable) */ __webpack_exports__["fromRotationTranslation"] = fromRotationTranslation;
/* harmony export (immutable) */ __webpack_exports__["getTranslation"] = getTranslation;
/* harmony export (immutable) */ __webpack_exports__["getScaling"] = getScaling;
/* harmony export (immutable) */ __webpack_exports__["getRotation"] = getRotation;
/* harmony export (immutable) */ __webpack_exports__["fromRotationTranslationScale"] = fromRotationTranslationScale;
/* harmony export (immutable) */ __webpack_exports__["fromRotationTranslationScaleOrigin"] = fromRotationTranslationScaleOrigin;
/* harmony export (immutable) */ __webpack_exports__["fromQuat"] = fromQuat;
/* harmony export (immutable) */ __webpack_exports__["frustum"] = frustum;
/* harmony export (immutable) */ __webpack_exports__["perspective"] = perspective;
/* harmony export (immutable) */ __webpack_exports__["perspectiveFromFieldOfView"] = perspectiveFromFieldOfView;
/* harmony export (immutable) */ __webpack_exports__["ortho"] = ortho;
/* harmony export (immutable) */ __webpack_exports__["lookAt"] = lookAt;
/* harmony export (immutable) */ __webpack_exports__["targetTo"] = targetTo;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(3);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 4x4 Matrix
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](16);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */
function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}

/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */
function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}


/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    let a01 = a[1], a02 = a[2], a03 = a[3];
    let a12 = a[6], a13 = a[7];
    let a23 = a[11];

    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function invert(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

  return out;
}

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function adjoint(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
  out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
  out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
  out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
  out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
  out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
  return out;
}

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}

/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  // Cache only the current line of the second matrix
  let b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
  out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
  out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
  out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
  return out;
}

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
  let x = v[0], y = v[1], z = v[2];
  let a00, a01, a02, a03;
  let a10, a11, a12, a13;
  let a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
    out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
    out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}

/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function scale(out, a, v) {
  let x = v[0], y = v[1], z = v[2];

  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function rotate(out, a, rad, axis) {
  let x = axis[0], y = axis[1], z = axis[2];
  let len = Math.sqrt(x * x + y * y + z * z);
  let s, c, t;
  let a00, a01, a02, a03;
  let a10, a11, a12, a13;
  let a20, a21, a22, a23;
  let b00, b01, b02;
  let b10, b11, b12;
  let b20, b21, b22;

  if (Math.abs(len) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]) { return null; }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
  a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
  a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

  // Construct the elements of the rotation matrix
  b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
  b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
  b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

  // Perform rotation-specific matrix multiplication
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) { // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateX(out, a, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  let a10 = a[4];
  let a11 = a[5];
  let a12 = a[6];
  let a13 = a[7];
  let a20 = a[8];
  let a21 = a[9];
  let a22 = a[10];
  let a23 = a[11];

  if (a !== out) { // If the source and destination differ, copy the unchanged rows
    out[0]  = a[0];
    out[1]  = a[1];
    out[2]  = a[2];
    out[3]  = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateY(out, a, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  let a00 = a[0];
  let a01 = a[1];
  let a02 = a[2];
  let a03 = a[3];
  let a20 = a[8];
  let a21 = a[9];
  let a22 = a[10];
  let a23 = a[11];

  if (a !== out) { // If the source and destination differ, copy the unchanged rows
    out[4]  = a[4];
    out[5]  = a[5];
    out[6]  = a[6];
    out[7]  = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateZ(out, a, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  let a00 = a[0];
  let a01 = a[1];
  let a02 = a[2];
  let a03 = a[3];
  let a10 = a[4];
  let a11 = a[5];
  let a12 = a[6];
  let a13 = a[7];

  if (a !== out) { // If the source and destination differ, copy the unchanged last row
    out[8]  = a[8];
    out[9]  = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function fromRotation(out, rad, axis) {
  let x = axis[0], y = axis[1], z = axis[2];
  let len = Math.sqrt(x * x + y * y + z * z);
  let s, c, t;

  if (Math.abs(len) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]) { return null; }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  // Perform rotation-specific matrix multiplication
  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromXRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0]  = 1;
  out[1]  = 0;
  out[2]  = 0;
  out[3]  = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromYRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0]  = c;
  out[1]  = 0;
  out[2]  = -s;
  out[3]  = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromZRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0]  = c;
  out[1]  = s;
  out[2]  = 0;
  out[3]  = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromRotationTranslation(out, q, v) {
  // Quaternion math
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;

  return out;
}

/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];

  return out;
}

/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getScaling(out, mat) {
  let m11 = mat[0];
  let m12 = mat[1];
  let m13 = mat[2];
  let m21 = mat[4];
  let m22 = mat[5];
  let m23 = mat[6];
  let m31 = mat[8];
  let m32 = mat[9];
  let m33 = mat[10];

  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);

  return out;
}

/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */
function getRotation(out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  let trace = mat[0] + mat[5] + mat[10];
  let S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S;
    out[2] = (mat[1] - mat[4]) / S;
  } else if ((mat[0] > mat[5])&(mat[0] > mat[10])) {
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S;
    out[2] = (mat[8] + mat[2]) / S;
  } else if (mat[5] > mat[10]) {
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S;
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S;
  } else {
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;
  let sx = s[0];
  let sy = s[1];
  let sz = s[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;

  return out;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  let sx = s[0];
  let sy = s[1];
  let sz = s[2];

  let ox = o[0];
  let oy = o[1];
  let oz = o[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
  out[15] = 1;

  return out;
}

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
function fromQuat(out, q) {
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let yx = y * x2;
  let yy = y * y2;
  let zx = z * x2;
  let zy = z * y2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;

  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;

  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;

  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;

  return out;
}

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
function frustum(out, left, right, bottom, top, near, far) {
  let rl = 1 / (right - left);
  let tb = 1 / (top - bottom);
  let nf = 1 / (near - far);
  out[0] = (near * 2) * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = (near * 2) * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = (far * near * 2) * nf;
  out[15] = 0;
  return out;
}

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
  let f = 1.0 / Math.tan(fovy / 2);
  let nf = 1 / (near - far);
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = (2 * far * near) * nf;
  out[15] = 0;
  return out;
}

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspectiveFromFieldOfView(out, fov, near, far) {
  let upTan = Math.tan(fov.upDegrees * Math.PI/180.0);
  let downTan = Math.tan(fov.downDegrees * Math.PI/180.0);
  let leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0);
  let rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0);
  let xScale = 2.0 / (leftTan + rightTan);
  let yScale = 2.0 / (upTan + downTan);

  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = ((upTan - downTan) * yScale * 0.5);
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = (far * near) / (near - far);
  out[15] = 0.0;
  return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function ortho(out, left, right, bottom, top, near, far) {
  let lr = 1 / (left - right);
  let bt = 1 / (bottom - top);
  let nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
  let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  let eyex = eye[0];
  let eyey = eye[1];
  let eyez = eye[2];
  let upx = up[0];
  let upy = up[1];
  let upz = up[2];
  let centerx = center[0];
  let centery = center[1];
  let centerz = center[2];

  if (Math.abs(eyex - centerx) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"] &&
      Math.abs(eyey - centery) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"] &&
      Math.abs(eyez - centerz) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]) {
    return mat4.identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;

  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;

  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;

  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;

  return out;
}

/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function targetTo(out, eye, target, up) {
  let eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];

  let z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];

  let len = z0*z0 + z1*z1 + z2*z2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  let x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
          a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
          a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +
          a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
}

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
}

/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}

/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  out[4] = a[4] + (b[4] * scale);
  out[5] = a[5] + (b[5] * scale);
  out[6] = a[6] + (b[6] * scale);
  out[7] = a[7] + (b[7] * scale);
  out[8] = a[8] + (b[8] * scale);
  out[9] = a[9] + (b[9] * scale);
  out[10] = a[10] + (b[10] * scale);
  out[11] = a[11] + (b[11] * scale);
  out[12] = a[12] + (b[12] * scale);
  out[13] = a[13] + (b[13] * scale);
  out[14] = a[14] + (b[14] * scale);
  out[15] = a[15] + (b[15] * scale);
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] &&
         a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] &&
         a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] &&
         a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0  = a[0],  a1  = a[1],  a2  = a[2],  a3  = a[3];
  let a4  = a[4],  a5  = a[5],  a6  = a[6],  a7  = a[7];
  let a8  = a[8],  a9  = a[9],  a10 = a[10], a11 = a[11];
  let a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];

  let b0  = b[0],  b1  = b[1],  b2  = b[2],  b3  = b[3];
  let b4  = b[4],  b5  = b[5],  b6  = b[6],  b7  = b[7];
  let b8  = b[8],  b9  = b[9],  b10 = b[10], b11 = b[11];
  let b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];

  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
          Math.abs(a4 - b4) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
          Math.abs(a5 - b5) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
          Math.abs(a6 - b6) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
          Math.abs(a7 - b7) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
          Math.abs(a8 - b8) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&
          Math.abs(a9 - b9) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&
          Math.abs(a10 - b10) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&
          Math.abs(a11 - b11) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&
          Math.abs(a12 - b12) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&
          Math.abs(a13 - b13) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&
          Math.abs(a14 - b14) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&
          Math.abs(a15 - b15) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a15), Math.abs(b15)));
}

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat4.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["setAxisAngle"] = setAxisAngle;
/* harmony export (immutable) */ __webpack_exports__["getAxisAngle"] = getAxisAngle;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["rotateX"] = rotateX;
/* harmony export (immutable) */ __webpack_exports__["rotateY"] = rotateY;
/* harmony export (immutable) */ __webpack_exports__["rotateZ"] = rotateZ;
/* harmony export (immutable) */ __webpack_exports__["calculateW"] = calculateW;
/* harmony export (immutable) */ __webpack_exports__["slerp"] = slerp;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["conjugate"] = conjugate;
/* harmony export (immutable) */ __webpack_exports__["fromMat3"] = fromMat3;
/* harmony export (immutable) */ __webpack_exports__["fromEuler"] = fromEuler;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mat3__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__vec3__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__vec4__ = __webpack_require__(23);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */






/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  let s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}

/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */
function getAxisAngle(out_axis, q) {
  let rad = Math.acos(q[3]) * 2.0;
  let s = Math.sin(rad / 2.0);
  if (s != 0.0) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
function multiply(out, a, b) {
  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = b[0], by = b[1], bz = b[2], bw = b[3];

  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateX(out, a, rad) {
  rad *= 0.5;

  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = Math.sin(rad), bw = Math.cos(rad);

  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateY(out, a, rad) {
  rad *= 0.5;

  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let by = Math.sin(rad), bw = Math.cos(rad);

  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateZ(out, a, rad) {
  rad *= 0.5;

  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bz = Math.sin(rad), bw = Math.cos(rad);

  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
function calculateW(out, a) {
  let x = a[0], y = a[1], z = a[2];

  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = b[0], by = b[1], bz = b[2], bw = b[3];

  let omega, cosom, sinom, scale0, scale1;

  // calc cosine
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  // adjust signs (if necessary)
  if ( cosom < 0.0 ) {
    cosom = -cosom;
    bx = - bx;
    by = - by;
    bz = - bz;
    bw = - bw;
  }
  // calculate coefficients
  if ( (1.0 - cosom) > 0.000001 ) {
    // standard case (slerp)
    omega  = Math.acos(cosom);
    sinom  = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  }
  // calculate final values
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;

  return out;
}

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
function invert(out, a) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let dot = a0*a0 + a1*a1 + a2*a2 + a3*a3;
  let invDot = dot ? 1.0/dot : 0;

  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0*invDot;
  out[1] = -a1*invDot;
  out[2] = -a2*invDot;
  out[3] = a3*invDot;
  return out;
}

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  let fTrace = m[0] + m[4] + m[8];
  let fRoot;

  if ( fTrace > 0.0 ) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0);  // 2w
    out[3] = 0.5 * fRoot;
    fRoot = 0.5/fRoot;  // 1/(4w)
    out[0] = (m[5]-m[7])*fRoot;
    out[1] = (m[6]-m[2])*fRoot;
    out[2] = (m[1]-m[3])*fRoot;
  } else {
    // |w| <= 1/2
    let i = 0;
    if ( m[4] > m[0] )
      i = 1;
    if ( m[8] > m[i*3+i] )
      i = 2;
    let j = (i+1)%3;
    let k = (i+2)%3;

    fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
    out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
    out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
  }

  return out;
}

/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */
function fromEuler(out, x, y, z) {
    let halfToRad = 0.5 * Math.PI / 180.0;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;

    let sx = Math.sin(x);
    let cx = Math.cos(x);
    let sy = Math.sin(y);
    let cy = Math.cos(y);
    let sz = Math.sin(z);
    let cz = Math.cos(z);

    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;

    return out;
}

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
const clone = __WEBPACK_IMPORTED_MODULE_3__vec4__["clone"];
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;


/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
const fromValues = __WEBPACK_IMPORTED_MODULE_3__vec4__["fromValues"];
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;


/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
const copy = __WEBPACK_IMPORTED_MODULE_3__vec4__["copy"];
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;


/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
const set = __WEBPACK_IMPORTED_MODULE_3__vec4__["set"];
/* harmony export (immutable) */ __webpack_exports__["set"] = set;


/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
const add = __WEBPACK_IMPORTED_MODULE_3__vec4__["add"];
/* harmony export (immutable) */ __webpack_exports__["add"] = add;


/**
 * Alias for {@link quat.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
const scale = __WEBPACK_IMPORTED_MODULE_3__vec4__["scale"];
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;


/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
const dot = __WEBPACK_IMPORTED_MODULE_3__vec4__["dot"];
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;


/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
const lerp = __WEBPACK_IMPORTED_MODULE_3__vec4__["lerp"];
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;


/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 */
const length = __WEBPACK_IMPORTED_MODULE_3__vec4__["length"];
/* harmony export (immutable) */ __webpack_exports__["length"] = length;


/**
 * Alias for {@link quat.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
const squaredLength = __WEBPACK_IMPORTED_MODULE_3__vec4__["squaredLength"];
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;


/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
const normalize = __WEBPACK_IMPORTED_MODULE_3__vec4__["normalize"];
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;


/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
const exactEquals = __WEBPACK_IMPORTED_MODULE_3__vec4__["exactEquals"];
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;


/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
const equals = __WEBPACK_IMPORTED_MODULE_3__vec4__["equals"];
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;


/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
const rotationTo = (function() {
  let tmpvec3 = __WEBPACK_IMPORTED_MODULE_2__vec3__["create"]();
  let xUnitVec3 = __WEBPACK_IMPORTED_MODULE_2__vec3__["fromValues"](1,0,0);
  let yUnitVec3 = __WEBPACK_IMPORTED_MODULE_2__vec3__["fromValues"](0,1,0);

  return function(out, a, b) {
    let dot = __WEBPACK_IMPORTED_MODULE_2__vec3__["dot"](a, b);
    if (dot < -0.999999) {
      __WEBPACK_IMPORTED_MODULE_2__vec3__["cross"](tmpvec3, xUnitVec3, a);
      if (__WEBPACK_IMPORTED_MODULE_2__vec3__["len"](tmpvec3) < 0.000001)
        __WEBPACK_IMPORTED_MODULE_2__vec3__["cross"](tmpvec3, yUnitVec3, a);
      __WEBPACK_IMPORTED_MODULE_2__vec3__["normalize"](tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      __WEBPACK_IMPORTED_MODULE_2__vec3__["cross"](tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
})();
/* harmony export (immutable) */ __webpack_exports__["rotationTo"] = rotationTo;


/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 */
const sqlerp = (function () {
  let temp1 = create();
  let temp2 = create();

  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));

    return out;
  };
}());
/* harmony export (immutable) */ __webpack_exports__["sqlerp"] = sqlerp;


/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
const setAxes = (function() {
  let matr = __WEBPACK_IMPORTED_MODULE_1__mat3__["create"]();

  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];

    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];

    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];

    return normalize(out, fromMat3(out, matr));
  };
})();
/* harmony export (immutable) */ __webpack_exports__["setAxes"] = setAxes;



/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["divide"] = divide;
/* harmony export (immutable) */ __webpack_exports__["ceil"] = ceil;
/* harmony export (immutable) */ __webpack_exports__["floor"] = floor;
/* harmony export (immutable) */ __webpack_exports__["min"] = min;
/* harmony export (immutable) */ __webpack_exports__["max"] = max;
/* harmony export (immutable) */ __webpack_exports__["round"] = round;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["scaleAndAdd"] = scaleAndAdd;
/* harmony export (immutable) */ __webpack_exports__["distance"] = distance;
/* harmony export (immutable) */ __webpack_exports__["squaredDistance"] = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["length"] = length;
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["negate"] = negate;
/* harmony export (immutable) */ __webpack_exports__["inverse"] = inverse;
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;
/* harmony export (immutable) */ __webpack_exports__["cross"] = cross;
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;
/* harmony export (immutable) */ __webpack_exports__["random"] = random;
/* harmony export (immutable) */ __webpack_exports__["transformMat2"] = transformMat2;
/* harmony export (immutable) */ __webpack_exports__["transformMat2d"] = transformMat2d;
/* harmony export (immutable) */ __webpack_exports__["transformMat3"] = transformMat3;
/* harmony export (immutable) */ __webpack_exports__["transformMat4"] = transformMat4;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(3);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](2);
  out[0] = 0;
  out[1] = 0;
  return out;
}

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
function fromValues(x, y) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](2);
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
};

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
};

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
};

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
};

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
};

/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */
function round (out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return Math.sqrt(x*x + y*y);
};

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return x*x + y*y;
};

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  var x = a[0],
    y = a[1];
  return Math.sqrt(x*x + y*y);
};

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength (a) {
  var x = a[0],
    y = a[1];
  return x*x + y*y;
};

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
function normalize(out, a) {
  var x = a[0],
    y = a[1];
  var len = x*x + y*y;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
  }
  return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
function lerp(out, a, b, t) {
  var ax = a[0],
    ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
function random(out, scale) {
  scale = scale || 1.0;
  var r = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2d(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat3(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat4(out, a, m) {
  let x = a[0];
  let y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec2(' + a[0] + ', ' + a[1] + ')';
}

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1];
  let b0 = b[0], b1 = b[1];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)));
}

/**
 * Alias for {@link vec2.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Alias for {@link vec2.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;


/**
 * Alias for {@link vec2.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link vec2.divide}
 * @function
 */
const div = divide;
/* harmony export (immutable) */ __webpack_exports__["div"] = div;


/**
 * Alias for {@link vec2.distance}
 * @function
 */
const dist = distance;
/* harmony export (immutable) */ __webpack_exports__["dist"] = dist;


/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
const sqrDist = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["sqrDist"] = sqrDist;


/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
const forEach = (function() {
  let vec = create();

  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if(!stride) {
      stride = 2;
    }

    if(!offset) {
      offset = 0;
    }

    if(count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for(i = offset; i < l; i += stride) {
      vec[0] = a[i]; vec[1] = a[i+1];
      fn(vec, vec, arg);
      a[i] = vec[0]; a[i+1] = vec[1];
    }

    return a;
  };
})();
/* harmony export (immutable) */ __webpack_exports__["forEach"] = forEach;



/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = getAndApplyExtension;
// VertexArrayObject.js

function getAndApplyExtension(gl, name) {
	var ext = gl.getExtension(name);
	if (!ext) {
		return false;
	}
	var suffix = name.split('_')[0];
	var suffixRE = new RegExp(suffix + '$');

	for (var key in ext) {
		var val = ext[key];
		if (typeof val === 'function') {
			var unsuffixedKey = key.replace(suffixRE, '');
			if (key.substring) {
				gl[unsuffixedKey] = ext[key].bind(ext);
				// console.log('Replacing :', key, '=>', unsuffixedKey);
			}
		}
	}

	return true;
}

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _WebglConst = __webpack_require__(24);

var _WebglConst2 = _interopRequireDefault(_WebglConst);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// exposeAttributes.js

var exposeAttributes = function exposeAttributes() {
	// GL.VERTEX_SHADER         = GL.gl.VERTEX_SHADER;
	// GL.FRAGMENT_SHADER       = GL.gl.FRAGMENT_SHADER;
	// GL.COMPILE_STATUS        = GL.gl.COMPILE_STATUS;
	// GL.DEPTH_TEST            = GL.gl.DEPTH_TEST;
	// GL.CULL_FACE             = GL.gl.CULL_FACE;
	// GL.BLEND                 = GL.gl.BLEND;
	// GL.POINTS                = GL.gl.POINTS;
	// GL.LINES                 = GL.gl.LINES;
	// GL.TRIANGLES             = GL.gl.TRIANGLES;

	// GL.LINEAR                	= GL.gl.LINEAR;
	// GL.NEAREST               	= GL.gl.NEAREST;
	// GL.LINEAR_MIPMAP_NEAREST 	= GL.gl.LINEAR_MIPMAP_NEAREST;
	// GL.NEAREST_MIPMAP_LINEAR 	= GL.gl.NEAREST_MIPMAP_LINEAR;
	// GL.LINEAR_MIPMAP_LINEAR 	= GL.gl.LINEAR_MIPMAP_LINEAR;
	// GL.NEAREST_MIPMAP_NEAREST 	= GL.gl.NEAREST_MIPMAP_NEAREST;
	// GL.MIRRORED_REPEAT       	= GL.gl.MIRRORED_REPEAT;
	// GL.CLAMP_TO_EDGE         	= GL.gl.CLAMP_TO_EDGE;
	// GL.SCISSOR_TEST		   	 	= GL.gl.SCISSOR_TEST;
	// GL.UNSIGNED_BYTE		 	= GL.gl.UNSIGNED_BYTE;
	for (var s in _WebglConst2.default) {
		if (!_GLTool2.default[s]) {
			_GLTool2.default[s] = _WebglConst2.default[s];
		} else {
			console.log('already exist : ', s);
		}
	}
};

exports.default = exposeAttributes;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function () {
	if (!hasChecked) {
		_float = checkFloat();
	}

	return _float;
};

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hasChecked = false; // getFloat.js

var _float = void 0;

function checkFloat() {
	if (_GLTool2.default.webgl2) {
		return _GLTool2.default.gl.FLOAT;
	} else {
		var extFloat = _GLTool2.default.getExtension('OES_texture_float');
		if (extFloat) {
			return _GLTool2.default.gl.FLOAT;
		} else {
			console.warn('USING FLOAT BUT OES_texture_float NOT SUPPORTED');
			return _GLTool2.default.gl.UNSIGNED_BYTE;
		}
	}

	hasChecked = true;
};

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function () {
	if (!hasChecked) {
		halfFloat = checkHalfFloat();
	}

	return halfFloat;
};

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hasChecked = false; // getHalfFloat.js

var halfFloat = void 0;

function checkHalfFloat() {
	if (_GLTool2.default.webgl2) {
		return _GLTool2.default.gl.HALF_FLOAT;
	} else {
		var extHalfFloat = _GLTool2.default.getExtension('OES_texture_half_float');
		if (extHalfFloat) {
			return extHalfFloat.HALF_FLOAT_OES;
		} else {
			console.warn('USING HALF FLOAT BUT OES_texture_half_float NOT SUPPORTED');
			return _GLTool2.default.gl.UNSIGNED_BYTE;
		}
	}

	hasChecked = true;
};

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
// ExtensionsList.js

exports.default = ['EXT_shader_texture_lod', 'EXT_sRGB', 'EXT_frag_depth', 'OES_texture_float', 'OES_texture_half_float', 'OES_texture_float_linear', 'OES_texture_half_float_linear', 'OES_standard_derivatives', 'WEBGL_depth_texture', 'EXT_texture_filter_anisotropic', 'OES_vertex_array_object', 'ANGLE_instanced_arrays', 'WEBGL_draw_buffers'];

/***/ }),
/* 54 */
/***/ (function(module, exports) {

module.exports = function(strings) {
  if (typeof strings === 'string') strings = [strings]
  var exprs = [].slice.call(arguments,1)
  var parts = []
  for (var i = 0; i < strings.length-1; i++) {
    parts.push(strings[i], exprs[i] || '')
  }
  parts.push(strings[i])
  return parts.join('')
}


/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = "// basic.frag\n\n#define SHADER_NAME BASIC_FRAGMENT\n\nprecision lowp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform float time;\n// uniform sampler2D texture;\n\nvoid main(void) {\n    gl_FragColor = vec4(vTextureCoord, sin(time) * .5 + .5, 1.0);\n}"

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isPowerOfTwo(x) {
	return x !== 0 && !(x & x - 1);
} // getTextureParameters.js

;

var getTextureParameters = function getTextureParameters(mParams, mSource, mWidth, mHeight) {
	if (!mParams.minFilter) {
		var minFilter = _GLTool2.default.LINEAR;
		if (mWidth && mWidth) {
			if (isPowerOfTwo(mWidth) && isPowerOfTwo(mHeight)) {
				minFilter = _GLTool2.default.NEAREST_MIPMAP_LINEAR;
			}
		}

		mParams.minFilter = minFilter;
	}

	mParams.mipmap = mParams.mipmap || true;
	mParams.magFilter = mParams.magFilter || _GLTool2.default.LINEAR;
	mParams.wrapS = mParams.wrapS || _GLTool2.default.CLAMP_TO_EDGE;
	mParams.wrapT = mParams.wrapT || _GLTool2.default.CLAMP_TO_EDGE;
	mParams.internalFormat = mParams.internalFormat || _GLTool2.default.RGBA;
	mParams.format = mParams.format || _GLTool2.default.RGBA;
	mParams.premultiplyAlpha = mParams.premultiplyAlpha || false;
	mParams.level = mParams.level || 0;
	mParams.anisotropy = mParams.anisotropy || 0;
	return mParams;
};

exports.default = getTextureParameters;

/***/ }),
/* 57 */
/***/ (function(module, exports) {

// All values and structures referenced from:
// http://msdn.microsoft.com/en-us/library/bb943991.aspx/
//
// DX10 Cubemap support based on
// https://github.com/dariomanesku/cmft/issues/7#issuecomment-69516844
// https://msdn.microsoft.com/en-us/library/windows/desktop/bb943983(v=vs.85).aspx
// https://github.com/playcanvas/engine/blob/master/src/resources/resources_texture.js

var DDS_MAGIC = 0x20534444
var DDSD_MIPMAPCOUNT = 0x20000
var DDPF_FOURCC = 0x4

var FOURCC_DXT1 = fourCCToInt32('DXT1')
var FOURCC_DXT3 = fourCCToInt32('DXT3')
var FOURCC_DXT5 = fourCCToInt32('DXT5')
var FOURCC_DX10 = fourCCToInt32('DX10')
var FOURCC_FP32F = 116 // DXGI_FORMAT_R32G32B32A32_FLOAT

var DDSCAPS2_CUBEMAP = 0x200
var D3D10_RESOURCE_DIMENSION_TEXTURE2D = 3
var DXGI_FORMAT_R32G32B32A32_FLOAT = 2

// The header length in 32 bit ints
var headerLengthInt = 31

// Offsets into the header array
var off_magic = 0
var off_size = 1
var off_flags = 2
var off_height = 3
var off_width = 4
var off_mipmapCount = 7
var off_pfFlags = 20
var off_pfFourCC = 21
var off_caps2 = 28

module.exports = parseHeaders

function parseHeaders (arrayBuffer) {
  var header = new Int32Array(arrayBuffer, 0, headerLengthInt)

  if (header[off_magic] !== DDS_MAGIC) {
    throw new Error('Invalid magic number in DDS header')
  }

  if (!header[off_pfFlags] & DDPF_FOURCC) {
    throw new Error('Unsupported format, must contain a FourCC code')
  }

  var blockBytes
  var format
  var fourCC = header[off_pfFourCC]
  switch (fourCC) {
    case FOURCC_DXT1:
      blockBytes = 8
      format = 'dxt1'
      break
    case FOURCC_DXT3:
      blockBytes = 16
      format = 'dxt3'
      break
    case FOURCC_DXT5:
      blockBytes = 16
      format = 'dxt5'
      break
    case FOURCC_FP32F:
      format = 'rgba32f'
      break
    case FOURCC_DX10:
      var dx10Header = new Uint32Array(arrayBuffer.slice(128, 128 + 20))
      format = dx10Header[0]
      var resourceDimension = dx10Header[1]
      var miscFlag = dx10Header[2]
      var arraySize = dx10Header[3]
      var miscFlags2 = dx10Header[4]

      if (resourceDimension === D3D10_RESOURCE_DIMENSION_TEXTURE2D && format === DXGI_FORMAT_R32G32B32A32_FLOAT) {
        format = 'rgba32f'
      } else {
        throw new Error('Unsupported DX10 texture format ' + format)
      }
      break
    default:
      throw new Error('Unsupported FourCC code: ' + int32ToFourCC(fourCC))
  }

  var flags = header[off_flags]
  var mipmapCount = 1

  if (flags & DDSD_MIPMAPCOUNT) {
    mipmapCount = Math.max(1, header[off_mipmapCount])
  }

  var cubemap = false
  var caps2 = header[off_caps2]
  if (caps2 & DDSCAPS2_CUBEMAP) {
    cubemap = true
  }

  var width = header[off_width]
  var height = header[off_height]
  var dataOffset = header[off_size] + 4
  var texWidth = width
  var texHeight = height
  var images = []
  var dataLength

  if (fourCC === FOURCC_DX10) {
    dataOffset += 20
  }

  if (cubemap) {
    for (var f = 0; f < 6; f++) {
      if (format !== 'rgba32f') {
        throw new Error('Only RGBA32f cubemaps are supported')
      }
      var bpp = 4 * 32 / 8

      width = texWidth
      height = texHeight

      // cubemap should have all mipmap levels defined
      // Math.log2(width) + 1
      var requiredMipLevels = Math.log(width) / Math.log(2) + 1

      for (var i = 0; i < requiredMipLevels; i++) {
        dataLength = width * height * bpp
        images.push({
          offset: dataOffset,
          length: dataLength,
          shape: [ width, height ]
        })
        // Reuse data from the previous level if we are beyond mipmapCount
        // This is hack for CMFT not publishing full mipmap chain https://github.com/dariomanesku/cmft/issues/10
        if (i < mipmapCount) {
          dataOffset += dataLength
        }
        width = Math.floor(width / 2)
        height = Math.floor(height / 2)
      }
    }
  } else {
    for (var i = 0; i < mipmapCount; i++) {
      dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes

      images.push({
        offset: dataOffset,
        length: dataLength,
        shape: [ width, height ]
      })
      dataOffset += dataLength
      width = Math.floor(width / 2)
      height = Math.floor(height / 2)
    }
  }

  return {
    shape: [ texWidth, texHeight ],
    images: images,
    format: format,
    flags: flags,
    cubemap: cubemap
  }
}

function fourCCToInt32 (value) {
  return value.charCodeAt(0) +
    (value.charCodeAt(1) << 8) +
    (value.charCodeAt(2) << 16) +
    (value.charCodeAt(3) << 24)
}

function int32ToFourCC (value) {
  return String.fromCharCode(
    value & 0xff,
    (value >> 8) & 0xff,
    (value >> 16) & 0xff,
    (value >> 24) & 0xff
  )
}


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// CubeFrameBuffer.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _GLCubeTexture = __webpack_require__(28);

var _GLCubeTexture2 = _interopRequireDefault(_GLCubeTexture);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;

var CubeFrameBuffer = function () {
	function CubeFrameBuffer(size) {
		var mParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		_classCallCheck(this, CubeFrameBuffer);

		gl = _GLTool2.default.gl;
		this._size = size;
		this.magFilter = mParameters.magFilter || gl.LINEAR;
		this.minFilter = mParameters.minFilter || gl.LINEAR;
		this.wrapS = mParameters.wrapS || gl.CLAMP_TO_EDGE;
		this.wrapT = mParameters.wrapT || gl.CLAMP_TO_EDGE;

		this._init();
	}

	_createClass(CubeFrameBuffer, [{
		key: '_init',
		value: function _init() {
			this.texture = gl.createTexture();
			this.glTexture = new _GLCubeTexture2.default(this.texture, {}, true);

			gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
			gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, this.magFilter);
			gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, this.minFilter);
			gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, this.wrapS);
			gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, this.wrapT);

			var targets = [gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];

			for (var i = 0; i < targets.length; i++) {
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
				gl.texImage2D(targets[i], 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.FLOAT, null);
			}

			this._frameBuffers = [];
			for (var _i = 0; _i < targets.length; _i++) {
				var frameBuffer = gl.createFramebuffer();
				gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, targets[_i], this.texture, 0);

				var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
				if (status !== gl.FRAMEBUFFER_COMPLETE) {
					console.log('\'gl.checkFramebufferStatus() returned \'' + status);
				}

				this._frameBuffers.push(frameBuffer);
			}

			// gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			gl.bindRenderbuffer(gl.RENDERBUFFER, null);
			gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
		}
	}, {
		key: 'bind',
		value: function bind(mTargetIndex) {

			// if(Math.random() > .99) console.log('bind :', mTargetIndex, this._frameBuffers[mTargetIndex]);
			_GLTool2.default.viewport(0, 0, this.width, this.height);
			gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffers[mTargetIndex]);
		}
	}, {
		key: 'unbind',
		value: function unbind() {
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			_GLTool2.default.viewport(0, 0, _GLTool2.default.width, _GLTool2.default.height);
		}

		//	TEXTURES

	}, {
		key: 'getTexture',
		value: function getTexture() {
			return this.glTexture;
		}

		//	GETTERS AND SETTERS

	}, {
		key: 'width',
		get: function get() {
			return this._size;
		}
	}, {
		key: 'height',
		get: function get() {
			return this._size;
		}
	}]);

	return CubeFrameBuffer;
}();

exports.default = CubeFrameBuffer;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // MultisampleFrameBuffer.js

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _GLTexture = __webpack_require__(26);

var _GLTexture2 = _interopRequireDefault(_GLTexture);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;

function isPowerOfTwo(x) {
	return x !== 0 && !(x & x - 1);
};

var MultisampleFrameBuffer = function () {
	function MultisampleFrameBuffer(mWidth, mHeight) {
		var mParameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

		_classCallCheck(this, MultisampleFrameBuffer);

		gl = _GLTool2.default.gl;

		this.width = mWidth;
		this.height = mHeight;

		this.magFilter = mParameters.magFilter || gl.LINEAR;
		this.minFilter = mParameters.minFilter || gl.LINEAR;
		this.wrapS = mParameters.wrapS || gl.CLAMP_TO_EDGE;
		this.wrapT = mParameters.wrapT || gl.CLAMP_TO_EDGE;
		this.useDepth = mParameters.useDepth || true;
		this.useStencil = mParameters.useStencil || false;
		this.texelType = mParameters.type;
		this._numSample = mParameters.numSample || 8;

		if (!isPowerOfTwo(this.width) || !isPowerOfTwo(this.height)) {
			this.wrapS = this.wrapT = gl.CLAMP_TO_EDGE;

			if (this.minFilter === gl.LINEAR_MIPMAP_NEAREST) {
				this.minFilter = gl.LINEAR;
			}
		}

		this._init();
	}

	_createClass(MultisampleFrameBuffer, [{
		key: '_init',
		value: function _init() {
			var texelType = gl.UNSIGNED_BYTE;
			if (this.texelType) {
				texelType = this.texelType;
			}

			this.texelType = texelType;

			this.frameBuffer = gl.createFramebuffer();
			this.frameBufferColor = gl.createFramebuffer();
			this.renderBufferColor = gl.createRenderbuffer();
			this.renderBufferDepth = gl.createRenderbuffer();
			this.glTexture = this._createTexture();
			this.glDepthTexture = this._createTexture(gl.DEPTH_COMPONENT16, gl.UNSIGNED_SHORT, gl.DEPTH_COMPONENT, true);

			gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBufferColor);
			gl.renderbufferStorageMultisample(gl.RENDERBUFFER, this._numSample, gl.RGBA8, this.width, this.height);

			gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBufferDepth);
			gl.renderbufferStorageMultisample(gl.RENDERBUFFER, this._numSample, gl.DEPTH_COMPONENT16, this.width, this.height);

			gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
			gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, this.renderBufferColor);
			gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.renderBufferDepth);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBufferColor);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.glTexture.texture, 0);
			// gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.glDepthTexture.texture, 0);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			// gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBufferDepth);
			// gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.glDepthTexture.texture, 0);
			// gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		}
	}, {
		key: '_createTexture',
		value: function _createTexture(mInternalformat, mTexelType, mFormat) {
			var forceNearest = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

			if (mInternalformat === undefined) {
				mInternalformat = gl.RGBA;
			}
			if (mTexelType === undefined) {
				mTexelType = this.texelType;
			}
			if (!mFormat) {
				mFormat = mInternalformat;
			}

			var t = gl.createTexture();
			var glt = new _GLTexture2.default(t, true);
			var magFilter = forceNearest ? _GLTool2.default.NEAREST : this.magFilter;
			var minFilter = forceNearest ? _GLTool2.default.NEAREST : this.minFilter;

			gl.bindTexture(gl.TEXTURE_2D, t);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this.wrapS);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this.wrapT);
			gl.texImage2D(gl.TEXTURE_2D, 0, mInternalformat, this.width, this.height, 0, mFormat, mTexelType, null);
			gl.bindTexture(gl.TEXTURE_2D, null);

			return glt;
		}
	}, {
		key: 'bind',
		value: function bind() {
			var mAutoSetViewport = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			if (mAutoSetViewport) {
				_GLTool2.default.viewport(0, 0, this.width, this.height);
			}
			gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
		}
	}, {
		key: 'unbind',
		value: function unbind() {
			var mAutoSetViewport = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			if (mAutoSetViewport) {
				_GLTool2.default.viewport(0, 0, _GLTool2.default.width, _GLTool2.default.height);
			}

			var width = this.width,
			    height = this.height;


			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.frameBuffer);
			gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.frameBufferColor);
			gl.clearBufferfv(gl.COLOR, 0, [0.0, 0.0, 0.0, 0.0]);
			gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, gl.COLOR_BUFFER_BIT, _GLTool2.default.NEAREST);
			// gl.blitFramebuffer(
			// 	0, 0, width, height,
			// 	0, 0, width, height,
			// 	gl.COLOR_BUFFER_BIT|gl.DEPTH_STENCIL, GL.NEAREST
			// );

			// gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.frameBuffer);
			// gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.frameBufferDepth);
			// gl.clearBufferfi(gl.DEPTH_STENCIL, 0, 1.0, 0);
			// gl.blitFramebuffer(
			// 	0, 0, width, height,
			// 	0, 0, width, height,
			// 	gl.DEPTH_BUFFER_BIT, gl.NEAREST
			// );

			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		}
	}, {
		key: 'getTexture',
		value: function getTexture() {
			var mIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

			return this.glTexture;
		}
	}, {
		key: 'getDepthTexture',
		value: function getDepthTexture() {
			return this.glDepthTexture;
		}
	}]);

	return MultisampleFrameBuffer;
}();

exports.default = MultisampleFrameBuffer;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // TransformFeedbackObject.js

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _GLShader = __webpack_require__(2);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Mesh = __webpack_require__(4);

var _Mesh2 = _interopRequireDefault(_Mesh);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;

var TransformFeedbackObject = function () {
	function TransformFeedbackObject(strVertexShader, strFragmentShader) {
		_classCallCheck(this, TransformFeedbackObject);

		gl = _GLTool2.default.gl;
		this._vs = strVertexShader;
		this._fs = strFragmentShader;

		this._init();
	}

	_createClass(TransformFeedbackObject, [{
		key: '_init',
		value: function _init() {
			this._meshCurrent = new _Mesh2.default();
			this._meshTarget = new _Mesh2.default();
			this._numPoints = -1;

			this._varyings = [];
			this.transformFeedback = gl.createTransformFeedback();
		}
	}, {
		key: 'bufferData',
		value: function bufferData(mData, mName, mVaryingName) {
			var isTransformFeedback = !!mVaryingName;
			console.log('is Transform feedback ?', mName, isTransformFeedback);
			this._meshCurrent.bufferData(mData, mName, null, gl.STREAM_COPY, false);
			this._meshTarget.bufferData(mData, mName, null, gl.STREAM_COPY, false);

			if (isTransformFeedback) {
				this._varyings.push(mVaryingName);

				if (this._numPoints < 0) {
					this._numPoints = mData.length;
				}
			}
		}
	}, {
		key: 'bufferIndex',
		value: function bufferIndex(mArrayIndices) {
			this._meshCurrent.bufferIndex(mArrayIndices);
			this._meshTarget.bufferIndex(mArrayIndices);
		}
	}, {
		key: 'uniform',
		value: function uniform(mName, mType, mValue) {
			if (this.shader) {
				this.shader.uniform(mName, mType, mValue);
			}
		}
	}, {
		key: 'generate',
		value: function generate() {
			this.shader = new _GLShader2.default(this._vs, this._fs, this._varyings);
		}
	}, {
		key: 'render',
		value: function render() {
			if (!this.shader) {
				this.generate();
			}

			this.shader.bind();
			_GLTool2.default.drawTransformFeedback(this);

			this._swap();
		}
	}, {
		key: '_swap',
		value: function _swap() {
			var tmp = this._meshCurrent;
			this._meshCurrent = this._meshTarget;
			this._meshTarget = tmp;
		}
	}, {
		key: 'numPoints',
		get: function get() {
			return this._numPoints;
		}
	}, {
		key: 'meshCurrent',
		get: function get() {
			return this._meshCurrent;
		}
	}, {
		key: 'meshTarget',
		get: function get() {
			return this._meshTarget;
		}
	}, {
		key: 'meshSource',
		get: function get() {
			return this._meshCurrent;
		}
	}, {
		key: 'meshDestination',
		get: function get() {
			return this._meshTarget;
		}
	}]);

	return TransformFeedbackObject;
}();

exports.default = TransformFeedbackObject;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// TweenNumber.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Easing = {
	Linear: {
		None: function None(k) {
			return k;
		}
	},
	Quadratic: {
		In: function In(k) {
			return k * k;
		},
		Out: function Out(k) {
			return k * (2 - k);
		},
		InOut: function InOut(k) {
			if ((k *= 2) < 1) {
				return 0.5 * k * k;
			}
			return -0.5 * (--k * (k - 2) - 1);
		}
	},
	Cubic: {
		In: function In(k) {
			return k * k * k;
		},
		Out: function Out(k) {
			return --k * k * k + 1;
		},
		InOut: function InOut(k) {
			if ((k *= 2) < 1) {
				return 0.5 * k * k * k;
			}
			return 0.5 * ((k -= 2) * k * k + 2);
		}
	},
	Quartic: {
		In: function In(k) {
			return k * k * k * k;
		},
		Out: function Out(k) {
			return 1 - --k * k * k * k;
		},
		InOut: function InOut(k) {
			if ((k *= 2) < 1) {
				return 0.5 * k * k * k * k;
			}
			return -0.5 * ((k -= 2) * k * k * k - 2);
		}
	},
	Quintic: {
		In: function In(k) {
			return k * k * k * k * k;
		},
		Out: function Out(k) {
			return --k * k * k * k * k + 1;
		},
		InOut: function InOut(k) {
			if ((k *= 2) < 1) {
				return 0.5 * k * k * k * k * k;
			}
			return 0.5 * ((k -= 2) * k * k * k * k + 2);
		}
	},
	Sinusoidal: {
		In: function In(k) {
			return 1 - Math.cos(k * Math.PI / 2);
		},
		Out: function Out(k) {
			return Math.sin(k * Math.PI / 2);
		},
		InOut: function InOut(k) {
			return 0.5 * (1 - Math.cos(Math.PI * k));
		}
	},
	Exponential: {
		In: function In(k) {
			return k === 0 ? 0 : Math.pow(1024, k - 1);
		},
		Out: function Out(k) {
			return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
		},
		InOut: function InOut(k) {
			if (k === 0) {
				return 0;
			}
			if (k === 1) {
				return 1;
			}
			if ((k *= 2) < 1) {
				return 0.5 * Math.pow(1024, k - 1);
			}
			return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
		}
	},
	Circular: {
		In: function In(k) {
			return 1 - Math.sqrt(1 - k * k);
		},
		Out: function Out(k) {
			return Math.sqrt(1 - --k * k);
		},
		InOut: function InOut(k) {
			if ((k *= 2) < 1) {
				return -0.5 * (Math.sqrt(1 - k * k) - 1);
			}
			return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
		}
	},
	Elastic: {
		In: function In(k) {
			var s = void 0;
			var a = 0.1;
			var p = 0.4;
			if (k === 0) {
				return 0;
			}
			if (k === 1) {
				return 1;
			}
			if (!a || a < 1) {
				a = 1;
				s = p / 4;
			} else {
				s = p * Math.asin(1 / a) / (2 * Math.PI);
			}
			return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
		},
		Out: function Out(k) {
			var s = void 0;
			var a = 0.1;
			var p = 0.4;
			if (k === 0) {
				return 0;
			}
			if (k === 1) {
				return 1;
			}
			if (!a || a < 1) {
				a = 1;
				s = p / 4;
			} else {
				s = p * Math.asin(1 / a) / (2 * Math.PI);
			}
			return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
		},
		InOut: function InOut(k) {
			var s = void 0;
			var a = 0.1;
			var p = 0.4;
			if (k === 0) {
				return 0;
			}
			if (k === 1) {
				return 1;
			}
			if (!a || a < 1) {
				a = 1;
				s = p / 4;
			} else {
				s = p * Math.asin(1 / a) / (2 * Math.PI);
			}
			if ((k *= 2) < 1) {
				return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
			}
			return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
		}
	},
	Back: {
		In: function In(k) {
			var s = 1.70158;
			return k * k * ((s + 1) * k - s);
		},
		Out: function Out(k) {
			var s = 1.70158;
			return --k * k * ((s + 1) * k + s) + 1;
		},
		InOut: function InOut(k) {
			var s = 1.70158 * 1.525;
			if ((k *= 2) < 1) {
				return 0.5 * (k * k * ((s + 1) * k - s));
			}
			return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
		}
	},
	Bounce: {
		in: function _in(k) {
			return 1 - Easing.Bounce.out(1 - k);
		},
		out: function out(k) {
			if (k < 1 / 2.75) {
				return 7.5625 * k * k;
			} else if (k < 2 / 2.75) {
				return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
			} else if (k < 2.5 / 2.75) {
				return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
			} else {
				return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
			}
		},
		inOut: function inOut(k) {
			if (k < 0.5) {
				return Easing.Bounce.in(k * 2) * 0.5;
			}
			return Easing.Bounce.out(k * 2 - 1) * 0.5 + 0.5;
		}
	}
};

function getFunc(mEasing) {
	switch (mEasing) {
		default:
		case 'linear':
			return Easing.Linear.None;
		case 'expIn':
			return Easing.Exponential.In;
		case 'expOut':
			return Easing.Exponential.Out;
		case 'expInOut':
			return Easing.Exponential.InOut;

		case 'cubicIn':
			return Easing.Cubic.In;
		case 'cubicOut':
			return Easing.Cubic.Out;
		case 'cubicInOut':
			return Easing.Cubic.InOut;

		case 'quarticIn':
			return Easing.Quartic.In;
		case 'quarticOut':
			return Easing.Quartic.Out;
		case 'quarticInOut':
			return Easing.Quartic.InOut;

		case 'quinticIn':
			return Easing.Quintic.In;
		case 'quinticOut':
			return Easing.Quintic.Out;
		case 'quinticInOut':
			return Easing.Quintic.InOut;

		case 'sinusoidalIn':
			return Easing.Sinusoidal.In;
		case 'sinusoidalOut':
			return Easing.Sinusoidal.Out;
		case 'sinusoidalInOut':
			return Easing.Sinusoidal.InOut;

		case 'circularIn':
			return Easing.Circular.In;
		case 'circularOut':
			return Easing.Circular.Out;
		case 'circularInOut':
			return Easing.Circular.InOut;

		case 'elasticIn':
			return Easing.Elastic.In;
		case 'elasticOut':
			return Easing.Elastic.Out;
		case 'elasticInOut':
			return Easing.Elastic.InOut;

		case 'backIn':
			return Easing.Back.In;
		case 'backOut':
			return Easing.Back.Out;
		case 'backInOut':
			return Easing.Back.InOut;

		case 'bounceIn':
			return Easing.Bounce.in;
		case 'bounceOut':
			return Easing.Bounce.out;
		case 'bounceInOut':
			return Easing.Bounce.inOut;
	}
}

var TweenNumber = function () {
	function TweenNumber(mValue) {
		var _this = this;

		var mEasing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'expOut';
		var mSpeed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.01;

		_classCallCheck(this, TweenNumber);

		this._value = mValue;
		this._startValue = mValue;
		this._targetValue = mValue;
		this._counter = 1;
		this.speed = mSpeed;
		this.easing = mEasing;
		this._needUpdate = true;

		this._efIndex = _scheduling2.default.addEF(function () {
			return _this._update();
		});
	}

	_createClass(TweenNumber, [{
		key: '_update',
		value: function _update() {
			var newCounter = this._counter + this.speed;
			if (newCounter > 1) {
				newCounter = 1;
			}
			if (this._counter === newCounter) {
				this._needUpdate = false;
				return;
			}

			this._counter = newCounter;
			this._needUpdate = true;
		}
	}, {
		key: 'limit',
		value: function limit(mMin, mMax) {
			if (mMin > mMax) {
				this.limit(mMax, mMin);
				return;
			}

			this._min = mMin;
			this._max = mMax;

			this._checkLimit();
		}
	}, {
		key: 'setTo',
		value: function setTo(mValue) {
			this._value = mValue;
			this._targetValue = mValue;
			this._counter = 1;
		}
	}, {
		key: '_checkLimit',
		value: function _checkLimit() {
			if (this._min !== undefined && this._targetValue < this._min) {
				this._targetValue = this._min;
			}

			if (this._max !== undefined && this._targetValue > this._max) {
				this._targetValue = this._max;
			}
		}
	}, {
		key: 'destroy',
		value: function destroy() {
			_scheduling2.default.removeEF(this._efIndex);
		}

		//	GETTERS / SETTERS

	}, {
		key: 'value',
		set: function set(mValue) {
			this._startValue = this._value;
			this._targetValue = mValue;
			this._checkLimit();
			this._counter = 0;
		},
		get: function get() {
			if (this._needUpdate) {
				var f = getFunc(this.easing);
				var p = f(this._counter);
				this._value = this._startValue + p * (this._targetValue - this._startValue);
				this._needUpdate = false;
			}
			return this._value;
		}
	}, {
		key: 'targetValue',
		get: function get() {
			return this._targetValue;
		}
	}]);

	return TweenNumber;
}();

exports.default = TweenNumber;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// QuatRotation.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _glMatrix = __webpack_require__(1);

var _glMatrix2 = _interopRequireDefault(_glMatrix);

var _EaseNumber = __webpack_require__(13);

var _EaseNumber2 = _interopRequireDefault(_EaseNumber);

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var getMouse = function getMouse(mEvent, mTarget) {

	var o = mTarget || {};
	if (mEvent.touches) {
		o.x = mEvent.touches[0].pageX;
		o.y = mEvent.touches[0].pageY;
	} else {
		o.x = mEvent.clientX;
		o.y = mEvent.clientY;
	}

	return o;
};

var QuatRotation = function () {
	function QuatRotation(mTarget) {
		var _this = this;

		var mListenerTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;
		var mEasing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;

		_classCallCheck(this, QuatRotation);

		this._target = mTarget;
		this._listenerTarget = mListenerTarget;

		this.matrix = _glMatrix2.default.mat4.create();
		this.m = _glMatrix2.default.mat4.create();
		this._vZaxis = _glMatrix2.default.vec3.clone([0, 0, 0]);
		this._zAxis = _glMatrix2.default.vec3.clone([0, 0, 1]);
		this.preMouse = { x: 0, y: 0 };
		this.mouse = { x: 0, y: 0 };
		this._isMouseDown = false;
		this._rotation = _glMatrix2.default.quat.create();
		this.tempRotation = _glMatrix2.default.quat.create();
		this._rotateZMargin = 0;
		this._offset = 0.004;
		this._slerp = -1;
		this._isLocked = false;

		this._diffX = new _EaseNumber2.default(0, mEasing);
		this._diffY = new _EaseNumber2.default(0, mEasing);

		this._listenerTarget.addEventListener('mousedown', function (e) {
			return _this._onDown(e);
		});
		this._listenerTarget.addEventListener('touchstart', function (e) {
			return _this._onDown(e);
		});
		this._listenerTarget.addEventListener('mousemove', function (e) {
			return _this._onMove(e);
		});
		this._listenerTarget.addEventListener('touchmove', function (e) {
			return _this._onMove(e);
		});
		window.addEventListener('touchend', function () {
			return _this._onUp();
		});
		window.addEventListener('mouseup', function () {
			return _this._onUp();
		});

		_scheduling2.default.addEF(function () {
			return _this._loop();
		});
	}

	// 	PUBLIC METHODS

	_createClass(QuatRotation, [{
		key: 'inverseControl',
		value: function inverseControl() {
			var isInvert = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			this._isInvert = isInvert;
		}
	}, {
		key: 'lock',
		value: function lock() {
			var mValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			this._isLocked = mValue;
		}
	}, {
		key: 'setCameraPos',
		value: function setCameraPos(mQuat) {
			var speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;

			this.easing = speed;
			if (this._slerp > 0) {
				return;
			}

			var tempRotation = _glMatrix2.default.quat.clone(this._rotation);
			this._updateRotation(tempRotation);
			this._rotation = _glMatrix2.default.quat.clone(tempRotation);
			this._currDiffX = this.diffX = 0;
			this._currDiffY = this.diffY = 0;

			this._isMouseDown = false;
			this._isRotateZ = 0;

			this._targetQuat = _glMatrix2.default.quat.clone(mQuat);
			this._slerp = 1;
		}
	}, {
		key: 'resetQuat',
		value: function resetQuat() {
			this._rotation = _glMatrix2.default.quat.clone([0, 0, 1, 0]);
			this.tempRotation = _glMatrix2.default.quat.clone([0, 0, 0, 0]);
			this._targetQuat = undefined;
			this._slerp = -1;
		}

		//	EVENT HANDLER

	}, {
		key: '_onDown',
		value: function _onDown(mEvent) {
			if (this._isLocked) {
				return;
			}

			var mouse = getMouse(mEvent);
			var tempRotation = _glMatrix2.default.quat.clone(this._rotation);
			this._updateRotation(tempRotation);
			this._rotation = tempRotation;

			this._isMouseDown = true;
			this._isRotateZ = 0;
			this.preMouse = { x: mouse.x, y: mouse.y };

			if (mouse.y < this._rotateZMargin || mouse.y > window.innerHeight - this._rotateZMargin) {
				this._isRotateZ = 1;
			} else if (mouse.x < this._rotateZMargin || mouse.x > window.innerWidth - this._rotateZMargin) {
				this._isRotateZ = 2;
			}

			this._diffX.setTo(0);
			this._diffY.setTo(0);
		}
	}, {
		key: '_onMove',
		value: function _onMove(mEvent) {
			if (this._isLocked) {
				return;
			}
			getMouse(mEvent, this.mouse);
		}
	}, {
		key: '_onUp',
		value: function _onUp() {
			if (this._isLocked) {
				return;
			}
			this._isMouseDown = false;
		}

		//	PRIVATE METHODS

	}, {
		key: '_updateRotation',
		value: function _updateRotation(mTempRotation) {
			if (this._isMouseDown && !this._isLocked) {
				this._diffX.value = -(this.mouse.x - this.preMouse.x);
				this._diffY.value = this.mouse.y - this.preMouse.y;

				if (this._isInvert) {
					this._diffX.value = -this._diffX.targetValue;
					this._diffY.value = -this._diffY.targetValue;
				}
			}

			var angle = void 0,
			    _quat = void 0;

			if (this._isRotateZ > 0) {
				if (this._isRotateZ === 1) {
					angle = -this._diffX.value * this._offset;
					angle *= this.preMouse.y < this._rotateZMargin ? -1 : 1;
					_quat = _glMatrix2.default.quat.clone([0, 0, Math.sin(angle), Math.cos(angle)]);
					_glMatrix2.default.quat.multiply(_quat, mTempRotation, _quat);
				} else {
					angle = -this._diffY.value * this._offset;
					angle *= this.preMouse.x < this._rotateZMargin ? 1 : -1;
					_quat = _glMatrix2.default.quat.clone([0, 0, Math.sin(angle), Math.cos(angle)]);
					_glMatrix2.default.quat.multiply(_quat, mTempRotation, _quat);
				}
			} else {
				var v = _glMatrix2.default.vec3.clone([this._diffX.value, this._diffY.value, 0]);
				var axis = _glMatrix2.default.vec3.create();
				_glMatrix2.default.vec3.cross(axis, v, this._zAxis);
				_glMatrix2.default.vec3.normalize(axis, axis);
				angle = _glMatrix2.default.vec3.length(v) * this._offset;
				_quat = _glMatrix2.default.quat.clone([Math.sin(angle) * axis[0], Math.sin(angle) * axis[1], Math.sin(angle) * axis[2], Math.cos(angle)]);
				_glMatrix2.default.quat.multiply(mTempRotation, _quat, mTempRotation);
			}
		}
	}, {
		key: '_loop',
		value: function _loop() {
			_glMatrix2.default.mat4.identity(this.m);

			if (this._targetQuat === undefined) {
				_glMatrix2.default.quat.set(this.tempRotation, this._rotation[0], this._rotation[1], this._rotation[2], this._rotation[3]);
				this._updateRotation(this.tempRotation);
			} else {
				this._slerp += (0 - this._slerp) * 0.1;

				if (this._slerp < 0.0005) {
					_glMatrix2.default.quat.copy(this._rotation, this._targetQuat);
					_glMatrix2.default.quat.copy(this.tempRotation, this._targetQuat);
					this._targetQuat = undefined;
					this._diffX.setTo(0);
					this._diffY.setTo(0);
					this._slerp = -1;
				} else {
					_glMatrix2.default.quat.set(this.tempRotation, 0, 0, 0, 0);
					_glMatrix2.default.quat.slerp(this.tempRotation, this._targetQuat, this._rotation, this._slerp);
				}
			}

			_glMatrix2.default.vec3.transformQuat(this._vZaxis, this._vZaxis, this.tempRotation);

			_glMatrix2.default.mat4.fromQuat(this.matrix, this.tempRotation);
		}

		//	GETTER AND SETTER

	}, {
		key: 'easing',
		set: function set(mValue) {
			this._diffX.easing = mValue;
			this._diffY.easing = mValue;
		},
		get: function get() {
			return this._diffX.easing;
		}
	}]);

	return QuatRotation;
}();

exports.default = QuatRotation;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _EventDispatcher2 = __webpack_require__(29);

var _EventDispatcher3 = _interopRequireDefault(_EventDispatcher2);

var _Ray = __webpack_require__(14);

var _Ray2 = _interopRequireDefault(_Ray);

var _getMouse = __webpack_require__(64);

var _getMouse2 = _interopRequireDefault(_getMouse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // TouchDetector.js


function distance(a, b) {
	var dx = a.x - b.x;
	var dy = a.y - b.y;
	return Math.sqrt(dx * dx + dy * dy);
}

var TouchDetector = function (_EventDispatcher) {
	_inherits(TouchDetector, _EventDispatcher);

	function TouchDetector(mMesh, mCamera) {
		var mSkipMoveCheck = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
		var mListenerTarget = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : window;

		_classCallCheck(this, TouchDetector);

		var _this = _possibleConstructorReturn(this, (TouchDetector.__proto__ || Object.getPrototypeOf(TouchDetector)).call(this));

		_this._mesh = mMesh;
		_this._mesh.generateFaces();
		_this._camera = mCamera;
		_this.faceVertices = mMesh.faces.map(function (face) {
			return face.vertices;
		});
		_this.clickTolerance = 8;

		_this._ray = new _Ray2.default([0, 0, 0], [0, 0, -1]);
		_this._hit = vec3.fromValues(-999, -999, -999);
		_this._lastPos;
		_this._firstPos;
		_this.mtxModel = mat4.create();

		_this._listenerTarget = mListenerTarget;
		_this._skippingMove = mSkipMoveCheck;

		_this._onMoveBind = function (e) {
			return _this._onMove(e);
		};
		_this._onDownBind = function (e) {
			return _this._onDown(e);
		};
		_this._onUpBind = function () {
			return _this._onUp();
		};

		_this.connect();
		return _this;
	}

	_createClass(TouchDetector, [{
		key: 'connect',
		value: function connect() {
			this._listenerTarget.addEventListener('mousedown', this._onDownBind);
			this._listenerTarget.addEventListener('mousemove', this._onMoveBind);
			this._listenerTarget.addEventListener('mouseup', this._onUpBind);
		}
	}, {
		key: 'disconnect',
		value: function disconnect() {
			this._listenerTarget.removeEventListener('mousedown', this._onDownBind);
			this._listenerTarget.removeEventListener('mousemove', this._onMoveBind);
			this._listenerTarget.removeEventListener('mouseup', this._onUpBind);
		}
	}, {
		key: '_checkHit',
		value: function _checkHit() {
			var _this2 = this;

			var mType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'onHit';

			var camera = this._camera;
			if (!camera) {
				return;
			}

			var mx = this._lastPos.x / _GLTool2.default.width * 2.0 - 1.0;
			var my = -(this._lastPos.y / _GLTool2.default.height) * 2.0 + 1.0;

			camera.generateRay([mx, my, 0], this._ray);

			var hit = void 0;
			var v0 = vec3.create();
			var v1 = vec3.create();
			var v2 = vec3.create();
			var dist = 0;

			var getVector = function getVector(v, target) {
				vec3.transformMat4(target, v, _this2.mtxModel);
			};

			for (var i = 0; i < this.faceVertices.length; i++) {
				var vertices = this.faceVertices[i];
				getVector(vertices[0], v0);
				getVector(vertices[1], v1);
				getVector(vertices[2], v2);
				var t = this._ray.intersectTriangle(v0, v1, v2);

				if (t) {
					if (hit) {
						var distToCam = vec3.dist(t, camera.position);
						if (distToCam < dist) {
							hit = vec3.clone(t);
							dist = distToCam;
						}
					} else {
						hit = vec3.clone(t);
						dist = vec3.dist(hit, camera.position);
					}
				}
			}

			if (hit) {
				this._hit = vec3.clone(hit);
				this.dispatchCustomEvent(mType, { hit: hit });
			} else {
				this.dispatchCustomEvent('onUp');
			}
		}
	}, {
		key: '_onDown',
		value: function _onDown(e) {
			this._firstPos = (0, _getMouse2.default)(e);
			this._lastPos = (0, _getMouse2.default)(e);
			this._checkHit('onDown');
		}
	}, {
		key: '_onMove',
		value: function _onMove(e) {
			this._lastPos = (0, _getMouse2.default)(e);
			if (!this._skippingMove) {
				this._checkHit();
			}
		}
	}, {
		key: '_onUp',
		value: function _onUp() {
			var dist = distance(this._firstPos, this._lastPos);
			if (dist < this.clickTolerance) {
				this._checkHit();
			}
		}
	}]);

	return TouchDetector;
}(_EventDispatcher3.default);

exports.default = TouchDetector;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function (e) {
	var x = void 0,
	    y = void 0;

	if (e.touches) {
		x = e.touches[0].pageX;
		y = e.touches[0].pageY;
	} else {
		x = e.clientX;
		y = e.clientY;
	}

	return {
		x: x, y: y
	};
};

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// CameraCube.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CameraPerspective2 = __webpack_require__(16);

var _CameraPerspective3 = _interopRequireDefault(_CameraPerspective2);

var _glMatrix = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CAMERA_SETTINGS = [[_glMatrix.vec3.fromValues(0, 0, 0), _glMatrix.vec3.fromValues(1, 0, 0), _glMatrix.vec3.fromValues(0, -1, 0)], [_glMatrix.vec3.fromValues(0, 0, 0), _glMatrix.vec3.fromValues(-1, 0, 0), _glMatrix.vec3.fromValues(0, -1, 0)], [_glMatrix.vec3.fromValues(0, 0, 0), _glMatrix.vec3.fromValues(0, 1, 0), _glMatrix.vec3.fromValues(0, 0, 1)], [_glMatrix.vec3.fromValues(0, 0, 0), _glMatrix.vec3.fromValues(0, -1, 0), _glMatrix.vec3.fromValues(0, 0, -1)], [_glMatrix.vec3.fromValues(0, 0, 0), _glMatrix.vec3.fromValues(0, 0, 1), _glMatrix.vec3.fromValues(0, -1, 0)], [_glMatrix.vec3.fromValues(0, 0, 0), _glMatrix.vec3.fromValues(0, 0, -1), _glMatrix.vec3.fromValues(0, -1, 0)]];

var CameraCube = function (_CameraPerspective) {
	_inherits(CameraCube, _CameraPerspective);

	function CameraCube() {
		_classCallCheck(this, CameraCube);

		var _this = _possibleConstructorReturn(this, (CameraCube.__proto__ || Object.getPrototypeOf(CameraCube)).call(this));

		_this.setPerspective(Math.PI / 2, 1, 0.1, 1000);
		return _this;
	}

	_createClass(CameraCube, [{
		key: 'face',
		value: function face(mIndex) {
			var o = CAMERA_SETTINGS[mIndex];
			this.lookAt(o[0], o[1], o[2]);
		}
	}]);

	return CameraCube;
}(_CameraPerspective3.default);

exports.default = CameraCube;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// ObjLoader.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BinaryLoader2 = __webpack_require__(17);

var _BinaryLoader3 = _interopRequireDefault(_BinaryLoader2);

var _Mesh = __webpack_require__(4);

var _Mesh2 = _interopRequireDefault(_Mesh);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ObjLoader = function (_BinaryLoader) {
	_inherits(ObjLoader, _BinaryLoader);

	function ObjLoader() {
		_classCallCheck(this, ObjLoader);

		return _possibleConstructorReturn(this, (ObjLoader.__proto__ || Object.getPrototypeOf(ObjLoader)).apply(this, arguments));
	}

	_createClass(ObjLoader, [{
		key: 'load',
		value: function load(url, callback) {
			var drawType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;

			this._drawType = drawType;
			_get(ObjLoader.prototype.__proto__ || Object.getPrototypeOf(ObjLoader.prototype), 'load', this).call(this, url, callback);
		}
	}, {
		key: '_onLoaded',
		value: function _onLoaded() {
			this.parseObj(this._req.response);
		}
	}, {
		key: 'parseObj',
		value: function parseObj(objStr) {
			var lines = objStr.split('\n');

			var positions = [];
			var coords = [];
			var finalNormals = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
			var indices = [];
			var count = 0;
			var result = void 0;

			// v float float float
			var vertexPattern = /v( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/;

			// vn float float float
			var normalPattern = /vn( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/;

			// vt float float
			var uvPattern = /vt( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/;

			// f vertex vertex vertex ...
			var facePattern1 = /f( +-?\d+)( +-?\d+)( +-?\d+)( +-?\d+)?/;

			// f vertex/uv vertex/uv vertex/uv ...
			var facePattern2 = /f( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))?/;

			// f vertex/uv/normal vertex/uv/normal vertex/uv/normal ...
			var facePattern3 = /f( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))?/;

			// f vertex//normal vertex//normal vertex//normal ... 
			var facePattern4 = /f( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))?/;

			function parseVertexIndex(value) {
				var index = parseInt(value);
				return (index >= 0 ? index - 1 : index + vertices.length / 3) * 3;
			}

			function parseNormalIndex(value) {
				var index = parseInt(value);
				return (index >= 0 ? index - 1 : index + normals.length / 3) * 3;
			}

			function parseUVIndex(value) {
				var index = parseInt(value);
				return (index >= 0 ? index - 1 : index + uvs.length / 2) * 2;
			}

			function addVertex(a, b, c) {
				positions.push([vertices[a], vertices[a + 1], vertices[a + 2]]);
				positions.push([vertices[b], vertices[b + 1], vertices[b + 2]]);
				positions.push([vertices[c], vertices[c + 1], vertices[c + 2]]);

				indices.push(count * 3 + 0);
				indices.push(count * 3 + 1);
				indices.push(count * 3 + 2);

				count++;
			}

			function addUV(a, b, c) {
				coords.push([uvs[a], uvs[a + 1]]);
				coords.push([uvs[b], uvs[b + 1]]);
				coords.push([uvs[c], uvs[c + 1]]);
			}

			function addNormal(a, b, c) {
				finalNormals.push([normals[a], normals[a + 1], normals[a + 2]]);
				finalNormals.push([normals[b], normals[b + 1], normals[b + 2]]);
				finalNormals.push([normals[c], normals[c + 1], normals[c + 2]]);
			}

			function addFace(a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd) {
				var ia = parseVertexIndex(a);
				var ib = parseVertexIndex(b);
				var ic = parseVertexIndex(c);
				var id = void 0;

				if (d === undefined) {

					addVertex(ia, ib, ic);
				} else {

					id = parseVertexIndex(d);

					addVertex(ia, ib, id);
					addVertex(ib, ic, id);
				}

				if (ua !== undefined) {

					ia = parseUVIndex(ua);
					ib = parseUVIndex(ub);
					ic = parseUVIndex(uc);

					if (d === undefined) {

						addUV(ia, ib, ic);
					} else {

						id = parseUVIndex(ud);

						addUV(ia, ib, id);
						addUV(ib, ic, id);
					}
				}

				if (na !== undefined) {

					ia = parseNormalIndex(na);
					ib = parseNormalIndex(nb);
					ic = parseNormalIndex(nc);

					if (d === undefined) {

						addNormal(ia, ib, ic);
					} else {

						id = parseNormalIndex(nd);

						addNormal(ia, ib, id);
						addNormal(ib, ic, id);
					}
				}
			}

			for (var i = 0; i < lines.length; i++) {
				var line = lines[i];
				line = line.trim();

				if (line.length === 0 || line.charAt(0) === '#') {

					continue;
				} else if ((result = vertexPattern.exec(line)) !== null) {

					vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
				} else if ((result = normalPattern.exec(line)) !== null) {

					normals.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
				} else if ((result = uvPattern.exec(line)) !== null) {

					uvs.push(parseFloat(result[1]), parseFloat(result[2]));
				} else if ((result = facePattern1.exec(line)) !== null) {

					addFace(result[1], result[2], result[3], result[4]);
				} else if ((result = facePattern2.exec(line)) !== null) {

					addFace(result[2], result[5], result[8], result[11], result[3], result[6], result[9], result[12]);
				} else if ((result = facePattern3.exec(line)) !== null) {
					addFace(result[2], result[6], result[10], result[14], result[3], result[7], result[11], result[15], result[4], result[8], result[12], result[16]);
				} else if ((result = facePattern4.exec(line)) !== null) {
					addFace(result[2], result[5], result[8], result[11], undefined, undefined, undefined, undefined, result[3], result[6], result[9], result[12]);
				}
			}

			return this._generateMeshes({
				positions: positions,
				coords: coords,
				normals: finalNormals,
				indices: indices
			});
		}
	}, {
		key: '_generateMeshes',
		value: function _generateMeshes(o) {
			var maxNumVertices = 65535;
			var hasNormals = o.normals.length > 0;
			var hasUVs = o.coords.length > 0;
			var mesh = void 0;

			if (o.positions.length > maxNumVertices) {
				var meshes = [];
				var lastIndex = 0;

				var oCopy = {};
				oCopy.positions = o.positions.concat();
				oCopy.coords = o.coords.concat();
				oCopy.indices = o.indices.concat();
				oCopy.normals = o.normals.concat();

				while (o.indices.length > 0) {

					var sliceNum = Math.min(maxNumVertices, o.positions.length);
					var indices = o.indices.splice(0, sliceNum);
					var positions = [];
					var coords = [];
					var normals = [];
					var index = void 0,
					    tmpIndex = 0;

					for (var i = 0; i < indices.length; i++) {
						if (indices[i] > tmpIndex) {
							tmpIndex = indices[i];
						}

						index = indices[i];

						positions.push(oCopy.positions[index]);
						if (hasUVs) {
							coords.push(oCopy.coords[index]);
						}
						if (hasNormals) {
							normals.push(oCopy.normals[index]);
						}

						indices[i] -= lastIndex;
					}

					lastIndex = tmpIndex + 1;

					mesh = new _Mesh2.default(this._drawType);
					mesh.bufferVertex(positions);
					if (hasUVs) {
						mesh.bufferTexCoord(coords);
					}

					mesh.bufferIndex(indices);
					if (hasNormals) {
						mesh.bufferNormal(normals);
					}

					meshes.push(mesh);
				}

				if (this._callback) {
					this._callback(meshes, oCopy);
				}

				return meshes;
			} else {
				mesh = new _Mesh2.default(this._drawType);
				mesh.bufferVertex(o.positions);
				if (hasUVs) {
					mesh.bufferTexCoord(o.coords);
				}
				mesh.bufferIndex(o.indices);
				if (hasNormals) {
					mesh.bufferNormal(o.normals);
				}

				if (this._callback) {
					this._callback(mesh, o);
				}

				return mesh;
			}

			return null;
		}
	}]);

	return ObjLoader;
}(_BinaryLoader3.default);

ObjLoader.parse = function (objStr) {
	var loader = new ObjLoader();
	return loader.parseObj(objStr);
};

exports.default = ObjLoader;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// HDRLoader.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _BinaryLoader2 = __webpack_require__(17);

var _BinaryLoader3 = _interopRequireDefault(_BinaryLoader2);

var _HDRParser = __webpack_require__(68);

var _HDRParser2 = _interopRequireDefault(_HDRParser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var HDRLoader = function (_BinaryLoader) {
	_inherits(HDRLoader, _BinaryLoader);

	function HDRLoader() {
		_classCallCheck(this, HDRLoader);

		return _possibleConstructorReturn(this, (HDRLoader.__proto__ || Object.getPrototypeOf(HDRLoader)).call(this, true));
	}

	_createClass(HDRLoader, [{
		key: 'parse',
		value: function parse(mArrayBuffer) {
			return (0, _HDRParser2.default)(mArrayBuffer);
		}
	}, {
		key: '_onLoaded',
		value: function _onLoaded() {
			var o = this.parse(this._req.response);
			if (this._callback) {
				this._callback(o);
			}
		}
	}]);

	return HDRLoader;
}(_BinaryLoader3.default);

HDRLoader.parse = function (mArrayBuffer) {
	return (0, _HDRParser2.default)(mArrayBuffer);
};

exports.default = HDRLoader;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// HDRParser.js



// Code ported by Marcin Ignac (2014)
// Based on Java implementation from
// https://code.google.com/r/cys12345-research/source/browse/hdr/image_processor/RGBE.java?r=7d84e9fd866b24079dbe61fa0a966ce8365f5726

Object.defineProperty(exports, "__esModule", {
	value: true
});
var radiancePattern = '#\\?RADIANCE';
var commentPattern = '#.*';
// let gammaPattern = 'GAMMA=';
var exposurePattern = 'EXPOSURE=\\s*([0-9]*[.][0-9]*)';
var formatPattern = 'FORMAT=32-bit_rle_rgbe';
var widthHeightPattern = '-Y ([0-9]+) \\+X ([0-9]+)';

// http://croquetweak.blogspot.co.uk/2014/08/deconstructing-floats-frexp-and-ldexp.html
// function ldexp(mantissa, exponent) {
//     return exponent > 1023 ? mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023) : exponent < -1074 ? mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074) : mantissa * Math.pow(2, exponent);
// }

function readPixelsRawRLE(buffer, data, offset, fileOffset, scanlineWidth, numScanlines) {
	var rgbe = new Array(4);
	var scanlineBuffer = null;
	var ptr = void 0;
	var ptrEnd = void 0;
	var count = void 0;
	var buf = new Array(2);
	var bufferLength = buffer.length;

	function readBuf(buf) {
		var bytesRead = 0;
		do {
			buf[bytesRead++] = buffer[fileOffset];
		} while (++fileOffset < bufferLength && bytesRead < buf.length);
		return bytesRead;
	}

	function readBufOffset(buf, offset, length) {
		var bytesRead = 0;
		do {
			buf[offset + bytesRead++] = buffer[fileOffset];
		} while (++fileOffset < bufferLength && bytesRead < length);
		return bytesRead;
	}

	function readPixelsRaw(buffer, data, offset, numpixels) {
		var numExpected = 4 * numpixels;
		var numRead = readBufOffset(data, offset, numExpected);
		if (numRead < numExpected) {
			throw new Error('Error reading raw pixels: got ' + numRead + ' bytes, expected ' + numExpected);
		}
	}

	while (numScanlines > 0) {
		if (readBuf(rgbe) < rgbe.length) {
			throw new Error('Error reading bytes: expected ' + rgbe.length);
		}

		if (rgbe[0] !== 2 || rgbe[1] !== 2 || (rgbe[2] & 0x80) !== 0) {
			// this file is not run length encoded
			data[offset++] = rgbe[0];
			data[offset++] = rgbe[1];
			data[offset++] = rgbe[2];
			data[offset++] = rgbe[3];
			readPixelsRaw(buffer, data, offset, scanlineWidth * numScanlines - 1);
			return;
		}

		if (((rgbe[2] & 0xFF) << 8 | rgbe[3] & 0xFF) !== scanlineWidth) {
			throw new Error('Wrong scanline width ' + ((rgbe[2] & 0xFF) << 8 | rgbe[3] & 0xFF) + ', expected ' + scanlineWidth);
		}

		if (scanlineBuffer === null) {
			scanlineBuffer = new Array(4 * scanlineWidth);
		}

		ptr = 0;
		/* read each of the four channels for the scanline into the buffer */
		for (var i = 0; i < 4; i++) {
			ptrEnd = (i + 1) * scanlineWidth;
			while (ptr < ptrEnd) {
				if (readBuf(buf) < buf.length) {
					throw new Error('Error reading 2-byte buffer');
				}
				if ((buf[0] & 0xFF) > 128) {
					/* a run of the same value */
					count = (buf[0] & 0xFF) - 128;
					if (count === 0 || count > ptrEnd - ptr) {
						throw new Error('Bad scanline data');
					}
					while (count-- > 0) {
						scanlineBuffer[ptr++] = buf[1];
					}
				} else {
					/* a non-run */
					count = buf[0] & 0xFF;
					if (count === 0 || count > ptrEnd - ptr) {
						throw new Error('Bad scanline data');
					}
					scanlineBuffer[ptr++] = buf[1];
					if (--count > 0) {
						if (readBufOffset(scanlineBuffer, ptr, count) < count) {
							throw new Error('Error reading non-run data');
						}
						ptr += count;
					}
				}
			}
		}

		/* copy byte data to output */
		for (var _i = 0; _i < scanlineWidth; _i++) {
			data[offset + 0] = scanlineBuffer[_i];
			data[offset + 1] = scanlineBuffer[_i + scanlineWidth];
			data[offset + 2] = scanlineBuffer[_i + 2 * scanlineWidth];
			data[offset + 3] = scanlineBuffer[_i + 3 * scanlineWidth];
			offset += 4;
		}

		numScanlines--;
	}
}

// Returns data as floats and flipped along Y by default
function parseHdr(buffer) {
	if (buffer instanceof ArrayBuffer) {
		buffer = new Uint8Array(buffer);
	}

	var fileOffset = 0;
	var bufferLength = buffer.length;

	var NEW_LINE = 10;

	function readLine() {
		var buf = '';
		do {
			var b = buffer[fileOffset];
			if (b === NEW_LINE) {
				++fileOffset;
				break;
			}
			buf += String.fromCharCode(b);
		} while (++fileOffset < bufferLength);
		return buf;
	}

	var width = 0;
	var height = 0;
	var exposure = 1;
	var gamma = 1;
	var rle = false;

	for (var i = 0; i < 20; i++) {
		var line = readLine();
		var match = void 0;
		if (match = line.match(radiancePattern)) {} else if (match = line.match(formatPattern)) {
			rle = true;
		} else if (match = line.match(exposurePattern)) {
			exposure = Number(match[1]);
		} else if (match = line.match(commentPattern)) {} else if (match = line.match(widthHeightPattern)) {
			height = Number(match[1]);
			width = Number(match[2]);
			break;
		}
	}

	if (!rle) {
		throw new Error('File is not run length encoded!');
	}

	var data = new Uint8Array(width * height * 4);
	var scanlineWidth = width;
	var numScanlines = height;

	readPixelsRawRLE(buffer, data, 0, fileOffset, scanlineWidth, numScanlines);

	// TODO: Should be Float16
	var floatData = new Float32Array(width * height * 4);
	for (var offset = 0; offset < data.length; offset += 4) {
		var r = data[offset + 0] / 255;
		var g = data[offset + 1] / 255;
		var b = data[offset + 2] / 255;
		var e = data[offset + 3];
		var f = Math.pow(2.0, e - 128.0);

		r *= f;
		g *= f;
		b *= f;

		var floatOffset = offset;

		floatData[floatOffset + 0] = r;
		floatData[floatOffset + 1] = g;
		floatData[floatOffset + 2] = b;
		floatData[floatOffset + 3] = 1.0;
	}

	return {
		shape: [width, height],
		exposure: exposure,
		gamma: gamma,
		data: floatData
	};
}

exports.default = parseHdr;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _colladaParser = __webpack_require__(70);

var _colladaParser2 = _interopRequireDefault(_colladaParser);

var _Mesh = __webpack_require__(4);

var _Mesh2 = _interopRequireDefault(_Mesh);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// ColladaParser.js

var generateMesh = function generateMesh(meshes) {
	var caches = {};

	meshes.forEach(function (mesh) {
		var _mesh$mesh = mesh.mesh,
		    vertices = _mesh$mesh.vertices,
		    normals = _mesh$mesh.normals,
		    coords = _mesh$mesh.coords,
		    triangles = _mesh$mesh.triangles,
		    name = _mesh$mesh.name;

		if (!caches[name]) {
			var glMesh = new _Mesh2.default().bufferFlattenData(vertices, 'aVertexPosition', 3).bufferFlattenData(coords, 'aTextureCoord', 2).bufferFlattenData(normals, 'aNormal', 3).bufferIndex(triangles);

			caches[name] = glMesh;
		}

		mesh.glMesh = caches[name];
	});
};

var parse = function parse(mData) {
	var meshes = _colladaParser2.default.parse(mData);
	generateMesh(meshes);

	return meshes;
};

var load = function load(mPath, mCallback) {
	_colladaParser2.default.load(mPath, function (meshes) {
		generateMesh(meshes);
		mCallback(meshes);
	});
};

var ColladaParser = {
	parse: parse,
	load: load
};

exports.default = ColladaParser;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Collada = __webpack_require__(71);

var _Collada2 = _interopRequireDefault(_Collada);

var _glMatrix = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// ColladaParser.js

var parseData = function parseData(mData) {
	var materials = mData.materials,
	    meshes = mData.meshes;


	var finalMeshes = [];
	var meshObjs = [];
	var allMeshes = [];

	//	getting all meshes' buffers
	for (var s in meshes) {
		var oMesh = meshes[s];
		var vertices = oMesh.vertices,
		    normals = oMesh.normals,
		    coords = oMesh.coords,
		    triangles = oMesh.triangles;

		var buffers = {
			vertices: vertices, normals: normals, coords: coords, triangles: triangles
		};
		allMeshes.push({
			id: s,
			buffers: buffers
		});
	}

	function getMaterial(id) {
		var mat = void 0;
		for (var _s in materials) {
			if (_s === id) {
				mat = materials[_s];
			}
		}

		var oMaterial = {};
		if (mat.diffuse) {
			oMaterial.diffuseColor = mat.diffuse;
		}

		oMaterial.diffuseColor = mat.diffuse || [0, 0, 0];
		oMaterial.shininess = mat.shininess || 0;
		if (mat.textures) {
			if (mat.textures.diffuse) {
				oMaterial.diffuseMapID = mat.textures.diffuse.map_id;
			}

			if (mat.textures.normal) {
				oMaterial.normalMapID = mat.textures.normal.map_id;
			}
		}

		return oMaterial;
	}

	function walk(node, mtxParent) {
		var m = _glMatrix.mat4.create();
		if (node.model) {
			_glMatrix.mat4.multiply(m, mtxParent, node.model);
		} else {
			_glMatrix.mat4.copy(m, mtxParent);
		}

		if (node.children.length > 0) {
			node.children.forEach(function (child) {
				walk(child, m);
			});
		}

		if (node.mesh) {
			var _oMesh = {};
			_oMesh.modelMatrix = m;
			_oMesh.mesh = meshes[node.mesh];
			_oMesh.id = node.id;
			_oMesh.name = node.name;
			_oMesh.material = getMaterial(node.material);
			meshObjs.push(_oMesh);
		}
	}

	var mtx = _glMatrix.mat4.create();
	walk(mData.root, mtx);

	return meshObjs;
};

var parse = function parse(mFile) {
	var o = _Collada2.default.parse(mFile);
	return parseData(o);
};

var load = function load(mPath, mCallBack) {
	_Collada2.default.load(mPath, function (mData) {
		mCallBack(parseData(mData));
	});
};

var ColladaParser = {
	load: load,
	parse: parse
};

exports.default = ColladaParser;
module.exports = exports['default'];
//# sourceMappingURL=ColladaParser.js.map

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _glMatrix = __webpack_require__(1);

var isWorker = global.document === undefined; // Collada.js

var DEG2RAD = Math.PI * 2 / 360;

//global temporal variables
var temp_mat4 = null;
var temp_vec2 = null;
var temp_vec3 = null;
var temp_vec4 = null;
var temp_quat = null;

function request(url, callback) {
	var req = new XMLHttpRequest();
	req.onload = function () {
		var response = this.response;
		if (this.status != 200) return;
		if (callback) callback(this.response);
	};
	req.open("get", url, true);
	req.send();
}

var Collada = {

	libsPath: "./",
	workerPath: "./",
	no_flip: true,
	use_transferables: true, //for workers
	onerror: null,
	verbose: false,
	config: { forceParser: false },

	init: function init(config) {
		config = config || {};
		for (var i in config) {
			this[i] = config[i];
		}this.config = config;

		if (isWorker) {
			try {
				importScripts(this.libsPath + "gl-matrix-min.js", this.libsPath + "tinyxml.js");
			} catch (err) {
				Collada.throwException(Collada.LIBMISSING_ERROR);
			}
		}

		//init glMatrix
		temp_mat4 = _glMatrix.mat4.create();
		temp_vec2 = vec3.create();
		temp_vec3 = vec3.create();
		temp_vec4 = vec3.create();
		temp_quat = _glMatrix.quat.create();

		if (isWorker) console.log("Collada worker ready");
	},

	load: function load(url, callback) {
		request(url, function (data) {
			if (!data) callback(null);else callback(Collada.parse(data));
		});
	},

	_xmlroot: null,
	_nodes_by_id: null,
	_transferables: null,
	_controllers_found: null,
	_geometries_found: null,

	safeString: function safeString(str) {
		if (!str) return "";

		if (this.convertID) return this.convertID(str);

		return str.replace(/ /g, "_");
	},

	LIBMISSING_ERROR: "Libraries loading error, when using workers remember to pass the URL to the tinyxml.js in the options.libsPath",
	NOXMLPARSER_ERROR: "TinyXML not found, when using workers remember to pass the URL to the tinyxml.js in the options.libsPath (Workers do not allow to access the native XML DOMParser)",
	throwException: function throwException(msg) {
		if (isWorker) self.postMessage({ action: "exception", msg: msg });else if (Collada.onerror) Collada.onerror(msg);
		throw msg;
	},

	getFilename: function getFilename(filename) {
		var pos = filename.lastIndexOf("\\");
		if (pos != -1) filename = filename.substr(pos + 1);
		//strip unix slashes
		pos = filename.lastIndexOf("/");
		if (pos != -1) filename = filename.substr(pos + 1);
		return filename;
	},

	last_name: 0,

	generateName: function generateName(v) {
		v = v || "name_";
		var name = v + this.last_name;
		this.last_name++;
		return name;
	},

	parse: function parse(data, options, filename) {
		options = options || {};
		filename = filename || "_dae_" + Date.now() + ".dae";

		//console.log("Parsing collada");
		var flip = false;

		var xmlparser = null;
		var root = null;
		this._transferables = [];

		if (this.verbose) console.log(" - XML parsing...");

		if (global["DOMParser"] && !this.config.forceParser) {
			xmlparser = new DOMParser();
			root = xmlparser.parseFromString(data, "text/xml");
			if (this.verbose) console.log(" - XML parsed");
		} else //USING JS XML PARSER IMPLEMENTATION (much slower)
			{
				if (!global["DOMImplementation"]) return Collada.throwException(Collada.NOXMLPARSER_ERROR);
				//use tinyxmlparser
				try {
					xmlparser = new DOMImplementation();
				} catch (err) {
					return Collada.throwException(Collada.NOXMLPARSER_ERROR);
				}

				root = xmlparser.loadXML(data);
				if (this.verbose) console.log(" - XML parsed");

				//for every node...
				var by_ids = root._nodes_by_id = {};
				for (var i = 0, l = root.all.length; i < l; ++i) {
					var node = root.all[i];
					by_ids[node.id] = node;
					if (node.getAttribute("sid")) by_ids[node.getAttribute("sid")] = node;
				}

				if (!this.extra_functions) {
					this.extra_functions = true;
					//these methods are missing so here is a lousy implementation
					DOMDocument.prototype.querySelector = DOMElement.prototype.querySelector = function (selector) {
						var tags = selector.split(" ");
						var current_element = this;

						while (tags.length) {
							var current = tags.shift();
							var tokens = current.split("#");
							var tagname = tokens[0];
							var id = tokens[1];
							var elements = tagname ? current_element.getElementsByTagName(tagname) : current_element.childNodes;
							if (!id) //no id filter
								{
									if (tags.length == 0) return elements.item(0);
									current_element = elements.item(0);
									continue;
								}

							//has id? check for all to see if one matches the id
							for (var i = 0; i < elements.length; i++) {
								if (elements.item(i).getAttribute("id") == id) {
									if (tags.length == 0) return elements.item(i);
									current_element = elements.item(i);
									break;
								}
							}
						}
						return null;
					};

					DOMDocument.prototype.querySelectorAll = DOMElement.prototype.querySelectorAll = function (selector) {
						var tags = selector.split(" ");
						if (tags.length == 1) return this.getElementsByTagName(selector);

						var current_element = this;
						var result = [];

						inner(this, tags);

						function inner(root, tags) {
							if (!tags) return;

							var current = tags.shift();
							var elements = root.getElementsByTagName(current);
							if (tags.length == 0) {
								for (var i = 0; i < elements.length; i++) {
									result.push(elements.item(i));
								}return;
							}

							for (var i = 0; i < elements.length; i++) {
								inner(elements.item(i), tags.concat());
							}
						}

						var list = new DOMNodeList(this.documentElement);
						list._nodes = result;
						list.length = result.length;

						return list;
					};

					Object.defineProperty(DOMElement.prototype, "textContent", {
						get: function get() {
							var nodes = this.getChildNodes();
							return nodes.item(0).toString();
						},
						set: function set() {}
					});
				}
			}
		this._xmlroot = root;
		var xmlcollada = root.querySelector("COLLADA");
		if (xmlcollada) {
			this._current_DAE_version = xmlcollada.getAttribute("version");
			console.log("DAE Version:" + this._current_DAE_version);
		}

		//var xmlvisual_scene = root.querySelector("visual_scene");
		var xmlvisual_scene = root.getElementsByTagName("visual_scene").item(0);
		if (!xmlvisual_scene) throw "visual_scene XML node not found in DAE";

		//hack to avoid problems with bones with spaces in names
		this._nodes_by_id = {}; //clear
		this._controllers_found = {}; //we need to check what controllers had been found, in case we miss one at the end
		this._geometries_found = {};

		//Create a scene tree
		var scene = {
			object_type: "SceneTree",
			light: null,
			materials: {},
			meshes: {},
			resources: {}, //used to store animation tracks
			root: { children: [] },
			external_files: {} //store info about external files mentioned in this 
		};

		//scene metadata (like author, tool, up vector, dates, etc)
		var xmlasset = root.getElementsByTagName("asset")[0];
		if (xmlasset) scene.metadata = this.readAsset(xmlasset);

		//parse nodes tree to extract names and ierarchy only
		var xmlnodes = xmlvisual_scene.childNodes;
		for (var i = 0; i < xmlnodes.length; i++) {
			if (xmlnodes.item(i).localName != "node") continue;

			var node = this.readNodeTree(xmlnodes.item(i), scene, 0, flip);
			if (node) scene.root.children.push(node);
		}

		//parse nodes content (two steps so we have first all the scene tree info)
		for (var i = 0; i < xmlnodes.length; i++) {
			if (xmlnodes.item(i).localName != "node") continue;
			this.readNodeInfo(xmlnodes.item(i), scene, 0, flip);
		}

		//read remaining controllers (in some cases some controllers are not linked from the nodes or the geometries)
		this.readLibraryControllers(scene);

		//read animations
		var animations = this.readAnimations(root, scene);
		if (animations) {
			var animations_name = "#animations_" + filename.substr(0, filename.indexOf("."));
			scene.resources[animations_name] = animations;
			scene.root.animations = animations_name;
		}

		//read external files (images)
		scene.images = this.readImages(root);

		//clear memory
		this._nodes_by_id = {};
		this._controllers_found = {};
		this._geometries_found = {};
		this._xmlroot = null;

		//console.log(scene);
		return scene;
	},

	/* Collect node ids, in case there is bones (with spaces in name) I need to know the nodenames in advance */
	/*
 readAllNodeNames: function(xmlnode)
 {
 	var node_id = this.safeString( xmlnode.getAttribute("id") );
 	if(node_id)
 		this._nodes_by_id[node_id] = true; //node found
 	//nodes seem to have to possible ids, id and sid, I guess one is unique, the other user-defined
 	var node_sid = this.safeString( xmlnode.getAttribute("sid") );
 	if(node_sid)
 		this._nodes_by_id[node_sid] = true; //node found
 
 	for( var i = 0; i < xmlnode.childNodes.length; i++ )
 	{
 		var xmlchild = xmlnode.childNodes.item(i);
 			//children
 		if(xmlchild.localName != "node")
 			continue;
 		this.readAllNodeNames(xmlchild);
 	}
 },
 	*/

	readAsset: function readAsset(xmlasset) {
		var metadata = {};

		for (var i = 0; i < xmlasset.childNodes.length; i++) {
			var xmlchild = xmlasset.childNodes.item(i);
			if (xmlchild.nodeType != 1) //not tag
				continue;
			switch (xmlchild.localName) {
				case "contributor":
					var tool = xmlchild.querySelector("authoring_tool");
					if (tool) metadata["authoring_tool"] = tool.textContext;
					break;
				case "unit":
					metadata["unit"] = xmlchild.getAttribute("name");break;
				default:
					metadata[xmlchild.localName] = xmlchild.textContent;break;
			}
		}

		return metadata;
	},

	readNodeTree: function readNodeTree(xmlnode, scene, level, flip) {
		var node_id = this.safeString(xmlnode.getAttribute("id"));
		var node_sid = this.safeString(xmlnode.getAttribute("sid"));

		if (!node_id && !node_sid) return null;

		//here we create the node
		var node = {
			id: node_sid || node_id,
			children: [],
			_depth: level
		};

		var node_type = xmlnode.getAttribute("type");
		if (node_type) node.type = node_type;

		var node_name = xmlnode.getAttribute("name");
		if (node_name) node.name = node_name;
		this._nodes_by_id[node.id] = node;
		if (node_id) this._nodes_by_id[node_id] = node;
		if (node_sid) this._nodes_by_id[node_sid] = node;

		//transform
		node.model = this.readTransform(xmlnode, level, flip);

		//node elements
		for (var i = 0; i < xmlnode.childNodes.length; i++) {
			var xmlchild = xmlnode.childNodes.item(i);
			if (xmlchild.nodeType != 1) //not tag
				continue;

			//children
			if (xmlchild.localName == "node") {
				var child_node = this.readNodeTree(xmlchild, scene, level + 1, flip);
				if (child_node) node.children.push(child_node);
				continue;
			}
		}

		return node;
	},

	readNodeInfo: function readNodeInfo(xmlnode, scene, level, flip, parent) {
		var node_id = this.safeString(xmlnode.getAttribute("id"));
		var node_sid = this.safeString(xmlnode.getAttribute("sid"));

		/*
  if(!node_id && !node_sid)
  {
  	console.warn("Collada: node without id, creating a random one");
  	node_id = this.generateName("node_");
  	return null;
  }
  */

		var node;
		if (!node_id && !node_sid) {
			//if there is no id, then either all of this node's properties 
			//should be assigned directly to its parent node, or the node doesn't
			//have a parent node, in which case its a light or something. 
			//So we get the parent by its id, and if there is no parent, we return null
			if (parent) node = this._nodes_by_id[parent.id || parent.sid];else return null;
		} else node = this._nodes_by_id[node_id || node_sid];

		if (!node) {
			console.warn("Collada: Node not found by id: " + (node_id || node_sid));
			return null;
		}

		//node elements
		for (var i = 0; i < xmlnode.childNodes.length; i++) {
			var xmlchild = xmlnode.childNodes.item(i);
			if (xmlchild.nodeType != 1) //not tag
				continue;

			//children
			if (xmlchild.localName == "node") {
				//pass parent node in case child node is a 'dead' node (has no id or sid)
				this.readNodeInfo(xmlchild, scene, level + 1, flip, xmlnode);
				continue;
			}

			//geometry
			if (xmlchild.localName == "instance_geometry") {
				var url = xmlchild.getAttribute("url");
				var mesh_id = url.toString().substr(1);
				node.mesh = mesh_id;

				if (!scene.meshes[url]) {
					var mesh_data = this.readGeometry(url, flip);
					if (mesh_data) {
						mesh_data.name = mesh_id;
						scene.meshes[mesh_id] = mesh_data;
					}
				}

				//binded material
				var xmlmaterials = xmlchild.querySelectorAll("instance_material");
				if (xmlmaterials) {
					for (var iMat = 0; iMat < xmlmaterials.length; ++iMat) {
						var xmlmaterial = xmlmaterials.item(iMat);
						if (!xmlmaterial) {
							console.warn("instance_material not found: " + i);
							continue;
						}

						var matname = xmlmaterial.getAttribute("target").toString().substr(1);
						//matname = matname.replace(/ /g,"_"); //names cannot have spaces
						if (!scene.materials[matname]) {

							var material = this.readMaterial(matname);
							if (material) {
								material.id = matname;
								scene.materials[material.id] = material;
							}
						}
						if (iMat == 0) node.material = matname;else {
							if (!node.materials) node.materials = [];
							node.materials.push(matname);
						}
					}
				}
			}

			//this node has a controller: skinning, morph targets or even multimaterial are controllers
			//warning: I detected that some nodes could have a controller but they are not referenced here.  ??
			if (xmlchild.localName == "instance_controller") {
				var url = xmlchild.getAttribute("url");
				var xmlcontroller = this._xmlroot.querySelector("controller" + url);

				if (xmlcontroller) {

					var mesh_data = this.readController(xmlcontroller, flip, scene);

					//binded materials
					var xmlbind_material = xmlchild.querySelector("bind_material");
					if (xmlbind_material) {
						//removed readBindMaterials up here for consistency
						var xmltechniques = xmlbind_material.querySelectorAll("technique_common");
						for (var iTec = 0; iTec < xmltechniques.length; iTec++) {
							var xmltechnique = xmltechniques.item(iTec);
							var xmlinstance_materials = xmltechnique.querySelectorAll("instance_material");
							for (var iMat = 0; iMat < xmlinstance_materials.length; iMat++) {
								var xmlinstance_material = xmlinstance_materials.item(iMat);
								if (!xmlinstance_material) {
									console.warn("instance_material for controller not found: " + xmlinstance_material);
									continue;
								}
								var matname = xmlinstance_material.getAttribute("target").toString().substr(1);
								if (!scene.materials[matname]) {

									var material = this.readMaterial(matname);
									if (material) {
										material.id = matname;
										scene.materials[material.id] = material;
									}
								}
								if (iMat == 0) node.material = matname;else {
									if (!node.materials) node.materials = [];
									node.materials.push(matname);
								}
							}
						}
					}

					if (mesh_data) {
						var mesh = mesh_data;
						if (mesh_data.type == "morph") {
							mesh = mesh_data.mesh;
							node.morph_targets = mesh_data.morph_targets;
						}

						mesh.name = url.toString();
						node.mesh = url.toString();
						scene.meshes[url] = mesh;
					}
				}
			}

			//light
			if (xmlchild.localName == "instance_light") {
				var url = xmlchild.getAttribute("url");
				this.readLight(node, url);
			}

			//camera
			if (xmlchild.localName == "instance_camera") {
				var url = xmlchild.getAttribute("url");
				this.readCamera(node, url);
			}

			//other possible tags?
		}
	},

	//if you want to rename some material names
	material_translate_table: {
		/*
  transparency: "opacity",
  reflectivity: "reflection_factor",
  specular: "specular_factor",
  shininess: "specular_gloss",
  emission: "emissive",
  diffuse: "color"
  */
	},

	light_translate_table: {

		point: "omni",
		directional: "directional",
		spot: "spot"
	},

	camera_translate_table: {
		xfov: "fov",
		aspect_ratio: "aspect",
		znear: "near",
		zfar: "far"
	},

	//used when id have spaces (regular selector do not support spaces)
	querySelectorAndId: function querySelectorAndId(root, selector, id) {
		var nodes = root.querySelectorAll(selector);
		for (var i = 0; i < nodes.length; i++) {
			var attr_id = nodes.item(i).getAttribute("id");
			if (!attr_id) continue;
			attr_id = attr_id.toString();
			if (attr_id == id) return nodes.item(i);
		}
		return null;
	},

	//returns the first element that matches a tag name, if not tagname is specified then the first tag element
	getFirstChildElement: function getFirstChildElement(root, localName) {
		var c = root.childNodes;
		for (var i = 0; i < c.length; ++i) {
			var item = c.item(i);
			if (item.localName && !localName || localName && localName == item.localName) return item;
		}
		return null;
	},

	readMaterial: function readMaterial(url) {
		var xmlmaterial = this.querySelectorAndId(this._xmlroot, "library_materials material", url);

		if (!xmlmaterial) return null;

		//get effect name
		var xmleffect = xmlmaterial.querySelector("instance_effect");
		if (!xmleffect) return null;

		var effect_url = xmleffect.getAttribute("url").substr(1);

		//get effect
		var xmleffects = this.querySelectorAndId(this._xmlroot, "library_effects effect", effect_url);

		if (!xmleffects) return null;

		//get common
		var xmltechnique = xmleffects.querySelector("technique");
		if (!xmltechnique) return null;

		//get newparams and convert to js object
		var xmlnewparams = xmleffects.querySelectorAll("newparam");
		var newparams = {};
		for (var i = 0; i < xmlnewparams.length; i++) {

			var init_from = xmlnewparams[i].querySelector("init_from");
			var parent;
			if (init_from) parent = init_from.innerHTML;else {
				var source = xmlnewparams[i].querySelector("source");
				parent = source.innerHTML;
			}

			newparams[xmlnewparams[i].getAttribute("sid")] = {
				parent: parent
			};
		}

		var material = {};

		//read the images here because we need to access them to assign texture names
		var images = this.readImages(this._xmlroot);

		var xmlphong = xmltechnique.querySelector("phong");
		if (!xmlphong) xmlphong = xmltechnique.querySelector("blinn");
		if (!xmlphong) xmlphong = xmltechnique.querySelector("lambert");
		if (!xmlphong) return null;

		//for every tag of properties
		for (var i = 0; i < xmlphong.childNodes.length; ++i) {
			var xmlparam = xmlphong.childNodes.item(i);

			if (!xmlparam.localName) //text tag
				continue;

			//translate name
			var param_name = xmlparam.localName.toString();
			if (this.material_translate_table[param_name]) param_name = this.material_translate_table[param_name];

			//value
			var xmlparam_value = this.getFirstChildElement(xmlparam);
			if (!xmlparam_value) continue;

			if (xmlparam_value.localName.toString() == "color") {
				var value = this.readContentAsFloats(xmlparam_value);
				if (xmlparam.getAttribute("opaque") == "RGB_ZERO") material[param_name] = value.subarray(0, 4);else material[param_name] = value.subarray(0, 3);
				continue;
			} else if (xmlparam_value.localName.toString() == "float") {
				material[param_name] = this.readContentAsFloats(xmlparam_value)[0];
				continue;
			} else if (xmlparam_value.localName.toString() == "texture") {
				if (!material.textures) material.textures = {};
				var map_id = xmlparam_value.getAttribute("texture");
				if (!map_id) continue;

				// if map_id is not a filename, lets go and look for it.
				if (map_id.indexOf('.') === -1) {
					//check effect parents
					map_id = this.getParentParam(newparams, map_id);

					if (images[map_id]) map_id = images[map_id].path;
				}

				//now get the texture filename from images

				var map_info = { map_id: map_id };
				var uvs = xmlparam_value.getAttribute("texcoord");
				map_info.uvs = uvs;
				material.textures[param_name] = map_info;
			}
		}

		material.object_type = "Material";
		return material;
	},

	getParentParam: function getParentParam(newparams, param) {
		if (!newparams[param]) return param;

		if (newparams[param].parent) return this.getParentParam(newparams, newparams[param].parent);else return param;
	},

	readLight: function readLight(node, url) {
		var light = {};

		var xmlnode = null;

		if (url.length > 1) //weird cases with id == #
			xmlnode = this._xmlroot.querySelector("library_lights " + url);else {
			var xmlliblights = this._xmlroot.querySelector("library_lights");
			xmlnode = this.getFirstChildElement(xmlliblights, "light");
		}

		if (!xmlnode) return null;

		//pack
		var children = [];
		var xml = xmlnode.querySelector("technique_common");
		if (xml) for (var i = 0; i < xml.childNodes.length; i++) {
			if (xml.childNodes.item(i).nodeType == 1) //tag
				children.push(xml.childNodes.item(i));
		}var xmls = xmlnode.querySelectorAll("technique");
		for (var i = 0; i < xmls.length; i++) {
			var xml2 = xmls.item(i);
			for (var j = 0; j < xml2.childNodes.length; j++) {
				if (xml2.childNodes.item(j).nodeType == 1) //tag
					children.push(xml2.childNodes.item(j));
			}
		}

		//get
		for (var i = 0; i < children.length; i++) {
			var xml = children[i];
			switch (xml.localName) {
				case "point":
					light.type = this.light_translate_table[xml.localName];
					parse_params(light, xml);
					break;
				case "directional":
					light.type = this.light_translate_table[xml.localName];
					parse_params(light, xml);
					break;
				case "spot":
					light.type = this.light_translate_table[xml.localName];
					parse_params(light, xml);
					break;

				case "intensity":
					light.intensity = this.readContentAsFloats(xml)[0];
					break;
			}
		}

		function parse_params(light, xml) {
			for (var i = 0; i < xml.childNodes.length; i++) {
				var child = xml.childNodes.item(i);
				if (!child || child.nodeType != 1) //tag
					continue;

				switch (child.localName) {
					case "color":
						light.color = Collada.readContentAsFloats(child);break;
					case "falloff_angle":
						light.angle_end = Collada.readContentAsFloats(child)[0];
						light.angle = light.angle_end - 10;
						break;
				}
			}
		}

		if (node.model) {
			//light position is final column of model
			light.position = [node.model[12], node.model[13], node.model[14]];
			//light forward vector is reverse of third column of model
			var forward = [-node.model[8], -node.model[9], -node.model[10]];
			//so light target is position + forward
			light.target = [light.position[0] + forward[0], light.position[1] + forward[1], light.position[2] + forward[2]];
		} else {
			console.warn("Could not read light position for light: " + node.name + ". Setting defaults.");
			light.position = [0, 0, 0];
			light.target = [0, -1, 0];
		}

		node.light = light;
	},

	readCamera: function readCamera(node, url) {
		var camera = {};

		var xmlnode = this._xmlroot.querySelector("library_cameras " + url);
		if (!xmlnode) return null;

		//pack
		var children = [];
		var xml = xmlnode.querySelector("technique_common");
		if (xml) //grab all internal stuff
			for (var i = 0; i < xml.childNodes.length; i++) {
				if (xml.childNodes.item(i).nodeType == 1) //tag
					children.push(xml.childNodes.item(i));
			} //
		for (var i = 0; i < children.length; i++) {
			var tag = children[i];
			parse_params(camera, tag);
		}

		function parse_params(camera, xml) {
			for (var i = 0; i < xml.childNodes.length; i++) {
				var child = xml.childNodes.item(i);
				if (!child || child.nodeType != 1) //tag
					continue;
				var translated = Collada.camera_translate_table[child.localName] || child.localName;
				camera[translated] = parseFloat(child.textContent);
			}
		}

		//parse to convert yfov to standard (x) fov
		if (camera.yfov && !camera.fov) {
			if (camera.aspect) {
				camera.fov = camera.yfov * camera.aspect;
			} else console.warn("Could not convert camera yfov to xfov because aspect ratio not set");
		}

		node.camera = camera;
	},

	readTransform: function readTransform(xmlnode, level, flip) {
		//identity
		var matrix = _glMatrix.mat4.create();
		var temp = _glMatrix.mat4.create();
		var tmpq = _glMatrix.quat.create();

		var flip_fix = false;

		//search for the matrix
		for (var i = 0; i < xmlnode.childNodes.length; i++) {
			var xml = xmlnode.childNodes.item(i);
			if (!xml || xml.nodeType != 1) //tag
				continue;

			if (xml.localName == "matrix") {
				var matrix = this.readContentAsFloats(xml);
				//console.log("Nodename: " + xmlnode.getAttribute("id"));
				//console.log(matrix);
				this.transformMatrix(matrix, level == 0);
				//console.log(matrix);
				return matrix;
			}

			if (xml.localName == "translate") {
				var values = this.readContentAsFloats(xml);
				if (flip && level > 0) {
					var tmp = values[1];
					values[1] = values[2];
					values[2] = -tmp; //swap coords
				}

				_glMatrix.mat4.translate(matrix, matrix, values);
				continue;
			}

			//rotate
			if (xml.localName == "rotate") {
				var values = this.readContentAsFloats(xml);
				if (values.length == 4) //x,y,z, angle
					{
						var id = xml.getAttribute("sid");
						if (id == "jointOrientX") {
							values[3] += 90;
							flip_fix = true;
						}
						//rotateX & rotateY & rotateZ done below

						if (flip) {
							var tmp = values[1];
							values[1] = values[2];
							values[2] = -tmp; //swap coords
						}

						if (values[3] != 0.0) {
							_glMatrix.quat.setAxisAngle(tmpq, values.subarray(0, 3), values[3] * DEG2RAD);
							_glMatrix.mat4.fromQuat(temp, tmpq);
							_glMatrix.mat4.multiply(matrix, matrix, temp);
						}
					}
				continue;
			}

			//scale
			if (xml.localName == "scale") {
				var values = this.readContentAsFloats(xml);
				if (flip) {
					var tmp = values[1];
					values[1] = values[2];
					values[2] = -tmp; //swap coords
				}
				_glMatrix.mat4.scale(matrix, matrix, values);
			}
		}

		return matrix;
	},

	readTransform2: function readTransform2(xmlnode, level, flip) {
		//identity
		var matrix = _glMatrix.mat4.create();
		var rotation = _glMatrix.quat.create();
		var tmpmatrix = _glMatrix.mat4.create();
		var tmpq = _glMatrix.quat.create();
		var translate = vec3.create();
		var scale = vec3.fromValues(1, 1, 1);

		var flip_fix = false;

		//search for the matrix
		for (var i = 0; i < xmlnode.childNodes.length; i++) {
			var xml = xmlnode.childNodes.item(i);

			if (xml.localName == "matrix") {
				var matrix = this.readContentAsFloats(xml);
				//console.log("Nodename: " + xmlnode.getAttribute("id"));
				//console.log(matrix);
				this.transformMatrix(matrix, level == 0);
				//console.log(matrix);
				return matrix;
			}

			if (xml.localName == "translate") {
				var values = this.readContentAsFloats(xml);
				translate.set(values);
				continue;
			}

			//rotate
			if (xml.localName == "rotate") {
				var values = this.readContentAsFloats(xml);
				if (values.length == 4) //x,y,z, angle
					{
						var id = xml.getAttribute("sid");
						if (id == "jointOrientX") {
							values[3] += 90;
							flip_fix = true;
						}
						//rotateX & rotateY & rotateZ done below

						if (flip) {
							var tmp = values[1];
							values[1] = values[2];
							values[2] = -tmp; //swap coords
						}

						if (values[3] != 0.0) {
							_glMatrix.quat.setAxisAngle(tmpq, values.subarray(0, 3), values[3] * DEG2RAD);
							_glMatrix.quat.multiply(rotation, rotation, tmpq);
						}
					}
				continue;
			}

			//scale
			if (xml.localName == "scale") {
				var values = this.readContentAsFloats(xml);
				if (flip) {
					var tmp = values[1];
					values[1] = values[2];
					values[2] = -tmp; //swap coords
				}
				scale.set(values);
			}
		}

		if (flip && level > 0) {
			var tmp = translate[1];
			translate[1] = translate[2];
			translate[2] = -tmp; //swap coords
		}
		_glMatrix.mat4.translate(matrix, matrix, translate);

		_glMatrix.mat4.fromQuat(tmpmatrix, rotation);
		//mat4.rotateX(tmpmatrix, tmpmatrix, Math.PI * 0.5);
		_glMatrix.mat4.multiply(matrix, matrix, tmpmatrix);
		_glMatrix.mat4.scale(matrix, matrix, scale);

		return matrix;
	},

	//for help read this: https://www.khronos.org/collada/wiki/Using_accessors
	readGeometry: function readGeometry(id, flip, scene) {
		//already read, could happend if several controllers point to the same mesh
		if (this._geometries_found[id] !== undefined) return this._geometries_found[id];

		//var xmlgeometry = this._xmlroot.querySelector("geometry" + id);
		var xmlgeometry = this._xmlroot.getElementById(id.substr(1));
		if (!xmlgeometry) {
			console.warn("readGeometry: geometry not found: " + id);
			this._geometries_found[id] = null;
			return null;
		}

		//if the geometry has morph targets then instead of storing it in a geometry, it is in a controller
		if (xmlgeometry.localName == "controller") {
			var geometry = this.readController(xmlgeometry, flip, scene);
			this._geometries_found[id] = geometry;
			return geometry;
		}

		if (xmlgeometry.localName != "geometry") {
			console.warn("readGeometry: tag should be geometry, instead it was found: " + xmlgeometry.localName);
			this._geometries_found[id] = null;
			return null;
		}

		var xmlmesh = xmlgeometry.querySelector("mesh");
		if (!xmlmesh) {
			console.warn("readGeometry: mesh not found in geometry: " + id);
			this._geometries_found[id] = null;
			return null;
		}

		//get data sources
		var sources = {};
		var xmlsources = xmlmesh.querySelectorAll("source");
		for (var i = 0; i < xmlsources.length; i++) {
			var xmlsource = xmlsources.item(i);
			if (!xmlsource.querySelector) continue;
			var float_array = xmlsource.querySelector("float_array");
			if (!float_array) continue;
			var floats = this.readContentAsFloats(float_array);

			var xmlaccessor = xmlsource.querySelector("accessor");
			var stride = parseInt(xmlaccessor.getAttribute("stride"));

			sources[xmlsource.getAttribute("id")] = { stride: stride, data: floats };
		}

		//get streams
		var xmlvertices = xmlmesh.querySelector("vertices input");
		var vertices_source = sources[xmlvertices.getAttribute("source").substr(1)];
		sources[xmlmesh.querySelector("vertices").getAttribute("id")] = vertices_source;

		var mesh = null;
		var xmlpolygons = xmlmesh.querySelector("polygons");
		if (xmlpolygons) mesh = this.readTriangles(xmlpolygons, sources);

		if (!mesh) {
			var xmltriangles = xmlmesh.querySelectorAll("triangles");
			if (xmltriangles && xmltriangles.length) mesh = this.readTriangles(xmltriangles, sources);
		}

		if (!mesh) {
			//polylist = true;
			//var vcount = null;
			//var xmlvcount = xmlpolygons.querySelector("vcount");
			//var vcount = this.readContentAsUInt32( xmlvcount );
			var xmlpolylist = xmlmesh.querySelector("polylist");
			if (xmlpolylist) mesh = this.readPolylist(xmlpolylist, sources);
		}

		if (!mesh) {
			var xmllinestrip = xmlmesh.querySelector("linestrips");
			if (xmllinestrip) mesh = this.readLineStrip(sources, xmllinestrip);
		}

		if (!mesh) {
			console.log("no polygons or triangles in mesh: " + id);
			this._geometries_found[id] = null;
			return null;
		}

		//swap coords (X,Y,Z) -> (X,Z,-Y)
		if (flip && !this.no_flip) {
			var tmp = 0;
			var array = mesh.vertices;
			for (var i = 0, l = array.length; i < l; i += 3) {
				tmp = array[i + 1];
				array[i + 1] = array[i + 2];
				array[i + 2] = -tmp;
			}

			array = mesh.normals;
			for (var i = 0, l = array.length; i < l; i += 3) {
				tmp = array[i + 1];
				array[i + 1] = array[i + 2];
				array[i + 2] = -tmp;
			}
		}

		//transferables for worker
		if (isWorker && this.use_transferables) {
			for (var i in mesh) {
				var data = mesh[i];
				if (data && data.buffer && data.length > 100) {
					this._transferables.push(data.buffer);
				}
			}
		}

		//extra info
		mesh.filename = id;
		mesh.object_type = "Mesh";

		this._geometries_found[id] = mesh;
		return mesh;
	},

	readTriangles: function readTriangles(xmltriangles, sources) {
		var use_indices = false;

		var groups = [];
		var buffers = [];
		var last_index = 0;
		var facemap = {};
		var vertex_remap = []; //maps DAE vertex index to Mesh vertex index (because when meshes are triangulated indices are changed
		var indicesArray = [];
		var last_start = 0;
		var group_name = "";
		var material_name = "";

		//for every triangles set (warning, some times they are repeated...)
		for (var tris = 0; tris < xmltriangles.length; tris++) {
			var xml_shape_root = xmltriangles.item(tris);
			var triangles = xml_shape_root.localName == "triangles";

			material_name = xml_shape_root.getAttribute("material");

			//for each buffer (input) build the structure info
			if (tris == 0) buffers = this.readShapeInputs(xml_shape_root, sources);

			//assuming buffers are ordered by offset

			//iterate data
			var xmlps = xml_shape_root.querySelectorAll("p");
			var num_data_vertex = buffers.length; //one value per input buffer

			//for every polygon (could be one with all the indices, could be several, depends on the program)
			for (var i = 0; i < xmlps.length; i++) {
				var xmlp = xmlps.item(i);
				if (!xmlp || !xmlp.textContent) break;

				var data = xmlp.textContent.trim().split(" ");

				//used for triangulate polys
				var first_index = -1;
				var current_index = -1;
				var prev_index = -1;

				//discomment to force 16bits indices
				//if(use_indices && last_index >= 256*256)
				//	break;

				var num_values_per_vertex = 1;
				for (var b in buffers) {
					num_values_per_vertex = Math.max(num_values_per_vertex, buffers[b][4] + 1);
				} //for every pack of indices in the polygon (vertex, normal, uv, ... )
				var current_data_pos = 0;
				for (var k = 0, l = data.length; k < l; k += num_values_per_vertex) {
					var vertex_id = data.slice(k, k + num_values_per_vertex).join(" "); //generate unique id

					prev_index = current_index;
					if (facemap.hasOwnProperty(vertex_id)) //add to arrays, keep the index
						current_index = facemap[vertex_id];else {
						//for every data buffer associated to this vertex
						for (var j = 0; j < buffers.length; ++j) {
							var buffer = buffers[j];
							var array = buffer[1]; //array where we accumulate the final data as we extract if from sources
							var source = buffer[3]; //where to read the data from

							//compute the index inside the data source array
							//var index = parseInt(data[k + j]);
							var index = parseInt(data[k + buffer[4]]);
							//current_data_pos += buffer[4];

							//remember this index in case we need to remap
							if (j == 0) vertex_remap[array.length / buffer[2]] = index; //not sure if buffer[2], it should be number of floats per vertex (usually 3)
							//vertex_remap[ array.length / num_data_vertex ] = index;

							//compute the position inside the source buffer where the final data is located
							index *= buffer[2]; //this works in most DAEs (not all)
							//index = index * buffer[2] + buffer[4]; //stride(2) offset(4)
							//index += buffer[4]; //stride(2) offset(4)
							//extract every value of this element and store it in its final array (every x,y,z, etc)
							for (var x = 0; x < buffer[2]; ++x) {
								if (source[index + x] === undefined) throw "UNDEFINED!"; //DEBUG
								array.push(source[index + x]);
							}
						}

						current_index = last_index;
						last_index += 1;
						facemap[vertex_id] = current_index;
					}

					if (!triangles) //the xml element is not triangles? then split polygons in triangles
						{
							if (k == 0) first_index = current_index;
							//if(k > 2 * num_data_vertex) //not sure if use this or the next line, the next one works in some DAEs but not sure if it works in all
							if (k > 2) //triangulate polygons: ensure this works
								{
									indicesArray.push(first_index);
									indicesArray.push(prev_index);
								}
						}

					indicesArray.push(current_index);
				} //per vertex
			} //per polygon

			var group = {
				name: group_name || "group" + tris,
				start: last_start,
				length: indicesArray.length - last_start,
				material: material_name || ""
			};
			last_start = indicesArray.length;
			groups.push(group);
		} //per triangles group

		var mesh = {
			vertices: new Float32Array(buffers[0][1]),
			info: { groups: groups },
			_remap: new Uint32Array(vertex_remap)
		};

		this.transformMeshInfo(mesh, buffers, indicesArray);

		return mesh;
	},

	readPolylist: function readPolylist(xml_shape_root, sources) {
		var use_indices = false;

		var groups = [];
		var buffers = [];
		var last_index = 0;
		var facemap = {};
		var vertex_remap = [];
		var indicesArray = [];
		var last_start = 0;
		var group_name = "";
		var material_name = "";

		material_name = xml_shape_root.getAttribute("material");
		buffers = this.readShapeInputs(xml_shape_root, sources);

		var xmlvcount = xml_shape_root.querySelector("vcount");
		var vcount = this.readContentAsUInt32(xmlvcount);

		var xmlp = xml_shape_root.querySelector("p");
		var data = this.readContentAsUInt32(xmlp);

		var num_data_vertex = buffers.length;

		var pos = 0;
		for (var i = 0, l = vcount.length; i < l; ++i) {
			var num_vertices = vcount[i];

			var first_index = -1;
			var current_index = -1;
			var prev_index = -1;

			//iterate vertices of this polygon
			for (var k = 0; k < num_vertices; ++k) {
				var vertex_id = data.subarray(pos, pos + num_data_vertex).join(" ");

				prev_index = current_index;
				if (facemap.hasOwnProperty(vertex_id)) //add to arrays, keep the index
					current_index = facemap[vertex_id];else {
					for (var j = 0; j < buffers.length; ++j) {
						var buffer = buffers[j];
						var index = parseInt(data[pos + j]); //p
						var array = buffer[1]; //array with all the data
						var source = buffer[3]; //where to read the data from
						if (j == 0) vertex_remap[array.length / num_data_vertex] = index;
						index *= buffer[2]; //stride
						for (var x = 0; x < buffer[2]; ++x) {
							array.push(source[index + x]);
						}
					}

					current_index = last_index;
					last_index += 1;
					facemap[vertex_id] = current_index;
				}

				if (num_vertices > 3) //split polygons then
					{
						if (k == 0) first_index = current_index;
						//if(k > 2 * num_data_vertex) //not sure if use this or the next line, the next one works in some DAEs but not sure if it works in all
						if (k > 2) //triangulate polygons: tested, this works
							{
								indicesArray.push(first_index);
								indicesArray.push(prev_index);
							}
					}

				indicesArray.push(current_index);
				pos += num_data_vertex;
			} //per vertex
		} //per polygon

		var mesh = {
			vertices: new Float32Array(buffers[0][1]),
			info: {},
			_remap: new Uint32Array(vertex_remap)
		};

		this.transformMeshInfo(mesh, buffers, indicesArray);

		return mesh;
	},

	readShapeInputs: function readShapeInputs(xml_shape_root, sources) {
		var buffers = [];

		var xmlinputs = xml_shape_root.querySelectorAll("input");
		for (var i = 0; i < xmlinputs.length; i++) {
			var xmlinput = xmlinputs.item(i);
			if (!xmlinput.getAttribute) continue;
			var semantic = xmlinput.getAttribute("semantic").toUpperCase();
			var stream_source = sources[xmlinput.getAttribute("source").substr(1)];
			var offset = parseInt(xmlinput.getAttribute("offset"));
			var data_set = 0;
			if (xmlinput.getAttribute("set")) data_set = parseInt(xmlinput.getAttribute("set"));
			buffers.push([semantic, [], stream_source.stride, stream_source.data, offset, data_set]);
		}

		return buffers;
	},

	transformMeshInfo: function transformMeshInfo(mesh, buffers, indicesArray) {
		//rename buffers (DAE has other names)
		var translator = {
			"normal": "normals",
			"texcoord": "coords"
		};
		for (var i = 1; i < buffers.length; ++i) {
			var name = buffers[i][0].toLowerCase();
			var data = buffers[i][1];
			if (!data.length) continue;

			if (translator[name]) name = translator[name];
			if (mesh[name]) name = name + buffers[i][5];
			mesh[name] = new Float32Array(data); //are they always float32? I think so
		}

		if (indicesArray && indicesArray.length) {
			if (mesh.vertices.length > 256 * 256) mesh.triangles = new Uint32Array(indicesArray);else mesh.triangles = new Uint16Array(indicesArray);
		}

		return mesh;
	},

	readLineStrip: function readLineStrip(sources, xmllinestrip) {
		var use_indices = false;

		var buffers = [];
		var last_index = 0;
		var facemap = {};
		var vertex_remap = [];
		var indicesArray = [];
		var last_start = 0;
		var group_name = "";
		var material_name = "";

		var tris = 0; //used in case there are several strips

		//for each buffer (input) build the structure info
		var xmlinputs = xmllinestrip.querySelectorAll("input");
		if (tris == 0) //first iteration, create buffers
			for (var i = 0; i < xmlinputs.length; i++) {
				var xmlinput = xmlinputs.item(i);
				if (!xmlinput.getAttribute) continue;
				var semantic = xmlinput.getAttribute("semantic").toUpperCase();
				var stream_source = sources[xmlinput.getAttribute("source").substr(1)];
				var offset = parseInt(xmlinput.getAttribute("offset"));
				var data_set = 0;
				if (xmlinput.getAttribute("set")) data_set = parseInt(xmlinput.getAttribute("set"));

				buffers.push([semantic, [], stream_source.stride, stream_source.data, offset, data_set]);
			}
		//assuming buffers are ordered by offset

		//iterate data
		var xmlps = xmllinestrip.querySelectorAll("p");
		var num_data_vertex = buffers.length; //one value per input buffer

		//for every polygon (could be one with all the indices, could be several, depends on the program)
		for (var i = 0; i < xmlps.length; i++) {
			var xmlp = xmlps.item(i);
			if (!xmlp || !xmlp.textContent) break;

			var data = xmlp.textContent.trim().split(" ");

			//used for triangulate polys
			var first_index = -1;
			var current_index = -1;
			var prev_index = -1;

			//if(use_indices && last_index >= 256*256)
			//	break;

			//for every pack of indices in the polygon (vertex, normal, uv, ... )
			for (var k = 0, l = data.length; k < l; k += num_data_vertex) {
				var vertex_id = data.slice(k, k + num_data_vertex).join(" "); //generate unique id

				prev_index = current_index;
				if (facemap.hasOwnProperty(vertex_id)) //add to arrays, keep the index
					current_index = facemap[vertex_id];else {
					for (var j = 0; j < buffers.length; ++j) {
						var buffer = buffers[j];
						var index = parseInt(data[k + j]);
						var array = buffer[1]; //array with all the data
						var source = buffer[3]; //where to read the data from
						if (j == 0) vertex_remap[array.length / num_data_vertex] = index;
						index *= buffer[2]; //stride
						for (var x = 0; x < buffer[2]; ++x) {
							array.push(source[index + x]);
						}
					}

					current_index = last_index;
					last_index += 1;
					facemap[vertex_id] = current_index;
				}

				indicesArray.push(current_index);
			} //per vertex
		} //per polygon

		var mesh = {
			primitive: "line_strip",
			vertices: new Float32Array(buffers[0][1]),
			info: {}
		};

		return this.transformMeshInfo(mesh, buffers, indicesArray);
	},

	//like querySelector but allows spaces in names because COLLADA allows space in names
	findXMLNodeById: function findXMLNodeById(root, nodename, id) {
		//precomputed
		if (this._xmlroot._nodes_by_id) {
			var n = this._xmlroot._nodes_by_id[id];
			if (n && n.localName == nodename) return n;
		} else //for the native parser
			{
				var n = this._xmlroot.getElementById(id);
				if (n) return n;
			}

		//recursive: slow
		var childs = root.childNodes;
		for (var i = 0; i < childs.length; ++i) {
			var xmlnode = childs.item(i);
			if (xmlnode.nodeType != 1) //no tag
				continue;
			if (xmlnode.localName != nodename) continue;
			var node_id = xmlnode.getAttribute("id");
			if (node_id == id) return xmlnode;
		}
		return null;
	},

	readImages: function readImages(root) {
		var xmlimages = root.querySelector("library_images");
		if (!xmlimages) return null;

		var images = {};

		var xmlimages_childs = xmlimages.childNodes;
		for (var i = 0; i < xmlimages_childs.length; ++i) {
			var xmlimage = xmlimages_childs.item(i);
			if (xmlimage.nodeType != 1) //no tag
				continue;

			var xmlinitfrom = xmlimage.querySelector("init_from");
			if (!xmlinitfrom) continue;
			if (xmlinitfrom.textContent) {
				var filename = this.getFilename(xmlinitfrom.textContent);
				var id = xmlimage.getAttribute("id");
				images[id] = { filename: filename, map: id, name: xmlimage.getAttribute("name"), path: xmlinitfrom.textContent };
			}
		}

		return images;
	},

	readAnimations: function readAnimations(root, scene) {
		var xmlanimations = root.querySelector("library_animations");
		if (!xmlanimations) return null;

		var xmlanimation_childs = xmlanimations.childNodes;

		var animations = {
			object_type: "Animation",
			takes: {}
		};

		var default_take = { tracks: [] };
		var tracks = default_take.tracks;

		for (var i = 0; i < xmlanimation_childs.length; ++i) {
			var xmlanimation = xmlanimation_childs.item(i);
			if (xmlanimation.nodeType != 1 || xmlanimation.localName != "animation") //no tag
				continue;

			var anim_id = xmlanimation.getAttribute("id");
			if (!anim_id) //nested animation (DAE 1.5)
				{
					var xmlanimation2_childs = xmlanimation.querySelectorAll("animation");
					if (xmlanimation2_childs.length) {
						for (var j = 0; j < xmlanimation2_childs.length; ++j) {
							var xmlanimation2 = xmlanimation2_childs.item(j);
							this.readAnimation(xmlanimation2, tracks);
						}
					} else //source tracks?
						this.readAnimation(xmlanimation, tracks);
				} else //no nested (DAE 1.4)
				this.readAnimation(xmlanimation, tracks);
		}

		if (!tracks.length) return null; //empty animation

		//compute animation duration
		var max_time = 0;
		for (var i = 0; i < tracks.length; ++i) {
			if (max_time < tracks[i].duration) max_time = tracks[i].duration;
		}default_take.name = "default";
		default_take.duration = max_time;
		animations.takes[default_take.name] = default_take;
		return animations;
	},

	//animation xml
	readAnimation: function readAnimation(xmlanimation, result) {
		if (xmlanimation.localName != "animation") return null;

		//this could be missing when there are lots of anims packed in one <animation>
		var anim_id = xmlanimation.getAttribute("id");

		//channels are like animated properties
		var xmlchannel_list = xmlanimation.querySelectorAll("channel");
		if (!xmlchannel_list.length) return null;

		var tracks = result || [];

		for (var i = 0; i < xmlchannel_list.length; ++i) {
			var anim = this.readChannel(xmlchannel_list.item(i), xmlanimation);
			if (anim) tracks.push(anim);
		}

		return tracks;
	},

	readChannel: function readChannel(xmlchannel, xmlanimation) {
		if (xmlchannel.localName != "channel" || xmlanimation.localName != "animation") return null;

		var source = xmlchannel.getAttribute("source");
		var target = xmlchannel.getAttribute("target");

		//sampler, is in charge of the interpolation
		//var xmlsampler = xmlanimation.querySelector("sampler" + source);
		var xmlsampler = this.findXMLNodeById(xmlanimation, "sampler", source.substr(1));
		if (!xmlsampler) {
			console.error("Error DAE: Sampler not found in " + source);
			return null;
		}

		var inputs = {};
		var params = {};
		var sources = {};
		var xmlinputs = xmlsampler.querySelectorAll("input");

		var time_data = null;

		//iterate inputs: collada separates the keyframe info in independent streams, like time, interpolation method, value )
		for (var j = 0; j < xmlinputs.length; j++) {
			var xmlinput = xmlinputs.item(j);
			var source_name = xmlinput.getAttribute("source");

			//there are three 
			var semantic = xmlinput.getAttribute("semantic");

			//Search for source
			var xmlsource = this.findXMLNodeById(xmlanimation, "source", source_name.substr(1));
			if (!xmlsource) continue;

			var xmlparam = xmlsource.querySelector("param");
			if (!xmlparam) continue;

			var type = xmlparam.getAttribute("type");
			inputs[semantic] = { source: source_name, type: type };

			var data_array = null;

			if (type == "float" || type == "float4x4") {
				var xmlfloatarray = xmlsource.querySelector("float_array");
				var floats = this.readContentAsFloats(xmlfloatarray);
				sources[source_name] = floats;
				data_array = floats;
			} else //only floats and matrices are supported in animation
				continue;

			var param_name = xmlparam.getAttribute("name");
			if (param_name == "TIME") time_data = data_array;
			if (semantic == "OUTPUT") param_name = semantic;
			if (param_name) params[param_name] = type;else console.warn("Collada: <param> without name attribute in <animation>");
		}

		if (!time_data) {
			console.error("Error DAE: no TIME info found in <channel>: " + xmlchannel.getAttribute("source"));
			return null;
		}

		//construct animation
		var path = target.split("/");

		var anim = {};
		var nodename = path[0]; //safeString ?
		var node = this._nodes_by_id[nodename];
		var locator = node.id + "/" + path[1];
		//anim.nodename = this.safeString( path[0] ); //where it goes
		anim.name = path[1];
		anim.property = locator;
		var type = "number";
		var element_size = 1;
		var param_type = params["OUTPUT"];
		switch (param_type) {
			case "float":
				element_size = 1;break;
			case "float3x3":
				element_size = 9;type = "mat3";break;
			case "float4x4":
				element_size = 16;type = "mat4";break;
			default:
				break;
		}

		anim.type = type;
		anim.value_size = element_size;
		anim.duration = time_data[time_data.length - 1]; //last sample

		var value_data = sources[inputs["OUTPUT"].source];
		if (!value_data) return null;

		//Pack data ****************
		var num_samples = time_data.length;
		var sample_size = element_size + 1;
		var anim_data = new Float32Array(num_samples * sample_size);
		//for every sample
		for (var j = 0; j < time_data.length; ++j) {
			anim_data[j * sample_size] = time_data[j]; //set time
			var value = value_data.subarray(j * element_size, (j + 1) * element_size);
			if (param_type == "float4x4") {
				this.transformMatrix(value, node ? node._depth == 0 : 0);
				//mat4.transpose(value, value);
			}
			anim_data.set(value, j * sample_size + 1); //set data
		}

		if (isWorker && this.use_transferables) {
			var data = anim_data;
			if (data && data.buffer && data.length > 100) this._transferables.push(data.buffer);
		}

		anim.data = anim_data;
		return anim;
	},

	findNode: function findNode(root, id) {
		if (root.id == id) return root;
		if (root.children) for (var i in root.children) {
			var ret = this.findNode(root.children[i], id);
			if (ret) return ret;
		}
		return null;
	},

	//reads controllers and stores them in 
	readLibraryControllers: function readLibraryControllers(scene) {
		var xmllibrarycontrollers = this._xmlroot.querySelector("library_controllers");
		if (!xmllibrarycontrollers) return null;

		var xmllibrarycontrollers_childs = xmllibrarycontrollers.childNodes;

		for (var i = 0; i < xmllibrarycontrollers_childs.length; ++i) {
			var xmlcontroller = xmllibrarycontrollers_childs.item(i);
			if (xmlcontroller.nodeType != 1 || xmlcontroller.localName != "controller") //no tag
				continue;
			var id = xmlcontroller.getAttribute("id");
			//we have already processed this controller
			if (this._controllers_found[id]) continue;

			//read it (we wont use the returns, we will get it from this._controllers_found
			this.readController(xmlcontroller, null, scene);
		}
	},

	//used for skinning and morphing
	readController: function readController(xmlcontroller, flip, scene) {
		if (!xmlcontroller.localName == "controller") {
			console.warn("readController: not a controller: " + xmlcontroller.localName);
			return null;
		}

		var id = xmlcontroller.getAttribute("id");
		//use cached
		if (this._controllers_found[id]) return this._controllers_found[id];

		//AGUILA
		//TODO: does this work?
		// if (this._controllers_found[ id ])
		// 	return this._controllers_found[ id ];

		var use_indices = false;
		var mesh = null;
		var xmlskin = xmlcontroller.querySelector("skin");
		if (xmlskin) {
			mesh = this.readSkinController(xmlskin, flip, scene);
		}

		var xmlmorph = xmlcontroller.querySelector("morph");
		if (xmlmorph) mesh = this.readMorphController(xmlmorph, flip, scene, mesh);

		//cache and return
		if (this._controllers_found[id]) {
			id += "_1blah"; //??? this doesnt do anything
		} else this._controllers_found[id] = mesh;

		return mesh;
	},

	//read this to more info about DAE and skinning https://collada.org/mediawiki/index.php/Skinning
	readSkinController: function readSkinController(xmlskin, flip, scene) {
		//base geometry
		var id_geometry = xmlskin.getAttribute("source");

		var mesh = this.readGeometry(id_geometry, flip, scene);
		if (!mesh) return null;

		var sources = this.readSources(xmlskin, flip);
		if (!sources) return null;

		//matrix
		var bind_matrix = null;
		var xmlbindmatrix = xmlskin.querySelector("bind_shape_matrix");
		if (xmlbindmatrix) {
			bind_matrix = this.readContentAsFloats(xmlbindmatrix);
			this.transformMatrix(bind_matrix, true, true);
		} else bind_matrix = _glMatrix.mat4.create(); //identity

		//joints
		var joints = [];
		var xmljoints = xmlskin.querySelector("joints");
		if (xmljoints) {
			var joints_source = null; //which bones
			var inv_bind_source = null; //bind matrices
			var xmlinputs = xmljoints.querySelectorAll("input");
			for (var i = 0; i < xmlinputs.length; i++) {
				var xmlinput = xmlinputs[i];
				var sem = xmlinput.getAttribute("semantic").toUpperCase();
				var src = xmlinput.getAttribute("source");
				var source = sources[src.substr(1)];
				if (sem == "JOINT") joints_source = source;else if (sem == "INV_BIND_MATRIX") inv_bind_source = source;
			}

			//save bone names and inv matrix
			if (!inv_bind_source || !joints_source) {
				console.error("Error DAE: no joints or inv_bind sources found");
				return null;
			}

			for (var i in joints_source) {
				//get the inverse of the bind pose
				var inv_mat = inv_bind_source.subarray(i * 16, i * 16 + 16);
				var nodename = joints_source[i];
				var node = this._nodes_by_id[nodename];
				if (!node) {
					console.warn("Node " + nodename + " not found");
					continue;
				}
				this.transformMatrix(inv_mat, node._depth == 0, true);
				joints.push([nodename, inv_mat]);
			}
		}

		//weights
		var xmlvertexweights = xmlskin.querySelector("vertex_weights");
		if (xmlvertexweights) {

			//here we see the order 
			var weights_indexed_array = null;
			var xmlinputs = xmlvertexweights.querySelectorAll("input");
			for (var i = 0; i < xmlinputs.length; i++) {
				if (xmlinputs[i].getAttribute("semantic").toUpperCase() == "WEIGHT") weights_indexed_array = sources[xmlinputs.item(i).getAttribute("source").substr(1)];
			}

			if (!weights_indexed_array) throw "no weights found";

			var xmlvcount = xmlvertexweights.querySelector("vcount");
			var vcount = this.readContentAsUInt32(xmlvcount);

			var xmlv = xmlvertexweights.querySelector("v");
			var v = this.readContentAsUInt32(xmlv);

			var num_vertices = mesh.vertices.length / 3; //3 components per vertex
			var weights_array = new Float32Array(4 * num_vertices); //4 bones per vertex
			var bone_index_array = new Uint8Array(4 * num_vertices); //4 bones per vertex

			var pos = 0;
			var remap = mesh._remap;
			var max_bone = 0; //max bone affected

			for (var i = 0, l = vcount.length; i < l; ++i) {
				var num_bones = vcount[i]; //num bones influencing this vertex

				//find 4 with more influence
				//var v_tuplets = v.subarray(offset, offset + num_bones*2);

				var offset = pos;
				var b = bone_index_array.subarray(i * 4, i * 4 + 4);
				var w = weights_array.subarray(i * 4, i * 4 + 4);

				var sum = 0;
				for (var j = 0; j < num_bones && j < 4; ++j) {
					b[j] = v[offset + j * 2];
					if (b[j] > max_bone) max_bone = b[j];

					w[j] = weights_indexed_array[v[offset + j * 2 + 1]];
					sum += w[j];
				}

				//normalize weights
				if (num_bones > 4 && sum < 1.0) {
					var inv_sum = 1 / sum;
					for (var j = 0; j < 4; ++j) {
						w[j] *= inv_sum;
					}
				}

				pos += num_bones * 2;
			}

			//remap: because vertices order is now changed after parsing the mesh
			var final_weights = new Float32Array(4 * num_vertices); //4 bones per vertex
			var final_bone_indices = new Uint8Array(4 * num_vertices); //4 bones per vertex
			var used_joints = [];

			//for every vertex in the mesh, process bone indices and weights
			for (var i = 0; i < num_vertices; ++i) {
				var p = remap[i] * 4;
				var w = weights_array.subarray(p, p + 4);
				var b = bone_index_array.subarray(p, p + 4);

				//sort by weight so relevant ones goes first
				for (var k = 0; k < 3; ++k) {
					var max_pos = k;
					var max_value = w[k];
					for (var j = k + 1; j < 4; ++j) {
						if (w[j] <= max_value) continue;
						max_pos = j;
						max_value = w[j];
					}
					if (max_pos != k) {
						var tmp = w[k];
						w[k] = w[max_pos];
						w[max_pos] = tmp;
						tmp = b[k];
						b[k] = b[max_pos];
						b[max_pos] = tmp;
					}
				}

				//store
				final_weights.set(w, i * 4);
				final_bone_indices.set(b, i * 4);

				//mark bones used
				if (w[0]) used_joints[b[0]] = true;
				if (w[1]) used_joints[b[1]] = true;
				if (w[2]) used_joints[b[2]] = true;
				if (w[3]) used_joints[b[3]] = true;
			}

			if (max_bone >= joints.length) console.warn("Mesh uses higher bone index than bones found");

			//trim unused bones (collada could give you 100 bones for an object that only uses a fraction of them)
			if (1) {
				var new_bones = [];
				var bones_translation = {};
				for (var i = 0; i < used_joints.length; ++i) {
					if (used_joints[i]) {
						bones_translation[i] = new_bones.length;
						new_bones.push(joints[i]);
					}
				} //in case there are less bones in use...
				if (new_bones.length < joints.length) {
					//remap
					for (var i = 0; i < final_bone_indices.length; i++) {
						final_bone_indices[i] = bones_translation[final_bone_indices[i]];
					}joints = new_bones;
				}
				//console.log("Bones: ", joints.length, " used:", num_used_joints );
			}

			//console.log("Bones: ", joints.length, "Max bone: ", max_bone);

			mesh.weights = final_weights;
			mesh.bone_indices = final_bone_indices;
			mesh.bones = joints;
			mesh.bind_matrix = bind_matrix;

			//delete mesh["_remap"];
		}

		return mesh;
	},

	//NOT TESTED
	readMorphController: function readMorphController(xmlmorph, flip, scene, mesh) {
		var id_geometry = xmlmorph.getAttribute("source");
		var base_mesh = this.readGeometry(id_geometry, flip, scene);
		if (!base_mesh) return null;

		//read sources with blend shapes info (which ones, and the weight)
		var sources = this.readSources(xmlmorph, flip);

		var morphs = [];

		//targets
		var xmltargets = xmlmorph.querySelector("targets");
		if (!xmltargets) return null;

		var xmlinputs = xmltargets.querySelectorAll("input");
		var targets = null;
		var weights = null;

		for (var i = 0; i < xmlinputs.length; i++) {
			var xmlinput = xmlinputs.item(i);
			var semantic = xmlinput.getAttribute("semantic").toUpperCase();
			var data = sources[xmlinput.getAttribute("source").substr(1)];
			if (semantic == "MORPH_TARGET") targets = data;else if (semantic == "MORPH_WEIGHT") weights = data;
		}

		if (!targets || !weights) {
			console.warn("Morph controller without targets or weights. Skipping it.");
			return null;
		}

		//get targets
		for (var i in targets) {
			var id = "#" + targets[i];
			var geometry = this.readGeometry(id, flip, scene);
			scene.meshes[id] = geometry;
			morphs.push({ mesh: id, weight: weights[i] });
		}

		base_mesh.morph_targets = morphs;
		return base_mesh;
	},

	readBindMaterials: function readBindMaterials(xmlbind_material, mesh) {
		var materials = [];

		var xmltechniques = xmlbind_material.querySelectorAll("technique_common");
		for (var i = 0; i < xmltechniques.length; i++) {
			var xmltechnique = xmltechniques.item(i);
			var xmlinstance_materials = xmltechnique.querySelectorAll("instance_material");
			for (var j = 0; j < xmlinstance_materials.length; j++) {
				var xmlinstance_material = xmlinstance_materials.item(j);
				if (xmlinstance_material) materials.push(xmlinstance_material.getAttribute("symbol"));
			}
		}

		return materials;
	},

	readSources: function readSources(xmlnode, flip) {
		//for data sources
		var sources = {};
		var xmlsources = xmlnode.querySelectorAll("source");
		for (var i = 0; i < xmlsources.length; i++) {
			var xmlsource = xmlsources.item(i);
			if (!xmlsource.querySelector) //??
				continue;

			var float_array = xmlsource.querySelector("float_array");
			if (float_array) {
				var floats = this.readContentAsFloats(xmlsource);
				sources[xmlsource.getAttribute("id")] = floats;
				continue;
			}

			var name_array = xmlsource.querySelector("Name_array");
			if (name_array) {
				var names = this.readContentAsStringsArray(name_array);
				if (!names) continue;
				sources[xmlsource.getAttribute("id")] = names;
				continue;
			}

			var ref_array = xmlsource.querySelector("IDREF_array");
			if (ref_array) {
				var names = this.readContentAsStringsArray(ref_array);
				if (!names) continue;
				sources[xmlsource.getAttribute("id")] = names;
				continue;
			}
		}

		return sources;
	},

	readContentAsUInt32: function readContentAsUInt32(xmlnode) {
		if (!xmlnode) return null;
		var text = xmlnode.textContent;
		text = text.replace(/\n/gi, " "); //remove line breaks
		text = text.trim(); //remove empty spaces
		if (text.length == 0) return null;
		var numbers = text.split(" "); //create array
		var floats = new Uint32Array(numbers.length);
		for (var k = 0; k < numbers.length; k++) {
			floats[k] = parseInt(numbers[k]);
		}return floats;
	},

	readContentAsFloats: function readContentAsFloats(xmlnode) {
		if (!xmlnode) return null;
		var text = xmlnode.textContent;
		text = text.replace(/\n/gi, " "); //remove line breaks
		text = text.replace(/\s\s+/gi, " ");
		text = text.replace(/\t/gi, "");
		text = text.trim(); //remove empty spaces
		var numbers = text.split(" "); //create array
		var count = xmlnode.getAttribute("count");
		var length = count ? parseInt(count) : numbers.length;
		var floats = new Float32Array(length);
		for (var k = 0; k < numbers.length; k++) {
			floats[k] = parseFloat(numbers[k]);
		}return floats;
	},

	readContentAsStringsArray: function readContentAsStringsArray(xmlnode) {
		if (!xmlnode) return null;
		var text = xmlnode.textContent;
		text = text.replace(/\n/gi, " "); //remove line breaks
		text = text.replace(/\s\s/gi, " ");
		text = text.trim(); //remove empty spaces
		var words = text.split(" "); //create array
		for (var k = 0; k < words.length; k++) {
			words[k] = words[k].trim();
		}if (xmlnode.getAttribute("count") && parseInt(xmlnode.getAttribute("count")) != words.length) {
			var merged_words = [];
			var name = "";
			for (var i in words) {
				if (!name) name = words[i];else name += " " + words[i];
				if (!this._nodes_by_id[this.safeString(name)]) continue;
				merged_words.push(this.safeString(name));
				name = "";
			}

			var count = parseInt(xmlnode.getAttribute("count"));
			if (merged_words.length == count) return merged_words;

			console.error("Error: bone names have spaces, avoid using spaces in names");
			return null;
		}
		return words;
	},

	max3d_matrix_0: new Float32Array([0, -1, 0, 0, 0, 0, -1, 0, 1, 0, 0, -0, 0, 0, 0, 1]),
	//max3d_matrix_other: new Float32Array([0, -1, 0, 0, 0, 0, -1, 0, 1, 0, 0, -0, 0, 0, 0, 1]),

	transformMatrix: function transformMatrix(matrix, first_level, inverted) {
		_glMatrix.mat4.transpose(matrix, matrix);

		if (this.no_flip) return matrix;

		//WARNING: DO NOT CHANGE THIS FUNCTION, THE SKY WILL FALL
		if (first_level) {

			//flip row two and tree
			var temp = new Float32Array(matrix.subarray(4, 8)); //swap rows
			matrix.set(matrix.subarray(8, 12), 4);
			matrix.set(temp, 8);

			//reverse Z
			temp = matrix.subarray(8, 12);
			vec4.scale(temp, temp, -1);
		} else {
			var M = _glMatrix.mat4.create();
			var m = matrix;

			//if(inverted) mat4.invert(m,m);

			/* non trasposed
   M.set([m[0],m[8],-m[4]], 0);
   M.set([m[2],m[10],-m[6]], 4);
   M.set([-m[1],-m[9],m[5]], 8);
   M.set([m[3],m[11],-m[7]], 12);
   */

			M.set([m[0], m[2], -m[1]], 0);
			M.set([m[8], m[10], -m[9]], 4);
			M.set([-m[4], -m[6], m[5]], 8);
			M.set([m[12], m[14], -m[13]], 12);

			m.set(M);

			//if(inverted) mat4.invert(m,m);
		}
		return matrix;
	}
};

exports.default = Collada;
module.exports = exports['default'];
//# sourceMappingURL=Collada.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _xhr = __webpack_require__(73);

var _xhr2 = _interopRequireDefault(_xhr);

var _Mesh = __webpack_require__(4);

var _Mesh2 = _interopRequireDefault(_Mesh);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// GltfLoader.js

var ARRAY_CTOR_MAP = {
	5120: Int8Array,
	5121: Uint8Array,
	5122: Int16Array,
	5123: Uint16Array,
	5125: Uint32Array,
	5126: Float32Array
};

var SIZE_MAP = {
	SCALAR: 1,
	VEC2: 2,
	VEC3: 3,
	VEC4: 4,
	MAT2: 4,
	MAT3: 9,
	MAT4: 16
};

var semanticAttributeMap = {
	NORMAL: 'aNormal',
	POSITION: 'aVertexPosition',
	// 'TANGENT': 'aTangent',
	TEXCOORD_0: 'aTextureCoord',
	TEXCOORD_1: 'aTextureCoord1',
	WEIGHTS_0: 'aWeight',
	JOINTS_0: 'aJoint',
	COLOR: 'aColor'
};

var base = void 0;

var load = function load(mSource) {
	return new Promise(function (resolve, reject) {
		if (typeof mSource === 'string') {
			base = mSource.substring(0, mSource.lastIndexOf('/') + 1);
		} else {
			base = '';
		}

		_loadGltf(mSource).then(_loadBin).then(_getBufferViewData).then(_loadTextures).then(_parseMesh).then(_parseNodes).then(function (gltfInfo) {
			resolve(gltfInfo);
		}).catch(function (e) {
			console.log('Error:', e);
		});
	});
};

var _parseNodes = function _parseNodes(gltf) {
	return new Promise(function (resolve, reject) {
		var nodes = gltf.nodes;


		nodes.forEach(function (nodeInfo, i) {
			if (nodeInfo.camera != null && undefined.includeCamera) {
				// setup camera
			} else if (nodeInfo.mesh != null) {
				// console.log(i, 'Mesh index :', nodeInfo.mesh);
			}
		});
		resolve(gltf);
	});
};

var _parseMesh = function _parseMesh(gltf) {
	return new Promise(function (resolve, reject) {
		var meshes = gltf.meshes;

		gltf.geometries = [];
		gltf.output = {
			meshes: [],
			scene: {}
		};

		meshes.forEach(function (mesh, i) {
			var primitives = mesh.primitives;

			var geometry = {};

			primitives.forEach(function (primitiveInfo, i) {
				var semantics = Object.keys(primitiveInfo.attributes);

				semantics.forEach(function (semantic, i) {
					var accessorIdx = primitiveInfo.attributes[semantic];
					var attributeInfo = gltf.accessors[accessorIdx];
					var attributeName = semanticAttributeMap[semantic];
					if (!attributeName) {
						return;
					}
					var size = SIZE_MAP[attributeInfo.type];
					var attributeArray = _getAccessorData(gltf, accessorIdx);
					if (attributeArray instanceof Uint32Array) {
						attributeArray = new Float32Array(attributeArray);
					}

					geometry[attributeName] = {
						value: attributeArray,
						size: size
					};
					// console.log('attribute', attributeName, geometry[attributeName]);
				});

				//	parse index
				if (primitiveInfo.indices != null) {
					var attributeArray = _getAccessorData(gltf, primitiveInfo.indices, true);
					geometry.indices = {
						value: attributeArray,
						size: 1
					};
				}

				var m = new _Mesh2.default();

				for (var s in geometry) {
					var data = geometry[s];
					if (s !== 'indices') {
						// console.log(s, data);
						m.bufferFlattenData(data.value, s, data.size);
					} else {
						// console.log(data.value);
						m.bufferIndex(data.value);
					}
				}
				gltf.output.meshes.push(m);
				gltf.geometries.push(geometry);
			});
		});

		resolve(gltf);
	});
};

var _getBufferViewData = function _getBufferViewData(gltfInfo) {
	return new Promise(function (resolve, reject) {
		var bufferViews = gltfInfo.bufferViews,
		    buffers = gltfInfo.buffers;


		bufferViews.forEach(function (bufferViewInfo, i) {
			var buffer = buffers[bufferViewInfo.buffer].data;
			bufferViewInfo.data = buffer.slice(bufferViewInfo.byteOffset || 0, (bufferViewInfo.byteOffset || 0) + (bufferViewInfo.byteLength || 0));
		});
		resolve(gltfInfo);
	});
};

var _loadGltf = function _loadGltf(mSource) {
	return new Promise(function (resolve, reject) {
		if (typeof mSource !== 'string') {
			resolve(mSource);
		} else {
			(0, _xhr2.default)(mSource).then(function (o) {
				resolve(JSON.parse(o));
			}, function (e) {
				reject(e);
			});
		}
	});
};

var _loadBin = function _loadBin(gltfInfo) {
	return new Promise(function (resolve, reject) {

		if (gltfInfo.buffers) {
			var count = gltfInfo.buffers.length;

			gltfInfo.buffers.forEach(function (buffer) {

				var urlBin = '' + base + gltfInfo.buffers[0].uri;
				(0, _xhr2.default)(urlBin, true).then(function (o) {
					buffer.data = o;

					count--;
					if (count === 0) {
						resolve(gltfInfo);
					}
				}, function (e) {
					reject(e);
				});
			});
		} else {
			resolve(gltfInfo);
		}
	});
};

var _loadTextures = function _loadTextures(gltfInfo) {
	return new Promise(function (resolve, reject) {
		console.log('TODO : Loading textures');
		resolve(gltfInfo);
	});
};

var parse = function parse(mGltfInfo, mBin) {
	return new Promise(function (resolve, reject) {
		resolve(mSource);
	});
};

var _getAccessorData = function _getAccessorData(gltf, accessorIdx) {
	var isIndices = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	var accessorInfo = gltf.accessors[accessorIdx];
	var buffer = gltf.bufferViews[accessorInfo.bufferView].data;
	var byteOffset = accessorInfo.byteOffset || 0;
	var ArrayCtor = ARRAY_CTOR_MAP[accessorInfo.componentType] || Float32Array;
	var size = SIZE_MAP[accessorInfo.type];
	if (size == null && isIndices) {
		size = 1;
	}
	var arr = new ArrayCtor(buffer, byteOffset, size * accessorInfo.count);
	var quantizeExtension = accessorInfo.extensions && accessorInfo.extensions['WEB3D_quantized_attributes'];
	if (quantizeExtension) {
		var decodedArr = new Float32Array(size * accessorInfo.count);
		var decodeMatrix = quantizeExtension.decodeMatrix;
		var decodeOffset = new Array(size);
		var decodeScale = new Array(size);
		for (var k = 0; k < size; k++) {
			decodeOffset[k] = decodeMatrix[size * (size + 1) + k];
			decodeScale[k] = decodeMatrix[k * (size + 1) + k];
		}
		for (var i = 0; i < accessorInfo.count; i++) {
			for (var _k = 0; _k < size; _k++) {
				decodedArr[i * size + _k] = arr[i * size + _k] * decodeScale[_k] + decodeOffset[_k];
			}
		}

		arr = decodedArr;
	}

	// console.log({buffer, byteOffset, ArrayCtor, size, arr});

	return arr;
};

exports.default = {
	load: load,
	parse: parse
};

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
// xhr.js

var load = function load(mPath, isArrayBuffer) {
	return new Promise(function (resolve, reject) {
		var req = new XMLHttpRequest();
		req.addEventListener('load', function (e) {
			resolve(req.response);
		});

		req.addEventListener('error', function (e) {
			reject(e);
		});

		if (isArrayBuffer) {
			req.responseType = 'arraybuffer';
		}

		req.open('GET', mPath);
		req.send();
	});
};

exports.default = load;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // EffectComposer.js

var _Pass = __webpack_require__(9);

var _Pass2 = _interopRequireDefault(_Pass);

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _FrameBuffer = __webpack_require__(12);

var _FrameBuffer2 = _interopRequireDefault(_FrameBuffer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EffectComposer = function () {
	function EffectComposer(mWidth, mHeight) {
		var mParmas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

		_classCallCheck(this, EffectComposer);

		this._width = mWidth || _GLTool2.default.width;
		this._height = mHeight || _GLTool2.default.height;

		this._params = {};
		this.setSize(mWidth, mHeight);
		this._mesh = _Geom2.default.bigTriangle();
		this._passes = [];
		this._returnTexture;
	}

	_createClass(EffectComposer, [{
		key: 'addPass',
		value: function addPass(pass) {
			if (pass.passes) {
				this.addPass(pass.passes);
				return;
			}

			if (pass.length) {
				for (var i = 0; i < pass.length; i++) {
					this._passes.push(pass[i]);
				}
			} else {
				this._passes.push(pass);
			}
		}
	}, {
		key: 'render',
		value: function render(mSource) {
			var _this = this;

			var source = mSource;
			var fboTarget = void 0;

			this._passes.forEach(function (pass) {

				//	get target
				if (pass.hasFbo) {
					fboTarget = pass.fbo;
				} else {
					fboTarget = _this._fboTarget;
				}

				//	render
				fboTarget.bind();
				_GLTool2.default.clear(0, 0, 0, 0);
				pass.render(source);
				_GLTool2.default.draw(_this._mesh);
				fboTarget.unbind();

				//	reset source
				if (pass.hasFbo) {
					source = pass.fbo.getTexture();
				} else {
					_this._swap();
					source = _this._fboCurrent.getTexture();
				}
			});

			this._returnTexture = source;

			return source;
		}
	}, {
		key: '_swap',
		value: function _swap() {
			var tmp = this._fboCurrent;
			this._fboCurrent = this._fboTarget;
			this._fboTarget = tmp;

			this._current = this._fboCurrent;
			this._target = this._fboTarget;
		}
	}, {
		key: 'setSize',
		value: function setSize(mWidth, mHeight) {
			this._width = mWidth;
			this._height = mHeight;
			this._fboCurrent = new _FrameBuffer2.default(this._width, this._height, this._params);
			this._fboTarget = new _FrameBuffer2.default(this._width, this._height, this._params);
		}
	}, {
		key: 'getTexture',
		value: function getTexture() {
			return this._returnTexture;
		}
	}, {
		key: 'passes',
		get: function get() {
			return this._passes;
		}
	}]);

	return EffectComposer;
}();

exports.default = EffectComposer;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _PassVBlur = __webpack_require__(38);

var _PassVBlur2 = _interopRequireDefault(_PassVBlur);

var _PassHBlur = __webpack_require__(40);

var _PassHBlur2 = _interopRequireDefault(_PassHBlur);

var _PassMacro2 = __webpack_require__(37);

var _PassMacro3 = _interopRequireDefault(_PassMacro2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // PassBlur.js

var PassBlur = function (_PassMacro) {
	_inherits(PassBlur, _PassMacro);

	function PassBlur() {
		var mQuality = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 9;
		var mWidth = arguments[1];
		var mHeight = arguments[2];
		var mParams = arguments[3];

		_classCallCheck(this, PassBlur);

		var _this = _possibleConstructorReturn(this, (PassBlur.__proto__ || Object.getPrototypeOf(PassBlur)).call(this));

		var vBlur = new _PassVBlur2.default(mQuality, mWidth, mHeight, mParams);
		var hBlur = new _PassHBlur2.default(mQuality, mWidth, mHeight, mParams);

		_this.addPass(vBlur);
		_this.addPass(hBlur);
		return _this;
	}

	return PassBlur;
}(_PassMacro3.default);

exports.default = PassBlur;

/***/ }),
/* 76 */
/***/ (function(module, exports) {

module.exports = "// blur5.frag\n// source  : https://github.com/Jam3/glsl-fast-gaussian-blur\n\n#define SHADER_NAME BLUR_5\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\nuniform vec2 uDirection;\nuniform vec2 uResolution;\n\nvec4 blur5(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n\tvec4 color = vec4(0.0);\n\tvec2 off1 = vec2(1.3333333333333333) * direction;\n\tcolor += texture2D(image, uv) * 0.29411764705882354;\n\tcolor += texture2D(image, uv + (off1 / resolution)) * 0.35294117647058826;\n\tcolor += texture2D(image, uv - (off1 / resolution)) * 0.35294117647058826;\n\treturn color; \n}\n\n\nvoid main(void) {\n    gl_FragColor = blur5(texture, vTextureCoord, uResolution, uDirection);\n}"

/***/ }),
/* 77 */
/***/ (function(module, exports) {

module.exports = "// blur9.frag\n// source  : https://github.com/Jam3/glsl-fast-gaussian-blur\n\n#define SHADER_NAME BLUR_9\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\nuniform vec2 uDirection;\nuniform vec2 uResolution;\n\nvec4 blur9(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n\tvec4 color = vec4(0.0);\n\tvec2 off1 = vec2(1.3846153846) * direction;\n\tvec2 off2 = vec2(3.2307692308) * direction;\n\tcolor += texture2D(image, uv) * 0.2270270270;\n\tcolor += texture2D(image, uv + (off1 / resolution)) * 0.3162162162;\n\tcolor += texture2D(image, uv - (off1 / resolution)) * 0.3162162162;\n\tcolor += texture2D(image, uv + (off2 / resolution)) * 0.0702702703;\n\tcolor += texture2D(image, uv - (off2 / resolution)) * 0.0702702703;\n\treturn color;\n}\n\n\nvoid main(void) {\n    gl_FragColor = blur9(texture, vTextureCoord, uResolution, uDirection);\n}"

/***/ }),
/* 78 */
/***/ (function(module, exports) {

module.exports = "// blur13.frag\n// source  : https://github.com/Jam3/glsl-fast-gaussian-blur\n\n#define SHADER_NAME BLUR_13\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\nuniform vec2 uDirection;\nuniform vec2 uResolution;\n\nvec4 blur13(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n\tvec4 color = vec4(0.0);\n\tvec2 off1 = vec2(1.411764705882353) * direction;\n\tvec2 off2 = vec2(3.2941176470588234) * direction;\n\tvec2 off3 = vec2(5.176470588235294) * direction;\n\tcolor += texture2D(image, uv) * 0.1964825501511404;\n\tcolor += texture2D(image, uv + (off1 / resolution)) * 0.2969069646728344;\n\tcolor += texture2D(image, uv - (off1 / resolution)) * 0.2969069646728344;\n\tcolor += texture2D(image, uv + (off2 / resolution)) * 0.09447039785044732;\n\tcolor += texture2D(image, uv - (off2 / resolution)) * 0.09447039785044732;\n\tcolor += texture2D(image, uv + (off3 / resolution)) * 0.010381362401148057;\n\tcolor += texture2D(image, uv - (off3 / resolution)) * 0.010381362401148057;\n\treturn color;\n}\n\n\nvoid main(void) {\n    gl_FragColor = blur13(texture, vTextureCoord, uResolution, uDirection);\n}"

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Pass2 = __webpack_require__(9);

var _Pass3 = _interopRequireDefault(_Pass2);

var _fxaa = __webpack_require__(41);

var _fxaa2 = _interopRequireDefault(_fxaa);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // PassFxaa.js

var PassFxaa = function (_Pass) {
	_inherits(PassFxaa, _Pass);

	function PassFxaa() {
		_classCallCheck(this, PassFxaa);

		var _this = _possibleConstructorReturn(this, (PassFxaa.__proto__ || Object.getPrototypeOf(PassFxaa)).call(this, _fxaa2.default));

		_this.uniform('uResolution', [1 / _GLTool2.default.width, 1 / _GLTool2.default.height]);
		return _this;
	}

	return PassFxaa;
}(_Pass3.default);

exports.default = PassFxaa;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _GLShader = __webpack_require__(2);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchCopy.js

var vs = __webpack_require__(18);
var fs = __webpack_require__(19);

var BatchCopy = function (_Batch) {
	_inherits(BatchCopy, _Batch);

	function BatchCopy() {
		_classCallCheck(this, BatchCopy);

		var mesh = _Geom2.default.bigTriangle();
		var shader = new _GLShader2.default(vs, fs);

		var _this = _possibleConstructorReturn(this, (BatchCopy.__proto__ || Object.getPrototypeOf(BatchCopy)).call(this, mesh, shader));

		shader.bind();
		shader.uniform('texture', 'uniform1i', 0);
		return _this;
	}

	_createClass(BatchCopy, [{
		key: 'draw',
		value: function draw(texture) {
			this.shader.bind();
			texture.bind(0);
			_get(BatchCopy.prototype.__proto__ || Object.getPrototypeOf(BatchCopy.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchCopy;
}(_Batch3.default);

exports.default = BatchCopy;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Mesh = __webpack_require__(4);

var _Mesh2 = _interopRequireDefault(_Mesh);

var _GLShader = __webpack_require__(2);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchAxis.js

var vs = __webpack_require__(82);
var fs = __webpack_require__(83);

var BatchAxis = function (_Batch) {
	_inherits(BatchAxis, _Batch);

	function BatchAxis() {
		_classCallCheck(this, BatchAxis);

		var positions = [];
		var colors = [];
		var indices = [0, 1, 2, 3, 4, 5];
		var r = 9999;

		positions.push([-r, 0, 0]);
		positions.push([r, 0, 0]);
		positions.push([0, -r, 0]);
		positions.push([0, r, 0]);
		positions.push([0, 0, -r]);
		positions.push([0, 0, r]);

		colors.push([1, 0, 0]);
		colors.push([1, 0, 0]);
		colors.push([0, 1, 0]);
		colors.push([0, 1, 0]);
		colors.push([0, 0, 1]);
		colors.push([0, 0, 1]);

		var mesh = new _Mesh2.default(_GLTool2.default.LINES);
		mesh.bufferVertex(positions);
		mesh.bufferIndex(indices);
		mesh.bufferData(colors, 'aColor', 3);

		var shader = new _GLShader2.default(vs, fs);

		return _possibleConstructorReturn(this, (BatchAxis.__proto__ || Object.getPrototypeOf(BatchAxis)).call(this, mesh, shader));
	}

	return BatchAxis;
}(_Batch3.default);

exports.default = BatchAxis;

/***/ }),
/* 82 */
/***/ (function(module, exports) {

module.exports = "// axis.vert\n\n#define SHADER_NAME BASIC_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec3 aColor;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec3 vColor;\nvarying vec3 vNormal;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);\n    vColor = aColor;\n    vNormal = aNormal;\n}"

/***/ }),
/* 83 */
/***/ (function(module, exports) {

module.exports = "// axis.frag\n\n#define SHADER_NAME SIMPLE_TEXTURE\n\nprecision lowp float;\n#define GLSLIFY 1\nvarying vec3 vColor;\nvarying vec3 vNormal;\n\nvoid main(void) {\n\t// vec3 color = vNormal;\n\tvec3 color = vColor + vNormal * 0.0001;\n    gl_FragColor = vec4(color, 1.0);\n}"

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _GLShader = __webpack_require__(2);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchBall.js

var vs = __webpack_require__(34);
var fs = __webpack_require__(10);

var BatchBall = function (_Batch) {
	_inherits(BatchBall, _Batch);

	function BatchBall() {
		_classCallCheck(this, BatchBall);

		var mesh = _Geom2.default.sphere(1, 24);
		var shader = new _GLShader2.default(vs, fs);
		return _possibleConstructorReturn(this, (BatchBall.__proto__ || Object.getPrototypeOf(BatchBall)).call(this, mesh, shader));
	}

	_createClass(BatchBall, [{
		key: 'draw',
		value: function draw() {
			var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];
			var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [1, 1, 1];
			var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 1, 1];
			var opacity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

			this.shader.bind();
			this.shader.uniform('position', 'uniform3fv', position);
			this.shader.uniform('scale', 'uniform3fv', scale);
			this.shader.uniform('color', 'uniform3fv', color);
			this.shader.uniform('opacity', 'uniform1f', opacity);
			_get(BatchBall.prototype.__proto__ || Object.getPrototypeOf(BatchBall.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchBall;
}(_Batch3.default);

exports.default = BatchBall;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Mesh = __webpack_require__(4);

var _Mesh2 = _interopRequireDefault(_Mesh);

var _GLShader = __webpack_require__(2);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchDotsPlane.js

var vs = __webpack_require__(86);
var fs = __webpack_require__(10);

var BatchDotsPlane = function (_Batch) {
	_inherits(BatchDotsPlane, _Batch);

	function BatchDotsPlane() {
		_classCallCheck(this, BatchDotsPlane);

		var positions = [];
		var indices = [];
		var index = 0;
		var size = 100;
		var i = void 0,
		    j = void 0;

		for (i = -size; i < size; i += 1) {
			for (j = -size; j < size; j += 1) {
				positions.push([i, j, 0]);
				indices.push(index);
				index++;

				positions.push([i, 0, j]);
				indices.push(index);
				index++;
			}
		}

		var mesh = new _Mesh2.default(_GLTool2.default.POINTS);
		mesh.bufferVertex(positions);
		mesh.bufferIndex(indices);

		var shader = new _GLShader2.default(vs, fs);

		var _this = _possibleConstructorReturn(this, (BatchDotsPlane.__proto__ || Object.getPrototypeOf(BatchDotsPlane)).call(this, mesh, shader));

		_this.color = [1, 1, 1];
		_this.opacity = 0.5;
		return _this;
	}

	_createClass(BatchDotsPlane, [{
		key: 'draw',
		value: function draw() {
			this.shader.bind();
			this.shader.uniform('color', 'uniform3fv', this.color);
			this.shader.uniform('opacity', 'uniform1f', this.opacity);
			// GL.draw(this.mesh);
			_get(BatchDotsPlane.prototype.__proto__ || Object.getPrototypeOf(BatchDotsPlane.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchDotsPlane;
}(_Batch3.default);

exports.default = BatchDotsPlane;

/***/ }),
/* 86 */
/***/ (function(module, exports) {

module.exports = "// basic.vert\n\n#define SHADER_NAME DOTS_PLANE_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec3 vNormal;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition + aNormal * 0.000001, 1.0);\n    gl_PointSize = 1.0;\n    vNormal = aNormal;\n}"

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Mesh = __webpack_require__(4);

var _Mesh2 = _interopRequireDefault(_Mesh);

var _GLShader = __webpack_require__(2);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchLine.js


var vs = __webpack_require__(11);
var fs = __webpack_require__(10);

var BatchAxis = function (_Batch) {
	_inherits(BatchAxis, _Batch);

	function BatchAxis() {
		_classCallCheck(this, BatchAxis);

		var positions = [];
		var indices = [0, 1];
		var coords = [[0, 0], [1, 1]];
		positions.push([0, 0, 0]);
		positions.push([0, 0, 0]);

		var mesh = new _Mesh2.default(_GLTool2.default.LINES);
		mesh.bufferVertex(positions);
		mesh.bufferTexCoord(coords);
		mesh.bufferIndex(indices);

		var shader = new _GLShader2.default(vs, fs);

		return _possibleConstructorReturn(this, (BatchAxis.__proto__ || Object.getPrototypeOf(BatchAxis)).call(this, mesh, shader));
	}

	_createClass(BatchAxis, [{
		key: 'draw',
		value: function draw(mPositionA, mPositionB) {
			var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 1, 1];
			var opacity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1.0;

			this._mesh.bufferVertex([mPositionA, mPositionB]);

			this._shader.bind();
			this._shader.uniform('color', 'vec3', color);
			this._shader.uniform('opacity', 'float', opacity);
			_get(BatchAxis.prototype.__proto__ || Object.getPrototypeOf(BatchAxis.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchAxis;
}(_Batch3.default);

exports.default = BatchAxis;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _GLShader = __webpack_require__(2);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchSkybox.js

var vs = __webpack_require__(35);
var fs = __webpack_require__(36);

var BatchSkybox = function (_Batch) {
	_inherits(BatchSkybox, _Batch);

	function BatchSkybox() {
		var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 20;

		_classCallCheck(this, BatchSkybox);

		var mesh = _Geom2.default.skybox(size);
		var shader = new _GLShader2.default(vs, fs);

		return _possibleConstructorReturn(this, (BatchSkybox.__proto__ || Object.getPrototypeOf(BatchSkybox)).call(this, mesh, shader));
	}

	_createClass(BatchSkybox, [{
		key: 'draw',
		value: function draw(texture) {
			this.shader.bind();
			texture.bind(0);
			_get(BatchSkybox.prototype.__proto__ || Object.getPrototypeOf(BatchSkybox.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchSkybox;
}(_Batch3.default);

exports.default = BatchSkybox;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _GLShader = __webpack_require__(2);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchSky.js

var vs = __webpack_require__(90);
var fs = __webpack_require__(19);

var BatchSky = function (_Batch) {
	_inherits(BatchSky, _Batch);

	function BatchSky() {
		var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;
		var seg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 24;

		_classCallCheck(this, BatchSky);

		var mesh = _Geom2.default.sphere(size, seg, true);
		var shader = new _GLShader2.default(vs, fs);

		return _possibleConstructorReturn(this, (BatchSky.__proto__ || Object.getPrototypeOf(BatchSky)).call(this, mesh, shader));
	}

	_createClass(BatchSky, [{
		key: 'draw',
		value: function draw(texture) {
			this.shader.bind();
			texture.bind(0);
			_get(BatchSky.prototype.__proto__ || Object.getPrototypeOf(BatchSky.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchSky;
}(_Batch3.default);

exports.default = BatchSky;

/***/ }),
/* 90 */
/***/ (function(module, exports) {

module.exports = "// sky.vert\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\n\nvoid main(void) {\n\tmat4 matView = uViewMatrix;\n\tmatView[3][0] = 0.0;\n\tmatView[3][1] = 0.0;\n\tmatView[3][2] = 0.0;\n\t\n    gl_Position = uProjectionMatrix * matView * uModelMatrix * vec4(aVertexPosition, 1.0);\n    vTextureCoord = aTextureCoord;\n    vNormal = aNormal;\n}"

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _GLShader = __webpack_require__(2);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchFXAA.js


var vs = __webpack_require__(18);
var fs = __webpack_require__(41);

var BatchFXAA = function (_Batch) {
	_inherits(BatchFXAA, _Batch);

	function BatchFXAA() {
		_classCallCheck(this, BatchFXAA);

		var mesh = _Geom2.default.bigTriangle();
		var shader = new _GLShader2.default(vs, fs);

		var _this = _possibleConstructorReturn(this, (BatchFXAA.__proto__ || Object.getPrototypeOf(BatchFXAA)).call(this, mesh, shader));

		shader.bind();
		shader.uniform('texture', 'uniform1i', 0);
		return _this;
	}

	_createClass(BatchFXAA, [{
		key: 'draw',
		value: function draw(texture) {
			this.shader.bind();
			texture.bind(0);
			this.shader.uniform('uResolution', 'vec2', [1 / _GLTool2.default.width, 1 / _GLTool2.default.height]);
			_get(BatchFXAA.prototype.__proto__ || Object.getPrototypeOf(BatchFXAA.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchFXAA;
}(_Batch3.default);

exports.default = BatchFXAA;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Scene.js

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _CameraPerspective = __webpack_require__(16);

var _CameraPerspective2 = _interopRequireDefault(_CameraPerspective);

var _CameraOrtho = __webpack_require__(31);

var _CameraOrtho2 = _interopRequireDefault(_CameraOrtho);

var _OrbitalControl = __webpack_require__(30);

var _OrbitalControl2 = _interopRequireDefault(_OrbitalControl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Scene = function () {
	function Scene() {
		var _this = this;

		_classCallCheck(this, Scene);

		this._children = [];
		this._matrixIdentity = mat4.create();
		_GLTool2.default.enableAlphaBlending();

		this._init();
		this._initTextures();
		this._initViews();

		this._efIndex = _scheduling2.default.addEF(function () {
			return _this._loop();
		});
		window.addEventListener('resize', function () {
			return _this.resize();
		});
	}

	//	PUBLIC METHODS

	_createClass(Scene, [{
		key: 'update',
		value: function update() {}
	}, {
		key: 'render',
		value: function render() {}
	}, {
		key: 'stop',
		value: function stop() {
			if (this._efIndex === -1) {
				return;
			}
			this._efIndex = _scheduling2.default.removeEF(this._efIndex);
		}
	}, {
		key: 'start',
		value: function start() {
			var _this2 = this;

			if (this._efIndex !== -1) {
				return;
			}

			this._efIndex = _scheduling2.default.addEF(function () {
				return _this2._loop();
			});
		}
	}, {
		key: 'resize',
		value: function resize() {
			_GLTool2.default.setSize(window.innerWidth, window.innerHeight);
			this.camera.setAspectRatio(_GLTool2.default.aspectRatio);
		}
	}, {
		key: 'addChild',
		value: function addChild(mChild) {
			this._children.push(mChild);
		}
	}, {
		key: 'removeChild',
		value: function removeChild(mChild) {
			var index = this._children.indexOf(mChild);
			if (index == -1) {
				console.warn('Child no exist');return;
			}

			this._children.splice(index, 1);
		}

		//	PROTECTED METHODS TO BE OVERRIDEN BY CHILDREN

	}, {
		key: '_initTextures',
		value: function _initTextures() {}
	}, {
		key: '_initViews',
		value: function _initViews() {}
	}, {
		key: '_renderChildren',
		value: function _renderChildren() {
			var child = void 0;
			for (var i = 0; i < this._children.length; i++) {
				child = this._children[i];
				child.toRender();
			}

			_GLTool2.default.rotate(this._matrixIdentity);
		}

		//	PRIVATE METHODS

	}, {
		key: '_init',
		value: function _init() {
			this.camera = new _CameraPerspective2.default();
			this.camera.setPerspective(45 * Math.PI / 180, _GLTool2.default.aspectRatio, 0.1, 100);
			this.orbitalControl = new _OrbitalControl2.default(this.camera, window, 15);
			this.orbitalControl.radius.value = 10;

			this.cameraOrtho = new _CameraOrtho2.default();
		}
	}, {
		key: '_loop',
		value: function _loop() {

			//	RESET VIEWPORT
			_GLTool2.default.viewport(0, 0, _GLTool2.default.width, _GLTool2.default.height);

			//	RESET CAMERA
			_GLTool2.default.setMatrices(this.camera);

			this.update();
			this._renderChildren();
			this.render();
		}
	}]);

	return Scene;
}();

exports.default = Scene;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // View.js

var _GLShader = __webpack_require__(2);

var _GLShader2 = _interopRequireDefault(_GLShader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var View = function () {
	function View(mStrVertex, mStrFrag) {
		_classCallCheck(this, View);

		this.shader = new _GLShader2.default(mStrVertex, mStrFrag);

		this._init();
	}

	//	PROTECTED METHODS

	_createClass(View, [{
		key: '_init',
		value: function _init() {}

		// 	PUBLIC METHODS

	}, {
		key: 'render',
		value: function render() {}
	}]);

	return View;
}();

exports.default = View;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Object3D2 = __webpack_require__(32);

var _Object3D3 = _interopRequireDefault(_Object3D2);

var _GLShader = __webpack_require__(2);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // View3D.js

var View3D = function (_Object3D) {
	_inherits(View3D, _Object3D);

	function View3D(mStrVertex, mStrFrag) {
		_classCallCheck(this, View3D);

		var _this = _possibleConstructorReturn(this, (View3D.__proto__ || Object.getPrototypeOf(View3D)).call(this));

		_this._children = [];
		_this.shader = new _GLShader2.default(mStrVertex, mStrFrag);
		_this._init();
		_this._matrixTemp = mat4.create();
		return _this;
	}

	//	PROTECTED METHODS

	_createClass(View3D, [{
		key: '_init',
		value: function _init() {}

		// 	PUBLIC METHODS

	}, {
		key: 'addChild',
		value: function addChild(mChild) {
			this._children.push(mChild);
		}
	}, {
		key: 'removeChild',
		value: function removeChild(mChild) {
			var index = this._children.indexOf(mChild);
			if (index == -1) {
				console.warn('Child no exist');return;
			}

			this._children.splice(index, 1);
		}
	}, {
		key: 'toRender',
		value: function toRender(matrix) {
			if (matrix === undefined) {
				matrix = mat4.create();
			}
			mat4.mul(this._matrixTemp, matrix, this.matrix);
			_GLTool2.default.rotate(this._matrixTemp);
			this.render();

			for (var i = 0; i < this._children.length; i++) {
				var child = this._children[i];
				child.toRender(this.matrix);
			}
		}
	}, {
		key: 'render',
		value: function render() {}
	}]);

	return View3D;
}(_Object3D3.default);

exports.default = View3D;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _assetList = __webpack_require__(97);

var _assetList2 = _interopRequireDefault(_assetList);

var _alfrid = __webpack_require__(20);

var _alfrid2 = _interopRequireDefault(_alfrid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Assets.js

var Assets = {};
var _assets = [];

var getAsset = function getAsset(id) {
	return assets.find(function (a) {
		return a.id === id;
	}).file;
};

var getExtension = function getExtension(mFile) {
	var ary = mFile.split('.');
	return ary[ary.length - 1];
};

Assets.init = function () {
	var hdrCubemaps = {};
	_assets = _assetList2.default.map(function (o) {
		var ext = getExtension(o.url);
		var file = getAsset(o.id);
		var texture = void 0;

		switch (ext) {
			case 'jpg':
			case 'png':
				texture = new _alfrid.GLTexture(file);
				return {
					id: o.id,
					file: texture
				};
				break;

			case 'hdr':
				var cubemapName = o.id.split('_')[0];
				texture = _alfrid2.default.HDRLoader.parse(file);

				var oAsset = {
					id: o.id,
					file: texture
				};

				if (!hdrCubemaps[cubemapName]) {
					hdrCubemaps[cubemapName] = [];
				}

				hdrCubemaps[cubemapName].push(oAsset);
				return oAsset;

				break;
			case 'dds':
				texture = _alfrid.GLCubeTexture.parseDDS(file);
				return {
					id: o.id,
					file: texture
				};
				break;

			case 'obj':
				var mesh = _alfrid.ObjLoader.parse(file);
				return {
					id: o.id,
					file: mesh
				};
				break;
		}
	});

	for (var s in hdrCubemaps) {
		if (hdrCubemaps[s].length == 6) {
			console.log('Generate Cubemap :', s);

			var ary = [Assets.get(s + '_posx'), Assets.get(s + '_negx'), Assets.get(s + '_posy'), Assets.get(s + '_negy'), Assets.get(s + '_posz'), Assets.get(s + '_negz')];

			var texture = new _alfrid2.default.GLCubeTexture(ary);
			_assets.push({
				id: s,
				file: texture
			});
		}
	}

	if (_assets.length > 0) {
		console.debug('ASSETS:');
		console.table(_assets);
	}
};

Assets.get = function (mId) {
	return _assets.find(function (a) {
		return a.id === mId;
	}).file;
};

exports.default = Assets;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
// Config.js

exports.default = {
	gamma: 3
};

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var assetsToLoad = [{ "id": "albedo", "url": "assets/img/albedo.jpg", "type": "jpg" }, { "id": "ao", "url": "assets/img/ao.jpg", "type": "jpg" }, { "id": "brdfLUT", "url": "assets/img/brdfLUT.png", "type": "png" }, { "id": "metalGloss", "url": "assets/img/metalGloss.jpg", "type": "jpg" }, { "id": "normal", "url": "assets/img/normal.jpg", "type": "jpg" }, { "id": "studio10_irradiance", "url": "assets/img/studio10_irradiance.dds", "type": "binary" }, { "id": "studio10_radiance", "url": "assets/img/studio10_radiance.dds", "type": "binary" }, { "id": "studio11_irradiance", "url": "assets/img/studio11_irradiance.dds", "type": "binary" }, { "id": "studio11_radiance", "url": "assets/img/studio11_radiance.dds", "type": "binary" }, { "id": "studio12_irradiance", "url": "assets/img/studio12_irradiance.dds", "type": "binary" }, { "id": "studio12_radiance", "url": "assets/img/studio12_radiance.dds", "type": "binary" }, { "id": "studio1_irradiance", "url": "assets/img/studio1_irradiance.dds", "type": "binary" }, { "id": "studio1_radiance", "url": "assets/img/studio1_radiance.dds", "type": "binary" }, { "id": "studio2_irradiance", "url": "assets/img/studio2_irradiance.dds", "type": "binary" }, { "id": "studio2_radiance", "url": "assets/img/studio2_radiance.dds", "type": "binary" }, { "id": "studio3_irradiance", "url": "assets/img/studio3_irradiance.dds", "type": "binary" }, { "id": "studio3_radiance", "url": "assets/img/studio3_radiance.dds", "type": "binary" }, { "id": "studio4_irradiance", "url": "assets/img/studio4_irradiance.dds", "type": "binary" }, { "id": "studio4_radiance", "url": "assets/img/studio4_radiance.dds", "type": "binary" }, { "id": "studio5_irradiance", "url": "assets/img/studio5_irradiance.dds", "type": "binary" }, { "id": "studio5_radiance", "url": "assets/img/studio5_radiance.dds", "type": "binary" }, { "id": "studio6_irradiance", "url": "assets/img/studio6_irradiance.dds", "type": "binary" }, { "id": "studio6_radiance", "url": "assets/img/studio6_radiance.dds", "type": "binary" }, { "id": "studio7_irradiance", "url": "assets/img/studio7_irradiance.dds", "type": "binary" }, { "id": "studio7_radiance", "url": "assets/img/studio7_radiance.dds", "type": "binary" }, { "id": "studio8_irradiance", "url": "assets/img/studio8_irradiance.dds", "type": "binary" }, { "id": "studio8_radiance", "url": "assets/img/studio8_radiance.dds", "type": "binary" }, { "id": "studio9_irradiance", "url": "assets/img/studio9_irradiance.dds", "type": "binary" }, { "id": "studio9_radiance", "url": "assets/img/studio9_radiance.dds", "type": "binary" }];

exports.default = assetsToLoad;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Config = __webpack_require__(96);

var _Config2 = _interopRequireDefault(_Config);

var _fastUrlParser = __webpack_require__(111);

var _fastUrlParser2 = _interopRequireDefault(_fastUrlParser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Settings.js

_fastUrlParser2.default.queryString = __webpack_require__(117);

var enabled = true;

var reload = function reload() {
	if (!enabled) {
		return;
	}
	window.location.href = window.location.origin + window.location.pathname + '?config=' + JSON.stringify(_Config2.default);
};

var refresh = function refresh() {
	if (!enabled) {
		return;
	}
	window.history.pushState('experiment', 'Title', window.location.origin + window.location.pathname + '?config=' + JSON.stringify(_Config2.default));
};

var delayIndex = -1;

var delayReload = function delayReload() {
	if (!enabled) {
		return;
	}
	window.clearTimeout(delayIndex);

	delayIndex = window.setTimeout(function () {
		window.location.href = window.location.origin + window.location.pathname + '?config=' + JSON.stringify(_Config2.default);
	}, 500);
};

var init = function init() {
	var mEnabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

	enabled = mEnabled;
	var parsed = _fastUrlParser2.default.parse(window.location.search, true);

	if (parsed.query.config) {
		var oConfig = JSON.parse(parsed.query.config);

		for (var key in oConfig) {
			_Config2.default[key] = oConfig[key];
		}
	}

	console.log('Config :', _Config2.default);
	refresh();
};

exports.default = {
	enabled: enabled,
	reload: reload,
	refresh: refresh,
	delayReload: delayReload,
	init: init
};

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var EventEmitter = __webpack_require__(121).EventEmitter;

function Emitter() {
    EventEmitter.call(this);
    this.setMaxListeners(20);
}

Emitter.prototype = Object.create(EventEmitter.prototype);
Emitter.prototype.constructor = Emitter;

Emitter.prototype.off = function(type, listener) {
    if (listener) {
        return this.removeListener(type, listener);
    }
    if (type) {
        return this.removeAllListeners(type);
    }
    return this.removeAllListeners();
};

module.exports = Emitter;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
    mbs: 0,
    secs: 0,
    update: function(request, startTime, url, log) {
        var length;
        var headers = request.getAllResponseHeaders();
        if (headers) {
            var match = headers.match(/content-length: (\d+)/i);
            if (match && match.length) {
                length = match[1];
            }
        }
        // var length = request.getResponseHeader('Content-Length');
        if (length) {
            length = parseInt(length, 10);
            var mbs = length / 1024 / 1024;
            var secs = (Date.now() - startTime) / 1000;
            this.secs += secs;
            this.mbs += mbs;
            if (log) {
                this.log(url, mbs, secs);
            }
        } else if(log) {
            console.warn.call(console, 'Can\'t get Content-Length:', url);
        }
    },
    log: function(url, mbs, secs) {
        if (url) {
            var file = 'File loaded: ' +
                url.substr(url.lastIndexOf('/') + 1) +
                ' size:' + mbs.toFixed(2) + 'mb' +
                ' time:' + secs.toFixed(2) + 's' +
                ' speed:' + (mbs / secs).toFixed(2) + 'mbps';

            console.log.call(console, file);
        }
        var total = 'Total loaded: ' + this.mbs.toFixed(2) + 'mb' +
            ' time:' + this.secs.toFixed(2) + 's' +
            ' speed:' + this.getMbps().toFixed(2) + 'mbps';
        console.log.call(console, total);
    },
    getMbps: function() {
        return this.mbs / this.secs;
    }
};


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(102);

var _debugPolyfill = __webpack_require__(106);

var _debugPolyfill2 = _interopRequireDefault(_debugPolyfill);

var _alfrid = __webpack_require__(20);

var _alfrid2 = _interopRequireDefault(_alfrid);

var _SceneApp = __webpack_require__(107);

var _SceneApp2 = _interopRequireDefault(_SceneApp);

var _assetsLoader = __webpack_require__(119);

var _assetsLoader2 = _interopRequireDefault(_assetsLoader);

var _assetList = __webpack_require__(97);

var _assetList2 = _interopRequireDefault(_assetList);

var _Assets = __webpack_require__(95);

var _Assets2 = _interopRequireDefault(_Assets);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

if (document.body) {
	_init();
} else {
	window.addEventListener('DOMContentLoaded', _init);
}

function _init() {

	//	LOADING ASSETS
	if (_assetList2.default.length > 0) {
		document.body.classList.add('isLoading');

		var loader = new _assetsLoader2.default({
			assets: _assetList2.default
		}).on('error', function (error) {
			console.log('Error :', error);
		}).on('progress', function (p) {
			// console.log('Progress : ', p);
			var loader = document.body.querySelector('.Loading-Bar');
			if (loader) loader.style.width = p * 100 + '%';
		}).on('complete', _onImageLoaded).start();
	} else {
		_init3D();
	}
}

function _onImageLoaded(o) {
	//	ASSETS
	console.log('Image Loaded : ', o);
	window.assets = o;
	var loader = document.body.querySelector('.Loading-Bar');
	console.log('Loader :', loader);
	loader.style.width = '100%';

	_init3D();

	setTimeout(function () {
		document.body.classList.remove('isLoading');
	}, 250);
}

function _init3D() {
	//	CREATE CANVAS
	var canvas = document.createElement('canvas');
	canvas.className = 'Main-Canvas';
	document.body.appendChild(canvas);

	//	INIT 3D TOOL
	_alfrid.GL.init(canvas, { ignoreWebgl2: true });

	//	INIT ASSETS
	_Assets2.default.init();

	//	CREATE SCENE
	var scene = new _SceneApp2.default();
}

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(43);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(104)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(true) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept(43, function() {
			var newContent = __webpack_require__(43);
			if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 103 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			memo[selector] = fn.call(this, selector);
		}

		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(105);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton) options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 105 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// debugPolyfill.js

window.gui = {
	add: function add() {}
};

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _alfrid = __webpack_require__(20);

var _alfrid2 = _interopRequireDefault(_alfrid);

var _ViewMicro = __webpack_require__(108);

var _ViewMicro2 = _interopRequireDefault(_ViewMicro);

var _Assets = __webpack_require__(95);

var _Assets2 = _interopRequireDefault(_Assets);

var _Settings = __webpack_require__(98);

var _Settings2 = _interopRequireDefault(_Settings);

var _Config = __webpack_require__(96);

var _Config2 = _interopRequireDefault(_Config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // SceneApp.js

// import ViewObjModel from './ViewObjModel';


var SceneApp = function (_Scene) {
	_inherits(SceneApp, _Scene);

	function SceneApp() {
		_classCallCheck(this, SceneApp);

		_Settings2.default.init();

		var _this = _possibleConstructorReturn(this, (SceneApp.__proto__ || Object.getPrototypeOf(SceneApp)).call(this));

		_this.resize();
		_alfrid.GL.enableAlphaBlending();
		_this.orbitalControl.rx.value = _this.orbitalControl.ry.value = 0.3;
		_this.orbitalControl.radius.value = 5;
		return _this;
	}

	_createClass(SceneApp, [{
		key: '_initTextures',
		value: function _initTextures() {
			console.log('init textures');
		}
	}, {
		key: '_initViews',
		value: function _initViews() {
			var _this2 = this;

			console.log('init views');

			this._bCopy = new _alfrid2.default.BatchCopy();
			this._bAxis = new _alfrid2.default.BatchAxis();
			this._bDots = new _alfrid2.default.BatchDotsPlane();
			this._bSky = new _alfrid2.default.BatchSkybox();

			// this._vModel = new ViewObjModel();

			this._vMicro = new _ViewMicro2.default();

			this.env = 'studio1';

			var envs = [];
			for (var i = 1; i <= 12; i++) {
				envs.push('studio' + i);
			}

			this._updateEnvMap();

			gui.add(this, 'env', envs).onFinishChange(function () {
				return _this2._updateEnvMap();
			});
		}
	}, {
		key: '_updateEnvMap',
		value: function _updateEnvMap() {
			this.textureIrr = _Assets2.default.get(this.env + '_irradiance');
			this.textureRad = _Assets2.default.get(this.env + '_radiance');
		}
	}, {
		key: 'render',
		value: function render() {
			_alfrid.GL.clear(0, 0, 0, 0);

			this._bSky.draw(this.textureRad);
			this._vMicro.render(this.textureIrr, this.textureRad);
		}
	}, {
		key: 'resize',
		value: function resize() {
			var _window = window,
			    innerWidth = _window.innerWidth,
			    innerHeight = _window.innerHeight,
			    devicePixelRatio = _window.devicePixelRatio;

			_alfrid.GL.setSize(innerWidth, innerHeight);
			this.camera.setAspectRatio(_alfrid.GL.aspectRatio);
		}
	}]);

	return SceneApp;
}(_alfrid.Scene);

exports.default = SceneApp;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _alfrid = __webpack_require__(20);

var _alfrid2 = _interopRequireDefault(_alfrid);

var _gltf = __webpack_require__(109);

var _gltf2 = _interopRequireDefault(_gltf);

var _gltf3 = __webpack_require__(110);

var _gltf4 = _interopRequireDefault(_gltf3);

var _Assets = __webpack_require__(95);

var _Assets2 = _interopRequireDefault(_Assets);

var _Config = __webpack_require__(96);

var _Config2 = _interopRequireDefault(_Config);

var _Settings = __webpack_require__(98);

var _Settings2 = _interopRequireDefault(_Settings);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // ViewMicro.js

var definesToString = function definesToString(defines) {
	var outStr = '';
	for (var def in defines) {
		if (defines[def]) {
			outStr += '#define ' + def + ' ' + defines[def] + '\n';
		}
	}
	return outStr;
};

var ViewMicro = function (_alfrid$View) {
	_inherits(ViewMicro, _alfrid$View);

	function ViewMicro() {
		_classCallCheck(this, ViewMicro);

		var defines = {
			'USE_IBL': 1,
			'HAS_BASECOLORMAP': 1,
			'HAS_NORMALMAP': 1,
			'HAS_EMISSIVEMAP': 0,
			'HAS_OCCLUSIONMAP': 1,
			'HAS_METALROUGHNESSMAP': 1
		};

		var defineStr = definesToString(defines);
		var _vs = defineStr + '\n' + _gltf2.default;
		var _fs = defineStr + '\n' + _gltf4.default;
		return _possibleConstructorReturn(this, (ViewMicro.__proto__ || Object.getPrototypeOf(ViewMicro)).call(this, _vs, _fs));
	}

	_createClass(ViewMicro, [{
		key: '_init',
		value: function _init() {
			var _this2 = this;

			// load gltf file
			var url = 'assets/gltf/microphone.gltf';

			_alfrid.GLTFLoader.load(url).then(function (gltfInfo) {
				return _this2._onLoaded(gltfInfo);
			}).catch(function (e) {
				console.log('Error loading gltf:', e);
			});

			gui.add(_Config2.default, 'gamma', 1, 5).onChange(_Settings2.default.refresh);
			//	textures

			var textureBrdf = _Assets2.default.get('brdfLUT');
			var textureColor = _Assets2.default.get('albedo');
			var textureMetalGloss = _Assets2.default.get('metalGloss');
			var textureAO = _Assets2.default.get('ao');
			var textureNormal = _Assets2.default.get('normal');
			// textureIrr = alfrid.GLCubeTexture.parseDDS(Assets.get('plight_irradiance');
			// textureRad = alfrid.GLCubeTexture.parseDDS(Assets.get('plight_radiance');


			//	binding
			var shader = this.shader;

			shader.bind();

			shader.uniform('uAoMap', 'uniform1i', 0);
			textureAO.bind(0);

			shader.uniform("uBRDFMap", "uniform1i", 1);
			textureBrdf.bind(1);

			shader.uniform("uColorMap", "uniform1i", 2);
			textureColor.bind(2);

			shader.uniform("uNormalMap", "uniform1i", 3);
			textureNormal.bind(3);

			shader.uniform("uMetallicRoughnessMap", "uniform1i", 4);
			textureMetalGloss.bind(4);

			shader.uniform('uRadianceMap', 'uniform1i', 5);
			shader.uniform('uIrradianceMap', 'uniform1i', 6);

			var baseColor = [1, 1, 1];
			var roughness = 1;
			var metallic = 1;

			shader.uniform('uBaseColor', 'uniform3fv', baseColor);
			shader.uniform('uRoughness', 'uniform1f', roughness);
			shader.uniform('uMetallic', 'uniform1f', metallic);
			shader.uniform("uNormalScale", "float", 1);
			shader.uniform("uEmissiveFactor", "vec3", [0.5, 0.5, 0.5]);

			shader.uniform("uLightDirection", "vec3", [0.5, 0.5, 0.5]);
			shader.uniform("uLightColor", "vec3", [0, 0, 0]);

			shader.uniform("uScaleDiffBaseMR", "vec4", [0, 0, 0, 0]);
			shader.uniform("uScaleFGDSpec", "vec4", [0, 0, 0, 0]);
			shader.uniform("uScaleIBLAmbient", "vec4", [1, 1, 1, 1]);

			shader.uniform("uOcclusionStrength", "float", 1);
		}
	}, {
		key: '_onLoaded',
		value: function _onLoaded(gltfInfo) {
			console.log('loaded :', gltfInfo);
			this.mesh = gltfInfo.output.meshes;
		}
	}, {
		key: 'render',
		value: function render(textureIrr, textureRad) {
			if (!this.mesh) {
				return;
			}
			this.shader.bind();

			this.shader.uniform("uGamma", "float", _Config2.default.gamma);
			textureRad.bind(5);
			textureIrr.bind(6);

			_alfrid.GL.draw(this.mesh);
		}
	}]);

	return ViewMicro;
}(_alfrid2.default.View);

exports.default = ViewMicro;

/***/ }),
/* 109 */
/***/ (function(module, exports) {

module.exports = "#define SHADER_NAME gltf_pbr_vert\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\n\n\nvoid main(void) {\n\tvec4 position = uModelMatrix * vec4(aVertexPosition, 1.0);\n\tvPosition     = position.xyz / position.w;\n\t\n\tvNormal       = normalize(vec3(uModelMatrix * vec4(aNormal, 0.0)));\n\t// vNormal       = uNormalMatrix * aNormal;\n\tvTextureCoord = vec2(aTextureCoord.x, 1.0 - aTextureCoord.y);\n\t\n\tgl_Position   = uProjectionMatrix * uViewMatrix * position;\n}\n"

/***/ }),
/* 110 */
/***/ (function(module, exports) {

module.exports = "#define SHADER_NAME pbr_frag\n\n#extension GL_EXT_shader_texture_lod: enable\n#extension GL_OES_standard_derivatives : enable\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D \tuBRDFMap;\nuniform samplerCube uRadianceMap;\nuniform samplerCube uIrradianceMap;\n\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D uColorMap;\n#endif\n\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D uAoMap;\nuniform float uOcclusionStrength;\n#endif\n\n#ifdef HAS_NORMALMAP\nuniform sampler2D uNormalMap;\nuniform float uNormalScale;\n#endif\n\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D uEmissiveMap;\nuniform vec3 uEmissiveFactor;\n#endif\n\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D uMetallicRoughnessMap;\n#endif\n\nuniform vec3 uLightDirection;\nuniform vec3 uLightColor;\nuniform vec3 uCameraPos;\n\nuniform vec4 uScaleDiffBaseMR;\nuniform vec4 uScaleFGDSpec;\nuniform vec4 uScaleIBLAmbient;\n\nuniform vec3 uBaseColor;\nuniform float uRoughness;\nuniform float uMetallic;\nuniform float uGamma;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\n\n//\tFrom GLTF WebGL PBR :\n//\thttps://github.com/KhronosGroup/glTF-WebGL-PBR\n\n// Encapsulate the various inputs used by the various functions in the shading equation\n// We store values in this struct to simplify the integration of alternative implementations\n// of the shading terms, outlined in the Readme.MD Appendix.\nstruct PBRInfo\n{\n\tfloat NdotL;                  // cos angle between normal and light direction\n\tfloat NdotV;                  // cos angle between normal and view direction\n\tfloat NdotH;                  // cos angle between normal and half vector\n\tfloat LdotH;                  // cos angle between light direction and half vector\n\tfloat VdotH;                  // cos angle between view direction and half vector\n\tfloat perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)\n\tfloat metalness;              // metallic value at the surface\n\tvec3 reflectance0;            // full reflectance color (normal incidence angle)\n\tvec3 reflectance90;           // reflectance color at grazing angle\n\tfloat alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])\n\tvec3 diffuseColor;            // color contribution from diffuse lighting\n\tvec3 specularColor;           // color contribution from specular lighting\n};\n\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n\t#ifdef MANUAL_SRGB\n\t#ifdef SRGB_FAST_APPROXIMATION\n\tvec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n\t#else //SRGB_FAST_APPROXIMATION\n\tvec3 bLess = step(vec3(0.04045),srgbIn.xyz);\n\tvec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n\t#endif //SRGB_FAST_APPROXIMATION\n\treturn vec4(linOut,srgbIn.w);;\n\t#else //MANUAL_SRGB\n\treturn srgbIn;\n\t#endif //MANUAL_SRGB\n}\n\n\nvec3 getNormal() {\n\tvec3 pos_dx = dFdx(vPosition);\n\tvec3 pos_dy = dFdy(vPosition);\n\tvec3 tex_dx = dFdx(vec3(vTextureCoord, 0.0));\n\tvec3 tex_dy = dFdy(vec3(vTextureCoord, 0.0));\n\tvec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n\tvec3 ng = normalize(vNormal);\n\n\tt = normalize(t - ng * dot(ng, t));\n\tvec3 b = normalize(cross(ng, t));\n\tmat3 tbn = mat3(t, b, ng);\n\n#ifdef HAS_NORMALMAP\n\tvec3 n = texture2D(uNormalMap, vTextureCoord).rgb;\n\tn = normalize(tbn * ((2.0 * n - 1.0) * vec3(uNormalScale, uNormalScale, 1.0)));\n#else\n\t// The tbn matrix is linearly interpolated, so we need to re-normalize\n\tvec3 n = normalize(tbn[2].xyz);\n#endif\n\n\treturn n;\n}\n\n\nvec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)\n{\n\tfloat mipCount = 8.0; // resolution of 128x128\n\tfloat lod = (pbrInputs.perceptualRoughness * mipCount);\n\t// retrieve a scale and bias to F0. See [1], Figure 3\n\tvec3 brdf = SRGBtoLINEAR(texture2D(uBRDFMap, vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;\n\tvec3 diffuseLight = SRGBtoLINEAR(textureCube(uIrradianceMap, n)).rgb;\n\n\tvec3 specularLight = SRGBtoLINEAR(textureCubeLodEXT(uRadianceMap, reflection, lod)).rgb;\n\n\tvec3 diffuse = diffuseLight * pbrInputs.diffuseColor;\n\tvec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);\n\n\t// For presentation, this allows us to disable IBL terms\n\tdiffuse *= uScaleIBLAmbient.x;\n\tspecular *= uScaleIBLAmbient.y;\n\n\treturn diffuse + specular;\n}\n\n\nvec3 diffuse(PBRInfo pbrInputs)\n{\n\treturn pbrInputs.diffuseColor / M_PI;\n}\n\n\nvec3 specularReflection(PBRInfo pbrInputs)\n{\n\treturn pbrInputs.reflectance0 + (pbrInputs.reflectance90 - pbrInputs.reflectance0) * pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\n}\n\nfloat geometricOcclusion(PBRInfo pbrInputs)\n{\n\tfloat NdotL = pbrInputs.NdotL;\n\tfloat NdotV = pbrInputs.NdotV;\n\tfloat r = pbrInputs.alphaRoughness;\n\n\tfloat attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n\tfloat attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n\treturn attenuationL * attenuationV;\n}\n\n\nfloat microfacetDistribution(PBRInfo pbrInputs)\n{\n\tfloat roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\n\tfloat f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;\n\treturn roughnessSq / (M_PI * f * f);\n}\n\nvoid main() {\n\n\tfloat perceptualRoughness   = uRoughness;\n\tfloat metallic              = uMetallic;\n#ifdef HAS_METALROUGHNESSMAP\n\t// Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.\n\t// This layout intentionally reserves the 'r' channel for (optional) occlusion map data\n\tvec4 mrSample = texture2D(uMetallicRoughnessMap, vTextureCoord);\n\tperceptualRoughness = mrSample.g * perceptualRoughness;\n\tmetallic = mrSample.b * metallic;\n#endif\n\tperceptualRoughness         = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n\tmetallic                    = clamp(metallic, 0.0, 1.0);\n\tfloat alphaRoughness        = perceptualRoughness * perceptualRoughness;\n\n#ifdef HAS_BASECOLORMAP\t\n\tvec4 baseColor = SRGBtoLINEAR(texture2D(uColorMap, vTextureCoord));\n#else\n\tvec4 baseColor              = vec4(uBaseColor, 1.0);\n#endif\t\n\t\n\tvec3 f0                     = vec3(0.04);\n\tvec3 diffuseColor           = baseColor.rgb * (vec3(1.0) - f0);\n\tdiffuseColor                *= 1.0 - metallic;\n\tvec3 specularColor          = mix(f0, baseColor.rgb, metallic);\n\t\n\t// Compute reflectance.\n\tfloat reflectance           = max(max(specularColor.r, specularColor.g), specularColor.b);\n\t\n\t// For typical incident reflectance range (between 4% to 100%) set the grazing reflectance to 100% for typical fresnel effect.\n\t// For very low reflectance range on highly diffuse objects (below 4%), incrementally reduce grazing reflecance to 0%.\n\tfloat reflectance90         = clamp(reflectance * 25.0, 0.0, 1.0);\n\tvec3 specularEnvironmentR0  = specularColor.rgb;\n\tvec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\t\n\tvec3 n                      = getNormal();                             // normal at surface point\n\tvec3 v                      = normalize(uCameraPos - vPosition);        // Vector from surface point to camera\n\tvec3 l                      = normalize(uLightDirection);             // Vector from surface point to light\n\tvec3 h                      = normalize(l+v);                          // Half vector between both l and v\n\tvec3 reflection             = -normalize(reflect(v, n));\n\t\n\tfloat NdotL                 = clamp(dot(n, l), 0.001, 1.0);\n\tfloat NdotV                 = abs(dot(n, v)) + 0.001;\n\tfloat NdotH                 = clamp(dot(n, h), 0.0, 1.0);\n\tfloat LdotH                 = clamp(dot(l, h), 0.0, 1.0);\n\tfloat VdotH                 = clamp(dot(v, h), 0.0, 1.0);\n\n\tPBRInfo pbrInputs = PBRInfo(\n\t\tNdotL,\n\t\tNdotV,\n\t\tNdotH,\n\t\tLdotH,\n\t\tVdotH,\n\t\tperceptualRoughness,\n\t\tmetallic,\n\t\tspecularEnvironmentR0,\n\t\tspecularEnvironmentR90,\n\t\talphaRoughness,\n\t\tdiffuseColor,\n\t\tspecularColor\n\t);\n\n\t// Calculate the shading terms for the microfacet specular shading model\n\tvec3 F              = specularReflection(pbrInputs);\n\tfloat G             = geometricOcclusion(pbrInputs);\n\tfloat D             = microfacetDistribution(pbrInputs);\n\t\n\t// Calculation of analytical lighting contribution\n\tvec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);\n\tvec3 specContrib    = F * G * D / (4.0 * NdotL * NdotV);\n\t// Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)\n\tvec3 color          = NdotL * uLightColor * (diffuseContrib + specContrib);\n\t\n#ifdef USE_IBL\n\tcolor += getIBLContribution(pbrInputs, n, reflection);\n#endif\n\n#ifdef HAS_OCCLUSIONMAP\t\n\tfloat ao            = texture2D(uAoMap, vTextureCoord).r;\n\tcolor               = mix(color, color * ao, uOcclusionStrength);\n#endif\t\n\n#ifdef HAS_EMISSIVEMAP\n\tvec3 emissive = SRGBtoLINEAR(texture2D(uEmissiveMap, vTextureCoord)).rgb * uEmissiveFactor;\n\tcolor += emissive;\n#endif\n\t\n\t// This section uses mix to override final color for reference app visualization\n\t// of various parameters in the lighting equation.\n\tcolor               = mix(color, F, uScaleFGDSpec.x);\n\tcolor               = mix(color, vec3(G), uScaleFGDSpec.y);\n\tcolor               = mix(color, vec3(D), uScaleFGDSpec.z);\n\tcolor               = mix(color, specContrib, uScaleFGDSpec.w);\n\t\n\tcolor               = mix(color, diffuseContrib, uScaleDiffBaseMR.x);\n\tcolor               = mix(color, baseColor.rgb, uScaleDiffBaseMR.y);\n\tcolor               = mix(color, vec3(metallic), uScaleDiffBaseMR.z);\n\tcolor               = mix(color, vec3(perceptualRoughness), uScaleDiffBaseMR.w);\n\t\n\t// output the fragment color\n\tgl_FragColor        = vec4(pow(color,vec3(1.0/uGamma)), baseColor.a);\n\t// gl_FragColor        = vec4(vTextureCoord, 1.0, 1.0);\n\t// gl_FragColor        = vec4(getNormal(), 1.0);\n\n}"

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
Copyright (c) 2014 Petka Antonov

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
function Url() {
    //For more efficient internal representation and laziness.
    //The non-underscore versions of these properties are accessor functions
    //defined on the prototype.
    this._protocol = null;
    this._href = "";
    this._port = -1;
    this._query = null;

    this.auth = null;
    this.slashes = null;
    this.host = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.pathname = null;

    this._prependSlash = false;
}

var querystring = __webpack_require__(112);

Url.queryString = querystring;

Url.prototype.parse =
function Url$parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
    if (typeof str !== "string") {
        throw new TypeError("Parameter 'url' must be a string, not " +
            typeof str);
    }
    var start = 0;
    var end = str.length - 1;

    //Trim leading and trailing ws
    while (str.charCodeAt(start) <= 0x20 /*' '*/) start++;
    while (str.charCodeAt(end) <= 0x20 /*' '*/) end--;

    start = this._parseProtocol(str, start, end);

    //Javascript doesn't have host
    if (this._protocol !== "javascript") {
        start = this._parseHost(str, start, end, hostDenotesSlash);
        var proto = this._protocol;
        if (!this.hostname &&
            (this.slashes || (proto && !slashProtocols[proto]))) {
            this.hostname = this.host = "";
        }
    }

    if (start <= end) {
        var ch = str.charCodeAt(start);

        if (ch === 0x2F /*'/'*/ || ch === 0x5C /*'\'*/) {
            this._parsePath(str, start, end, disableAutoEscapeChars);
        }
        else if (ch === 0x3F /*'?'*/) {
            this._parseQuery(str, start, end, disableAutoEscapeChars);
        }
        else if (ch === 0x23 /*'#'*/) {
          this._parseHash(str, start, end, disableAutoEscapeChars);
        }
        else if (this._protocol !== "javascript") {
            this._parsePath(str, start, end, disableAutoEscapeChars);
        }
        else { //For javascript the pathname is just the rest of it
            this.pathname = str.slice(start, end + 1 );
        }

    }

    if (!this.pathname && this.hostname &&
        this._slashProtocols[this._protocol]) {
        this.pathname = "/";
    }

    if (parseQueryString) {
        var search = this.search;
        if (search == null) {
            search = this.search = "";
        }
        if (search.charCodeAt(0) === 0x3F /*'?'*/) {
            search = search.slice(1);
        }
        //This calls a setter function, there is no .query data property
        this.query = Url.queryString.parse(search);
    }
};

Url.prototype.resolve = function Url$resolve(relative) {
    return this.resolveObject(Url.parse(relative, false, true)).format();
};

Url.prototype.format = function Url$format() {
    var auth = this.auth || "";

    if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ":");
        auth += "@";
    }

    var protocol = this.protocol || "";
    var pathname = this.pathname || "";
    var hash = this.hash || "";
    var search = this.search || "";
    var query = "";
    var hostname = this.hostname || "";
    var port = this.port || "";
    var host = false;
    var scheme = "";

    //Cache the result of the getter function
    var q = this.query;
    if (q && typeof q === "object") {
        query = Url.queryString.stringify(q);
    }

    if (!search) {
        search = query ? "?" + query : "";
    }

    if (protocol && protocol.charCodeAt(protocol.length - 1) !== 0x3A /*':'*/)
        protocol += ":";

    if (this.host) {
        host = auth + this.host;
    }
    else if (hostname) {
        var ip6 = hostname.indexOf(":") > -1;
        if (ip6) hostname = "[" + hostname + "]";
        host = auth + hostname + (port ? ":" + port : "");
    }

    var slashes = this.slashes ||
        ((!protocol ||
        slashProtocols[protocol]) && host !== false);


    if (protocol) scheme = protocol + (slashes ? "//" : "");
    else if (slashes) scheme = "//";

    if (slashes && pathname && pathname.charCodeAt(0) !== 0x2F /*'/'*/) {
        pathname = "/" + pathname;
    }
    if (search && search.charCodeAt(0) !== 0x3F /*'?'*/)
        search = "?" + search;
    if (hash && hash.charCodeAt(0) !== 0x23 /*'#'*/)
        hash = "#" + hash;

    pathname = escapePathName(pathname);
    search = escapeSearch(search);

    return scheme + (host === false ? "" : host) + pathname + search + hash;
};

Url.prototype.resolveObject = function Url$resolveObject(relative) {
    if (typeof relative === "string")
        relative = Url.parse(relative, false, true);

    var result = this._clone();

    // hash is always overridden, no matter what.
    // even href="" will remove it.
    result.hash = relative.hash;

    // if the relative url is empty, then there"s nothing left to do here.
    if (!relative.href) {
        result._href = "";
        return result;
    }

    // hrefs like //foo/bar always cut to the protocol.
    if (relative.slashes && !relative._protocol) {
        relative._copyPropsTo(result, true);

        if (slashProtocols[result._protocol] &&
            result.hostname && !result.pathname) {
            result.pathname = "/";
        }
        result._href = "";
        return result;
    }

    if (relative._protocol && relative._protocol !== result._protocol) {
        // if it"s a known url protocol, then changing
        // the protocol does weird things
        // first, if it"s not file:, then we MUST have a host,
        // and if there was a path
        // to begin with, then we MUST have a path.
        // if it is file:, then the host is dropped,
        // because that"s known to be hostless.
        // anything else is assumed to be absolute.
        if (!slashProtocols[relative._protocol]) {
            relative._copyPropsTo(result, false);
            result._href = "";
            return result;
        }

        result._protocol = relative._protocol;
        if (!relative.host && relative._protocol !== "javascript") {
            var relPath = (relative.pathname || "").split("/");
            while (relPath.length && !(relative.host = relPath.shift()));
            if (!relative.host) relative.host = "";
            if (!relative.hostname) relative.hostname = "";
            if (relPath[0] !== "") relPath.unshift("");
            if (relPath.length < 2) relPath.unshift("");
            result.pathname = relPath.join("/");
        } else {
            result.pathname = relative.pathname;
        }

        result.search = relative.search;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result._port = relative._port;
        result.slashes = result.slashes || relative.slashes;
        result._href = "";
        return result;
    }

    var isSourceAbs =
        (result.pathname && result.pathname.charCodeAt(0) === 0x2F /*'/'*/);
    var isRelAbs = (
            relative.host ||
            (relative.pathname &&
            relative.pathname.charCodeAt(0) === 0x2F /*'/'*/)
        );
    var mustEndAbs = (isRelAbs || isSourceAbs ||
                        (result.host && relative.pathname));

    var removeAllDots = mustEndAbs;

    var srcPath = result.pathname && result.pathname.split("/") || [];
    var relPath = relative.pathname && relative.pathname.split("/") || [];
    var psychotic = result._protocol && !slashProtocols[result._protocol];

    // if the url is a non-slashed url, then relative
    // links like ../.. should be able
    // to crawl up to the hostname, as well.  This is strange.
    // result.protocol has already been set by now.
    // Later on, put the first path part into the host field.
    if (psychotic) {
        result.hostname = "";
        result._port = -1;
        if (result.host) {
            if (srcPath[0] === "") srcPath[0] = result.host;
            else srcPath.unshift(result.host);
        }
        result.host = "";
        if (relative._protocol) {
            relative.hostname = "";
            relative._port = -1;
            if (relative.host) {
                if (relPath[0] === "") relPath[0] = relative.host;
                else relPath.unshift(relative.host);
            }
            relative.host = "";
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
    }

    if (isRelAbs) {
        // it"s absolute.
        result.host = relative.host ?
            relative.host : result.host;
        result.hostname = relative.hostname ?
            relative.hostname : result.hostname;
        result.search = relative.search;
        srcPath = relPath;
        // fall through to the dot-handling below.
    } else if (relPath.length) {
        // it"s relative
        // throw away the existing file, and take the new path instead.
        if (!srcPath) srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
    } else if (relative.search) {
        // just pull out the search.
        // like href="?foo".
        // Put this after the other two cases because it simplifies the booleans
        if (psychotic) {
            result.hostname = result.host = srcPath.shift();
            //occationaly the auth can get stuck only in host
            //this especialy happens in cases like
            //url.resolveObject("mailto:local1@domain1", "local2@domain2")
            var authInHost = result.host && result.host.indexOf("@") > 0 ?
                result.host.split("@") : false;
            if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
            }
        }
        result.search = relative.search;
        result._href = "";
        return result;
    }

    if (!srcPath.length) {
        // no path at all.  easy.
        // we"ve already handled the other stuff above.
        result.pathname = null;
        result._href = "";
        return result;
    }

    // if a url ENDs in . or .., then it must get a trailing slash.
    // however, if it ends in anything else non-slashy,
    // then it must NOT get a trailing slash.
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (
        (result.host || relative.host) && (last === "." || last === "..") ||
        last === "");

    // strip single dots, resolve double dots to parent dir
    // if the path tries to go above the root, `up` ends up > 0
    var up = 0;
    for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last === ".") {
            srcPath.splice(i, 1);
        } else if (last === "..") {
            srcPath.splice(i, 1);
            up++;
        } else if (up) {
            srcPath.splice(i, 1);
            up--;
        }
    }

    // if the path is allowed to go above the root, restore leading ..s
    if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
            srcPath.unshift("..");
        }
    }

    if (mustEndAbs && srcPath[0] !== "" &&
        (!srcPath[0] || srcPath[0].charCodeAt(0) !== 0x2F /*'/'*/)) {
        srcPath.unshift("");
    }

    if (hasTrailingSlash && (srcPath.join("/").substr(-1) !== "/")) {
        srcPath.push("");
    }

    var isAbsolute = srcPath[0] === "" ||
        (srcPath[0] && srcPath[0].charCodeAt(0) === 0x2F /*'/'*/);

    // put the host back
    if (psychotic) {
        result.hostname = result.host = isAbsolute ? "" :
            srcPath.length ? srcPath.shift() : "";
        //occationaly the auth can get stuck only in host
        //this especialy happens in cases like
        //url.resolveObject("mailto:local1@domain1", "local2@domain2")
        var authInHost = result.host && result.host.indexOf("@") > 0 ?
            result.host.split("@") : false;
        if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
        }
    }

    mustEndAbs = mustEndAbs || (result.host && srcPath.length);

    if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
    }

    result.pathname = srcPath.length === 0 ? null : srcPath.join("/");
    result.auth = relative.auth || result.auth;
    result.slashes = result.slashes || relative.slashes;
    result._href = "";
    return result;
};

var punycode = __webpack_require__(115);
Url.prototype._hostIdna = function Url$_hostIdna(hostname) {
    // IDNA Support: Returns a punycoded representation of "domain".
    // It only converts parts of the domain name that
    // have non-ASCII characters, i.e. it doesn't matter if
    // you call it with a domain that already is ASCII-only.
    return punycode.toASCII(hostname);
};

var escapePathName = Url.prototype._escapePathName =
function Url$_escapePathName(pathname) {
    if (!containsCharacter2(pathname, 0x23 /*'#'*/, 0x3F /*'?'*/)) {
        return pathname;
    }
    //Avoid closure creation to keep this inlinable
    return _escapePath(pathname);
};

var escapeSearch = Url.prototype._escapeSearch =
function Url$_escapeSearch(search) {
    if (!containsCharacter2(search, 0x23 /*'#'*/, -1)) return search;
    //Avoid closure creation to keep this inlinable
    return _escapeSearch(search);
};

Url.prototype._parseProtocol = function Url$_parseProtocol(str, start, end) {
    var doLowerCase = false;
    var protocolCharacters = this._protocolCharacters;

    for (var i = start; i <= end; ++i) {
        var ch = str.charCodeAt(i);

        if (ch === 0x3A /*':'*/) {
            var protocol = str.slice(start, i);
            if (doLowerCase) protocol = protocol.toLowerCase();
            this._protocol = protocol;
            return i + 1;
        }
        else if (protocolCharacters[ch] === 1) {
            if (ch < 0x61 /*'a'*/)
                doLowerCase = true;
        }
        else {
            return start;
        }

    }
    return start;
};

Url.prototype._parseAuth = function Url$_parseAuth(str, start, end, decode) {
    var auth = str.slice(start, end + 1);
    if (decode) {
        auth = decodeURIComponent(auth);
    }
    this.auth = auth;
};

Url.prototype._parsePort = function Url$_parsePort(str, start, end) {
    //Internal format is integer for more efficient parsing
    //and for efficient trimming of leading zeros
    var port = 0;
    //Distinguish between :0 and : (no port number at all)
    var hadChars = false;
    var validPort = true;

    for (var i = start; i <= end; ++i) {
        var ch = str.charCodeAt(i);

        if (0x30 /*'0'*/ <= ch && ch <= 0x39 /*'9'*/) {
            port = (10 * port) + (ch - 0x30 /*'0'*/);
            hadChars = true;
        }
        else {
            validPort = false;
            if (ch === 0x5C/*'\'*/ || ch === 0x2F/*'/'*/) {
                validPort = true;
            }
            break;
        }

    }
    if ((port === 0 && !hadChars) || !validPort) {
        if (!validPort) {
            this._port = -2;
        }
        return 0;
    }

    this._port = port;
    return i - start;
};

Url.prototype._parseHost =
function Url$_parseHost(str, start, end, slashesDenoteHost) {
    var hostEndingCharacters = this._hostEndingCharacters;
    var first = str.charCodeAt(start);
    var second = str.charCodeAt(start + 1);
    if ((first === 0x2F /*'/'*/ || first === 0x5C /*'\'*/) &&
        (second === 0x2F /*'/'*/ || second === 0x5C /*'\'*/)) {
        this.slashes = true;

        //The string starts with //
        if (start === 0) {
            //The string is just "//"
            if (end < 2) return start;
            //If slashes do not denote host and there is no auth,
            //there is no host when the string starts with //
            var hasAuth =
                containsCharacter(str, 0x40 /*'@'*/, 2, hostEndingCharacters);
            if (!hasAuth && !slashesDenoteHost) {
                this.slashes = null;
                return start;
            }
        }
        //There is a host that starts after the //
        start += 2;
    }
    //If there is no slashes, there is no hostname if
    //1. there was no protocol at all
    else if (!this._protocol ||
        //2. there was a protocol that requires slashes
        //e.g. in 'http:asd' 'asd' is not a hostname
        slashProtocols[this._protocol]
    ) {
        return start;
    }

    var doLowerCase = false;
    var idna = false;
    var hostNameStart = start;
    var hostNameEnd = end;
    var lastCh = -1;
    var portLength = 0;
    var charsAfterDot = 0;
    var authNeedsDecoding = false;

    var j = -1;

    //Find the last occurrence of an @-sign until hostending character is met
    //also mark if decoding is needed for the auth portion
    for (var i = start; i <= end; ++i) {
        var ch = str.charCodeAt(i);

        if (ch === 0x40 /*'@'*/) {
            j = i;
        }
        //This check is very, very cheap. Unneeded decodeURIComponent is very
        //very expensive
        else if (ch === 0x25 /*'%'*/) {
            authNeedsDecoding = true;
        }
        else if (hostEndingCharacters[ch] === 1) {
            break;
        }
    }

    //@-sign was found at index j, everything to the left from it
    //is auth part
    if (j > -1) {
        this._parseAuth(str, start, j - 1, authNeedsDecoding);
        //hostname starts after the last @-sign
        start = hostNameStart = j + 1;
    }

    //Host name is starting with a [
    if (str.charCodeAt(start) === 0x5B /*'['*/) {
        for (var i = start + 1; i <= end; ++i) {
            var ch = str.charCodeAt(i);

            //Assume valid IP6 is between the brackets
            if (ch === 0x5D /*']'*/) {
                if (str.charCodeAt(i + 1) === 0x3A /*':'*/) {
                    portLength = this._parsePort(str, i + 2, end) + 1;
                }
                var hostname = str.slice(start + 1, i).toLowerCase();
                this.hostname = hostname;
                this.host = this._port > 0 ?
                    "[" + hostname + "]:" + this._port :
                    "[" + hostname + "]";
                this.pathname = "/";
                return i + portLength + 1;
            }
        }
        //Empty hostname, [ starts a path
        return start;
    }

    for (var i = start; i <= end; ++i) {
        if (charsAfterDot > 62) {
            this.hostname = this.host = str.slice(start, i);
            return i;
        }
        var ch = str.charCodeAt(i);

        if (ch === 0x3A /*':'*/) {
            portLength = this._parsePort(str, i + 1, end) + 1;
            hostNameEnd = i - 1;
            break;
        }
        else if (ch < 0x61 /*'a'*/) {
            if (ch === 0x2E /*'.'*/) {
                //Node.js ignores this error
                /*
                if (lastCh === DOT || lastCh === -1) {
                    this.hostname = this.host = "";
                    return start;
                }
                */
                charsAfterDot = -1;
            }
            else if (0x41 /*'A'*/ <= ch && ch <= 0x5A /*'Z'*/) {
                doLowerCase = true;
            }
            //Valid characters other than ASCII letters -, _, +, 0-9
            else if (!(ch === 0x2D /*'-'*/ ||
                       ch === 0x5F /*'_'*/ ||
                       ch === 0x2B /*'+'*/ ||
                       (0x30 /*'0'*/ <= ch && ch <= 0x39 /*'9'*/))
                ) {
                if (hostEndingCharacters[ch] === 0 &&
                    this._noPrependSlashHostEnders[ch] === 0) {
                    this._prependSlash = true;
                }
                hostNameEnd = i - 1;
                break;
            }
        }
        else if (ch >= 0x7B /*'{'*/) {
            if (ch <= 0x7E /*'~'*/) {
                if (this._noPrependSlashHostEnders[ch] === 0) {
                    this._prependSlash = true;
                }
                hostNameEnd = i - 1;
                break;
            }
            idna = true;
        }
        lastCh = ch;
        charsAfterDot++;
    }

    //Node.js ignores this error
    /*
    if (lastCh === DOT) {
        hostNameEnd--;
    }
    */

    if (hostNameEnd + 1 !== start &&
        hostNameEnd - hostNameStart <= 256) {
        var hostname = str.slice(hostNameStart, hostNameEnd + 1);
        if (doLowerCase) hostname = hostname.toLowerCase();
        if (idna) hostname = this._hostIdna(hostname);
        this.hostname = hostname;
        this.host = this._port > 0 ? hostname + ":" + this._port : hostname;
    }

    return hostNameEnd + 1 + portLength;

};

Url.prototype._copyPropsTo = function Url$_copyPropsTo(input, noProtocol) {
    if (!noProtocol) {
        input._protocol = this._protocol;
    }
    input._href = this._href;
    input._port = this._port;
    input._prependSlash = this._prependSlash;
    input.auth = this.auth;
    input.slashes = this.slashes;
    input.host = this.host;
    input.hostname = this.hostname;
    input.hash = this.hash;
    input.search = this.search;
    input.pathname = this.pathname;
};

Url.prototype._clone = function Url$_clone() {
    var ret = new Url();
    ret._protocol = this._protocol;
    ret._href = this._href;
    ret._port = this._port;
    ret._prependSlash = this._prependSlash;
    ret.auth = this.auth;
    ret.slashes = this.slashes;
    ret.host = this.host;
    ret.hostname = this.hostname;
    ret.hash = this.hash;
    ret.search = this.search;
    ret.pathname = this.pathname;
    return ret;
};

Url.prototype._getComponentEscaped =
function Url$_getComponentEscaped(str, start, end, isAfterQuery) {
    var cur = start;
    var i = start;
    var ret = "";
    var autoEscapeMap = isAfterQuery ?
        this._afterQueryAutoEscapeMap : this._autoEscapeMap;
    for (; i <= end; ++i) {
        var ch = str.charCodeAt(i);
        var escaped = autoEscapeMap[ch];

        if (escaped !== "" && escaped !== undefined) {
            if (cur < i) ret += str.slice(cur, i);
            ret += escaped;
            cur = i + 1;
        }
    }
    if (cur < i + 1) ret += str.slice(cur, i);
    return ret;
};

Url.prototype._parsePath =
function Url$_parsePath(str, start, end, disableAutoEscapeChars) {
    var pathStart = start;
    var pathEnd = end;
    var escape = false;
    var autoEscapeCharacters = this._autoEscapeCharacters;
    var prePath = this._port === -2 ? "/:" : "";

    for (var i = start; i <= end; ++i) {
        var ch = str.charCodeAt(i);
        if (ch === 0x23 /*'#'*/) {
          this._parseHash(str, i, end, disableAutoEscapeChars);
            pathEnd = i - 1;
            break;
        }
        else if (ch === 0x3F /*'?'*/) {
            this._parseQuery(str, i, end, disableAutoEscapeChars);
            pathEnd = i - 1;
            break;
        }
        else if (!disableAutoEscapeChars && !escape && autoEscapeCharacters[ch] === 1) {
            escape = true;
        }
    }

    if (pathStart > pathEnd) {
        this.pathname = prePath === "" ? "/" : prePath;
        return;
    }

    var path;
    if (escape) {
        path = this._getComponentEscaped(str, pathStart, pathEnd, false);
    }
    else {
        path = str.slice(pathStart, pathEnd + 1);
    }
    this.pathname = prePath === ""
        ? (this._prependSlash ? "/" + path : path)
        : prePath + path;
};

Url.prototype._parseQuery = function Url$_parseQuery(str, start, end, disableAutoEscapeChars) {
    var queryStart = start;
    var queryEnd = end;
    var escape = false;
    var autoEscapeCharacters = this._autoEscapeCharacters;

    for (var i = start; i <= end; ++i) {
        var ch = str.charCodeAt(i);

        if (ch === 0x23 /*'#'*/) {
            this._parseHash(str, i, end, disableAutoEscapeChars);
            queryEnd = i - 1;
            break;
        }
        else if (!disableAutoEscapeChars && !escape && autoEscapeCharacters[ch] === 1) {
            escape = true;
        }
    }

    if (queryStart > queryEnd) {
        this.search = "";
        return;
    }

    var query;
    if (escape) {
        query = this._getComponentEscaped(str, queryStart, queryEnd, true);
    }
    else {
        query = str.slice(queryStart, queryEnd + 1);
    }
    this.search = query;
};

Url.prototype._parseHash = function Url$_parseHash(str, start, end, disableAutoEscapeChars) {
    if (start > end) {
        this.hash = "";
        return;
    }

    this.hash = disableAutoEscapeChars ?
        str.slice(start, end + 1) : this._getComponentEscaped(str, start, end, true);
};

Object.defineProperty(Url.prototype, "port", {
    get: function() {
        if (this._port >= 0) {
            return ("" + this._port);
        }
        return null;
    },
    set: function(v) {
        if (v == null) {
            this._port = -1;
        }
        else {
            this._port = parseInt(v, 10);
        }
    }
});

Object.defineProperty(Url.prototype, "query", {
    get: function() {
        var query = this._query;
        if (query != null) {
            return query;
        }
        var search = this.search;

        if (search) {
            if (search.charCodeAt(0) === 0x3F /*'?'*/) {
                search = search.slice(1);
            }
            if (search !== "") {
                this._query = search;
                return search;
            }
        }
        return search;
    },
    set: function(v) {
        this._query = v;
    }
});

Object.defineProperty(Url.prototype, "path", {
    get: function() {
        var p = this.pathname || "";
        var s = this.search || "";
        if (p || s) {
            return p + s;
        }
        return (p == null && s) ? ("/" + s) : null;
    },
    set: function() {}
});

Object.defineProperty(Url.prototype, "protocol", {
    get: function() {
        var proto = this._protocol;
        return proto ? proto + ":" : proto;
    },
    set: function(v) {
        if (typeof v === "string") {
            var end = v.length - 1;
            if (v.charCodeAt(end) === 0x3A /*':'*/) {
                this._protocol = v.slice(0, end);
            }
            else {
                this._protocol = v;
            }
        }
        else if (v == null) {
            this._protocol = null;
        }
    }
});

Object.defineProperty(Url.prototype, "href", {
    get: function() {
        var href = this._href;
        if (!href) {
            href = this._href = this.format();
        }
        return href;
    },
    set: function(v) {
        this._href = v;
    }
});

Url.parse = function Url$Parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
    if (str instanceof Url) return str;
    var ret = new Url();
    ret.parse(str, !!parseQueryString, !!hostDenotesSlash, !!disableAutoEscapeChars);
    return ret;
};

Url.format = function Url$Format(obj) {
    if (typeof obj === "string") {
        obj = Url.parse(obj);
    }
    if (!(obj instanceof Url)) {
        return Url.prototype.format.call(obj);
    }
    return obj.format();
};

Url.resolve = function Url$Resolve(source, relative) {
    return Url.parse(source, false, true).resolve(relative);
};

Url.resolveObject = function Url$ResolveObject(source, relative) {
    if (!source) return relative;
    return Url.parse(source, false, true).resolveObject(relative);
};

function _escapePath(pathname) {
    return pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
    });
}

function _escapeSearch(search) {
    return search.replace(/#/g, function(match) {
        return encodeURIComponent(match);
    });
}

//Search `char1` (integer code for a character) in `string`
//starting from `fromIndex` and ending at `string.length - 1`
//or when a stop character is found
function containsCharacter(string, char1, fromIndex, stopCharacterTable) {
    var len = string.length;
    for (var i = fromIndex; i < len; ++i) {
        var ch = string.charCodeAt(i);

        if (ch === char1) {
            return true;
        }
        else if (stopCharacterTable[ch] === 1) {
            return false;
        }
    }
    return false;
}

//See if `char1` or `char2` (integer codes for characters)
//is contained in `string`
function containsCharacter2(string, char1, char2) {
    for (var i = 0, len = string.length; i < len; ++i) {
        var ch = string.charCodeAt(i);
        if (ch === char1 || ch === char2) return true;
    }
    return false;
}

//Makes an array of 128 uint8's which represent boolean values.
//Spec is an array of ascii code points or ascii code point ranges
//ranges are expressed as [start, end]

//Create a table with the characters 0x30-0x39 (decimals '0' - '9') and
//0x7A (lowercaseletter 'z') as `true`:
//
//var a = makeAsciiTable([[0x30, 0x39], 0x7A]);
//a[0x30]; //1
//a[0x15]; //0
//a[0x35]; //1
function makeAsciiTable(spec) {
    var ret = new Uint8Array(128);
    spec.forEach(function(item){
        if (typeof item === "number") {
            ret[item] = 1;
        }
        else {
            var start = item[0];
            var end = item[1];
            for (var j = start; j <= end; ++j) {
                ret[j] = 1;
            }
        }
    });

    return ret;
}


var autoEscape = ["<", ">", "\"", "`", " ", "\r", "\n",
    "\t", "{", "}", "|", "\\", "^", "`", "'"];

var autoEscapeMap = new Array(128);



for (var i = 0, len = autoEscapeMap.length; i < len; ++i) {
    autoEscapeMap[i] = "";
}

for (var i = 0, len = autoEscape.length; i < len; ++i) {
    var c = autoEscape[i];
    var esc = encodeURIComponent(c);
    if (esc === c) {
        esc = escape(c);
    }
    autoEscapeMap[c.charCodeAt(0)] = esc;
}
var afterQueryAutoEscapeMap = autoEscapeMap.slice();
autoEscapeMap[0x5C /*'\'*/] = "/";

var slashProtocols = Url.prototype._slashProtocols = {
    http: true,
    https: true,
    gopher: true,
    file: true,
    ftp: true,

    "http:": true,
    "https:": true,
    "gopher:": true,
    "file:": true,
    "ftp:": true
};

//Optimize back from normalized object caused by non-identifier keys
function f(){}
f.prototype = slashProtocols;

Url.prototype._protocolCharacters = makeAsciiTable([
    [0x61 /*'a'*/, 0x7A /*'z'*/],
    [0x41 /*'A'*/, 0x5A /*'Z'*/],
    0x2E /*'.'*/, 0x2B /*'+'*/, 0x2D /*'-'*/
]);

Url.prototype._hostEndingCharacters = makeAsciiTable([
    0x23 /*'#'*/, 0x3F /*'?'*/, 0x2F /*'/'*/, 0x5C /*'\'*/
]);

Url.prototype._autoEscapeCharacters = makeAsciiTable(
    autoEscape.map(function(v) {
        return v.charCodeAt(0);
    })
);

//If these characters end a host name, the path will not be prepended a /
Url.prototype._noPrependSlashHostEnders = makeAsciiTable(
    [
        "<", ">", "'", "`", " ", "\r",
        "\n", "\t", "{", "}", "|",
        "^", "`", "\"", "%", ";"
    ].map(function(v) {
        return v.charCodeAt(0);
    })
);

Url.prototype._autoEscapeMap = autoEscapeMap;
Url.prototype._afterQueryAutoEscapeMap = afterQueryAutoEscapeMap;

module.exports = Url;

Url.replace = function Url$Replace() {
    __webpack_require__.c.url = {
        exports: Url
    };
};


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(113);
exports.encode = exports.stringify = __webpack_require__(114);


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(116)(module), __webpack_require__(42)))

/***/ }),
/* 116 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var QueryStringSerializer = __webpack_require__(118);
module.exports = QueryStringParser;

var rplus = /\+/g;
var rint = /^[0-9]+$/;
var isArray = Array.isArray;
var haveProp = {}.hasOwnProperty;

function QueryStringParser() {
    this.containsSparse = false;
    this.cacheKey = "";
    this.cacheVal = null;
}

QueryStringParser.maxLength = 32768;
QueryStringParser.maxDepth = 4;
QueryStringParser.maxKeys = 256;

QueryStringParser.parse = function QueryStringParser$Parse(str) {
    if (typeof str === "string") {
        var maxLength = QueryStringParser.maxLength;
        if (str.length > maxLength) {
            throw new RangeError(
                "str is too large (" +
                "QueryStringParser.maxLength=" + maxLength + ")"
            );
        }
        var parser = new QueryStringParser();
        return parser.parseString(str, false);
    }
    else if (str !== null && typeof str === "object") {
        var parser = new QueryStringParser();
        return parser.parseObject(str);
    }
    return {};
};

QueryStringParser.stringify =
function QueryStringParser$Stringify(value) {
    var serializer = new QueryStringSerializer();
    return serializer.serialize(value);
};

QueryStringParser.prototype.decode =
function QueryStringParser$decode(str, shouldDecode, containsPlus) {
    if (shouldDecode === false) return str;
    if (containsPlus === true) str = str.replace(rplus, " ");
    try {
        return decodeURIComponent(str);
    }
    catch (e) {
        return str;
    }
};

QueryStringParser.prototype.maybeArrayIndex =
function QueryStringParser$maybeArrayIndex(str, arrayLength) {
    var len = str.length;
    if (len === 0) {
        return arrayLength;
    }
    var ch = str.charCodeAt(0);

    if (ch === 48) {
        return len > 1 ? -1 : 0;
    }
    else if (48 <= ch && ch <= 57) {
        if (len === 1) {
            return ch - 48;
        }
        else if (rint.test(str)) {
            var v = parseInt(str, 10);
            if (0 < v && v <= 1073741822) {
                return v;
            }
        }
    }
    return -1;
};

QueryStringParser.prototype.getSlot =
function QueryStringParser$getSlot(dictionary, prevKey, curKey) {
    var slot;
    if (!(haveProp.call(dictionary, prevKey))) {
        var index = this.maybeArrayIndex(curKey, 0);
        if (index > -1) {
            slot = [];
        }
        else {
            slot = {};
        }
        dictionary[prevKey] = slot;
    }
    else {
        slot = dictionary[prevKey];
    }
    return slot;
};

QueryStringParser.prototype.placeNestedValue =
function QueryStringParser$placeNestedValue
(dictionary, key, value, i, prevKey, curKey) {
    var slot = this.getSlot(dictionary, prevKey, curKey);
    var index = -1;

    if (isArray(slot)) {
        index = this.maybeArrayIndex(curKey, slot.length);
    }

    var len = key.length;
    var depth = 2;
    var maxDepth = QueryStringParser.maxDepth;
    var start = -1;
    for (; i < len; ++i) {
        var ch = key.charCodeAt(i);
        if (ch === 91) {
            start = i + 1;
        }
        else if (ch === 93 &&
                start > -1) {
            prevKey = curKey;
            curKey = start === i ? "" : key.substring(start, i);
            start = -1;
            depth++;
            if (depth > maxDepth) {
                throw new RangeError("Nesting depth of keys is too large " +
                    "(QueryStringParser.maxDepth="+maxDepth+")" );
            }
            slot = this.getSlot(slot, prevKey, curKey);

            index = isArray(slot)
                ? this.maybeArrayIndex(curKey, slot.length)
                : -1;
        }
    }

    if(index > -1) {
        if (value !== "") {
            if (index === slot.length) {
                slot.push(value);
            }
            else {
                this.containsSparse = true;
                slot[index] = value;
            }
        }
    }
    else {
        this.insert(slot, curKey, value);
    }
};

QueryStringParser.prototype.insert =
function QueryStringParser$insert(dictionary, key, value) {
    var ret = null;
    if (haveProp.call(dictionary, key)) {
        var prev = dictionary[key];
        if( isArray(prev) ) {
            prev.push(value);
            ret = prev;
        }
        else {
            ret = [prev, value];
            dictionary[key] = ret;
        }
    }
    else {
        dictionary[key] = value;
    }
    return ret;
};

QueryStringParser.prototype.push =
function QueryStringParser$push(dictionary, key, value) {
    var ret = null;
    if (haveProp.call(dictionary, key)) {
        var prev = dictionary[key];
        prev.push(value);
        ret = prev;
    }
    else {
        ret = [value];
        dictionary[key] = ret;
    }
    return ret;
};

QueryStringParser.prototype.maybePlaceNestedValue =
function QueryStringParser$maybePlaceNestedValue(dictionary, key, value) {
    var len = key.length;
    if (key.charCodeAt(len - 1) !== 93) {
        this.placeValue(dictionary, key, value, false);
        return;
    }
    var start = -1;

    var i = 0;
    var curKey;
    var prevKey;

    for (; i < len; ++i) {
        var ch = key.charCodeAt(i);

        if (ch === 91) {
            start = i + 1;
            prevKey = key.slice(0, i);
        }
        else if (ch === 93) {
            if (start < 0) {
                this.placeValue(dictionary, key, value, false);
                return;
            }
            curKey = start === i ? "" : key.slice(start, i);
            i++;
            break;
        }
    }

    if (curKey === void 0) {
        this.placeValue(dictionary, key, value, false);
        return;
    }

    if (curKey === "" && value !== "" && i === len) {
        if (key === this.cacheKey) {
            this.cacheVal.push(value);
        }
        else {
            this.cacheKey = key;
            this.cacheVal = this.push(dictionary, prevKey, value);
        }
    }
    else {
        this.placeNestedValue(dictionary, key, value, i, prevKey, curKey);
    }
};

QueryStringParser.prototype.placeValue =
function QueryStringParser$placeValue(dictionary, key, value, possiblyNested) {
    if (possiblyNested === true) {
        this.maybePlaceNestedValue(dictionary, key, value);
        return;
    }
    if (key === this.cacheKey) {
        this.cacheVal.push(value);
        return;
    }
    var cache = this.insert(dictionary, key, value);
    if (cache !== null) {
        this.cacheKey = key;
        this.cacheVal = cache;
    }
};

QueryStringParser.prototype.compact =
function QueryStringParser$compact(obj) {
    if (isArray(obj)) {
        var ret = [];
        var keys = Object.keys(obj);
        for( var i = 0, len = keys.length; i < len; ++i ) {
            ret.push(obj[keys[i]]);
        }
        return ret;
    }
    else if (typeof obj === "object") {
        var keys = Object.keys(obj);
        for( var i = 0, len = keys.length; i < len; ++i ) {
            var key = keys[i];
            obj[key] = this.compact(obj[key]);
        }
    }
    else {
        return obj;
    }
};

QueryStringParser.prototype.parseObject =
function QueryStringParser$parseObject(obj) {
    var keys = Object.keys(obj);
    var len = keys.length;
    if (len === 0) {
        return {};
    }
    len--;
    var ret = "";
    var key;
    for( var i = 0; i < len; ++i ) {
        key = keys[i];
        ret += key + "=" + obj[key] + "&";
    }
    key = keys[i];
    ret += key + "=" + obj[key];
    return this.parseString(ret, true);
};

QueryStringParser.prototype.parseString =
function QueryStringParser$parseString(str, noDecode) {
    var maxKeys = QueryStringParser.maxKeys;
    var keys = 0;
    var decodeKey = false;
    var decodeValue = false;
    var possiblyNested = false;
    var len = str.length;
    var i = 0;
    var dictionary = {};
    var keyStart = 0;
    var keyEnd = 0;
    var valueStart = 0;
    var valueEnd = 0;
    var left = 0;
    var lastIndex = len - 1;
    var containsPlus = false;


    for (; i < len; ++i) {
        var ch = str.charCodeAt(i);

        if (ch === 91) {
            left++;
        }
        else if (left > 0 && ch === 93) {
            possiblyNested = true;
            left--;
        }
        else if (left === 0 && ch === 61) {
            var j = i + 1;

            keyEnd = i - 1;
            valueEnd = valueStart = j;
            var key = str.slice(keyStart, keyEnd + 1);
            key = this.decode(key, decodeKey, containsPlus);
            decodeKey = false;

            for (; j < len; ++j) {
                ch = str.charCodeAt(j);
                if ((ch === 43 || ch === 37) && !noDecode) {
                    if (ch === 43) containsPlus = true;
                    decodeValue = true;
                }
                if (ch === 38 || j === lastIndex) {
                    valueEnd = j;
                    i = j;

                    if (ch === 38) {
                        valueEnd--;
                    }

                    var value = str.slice(valueStart, valueEnd + 1);
                    value = this.decode(value, decodeValue, containsPlus);

                    this.placeValue(dictionary, key, value, possiblyNested);

                    containsPlus = decodeValue = false;
                    possiblyNested = false;

                    keyStart = j + 1;
                    keys++;
                    if (keys > maxKeys) {
                        throw new RangeError("Amount of keys is too large " +
                            "(QueryStringParser.maxKeys=" + maxKeys + ")");
                    }
                    break;
                }
            }
        }
        else if ((ch === 43 || ch === 37) && !noDecode) {
            if (ch === 43) containsPlus = true;
            decodeKey = true;
        }
    }
    if (keyStart !== len) {
        var value = "";
        var key = str.slice(keyStart, len);
        key = this.decode(key, decodeKey, containsPlus);
        this.placeValue(dictionary, key, value, possiblyNested);
    }


    if (this.containsSparse) {
        this.compact(dictionary);
    }

    return dictionary;
};


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

module.exports = QueryStringSerializer;
var enc = encodeURIComponent;
var ARRAY = [];
var isArray = Array.isArray;
var getProto = Object.getPrototypeOf;
var oProto = getProto({});

function isObject(obj) {
    if (isArray(obj)) {
        return true;
    }
    if (obj === null || typeof obj !== "object") {
        return false;
    }
    var proto = getProto(obj);

    return proto === oProto || proto === null;
}

function QueryStringSerializer() {

}

QueryStringSerializer.prototype.serialize =
function QueryStringSerializer$serialize(obj) {
    if (obj === null ||
        typeof obj !== "object") {
        throw new TypeError("the obj to stringify must be an object");
    }
    var keys = Object.keys(obj);
    var len = keys.length;
    var array = ARRAY;
    var stack = [];
    var ret = [];
    var cur = obj;
    var keyPrefix = "";

    for (var i = 0; i < len; ++i) {
        var key = keys === array ? i : keys[i];
        var value = cur[key];
        if (isObject(value)) {
            stack.push(keyPrefix, cur, keys, len, i);

            if (keyPrefix === "") {
                keyPrefix = key;
            }
            else {
                keyPrefix = keyPrefix + "[" + enc(key) + "]";
            }

            if (isArray(value)) {
                keys = array;
                len = value.length;
            }
            else {
                keys = Object.keys(value);
                len = keys.length;
            }
            i = -1;
            cur = value;
        }
        else {
            if (typeof value !== "string") {
                value = "" + value;
            }

            var serializedKey = keyPrefix === ""
                                ? enc(key)
                                : keyPrefix + "[" + enc(key) + "]";
            ret.push(serializedKey + "=" + enc(value));
        }

        if(i === len - 1 && stack.length > 0) {
            i = stack.pop();
            len = stack.pop();
            keys = stack.pop();
            cur = stack.pop();
            keyPrefix = stack.pop();
        }
    }

    return ret.join("&");
};


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assetsLoader = __webpack_require__(120);
assetsLoader.stats = __webpack_require__(100);

module.exports = assetsLoader;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Emitter = __webpack_require__(99);
var createLoader = __webpack_require__(122);
var autoId = 0;

module.exports = function createGroup(config) {
    var group;
    var map = {};
    var assets = [];
    var queue = [];
    var numLoaded = 0;
    var numTotal = 0;
    var loaders = {};

    var add = function(options) {
        // console.debug('add', options);
        if (Array.isArray(options)) {
            options.forEach(add);
            return group;
        }
        var isGroup = !!options.assets && Array.isArray(options.assets);
        // console.debug('isGroup', isGroup);
        var loader;
        if (isGroup) {
            loader = createGroup(configure(options, config));
        } else {
            loader = createLoader(configure(options, config));
        }
        loader.once('destroy', destroyHandler);
        queue.push(loader);
        loaders[loader.id] = loader;
        return group;
    };

    var get = function(id) {
        if (!arguments.length) {
            return assets;
        }
        if (map[id]) {
            return map[id];
        }
        return loaders[id];
    };

    var find = function(id) {
        if (get(id)) {
            return get(id);
        }
        var found = null;
        Object.keys(loaders).some(function(key) {
            found = loaders[key].find && loaders[key].find(id);
            return !!found;
        });
        return found;
    };

    var getExtension = function(url) {
        return url && url.split('?')[0].split('.').pop().toLowerCase();
    };

    var configure = function(options, defaults) {
        if (typeof options === 'string') {
            var url = options;
            options = {
                url: url
            };
        }

        if (options.isTouchLocked === undefined) {
            options.isTouchLocked = defaults.isTouchLocked;
        }

        if (options.blob === undefined) {
            options.blob = defaults.blob;
        }

        if (options.basePath === undefined) {
            options.basePath = defaults.basePath;
        }

        options.id = options.id || options.url || String(++autoId);
        options.type = options.type || getExtension(options.url);
        options.crossOrigin = options.crossOrigin || defaults.crossOrigin;
        options.webAudioContext = options.webAudioContext || defaults.webAudioContext;
        options.log = defaults.log;

        return options;
    };

    var start = function() {
        numTotal = queue.length;

        queue.forEach(function(loader) {
            loader
                .on('progress', progressHandler)
                .once('complete', completeHandler)
                .once('error', errorHandler)
                .start();
        });

        queue = [];

        return group;
    };

    var progressHandler = function(progress) {
        var loaded = numLoaded + progress;
        group.emit('progress', loaded / numTotal);
    };

    var completeHandler = function(asset, id, type) {
        if (Array.isArray(asset)) {
            asset = { id: id, file: asset, type: type };
        }
        numLoaded++;
        group.emit('progress', numLoaded / numTotal);
        map[asset.id] = asset.file;
        assets.push(asset);
        group.emit('childcomplete', asset);
        checkComplete();
    };

    var errorHandler = function(err) {
        numTotal--;
        if (group.listeners('error').length) {
            group.emit('error', err);
        } else {
            console.error(err);
        }
        checkComplete();
    };

    var destroyHandler = function(id) {
        loaders[id] = null;
        delete loaders[id];

        map[id] = null;
        delete map[id];

        assets.some(function(asset, i) {
            if (asset.id === id) {
                assets.splice(i, 1);
                return true;
            }
        });
    };

    var checkComplete = function() {
        if (numLoaded >= numTotal) {
            group.emit('complete', assets, map, config.id, 'group');
        }
    };

    var destroy = function() {
        while (queue.length) {
            queue.pop().destroy();
        }
        group.off('error');
        group.off('progress');
        group.off('complete');
        assets = [];
        map = {};
        config.webAudioContext = null;
        numTotal = 0;
        numLoaded = 0;

        Object.keys(loaders).forEach(function(key) {
            loaders[key].destroy();
        });
        loaders = {};

        group.emit('destroy', group.id);

        return group;
    };

    // emits: progress, error, complete, destroy

    group = Object.create(Emitter.prototype, {
        _events: {
            value: {}
        },
        id: {
            get: function() {
                return config.id;
            }
        },
        add: {
            value: add
        },
        start: {
            value: start
        },
        get: {
            value: get
        },
        find: {
            value: find
        },
        getLoader: {
            value: function(id) {
                return loaders[id];
            }
        },
        loaded: {
            get: function() {
                return numLoaded >= numTotal;
            }
        },
        file: {
            get: function() {
                return assets;
            }
        },
        destroy: {
            value: destroy
        }
    });

    config = configure(config || {}, {
        basePath: '',
        blob: false,
        touchLocked: false,
        crossOrigin: null,
        webAudioContext: null,
        log: false
    });

    if (Array.isArray(config.assets)) {
        add(config.assets);
    }

    return Object.freeze(group);
};


/***/ }),
/* 121 */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Emitter = __webpack_require__(99);
var browserHasBlob = __webpack_require__(123);
var stats = __webpack_require__(100);

module.exports = function(options) {
    var id = options.id;
    var basePath = options.basePath || '';
    var url = options.url;
    var type = options.type;
    var crossOrigin = options.crossOrigin;
    var isTouchLocked = options.isTouchLocked;
    var blob = options.blob && browserHasBlob;
    var webAudioContext = options.webAudioContext;
    var log = options.log;

    var loader;
    var loadHandler;
    var request;
    var startTime;
    var timeout;
    var file;

    var start = function() {
        startTime = Date.now();

        switch (type) {
            case 'json':
                loadJSON();
                break;
            case 'jpg':
            case 'png':
            case 'gif':
            case 'webp':
                loadImage();
                break;
            case 'mp3':
            case 'ogg':
            case 'opus':
            case 'wav':
            case 'm4a':
                loadAudio();
                break;
            case 'ogv':
            case 'mp4':
            case 'webm':
            case 'hls':
                loadVideo();
                break;
            case 'bin':
            case 'binary':
                loadXHR('arraybuffer');
                break;
            case 'txt':
            case 'text':
                loadXHR('text');
                break;
            default:
                throw 'AssetsLoader ERROR: Unknown type for file with URL: ' + basePath + url + ' (' + type + ')';
        }
    };

    var dispatchComplete = function(data) {
        if (!data) {
            return;
        }
        file = {id: id, file: data, type: type};
        loader.emit('progress', 1);
        loader.emit('complete', file, id, type);
        removeListeners();
    };

    var loadXHR = function(responseType, customLoadHandler) {
        loadHandler = customLoadHandler || completeHandler;

        request = new XMLHttpRequest();
        request.open('GET', basePath + url, true);
        request.responseType = responseType;
        request.addEventListener('progress', progressHandler);
        request.addEventListener('load', loadHandler);
        request.addEventListener('error', errorHandler);
        request.send();
    };

    var progressHandler = function(event) {
        if (event.lengthComputable) {
            loader.emit('progress', event.loaded / event.total);
        }
    };

    var completeHandler = function() {
        if (success()) {
            dispatchComplete(request.response);
        }
    };

    var success = function() {
        // console.log('success', url, request.status);
        if (request && request.status < 400) {
            stats.update(request, startTime, url, log);
            return true;
        }
        errorHandler(request && request.statusText);
        return false;
    };

    // json

    var loadJSON = function() {
        loadXHR('json', function() {
            if (success()) {
                var data = request.response;
                if (typeof data === 'string') {
                    data = JSON.parse(data);
                }
                dispatchComplete(data);
            }
        });
    };

    // image

    var loadImage = function() {
        if (blob) {
            loadImageBlob();
        } else {
            loadImageElement();
        }
    };

    var loadImageElement = function() {
        request = new Image();
        if (crossOrigin) {
            request.crossOrigin = 'anonymous';
        }
        request.addEventListener('error', errorHandler, false);
        request.addEventListener('load', elementLoadHandler, false);
        request.src = basePath + url;
    };

    var elementLoadHandler = function(event) {
        window.clearTimeout(timeout);
        if (!event && (request.error || !request.readyState)) {
            errorHandler();
            return;
        }
        dispatchComplete(request);
    };

    var loadImageBlob = function() {
        loadXHR('blob', function() {
            if (success()) {
                request = new Image();
                request.addEventListener('error', errorHandler, false);
                request.addEventListener('load', imageBlobHandler, false);
                request.src = window.URL.createObjectURL(request.response);
            }
        });
    };

    var imageBlobHandler = function() {
        window.URL.revokeObjectURL(request.src);
        dispatchComplete(request);
    };

    // audio

    var loadAudio = function() {
        if (webAudioContext) {
            loadAudioBuffer();
        } else {
            loadMediaElement('audio');
        }
    };

    // video

    var loadVideo = function() {
        if (blob) {
            loadXHR('blob');
        } else {
            loadMediaElement('video');
        }
    };

    // audio buffer

    var loadAudioBuffer = function() {
        loadXHR('arraybuffer', function() {
            if (success()) {
                webAudioContext.decodeAudioData(
                    request.response,
                    function(buffer) {
                        request = null;
                        dispatchComplete(buffer);
                    },
                    function(e) {
                        errorHandler(e);
                    }
                );
            }
        });
    };

    // media element

    var loadMediaElement = function(tagName) {
        request = document.createElement(tagName);

        if (!isTouchLocked) {
            // timeout because sometimes canplaythrough doesn't fire
            window.clearTimeout(timeout);
            timeout = window.setTimeout(elementLoadHandler, 2000);
            request.addEventListener('canplaythrough', elementLoadHandler, false);
        }

        request.addEventListener('error', errorHandler, false);
        request.preload = 'auto';
        request.src = basePath + url;
        request.load();

        if (isTouchLocked) {
            dispatchComplete(request);
        }
    };

    // error

    var errorHandler = function(err) {
        // console.log('errorHandler', url, err);
        window.clearTimeout(timeout);

        var message = err;

        if (request && request.tagName && request.error) {
            var ERROR_STATE = ['', 'ABORTED', 'NETWORK', 'DECODE', 'SRC_NOT_SUPPORTED'];
            message = 'MediaError: ' + ERROR_STATE[request.error.code] + ' ' + request.src;
        } else if (request && request.statusText) {
            message = request.statusText;
        } else if (err && err.message) {
            message = err.message;
        } else if (err && err.type) {
            message = err.type;
        }

        loader.emit('error', 'Error loading "' + basePath + url + '" ' + message);

        destroy();
    };

    // clean up

    var removeListeners = function() {
        loader.off('error');
        loader.off('progress');
        loader.off('complete');

        if (request) {
            request.removeEventListener('progress', progressHandler);
            request.removeEventListener('load', loadHandler);
            request.removeEventListener('error', errorHandler);
            request.removeEventListener('load', elementLoadHandler);
            request.removeEventListener('canplaythrough', elementLoadHandler);
            request.removeEventListener('load', imageBlobHandler);
        }
    };

    var destroy = function() {
        removeListeners();

        if (request && request.abort && request.readyState < 4) {
            request.abort();
        }

        request = null;
        webAudioContext = null;
        file = null;

        window.clearTimeout(timeout);

        loader.emit('destroy', id);
    };

    // emits: progress, error, complete

    loader = Object.create(Emitter.prototype, {
        _events: {
            value: {}
        },
        id: {
            value: options.id
        },
        start: {
            value: start
        },
        loaded: {
            get: function() {
                return !!file;
            }
        },
        file: {
            get: function() {
                return file;
            }
        },
        destroy: {
            value: destroy
        }
    });

    return Object.freeze(loader);
};


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = (function() {
    try {
        return !!new Blob();
    } catch (e) {
        return false;
    }
}());


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYWFjNGJjNzU0M2RjNzEzZDRkNTEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvR0xUb29sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9HTFNoYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvY29tbW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL01lc2guanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvQmF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NjaGVkdWxpbmcvc3JjL3NjaGVkdWxlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9HZW9tLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL1dlYmdsTnVtYmVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3Bvc3QvUGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9zaGFkZXJzL3NpbXBsZUNvbG9yLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9iYXNpYy52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL0ZyYW1lQnVmZmVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL0Vhc2VOdW1iZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvbWF0aC9SYXkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvY2FtZXJhcy9DYW1lcmEuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvY2FtZXJhcy9DYW1lcmFQZXJzcGVjdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9sb2FkZXJzL0JpbmFyeUxvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9zaGFkZXJzL2JpZ1RyaWFuZ2xlLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9jb3B5LmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvV2ViZ2xDb25zdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9nZXRBdHRyaWJMb2MuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvR0xUZXh0dXJlLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL0dMVGV4dHVyZTIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvR0xDdWJlVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9FdmVudERpc3BhdGNoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvT3JiaXRhbENvbnRyb2wuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvY2FtZXJhcy9DYW1lcmFPcnRoby5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9vYmplY3RzL09iamVjdDNELmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL1NoYWRlckxpYnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9nZW5lcmFsLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9za3lib3gudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9zaGFkZXJzL3NreWJveC5mcmFnIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3Bvc3QvUGFzc01hY3JvLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3Bvc3QvUGFzc1ZCbHVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3Bvc3QvUGFzc0JsdXJCYXNlLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3Bvc3QvUGFzc0hCbHVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3NoYWRlcnMvZnhhYS5mcmFnIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3Njc3MvZ2xvYmFsLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDJkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9xdWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC92ZWMyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL2dldEFuZEFwcGx5RXh0ZW5zaW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL2V4cG9zZUF0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvZ2V0RmxvYXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvZ2V0SGFsZkZsb2F0LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL0V4dGVuc2lvbnNMaXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbHNsaWZ5L2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9iYXNpYy5mcmFnIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL2dldFRleHR1cmVQYXJhbWV0ZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYXJzZS1kZHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvQ3ViZUZyYW1lQnVmZmVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL011bHRpc2FtcGxlRnJhbWVCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvVHJhbnNmb3JtRmVlZGJhY2tPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvVHdlZW5OdW1iZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvUXVhdFJvdGF0aW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL1RvdWNoRGV0ZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvZ2V0TW91c2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvY2FtZXJhcy9DYW1lcmFDdWJlLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2xvYWRlcnMvT2JqTG9hZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2xvYWRlcnMvSERSTG9hZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL0hEUlBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9sb2FkZXJzL0NvbGxhZGFQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvbGxhZGEtcGFyc2VyL2xpYi9Db2xsYWRhUGFyc2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb2xsYWRhLXBhcnNlci9saWIvQ29sbGFkYS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9sb2FkZXJzL0dsdGZMb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvbG9hZGVycy94aHIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvcG9zdC9FZmZlY3RDb21wb3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9wb3N0L1Bhc3NCbHVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3NoYWRlcnMvYmx1cjUuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9zaGFkZXJzL2JsdXI5LmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9ibHVyMTMuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9wb3N0L1Bhc3NGeGFhLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hDb3B5LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hBeGlzLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3NoYWRlcnMvYXhpcy52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3NoYWRlcnMvYXhpcy5mcmFnIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hCYWxsLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hEb3RzUGxhbmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9kb3RzUGxhbmUudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL0JhdGNoTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL0JhdGNoU2t5Ym94LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hTa3kuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9za3kudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL0JhdGNoRlhBQS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL1NjZW5lLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL1ZpZXczRC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvQXNzZXRzLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9Db25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2Fzc2V0LWxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL1NldHRpbmdzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc3NldHMtbG9hZGVyL3NyYy9lbWl0dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc3NldHMtbG9hZGVyL3NyYy9zdGF0cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvYXBwLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3NzL2dsb2JhbC5zY3NzPzk3MzUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9kZWJ1Zy9kZWJ1Z1BvbHlmaWxsLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9TY2VuZUFwcC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvVmlld01pY3JvLmpzIiwid2VicGFjazovLy8uL3NyYy9zaGFkZXJzL2dsdGYudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVycy9nbHRmLmZyYWciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Zhc3QtdXJsLXBhcnNlci9zcmMvdXJscGFyc2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5ncGFyc2VyL2pzL3F1ZXJ5c3RyaW5ncGFyc2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZ3BhcnNlci9qcy9xdWVyeXN0cmluZ3NlcmlhbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fzc2V0cy1sb2FkZXIvc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc3NldHMtbG9hZGVyL3NyYy9ncm91cC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNzZXRzLWxvYWRlci9zcmMvbG9hZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc3NldHMtbG9hZGVyL3NyYy9icm93c2VyLWhhcy1ibG9iLmpzIl0sIm5hbWVzIjpbImdsIiwiR0xUb29sIiwiY2FudmFzIiwiX3ZpZXdwb3J0IiwiX2VuYWJsZWRWZXJ0ZXhBdHRyaWJ1dGUiLCJpZGVudGl0eU1hdHJpeCIsImNyZWF0ZSIsIl9ub3JtYWxNYXRyaXgiLCJfaW52ZXJzZU1vZGVsVmlld01hdHJpeCIsIl9tb2RlbE1hdHJpeCIsIl9tYXRyaXgiLCJfbWF0cml4U3RhY2tzIiwiX2xhc3RNZXNoIiwiX3VzZVdlYkdMMiIsIl9oYXNBcnJheUluc3RhbmNlIiwiX2V4dEFycmF5SW5zdGFuY2UiLCJfaGFzQ2hlY2tlZEV4dCIsImlkZW50aXR5IiwiaXNNb2JpbGUiLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwibUNhbnZhcyIsIm1QYXJhbWV0ZXJzIiwidW5kZWZpbmVkIiwiY29uc29sZSIsImVycm9yIiwiZGVzdHJveSIsInNldFNpemUiLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJ1c2VXZWJnbDIiLCJjdHgiLCJnZXRDb250ZXh0IiwibG9nIiwid2ViZ2wyIiwiaW5pdFdpdGhHTCIsImV4dGVuc2lvbnMiLCJpIiwibGVuZ3RoIiwiZ2V0RXh0ZW5zaW9uIiwiZW5hYmxlIiwiREVQVEhfVEVTVCIsIkNVTExfRkFDRSIsIkJMRU5EIiwiZW5hYmxlQWxwaGFCbGVuZGluZyIsIngiLCJ5IiwidyIsImgiLCJoYXNDaGFuZ2VkIiwidmlld3BvcnQiLCJzY2lzc29yIiwiciIsImciLCJiIiwiYSIsImNsZWFyQ29sb3IiLCJjbGVhciIsIkNPTE9SX0JVRkZFUl9CSVQiLCJERVBUSF9CVUZGRVJfQklUIiwibVZhbHVlIiwiY3VsbEZhY2UiLCJtQ2FtZXJhIiwiY2FtZXJhIiwicm90YXRlIiwibVNoYWRlciIsInNoYWRlciIsInNoYWRlclByb2dyYW0iLCJtUm90YXRpb24iLCJjb3B5IiwibXVsdGlwbHkiLCJtYXRyaXgiLCJmcm9tTWF0NCIsImludmVydCIsInRyYW5zcG9zZSIsIm1NZXNoIiwibURyYXdpbmdUeXBlIiwiZHJhdyIsImJpbmQiLCJ1bmlmb3JtIiwicHJvamVjdGlvbiIsImRyYXdUeXBlIiwiaXNJbnN0YW5jZWQiLCJkcmF3RWxlbWVudHNJbnN0YW5jZWQiLCJpQnVmZmVyIiwibnVtSXRlbXMiLCJVTlNJR05FRF9TSE9SVCIsIm51bUluc3RhbmNlIiwiUE9JTlRTIiwiZHJhd0FycmF5cyIsInZlcnRleFNpemUiLCJkcmF3RWxlbWVudHMiLCJ1bmJpbmQiLCJtVHJhbnNmb3JtT2JqZWN0IiwibWVzaFNvdXJjZSIsIm1lc2hEZXN0aW5hdGlvbiIsIm51bVBvaW50cyIsInRyYW5zZm9ybUZlZWRiYWNrIiwiZ2VuZXJhdGVCdWZmZXJzIiwiYmluZFRyYW5zZm9ybUZlZWRiYWNrIiwiVFJBTlNGT1JNX0ZFRURCQUNLIiwiYXR0cmlidXRlcyIsImZvckVhY2giLCJhdHRyIiwiYmluZEJ1ZmZlckJhc2UiLCJUUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSIiwiYnVmZmVyIiwiUkFTVEVSSVpFUl9ESVNDQVJEIiwiYmVnaW5UcmFuc2Zvcm1GZWVkYmFjayIsImVuZFRyYW5zZm9ybUZlZWRiYWNrIiwiZGlzYWJsZSIsInVzZVByb2dyYW0iLCJiaW5kQnVmZmVyIiwiQVJSQVlfQlVGRkVSIiwibVdpZHRoIiwibUhlaWdodCIsIl93aWR0aCIsIl9oZWlnaHQiLCJ3aWR0aCIsImhlaWdodCIsIl9hc3BlY3RSYXRpbyIsImV4dCIsIm1FeHRlbnNpb24iLCJibGVuZEZ1bmMiLCJTUkNfQUxQSEEiLCJPTkVfTUlOVVNfU1JDX0FMUEhBIiwiT05FIiwibXR4IiwiY2xvbmUiLCJwdXNoIiwicG9wIiwibVBhcmFtZXRlciIsInNldFZpZXdwb3J0IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiZSIsIkdMIiwiZ2xzbGlmeSIsInJlcXVpcmUiLCJpc1NhbWUiLCJhcnJheTEiLCJhcnJheTIiLCJhZGRMaW5lTnVtYmVycyIsInN0cmluZyIsImxpbmVzIiwic3BsaXQiLCJqb2luIiwiY2xvbmVBcnJheSIsIm1BcnJheSIsInNsaWNlIiwiRmxvYXQzMkFycmF5IiwiZGVmYXVsdFZlcnRleFNoYWRlciIsImRlZmF1bHRGcmFnbWVudFNoYWRlciIsInVuaWZvcm1NYXBwaW5nIiwiZmxvYXQiLCJ2ZWMyIiwidmVjMyIsInZlYzQiLCJpbnQiLCJtYXQzIiwibWF0NCIsIkdMU2hhZGVyIiwic3RyVmVydGV4U2hhZGVyIiwic3RyRnJhZ21lbnRTaGFkZXIiLCJtVmFyeWluZ3MiLCJwYXJhbWV0ZXJzIiwidW5pZm9ybVRleHR1cmVzIiwiX3ZhcnlpbmdzIiwidnNTaGFkZXIiLCJfY3JlYXRlU2hhZGVyUHJvZ3JhbSIsImZzU2hhZGVyIiwiX2F0dGFjaFNoYWRlclByb2dyYW0iLCJ1c2VTaGFkZXIiLCJtTmFtZSIsIm1UeXBlIiwidW5pZm9ybU9iamVjdCIsInVuaWZvcm1UeXBlIiwiaGFzVW5pZm9ybSIsIm9Vbmlmb3JtIiwicGFyYW1ldGVySW5kZXgiLCJuYW1lIiwiaXNOdW1iZXIiLCJnZXRVbmlmb3JtTG9jYXRpb24iLCJ0eXBlIiwidmFsdWUiLCJ1bmlmb3JtTG9jIiwiaW5kZXhPZiIsIm5lZWRVcGRhdGUiLCJtVW5pZm9ybU9iaiIsInVuaWZvcm1OYW1lIiwidW5pZm9ybVZhbHVlIiwiZ2V0VW5pZm9ybVR5cGUiLCJjb25jYXQiLCJ0bXAiLCJtU2hhZGVyU3RyIiwiaXNWZXJ0ZXhTaGFkZXIiLCJzaGFkZXJUeXBlIiwiVkVSVEVYX1NIQURFUiIsIkZSQUdNRU5UX1NIQURFUiIsImNyZWF0ZVNoYWRlciIsInNoYWRlclNvdXJjZSIsImNvbXBpbGVTaGFkZXIiLCJnZXRTaGFkZXJQYXJhbWV0ZXIiLCJDT01QSUxFX1NUQVRVUyIsIndhcm4iLCJnZXRTaGFkZXJJbmZvTG9nIiwibVZlcnRleFNoYWRlciIsIm1GcmFnbWVudFNoYWRlciIsImNyZWF0ZVByb2dyYW0iLCJhdHRhY2hTaGFkZXIiLCJkZWxldGVTaGFkZXIiLCJ0cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzIiwiU0VQQVJBVEVfQVRUUklCUyIsImxpbmtQcm9ncmFtIiwiaXNBcnJheSIsImdldEFycmF5VW5pZm9ybVR5cGUiLCJTVEFUSUNfRFJBVyIsImdldEJ1ZmZlciIsImNyZWF0ZUJ1ZmZlciIsImZvcm1CdWZmZXIiLCJtRGF0YSIsIm1OdW0iLCJhcnkiLCJvIiwiaiIsIk1lc2giLCJtVXNlVmFvIiwiX2F0dHJpYnV0ZXMiLCJfbnVtSW5zdGFuY2UiLCJfaW5kaWNlcyIsIl9mYWNlcyIsIl9idWZmZXJDaGFuZ2VkIiwiX2hhc0luZGV4QnVmZmVyQ2hhbmdlZCIsIl9oYXNWQU8iLCJfaXNJbnN0YW5jZWQiLCJfZXh0VkFPIiwiY3JlYXRlVmVydGV4QXJyYXkiLCJfdXNlVkFPIiwibUFycmF5VmVydGljZXMiLCJtRHJhd1R5cGUiLCJidWZmZXJEYXRhIiwibm9ybWFscyIsInZlcnRpY2VzIiwiYnVmZmVyTm9ybWFsIiwibUFycmF5VGV4Q29vcmRzIiwibU5vcm1hbHMiLCJtQXJyYXlJbmRpY2VzIiwiaXNEeW5hbWljIiwiX2RyYXdUeXBlIiwiRFlOQU1JQ19EUkFXIiwiQXJyYXkiLCJVaW50MTZBcnJheSIsIl9udW1JdGVtcyIsIm1JdGVtU2l6ZSIsImRhdGEiLCJkYXRhQXJyYXkiLCJhdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJpdGVtU2l6ZSIsInNvdXJjZSIsInZlcnRleEF0dHJpYkRpdmlzb3IiLCJtU2hhZGVyUHJvZ3JhbSIsImhhc1ZBTyIsImJpbmRWZXJ0ZXhBcnJheSIsInZhbyIsImF0dHJQb3NpdGlvbiIsInZlcnRleEF0dHJpYlBvaW50ZXIiLCJGTE9BVCIsIkVMRU1FTlRfQVJSQVlfQlVGRkVSIiwiX3ZhbyIsImF0dHJPYmoiLCJlbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSIsIl91cGRhdGVJbmRleEJ1ZmZlciIsInVzaW5nRmFjZU5vcm1hbHMiLCJnZW5lcmF0ZUZhY2VzIiwiX2NvbXB1dGVGYWNlTm9ybWFscyIsIl9jb21wdXRlVmVydGV4Tm9ybWFscyIsImZhY2VJbmRleCIsImZhY2UiLCJOIiwibm9ybWFsIiwiaW5kaWNlcyIsInN1bU5vcm1hbCIsInNldCIsIm5vcm1hbGl6ZSIsImlhIiwiaWIiLCJpYyIsImMiLCJ2YmEiLCJ2Y2EiLCJ2Tm9ybWFsIiwiZmluZCIsImdldFNvdXJjZSIsIkJhdGNoIiwiX21lc2giLCJfc2hhZGVyIiwibWVzaCIsIkdlb20iLCJtZXNoVHJpIiwicGxhbmUiLCJudW1TZWdtZW50cyIsImF4aXMiLCJwb3NpdGlvbnMiLCJjb29yZHMiLCJnYXBYIiwiZ2FwWSIsImdhcFVWIiwic3giLCJzeSIsImluZGV4IiwidHgiLCJ0eSIsInUiLCJ2IiwiYnVmZmVyVmVydGV4IiwiYnVmZmVyVGV4Q29vcmQiLCJidWZmZXJJbmRleCIsInNwaGVyZSIsInNpemUiLCJpc0ludmVydCIsImdldFBvc2l0aW9uIiwiaXNOb3JtYWwiLCJyeCIsIk1hdGgiLCJQSSIsInJ5IiwicG9zIiwic2luIiwidCIsImNvcyIsInByZWNpc2lvbiIsImZsb29yIiwicmV2ZXJzZSIsImN1YmUiLCJkIiwieiIsImNvdW50Iiwic2t5Ym94IiwiYmlnVHJpYW5nbGUiLCJtb2R1bGUiLCJleHBvcnRzIiwiUGFzcyIsIm1Tb3VyY2UiLCJtUGFyYW1zIiwiYmlnVHJpYW5nbGVWZXJ0IiwiX3VuaWZvcm1zIiwiX2hhc093bkZibyIsIl9mYm8iLCJtUGFybWFzIiwidGV4dHVyZSIsIndlYmdsRGVwdGhUZXh0dXJlIiwiaGFzQ2hlY2tlZE11bHRpUmVuZGVyU3VwcG9ydCIsImV4dERyYXdCdWZmZXIiLCJjaGVja011bHRpUmVuZGVyIiwiRnJhbWVCdWZmZXIiLCJtTnVtVGFyZ2V0cyIsImNoZWNrRXh0ZW5zaW9uIiwiX251bVRhcmdldHMiLCJfbXVsdGlwbGVUYXJnZXRzIiwiX3BhcmFtZXRlcnMiLCJfY2hlY2tNYXhOdW1SZW5kZXJUYXJnZXQiLCJfaW5pdCIsIl9pbml0VGV4dHVyZXMiLCJmcmFtZUJ1ZmZlciIsImNyZWF0ZUZyYW1lYnVmZmVyIiwiYmluZEZyYW1lYnVmZmVyIiwiRlJBTUVCVUZGRVIiLCJidWZmZXJzIiwiZnJhbWVidWZmZXJUZXh0dXJlMkQiLCJEUkFXX0ZSQU1FQlVGRkVSIiwiQ09MT1JfQVRUQUNITUVOVDAiLCJURVhUVVJFXzJEIiwiX3RleHR1cmVzIiwiZHJhd0J1ZmZlcnMiLCJERVBUSF9BVFRBQ0hNRU5UIiwiZ2xEZXB0aFRleHR1cmUiLCJkcmF3QnVmZmVyc1dFQkdMIiwiRkJPc3RhdHVzIiwiY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyIsIkZSQU1FQlVGRkVSX0NPTVBMRVRFIiwiYmluZFRleHR1cmUiLCJiaW5kUmVuZGVyYnVmZmVyIiwiUkVOREVSQlVGRkVSIiwibWF4TnVtRHJhd0J1ZmZlcnMiLCJnZXRQYXJhbWV0ZXIiLCJNQVhfRFJBV19CVUZGRVJTX1dFQkdMIiwiZ2x0IiwiX2NyZWF0ZVRleHR1cmUiLCJERVBUSF9DT01QT05FTlQxNiIsIkRFUFRIX0NPTVBPTkVOVCIsIm1pbkZpbHRlciIsIkxJTkVBUiIsIm1JbnRlcm5hbGZvcm1hdCIsIm1UZXhlbFR5cGUiLCJtRm9ybWF0IiwiT2JqZWN0IiwiYXNzaWduIiwiaW50ZXJuYWxGb3JtYXQiLCJSR0JBIiwiZm9ybWF0IiwiVU5TSUdORURfQllURSIsInMiLCJtQXV0b1NldFZpZXdwb3J0IiwiZ2VuZXJhdGVNaXBtYXAiLCJtSW5kZXgiLCJzaG93UGFyYW1ldGVycyIsIm1hZ0ZpbHRlciIsIndyYXBTIiwid3JhcFQiLCJFYXNlTnVtYmVyIiwibUVhc2luZyIsImVhc2luZyIsIl92YWx1ZSIsIl90YXJnZXRWYWx1ZSIsIl9lZkluZGV4IiwiYWRkRUYiLCJfdXBkYXRlIiwiTUlOX0RJRkYiLCJfY2hlY2tMaW1pdCIsImFicyIsIm1BZGQiLCJtTWluIiwibU1heCIsImxpbWl0IiwiX21pbiIsIl9tYXgiLCJyZW1vdmVFRiIsInRhcmdldCIsImVkZ2UxIiwiZWRnZTIiLCJkaWZmIiwiUmF5IiwibU9yaWdpbiIsIm1EaXJlY3Rpb24iLCJvcmlnaW4iLCJkaXJlY3Rpb24iLCJzY2FsZSIsImFkZCIsIm1UYXJnZXQiLCJzdWIiLCJtUG9pbnQiLCJyZXN1bHQiLCJkaXJlY3Rpb25EaXN0YW5jZSIsImRvdCIsInNxcnQiLCJkaXN0YW5jZVNxVG9Qb2ludCIsInYxIiwic3F1YXJlZERpc3RhbmNlIiwibUNlbnRlciIsIm1SYWRpdXMiLCJkaXN0YW5jZVRvUG9pbnQiLCJ0Y2EiLCJkMiIsInJhZGl1czIiLCJ0aGMiLCJ0MCIsInQxIiwiYXQiLCJtUGxhbmVDZW50ZXIiLCJtTm9ybWFsIiwiZGVub21pbmF0b3IiLCJtUEEiLCJtUEIiLCJtUEMiLCJiYWNrZmFjZUN1bGxpbmciLCJjcm9zcyIsIkRkTiIsInNpZ24iLCJEZFF4RTIiLCJEZEUxeFEiLCJRZG4iLCJDYW1lcmEiLCJfcXVhdCIsIl9vcmllbnRhdGlvbiIsIl9wcm9qZWN0aW9uIiwicG9zaXRpb24iLCJhRXllIiwiYUNlbnRlciIsImFVcCIsIl9leWUiLCJfY2VudGVyIiwibG9va0F0IiwiZnJvbVF1YXQiLCJ0cmFuc2xhdGUiLCJwb3NpdGlvbk9mZnNldCIsIm1Qcm9qIiwibVZpZXciLCJzZXRWaWV3Iiwic2V0UHJvamVjdGlvbiIsIm1JbnZlcnNlVmlld1Byb2oiLCJjYW1lcmFEaXIiLCJDYW1lcmFQZXJzcGVjdGl2ZSIsIm1Gb3YiLCJtQXNwZWN0UmF0aW8iLCJtTmVhciIsIm1GYXIiLCJfZm92IiwiX25lYXIiLCJfZmFyIiwicGVyc3BlY3RpdmUiLCJtU2NyZWVuUG9zaXRpb24iLCJtUmF5IiwicHJvaiIsInByb2plY3Rpb25NYXRyaXgiLCJ2aWV3Iiwidmlld01hdHJpeCIsInRyYW5zZm9ybU1hdDQiLCJCaW5hcnlMb2FkZXIiLCJpc0FycmF5QnVmZmVyIiwiX3JlcSIsIlhNTEh0dHBSZXF1ZXN0IiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9vbkxvYWRlZCIsIl9vblByb2dyZXNzIiwicmVzcG9uc2VUeXBlIiwidXJsIiwiY2FsbGJhY2siLCJfY2FsbGJhY2siLCJvcGVuIiwic2VuZCIsInJlc3BvbnNlIiwiR0xNIiwiVkVSU0lPTiIsIkFsZnJpZCIsImdsbSIsIkdMVGV4dHVyZSIsIkdMVGV4dHVyZU9sZCIsIkdMQ3ViZVRleHR1cmUiLCJDdWJlRnJhbWVCdWZmZXIiLCJTY2hlZHVsZXIiLCJFdmVudERpc3BhdGNoZXIiLCJUd2Vlbk51bWJlciIsIkNhbWVyYU9ydGhvIiwiQ2FtZXJhQ3ViZSIsIk9yYml0YWxDb250cm9sIiwiUXVhdFJvdGF0aW9uIiwiT2JqTG9hZGVyIiwiQ29sbGFkYVBhcnNlciIsIkhEUkxvYWRlciIsIkdMVEZMb2FkZXIiLCJCYXRjaENvcHkiLCJCYXRjaEF4aXMiLCJCYXRjaEJhbGwiLCJCYXRjaExpbmUiLCJCYXRjaFNreWJveCIsIkJhdGNoU2t5IiwiQmF0Y2hGWEFBIiwiQmF0Y2hEb3RzUGxhbmUiLCJTY2VuZSIsIlZpZXciLCJWaWV3M0QiLCJPYmplY3QzRCIsIlNoYWRlckxpYnMiLCJXZWJnbE51bWJlciIsIkVmZmVjdENvbXBvc2VyIiwiUGFzc01hY3JvIiwiUGFzc0JsdXIiLCJQYXNzVkJsdXIiLCJQYXNzSEJsdXIiLCJQYXNzRnhhYSIsIk11bHRpc2FtcGxlRnJhbWVCdWZmZXIiLCJUcmFuc2Zvcm1GZWVkYmFja09iamVjdCIsImFsIiwiVG91Y2hEZXRlY3RvciIsIkFDVElWRV9BVFRSSUJVVEVTIiwiQUNUSVZFX0FUVFJJQlVURV9NQVhfTEVOR1RIIiwiQUNUSVZFX1RFWFRVUkUiLCJBQ1RJVkVfVU5JRk9STVMiLCJBQ1RJVkVfVU5JRk9STV9NQVhfTEVOR1RIIiwiQUxJQVNFRF9MSU5FX1dJRFRIX1JBTkdFIiwiQUxJQVNFRF9QT0lOVF9TSVpFX1JBTkdFIiwiQUxQSEEiLCJBTFBIQV9CSVRTIiwiQUxXQVlTIiwiQVJSQVlfQlVGRkVSX0JJTkRJTkciLCJBVFRBQ0hFRF9TSEFERVJTIiwiQkFDSyIsIkJMRU5EX0NPTE9SIiwiQkxFTkRfRFNUX0FMUEhBIiwiQkxFTkRfRFNUX1JHQiIsIkJMRU5EX0VRVUFUSU9OIiwiQkxFTkRfRVFVQVRJT05fQUxQSEEiLCJCTEVORF9FUVVBVElPTl9SR0IiLCJCTEVORF9TUkNfQUxQSEEiLCJCTEVORF9TUkNfUkdCIiwiQkxVRV9CSVRTIiwiQk9PTCIsIkJPT0xfVkVDMiIsIkJPT0xfVkVDMyIsIkJPT0xfVkVDNCIsIkJST1dTRVJfREVGQVVMVF9XRUJHTCIsIkJVRkZFUl9TSVpFIiwiQlVGRkVSX1VTQUdFIiwiQllURSIsIkNDVyIsIkNMQU1QX1RPX0VER0UiLCJDT0xPUl9DTEVBUl9WQUxVRSIsIkNPTE9SX1dSSVRFTUFTSyIsIkNPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTIiwiQ09OU1RBTlRfQUxQSEEiLCJDT05TVEFOVF9DT0xPUiIsIkNPTlRFWFRfTE9TVF9XRUJHTCIsIkNVTExfRkFDRV9NT0RFIiwiQ1VSUkVOVF9QUk9HUkFNIiwiQ1VSUkVOVF9WRVJURVhfQVRUUklCIiwiQ1ciLCJERUNSIiwiREVDUl9XUkFQIiwiREVMRVRFX1NUQVRVUyIsIkRFUFRIX0JJVFMiLCJERVBUSF9DTEVBUl9WQUxVRSIsIlJFRCIsIkRFUFRIX0ZVTkMiLCJERVBUSF9SQU5HRSIsIkRFUFRIX1NURU5DSUwiLCJERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQiLCJERVBUSF9XUklURU1BU0siLCJESVRIRVIiLCJET05UX0NBUkUiLCJEU1RfQUxQSEEiLCJEU1RfQ09MT1IiLCJFTEVNRU5UX0FSUkFZX0JVRkZFUl9CSU5ESU5HIiwiRVFVQUwiLCJGQVNURVNUIiwiRkxPQVRfTUFUMiIsIkZMT0FUX01BVDMiLCJGTE9BVF9NQVQ0IiwiRkxPQVRfVkVDMiIsIkZMT0FUX1ZFQzMiLCJGTE9BVF9WRUM0IiwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9PQkpFQ1RfTkFNRSIsIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfT0JKRUNUX1RZUEUiLCJGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX1RFWFRVUkVfQ1VCRV9NQVBfRkFDRSIsIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfVEVYVFVSRV9MRVZFTCIsIkZSQU1FQlVGRkVSX0JJTkRJTkciLCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQiLCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlMiLCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVCIsIkZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEIiwiRlJPTlQiLCJGUk9OVF9BTkRfQkFDSyIsIkZST05UX0ZBQ0UiLCJGVU5DX0FERCIsIkZVTkNfUkVWRVJTRV9TVUJUUkFDVCIsIkZVTkNfU1VCVFJBQ1QiLCJHRU5FUkFURV9NSVBNQVBfSElOVCIsIkdFUVVBTCIsIkdSRUFURVIiLCJHUkVFTl9CSVRTIiwiSElHSF9GTE9BVCIsIkhJR0hfSU5UIiwiSU5DUiIsIklOQ1JfV1JBUCIsIklORk9fTE9HX0xFTkdUSCIsIklOVCIsIklOVF9WRUMyIiwiSU5UX1ZFQzMiLCJJTlRfVkVDNCIsIklOVkFMSURfRU5VTSIsIklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OIiwiSU5WQUxJRF9PUEVSQVRJT04iLCJJTlZBTElEX1ZBTFVFIiwiSU5WRVJUIiwiS0VFUCIsIkxFUVVBTCIsIkxFU1MiLCJMSU5FQVJfTUlQTUFQX0xJTkVBUiIsIkxJTkVBUl9NSVBNQVBfTkVBUkVTVCIsIkxJTkVTIiwiTElORV9MT09QIiwiTElORV9TVFJJUCIsIkxJTkVfV0lEVEgiLCJMSU5LX1NUQVRVUyIsIkxPV19GTE9BVCIsIkxPV19JTlQiLCJMVU1JTkFOQ0UiLCJMVU1JTkFOQ0VfQUxQSEEiLCJNQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyIsIk1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUiLCJNQVhfRlJBR01FTlRfVU5JRk9STV9WRUNUT1JTIiwiTUFYX1JFTkRFUkJVRkZFUl9TSVpFIiwiTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMiLCJNQVhfVEVYVFVSRV9TSVpFIiwiTUFYX1ZBUllJTkdfVkVDVE9SUyIsIk1BWF9WRVJURVhfQVRUUklCUyIsIk1BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUyIsIk1BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTIiwiTUFYX1ZJRVdQT1JUX0RJTVMiLCJNRURJVU1fRkxPQVQiLCJNRURJVU1fSU5UIiwiTUlSUk9SRURfUkVQRUFUIiwiTkVBUkVTVCIsIk5FQVJFU1RfTUlQTUFQX0xJTkVBUiIsIk5FQVJFU1RfTUlQTUFQX05FQVJFU1QiLCJORVZFUiIsIk5JQ0VTVCIsIk5PTkUiLCJOT1RFUVVBTCIsIk5PX0VSUk9SIiwiTlVNX0NPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTIiwiT05FX01JTlVTX0NPTlNUQU5UX0FMUEhBIiwiT05FX01JTlVTX0NPTlNUQU5UX0NPTE9SIiwiT05FX01JTlVTX0RTVF9BTFBIQSIsIk9ORV9NSU5VU19EU1RfQ09MT1IiLCJPTkVfTUlOVVNfU1JDX0NPTE9SIiwiT1VUX09GX01FTU9SWSIsIlBBQ0tfQUxJR05NRU5UIiwiUE9MWUdPTl9PRkZTRVRfRkFDVE9SIiwiUE9MWUdPTl9PRkZTRVRfRklMTCIsIlBPTFlHT05fT0ZGU0VUX1VOSVRTIiwiUkVEX0JJVFMiLCJSRU5ERVJCVUZGRVJfQUxQSEFfU0laRSIsIlJFTkRFUkJVRkZFUl9CSU5ESU5HIiwiUkVOREVSQlVGRkVSX0JMVUVfU0laRSIsIlJFTkRFUkJVRkZFUl9ERVBUSF9TSVpFIiwiUkVOREVSQlVGRkVSX0dSRUVOX1NJWkUiLCJSRU5ERVJCVUZGRVJfSEVJR0hUIiwiUkVOREVSQlVGRkVSX0lOVEVSTkFMX0ZPUk1BVCIsIlJFTkRFUkJVRkZFUl9SRURfU0laRSIsIlJFTkRFUkJVRkZFUl9TVEVOQ0lMX1NJWkUiLCJSRU5ERVJCVUZGRVJfV0lEVEgiLCJSRU5ERVJFUiIsIlJFUEVBVCIsIlJFUExBQ0UiLCJSR0IiLCJSR0I1X0ExIiwiUkdCNTY1IiwiUkdCQTQiLCJTQU1QTEVSXzJEIiwiU0FNUExFUl9DVUJFIiwiU0FNUExFUyIsIlNBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRSIsIlNBTVBMRV9CVUZGRVJTIiwiU0FNUExFX0NPVkVSQUdFIiwiU0FNUExFX0NPVkVSQUdFX0lOVkVSVCIsIlNBTVBMRV9DT1ZFUkFHRV9WQUxVRSIsIlNDSVNTT1JfQk9YIiwiU0NJU1NPUl9URVNUIiwiU0hBREVSX0NPTVBJTEVSIiwiU0hBREVSX1NPVVJDRV9MRU5HVEgiLCJTSEFERVJfVFlQRSIsIlNIQURJTkdfTEFOR1VBR0VfVkVSU0lPTiIsIlNIT1JUIiwiU1JDX0FMUEhBX1NBVFVSQVRFIiwiU1JDX0NPTE9SIiwiU1RFTkNJTF9BVFRBQ0hNRU5UIiwiU1RFTkNJTF9CQUNLX0ZBSUwiLCJTVEVOQ0lMX0JBQ0tfRlVOQyIsIlNURU5DSUxfQkFDS19QQVNTX0RFUFRIX0ZBSUwiLCJTVEVOQ0lMX0JBQ0tfUEFTU19ERVBUSF9QQVNTIiwiU1RFTkNJTF9CQUNLX1JFRiIsIlNURU5DSUxfQkFDS19WQUxVRV9NQVNLIiwiU1RFTkNJTF9CQUNLX1dSSVRFTUFTSyIsIlNURU5DSUxfQklUUyIsIlNURU5DSUxfQlVGRkVSX0JJVCIsIlNURU5DSUxfQ0xFQVJfVkFMVUUiLCJTVEVOQ0lMX0ZBSUwiLCJTVEVOQ0lMX0ZVTkMiLCJTVEVOQ0lMX0lOREVYIiwiU1RFTkNJTF9JTkRFWDgiLCJTVEVOQ0lMX1BBU1NfREVQVEhfRkFJTCIsIlNURU5DSUxfUEFTU19ERVBUSF9QQVNTIiwiU1RFTkNJTF9SRUYiLCJTVEVOQ0lMX1RFU1QiLCJTVEVOQ0lMX1ZBTFVFX01BU0siLCJTVEVOQ0lMX1dSSVRFTUFTSyIsIlNUUkVBTV9EUkFXIiwiU1VCUElYRUxfQklUUyIsIlRFWFRVUkUiLCJURVhUVVJFMCIsIlRFWFRVUkUxIiwiVEVYVFVSRTIiLCJURVhUVVJFMyIsIlRFWFRVUkU0IiwiVEVYVFVSRTUiLCJURVhUVVJFNiIsIlRFWFRVUkU3IiwiVEVYVFVSRTgiLCJURVhUVVJFOSIsIlRFWFRVUkUxMCIsIlRFWFRVUkUxMSIsIlRFWFRVUkUxMiIsIlRFWFRVUkUxMyIsIlRFWFRVUkUxNCIsIlRFWFRVUkUxNSIsIlRFWFRVUkUxNiIsIlRFWFRVUkUxNyIsIlRFWFRVUkUxOCIsIlRFWFRVUkUxOSIsIlRFWFRVUkUyMCIsIlRFWFRVUkUyMSIsIlRFWFRVUkUyMiIsIlRFWFRVUkUyMyIsIlRFWFRVUkUyNCIsIlRFWFRVUkUyNSIsIlRFWFRVUkUyNiIsIlRFWFRVUkUyNyIsIlRFWFRVUkUyOCIsIlRFWFRVUkUyOSIsIlRFWFRVUkUzMCIsIlRFWFRVUkUzMSIsIlRFWFRVUkVfQklORElOR18yRCIsIlRFWFRVUkVfQklORElOR19DVUJFX01BUCIsIlRFWFRVUkVfQ1VCRV9NQVAiLCJURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1giLCJURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1kiLCJURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1oiLCJURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1giLCJURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1kiLCJURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1oiLCJURVhUVVJFX01BR19GSUxURVIiLCJURVhUVVJFX01JTl9GSUxURVIiLCJURVhUVVJFX1dSQVBfUyIsIlRFWFRVUkVfV1JBUF9UIiwiVFJJQU5HTEVTIiwiVFJJQU5HTEVfRkFOIiwiVFJJQU5HTEVfU1RSSVAiLCJVTlBBQ0tfQUxJR05NRU5UIiwiVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCIsIlVOUEFDS19GTElQX1lfV0VCR0wiLCJVTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wiLCJVTlNJR05FRF9JTlQiLCJVTlNJR05FRF9TSE9SVF80XzRfNF80IiwiVU5TSUdORURfU0hPUlRfNV81XzVfMSIsIlVOU0lHTkVEX1NIT1JUXzVfNl81IiwiVkFMSURBVEVfU1RBVFVTIiwiVkVORE9SIiwiVkVSVEVYX0FUVFJJQl9BUlJBWV9CVUZGRVJfQklORElORyIsIlZFUlRFWF9BVFRSSUJfQVJSQVlfRU5BQkxFRCIsIlZFUlRFWF9BVFRSSUJfQVJSQVlfTk9STUFMSVpFRCIsIlZFUlRFWF9BVFRSSUJfQVJSQVlfUE9JTlRFUiIsIlZFUlRFWF9BVFRSSUJfQVJSQVlfU0laRSIsIlZFUlRFWF9BVFRSSUJfQVJSQVlfU1RSSURFIiwiVkVSVEVYX0FUVFJJQl9BUlJBWV9UWVBFIiwiVklFV1BPUlQiLCJaRVJPIiwiUjgiLCJjYWNoZUF0dHJpYkxvYyIsImdldEF0dHJpYkxvY2F0aW9uIiwiaXNQb3dlck9mVHdvIiwiaXNTb3VyY2VQb3dlck9mVHdvIiwib2JqIiwidmlkZW9XaWR0aCIsInZpZGVvSGVpZ2h0IiwiaXNUZXh0dXJlIiwiX3RleHR1cmUiLCJfbVNvdXJjZSIsImNyZWF0ZVRleHR1cmUiLCJfaXNWaWRlbyIsInRhZ05hbWUiLCJfcHJlbXVsdGlwbHlBbHBoYSIsIl9tYWdGaWx0ZXIiLCJfbWluRmlsdGVyIiwiX3dyYXBTIiwiX3dyYXBUIiwicGl4ZWxTdG9yZWkiLCJleHBvc3VyZSIsInRleEltYWdlMkQiLCJzaGFwZSIsInRleFBhcmFtZXRlcmkiLCJtYXgiLCJNQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQiLCJ0ZXhQYXJhbWV0ZXJmIiwiVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQiLCJfY2FuR2VuZXJhdGVNaXBtYXAiLCJhY3RpdmVUZXh0dXJlIiwiX2JpbmRJbmRleCIsIl93aGl0ZVRleHR1cmUiLCJfZ3JleVRleHR1cmUiLCJfYmxhY2tUZXh0dXJlIiwid2hpdGVUZXh0dXJlIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJncmV5VGV4dHVyZSIsImJsYWNrVGV4dHVyZSIsIm1QYXJhbSIsIl9zb3VyY2UiLCJfZ2V0RGltZW5zaW9uIiwiX3NvdXJjZVR5cGUiLCJnZXRTb3VyY2VUeXBlIiwiX2NoZWNrU291cmNlIiwiX3RleGVsVHlwZSIsIl9nZXRUZXhlbFR5cGUiLCJfaXNUZXh0dXJlUmVhZHkiLCJfcGFyYW1zIiwiX2NoZWNrTWlwbWFwIiwiX2NoZWNrV3JhcHBpbmciLCJfbG9vcCIsIl91cGxvYWRUZXh0dXJlIiwicmVhZHlTdGF0ZSIsIl9pc1NvdXJjZUh0bWxFbGVtZW50IiwicHJlbXVsdGlwbHlBbHBoYSIsImFuaXNvdHJvcHkiLCJsZXZlbCIsIm1pbiIsIl9nZW5lcmF0ZU1pcG1hcCIsInRleGVsVHlwZSIsIlVpbnQ4QXJyYXkiLCJtaXBtYXAiLCJIVE1MSW1hZ2VFbGVtZW50IiwiSFRNTENhbnZhc0VsZW1lbnQiLCJIVE1MVmlkZW9FbGVtZW50IiwiRERTRF9NSVBNQVBDT1VOVCIsIk9GRl9NSVBNQVBDT1VOVCIsImhlYWRlckxlbmd0aEludCIsImlzQ3ViZVRleHR1cmUiLCJoYXNNaXBtYXBzIiwibWlwbWFwQ291bnQiLCJ0YXJnZXRzIiwibnVtTGV2ZWxzIiwidW5pZm9ybTFpIiwicGFyc2VERFMiLCJtQXJyYXlCdWZmZXIiLCJjbGFtcCIsImRkc0luZm9zIiwiZmxhZ3MiLCJoZWFkZXIiLCJJbnQzMkFycmF5Iiwic291cmNlcyIsImltYWdlcyIsIm1hcCIsImltZyIsImZhY2VEYXRhIiwib2Zmc2V0Iiwic3VwcG9ydHNDdXN0b21FdmVudHMiLCJuZXdUZXN0Q3VzdG9tRXZlbnQiLCJjcmVhdGVFdmVudCIsIl9ldmVudExpc3RlbmVycyIsImFFdmVudFR5cGUiLCJhRnVuY3Rpb24iLCJjdXJyZW50QXJyYXkiLCJjdXJyZW50QXJyYXlMZW5ndGgiLCJzcGxpY2UiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYUV2ZW50IiwiZXZlbnRUeXBlIiwiY3VycmVudFRhcmdldCIsInRoZUVycm9yIiwibmV3RXZlbnQiLCJkZXRhaWwiLCJkaXNwYXRjaGVyIiwiZGlzcGF0Y2hFdmVudCIsImN1cnJlbnRFdmVudExpc3RlbmVycyIsIl9jb3B5QXJyYXkiLCJjdXJyZW50RnVuY3Rpb24iLCJjYWxsIiwiYURldGFpbCIsImluaXRDdXN0b21FdmVudCIsImRpc3BhdGNoQ3VzdG9tRXZlbnQiLCJvYmplY3ROYW1lIiwiaGFzT3duUHJvcGVydHkiLCJhQXJyYXkiLCJnZXRNb3VzZSIsIm1FdmVudCIsInRvdWNoZXMiLCJwYWdlWCIsInBhZ2VZIiwiY2xpZW50WCIsImNsaWVudFkiLCJtTGlzdGVuZXJUYXJnZXQiLCJfdGFyZ2V0IiwiX2xpc3RlbmVyVGFyZ2V0IiwiX21vdXNlIiwiX3ByZU1vdXNlIiwiY2VudGVyIiwiX3VwIiwiZnJvbVZhbHVlcyIsInJhZGl1cyIsIl9yeCIsIl9yeSIsIl9wcmVSWCIsIl9wcmVSWSIsIl9pc0xvY2tab29tIiwiX2lzTG9ja1JvdGF0aW9uIiwiX2lzSW52ZXJ0Iiwic2Vuc2l0aXZpdHkiLCJfd2hlZWxCaW5kIiwiX29uV2hlZWwiLCJfZG93bkJpbmQiLCJfb25Eb3duIiwiX21vdmVCaW5kIiwiX29uTW92ZSIsIl91cEJpbmQiLCJfb25VcCIsImNvbm5lY3QiLCJkaXNjb25uZWN0IiwiX2lzTW91c2VEb3duIiwidGFyZ2V0VmFsdWUiLCJwcmV2ZW50RGVmYXVsdCIsImRpZmZYIiwiZGlmZlkiLCJ3aGVlbERlbHRhIiwiX3VwZGF0ZVBvc2l0aW9uIiwiX3VwZGF0ZUNhbWVyYSIsInRyIiwiZXllIiwidXAiLCJvcnRobyIsImxlZnQiLCJyaWdodCIsInRvcCIsImJvdHRvbSIsIm5lYXIiLCJmYXIiLCJfbmVlZFVwZGF0ZSIsIl94IiwiX3kiLCJfeiIsIl9zeCIsIl9zeSIsIl9zeiIsIl9yeiIsIl9wb3NpdGlvbiIsIl9zY2FsZSIsIl9yb3RhdGlvbiIsIl9tYXRyaXhSb3RhdGlvbiIsIl9tYXRyaXhTY2FsZSIsIl9tYXRyaXhUcmFuc2xhdGlvbiIsIl9tYXRyaXhRdWF0ZXJuaW9uIiwicm90YXRlWCIsInJvdGF0ZVkiLCJyb3RhdGVaIiwibXVsIiwibVF1YXQiLCJzaW1wbGVDb2xvckZyYWciLCJnZW5lcmFsVmVydCIsImNvcHlGcmFnIiwiYmFzaWNWZXJ0Iiwic2t5Ym94VmVydCIsInNreWJveEZyYWciLCJfcGFzc2VzIiwicGFzcyIsIm1RdWFsaXR5IiwiZnNCbHVyNSIsImZzQmx1cjkiLCJmc0JsdXIxMyIsIlBhc3NCbHVyQmFzZSIsImZzIiwiZ2V0QW5kQXBwbHlFeHRlbnNpb24iLCJzdWZmaXgiLCJzdWZmaXhSRSIsIlJlZ0V4cCIsImtleSIsInZhbCIsInVuc3VmZml4ZWRLZXkiLCJyZXBsYWNlIiwic3Vic3RyaW5nIiwiZXhwb3NlQXR0cmlidXRlcyIsImhhc0NoZWNrZWQiLCJfZmxvYXQiLCJjaGVja0Zsb2F0IiwiZXh0RmxvYXQiLCJoYWxmRmxvYXQiLCJjaGVja0hhbGZGbG9hdCIsIkhBTEZfRkxPQVQiLCJleHRIYWxmRmxvYXQiLCJIQUxGX0ZMT0FUX09FUyIsImdldFRleHR1cmVQYXJhbWV0ZXJzIiwiX3NpemUiLCJnbFRleHR1cmUiLCJfZnJhbWVCdWZmZXJzIiwic3RhdHVzIiwibVRhcmdldEluZGV4IiwidXNlRGVwdGgiLCJ1c2VTdGVuY2lsIiwiX251bVNhbXBsZSIsIm51bVNhbXBsZSIsImZyYW1lQnVmZmVyQ29sb3IiLCJyZW5kZXJCdWZmZXJDb2xvciIsImNyZWF0ZVJlbmRlcmJ1ZmZlciIsInJlbmRlckJ1ZmZlckRlcHRoIiwicmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlIiwiUkdCQTgiLCJmcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciIsImZvcmNlTmVhcmVzdCIsIlJFQURfRlJBTUVCVUZGRVIiLCJjbGVhckJ1ZmZlcmZ2IiwiQ09MT1IiLCJibGl0RnJhbWVidWZmZXIiLCJfdnMiLCJfZnMiLCJfbWVzaEN1cnJlbnQiLCJfbWVzaFRhcmdldCIsIl9udW1Qb2ludHMiLCJjcmVhdGVUcmFuc2Zvcm1GZWVkYmFjayIsIm1WYXJ5aW5nTmFtZSIsImlzVHJhbnNmb3JtRmVlZGJhY2siLCJTVFJFQU1fQ09QWSIsImdlbmVyYXRlIiwiZHJhd1RyYW5zZm9ybUZlZWRiYWNrIiwiX3N3YXAiLCJFYXNpbmciLCJMaW5lYXIiLCJOb25lIiwiayIsIlF1YWRyYXRpYyIsIkluIiwiT3V0IiwiSW5PdXQiLCJDdWJpYyIsIlF1YXJ0aWMiLCJRdWludGljIiwiU2ludXNvaWRhbCIsIkV4cG9uZW50aWFsIiwicG93IiwiQ2lyY3VsYXIiLCJFbGFzdGljIiwicCIsImFzaW4iLCJCYWNrIiwiQm91bmNlIiwiaW4iLCJvdXQiLCJpbk91dCIsImdldEZ1bmMiLCJtU3BlZWQiLCJfc3RhcnRWYWx1ZSIsIl9jb3VudGVyIiwic3BlZWQiLCJuZXdDb3VudGVyIiwiZiIsIm0iLCJfdlpheGlzIiwiX3pBeGlzIiwicHJlTW91c2UiLCJtb3VzZSIsInF1YXQiLCJ0ZW1wUm90YXRpb24iLCJfcm90YXRlWk1hcmdpbiIsIl9vZmZzZXQiLCJfc2xlcnAiLCJfaXNMb2NrZWQiLCJfZGlmZlgiLCJfZGlmZlkiLCJfdXBkYXRlUm90YXRpb24iLCJfY3VyckRpZmZYIiwiX2N1cnJEaWZmWSIsIl9pc1JvdGF0ZVoiLCJfdGFyZ2V0UXVhdCIsInNldFRvIiwibVRlbXBSb3RhdGlvbiIsImFuZ2xlIiwic2xlcnAiLCJ0cmFuc2Zvcm1RdWF0IiwiZGlzdGFuY2UiLCJkeCIsImR5IiwibVNraXBNb3ZlQ2hlY2siLCJfY2FtZXJhIiwiZmFjZVZlcnRpY2VzIiwiZmFjZXMiLCJjbGlja1RvbGVyYW5jZSIsIl9yYXkiLCJfaGl0IiwiX2xhc3RQb3MiLCJfZmlyc3RQb3MiLCJtdHhNb2RlbCIsIl9za2lwcGluZ01vdmUiLCJfb25Nb3ZlQmluZCIsIl9vbkRvd25CaW5kIiwiX29uVXBCaW5kIiwibXgiLCJteSIsImdlbmVyYXRlUmF5IiwiaGl0IiwidjAiLCJ2MiIsImRpc3QiLCJnZXRWZWN0b3IiLCJpbnRlcnNlY3RUcmlhbmdsZSIsImRpc3RUb0NhbSIsIl9jaGVja0hpdCIsIkNBTUVSQV9TRVRUSU5HUyIsInNldFBlcnNwZWN0aXZlIiwicGFyc2VPYmoiLCJvYmpTdHIiLCJmaW5hbE5vcm1hbHMiLCJ1dnMiLCJ2ZXJ0ZXhQYXR0ZXJuIiwibm9ybWFsUGF0dGVybiIsInV2UGF0dGVybiIsImZhY2VQYXR0ZXJuMSIsImZhY2VQYXR0ZXJuMiIsImZhY2VQYXR0ZXJuMyIsImZhY2VQYXR0ZXJuNCIsInBhcnNlVmVydGV4SW5kZXgiLCJwYXJzZUludCIsInBhcnNlTm9ybWFsSW5kZXgiLCJwYXJzZVVWSW5kZXgiLCJhZGRWZXJ0ZXgiLCJhZGRVViIsImFkZE5vcm1hbCIsImFkZEZhY2UiLCJ1YSIsInViIiwidWMiLCJ1ZCIsIm5hIiwibmIiLCJuYyIsIm5kIiwiaWQiLCJsaW5lIiwidHJpbSIsImNoYXJBdCIsImV4ZWMiLCJwYXJzZUZsb2F0IiwiX2dlbmVyYXRlTWVzaGVzIiwibWF4TnVtVmVydGljZXMiLCJoYXNOb3JtYWxzIiwiaGFzVVZzIiwibWVzaGVzIiwibGFzdEluZGV4Iiwib0NvcHkiLCJzbGljZU51bSIsInRtcEluZGV4IiwicGFyc2UiLCJsb2FkZXIiLCJyYWRpYW5jZVBhdHRlcm4iLCJjb21tZW50UGF0dGVybiIsImV4cG9zdXJlUGF0dGVybiIsImZvcm1hdFBhdHRlcm4iLCJ3aWR0aEhlaWdodFBhdHRlcm4iLCJyZWFkUGl4ZWxzUmF3UkxFIiwiZmlsZU9mZnNldCIsInNjYW5saW5lV2lkdGgiLCJudW1TY2FubGluZXMiLCJyZ2JlIiwic2NhbmxpbmVCdWZmZXIiLCJwdHIiLCJwdHJFbmQiLCJidWYiLCJidWZmZXJMZW5ndGgiLCJyZWFkQnVmIiwiYnl0ZXNSZWFkIiwicmVhZEJ1Zk9mZnNldCIsInJlYWRQaXhlbHNSYXciLCJudW1waXhlbHMiLCJudW1FeHBlY3RlZCIsIm51bVJlYWQiLCJFcnJvciIsInBhcnNlSGRyIiwiQXJyYXlCdWZmZXIiLCJORVdfTElORSIsInJlYWRMaW5lIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZ2FtbWEiLCJybGUiLCJtYXRjaCIsIk51bWJlciIsImZsb2F0RGF0YSIsImZsb2F0T2Zmc2V0IiwiZ2VuZXJhdGVNZXNoIiwiY2FjaGVzIiwidHJpYW5nbGVzIiwiZ2xNZXNoIiwiYnVmZmVyRmxhdHRlbkRhdGEiLCJsb2FkIiwibVBhdGgiLCJtQ2FsbGJhY2siLCJBUlJBWV9DVE9SX01BUCIsIkludDhBcnJheSIsIkludDE2QXJyYXkiLCJVaW50MzJBcnJheSIsIlNJWkVfTUFQIiwiU0NBTEFSIiwiVkVDMiIsIlZFQzMiLCJWRUM0IiwiTUFUMiIsIk1BVDMiLCJNQVQ0Iiwic2VtYW50aWNBdHRyaWJ1dGVNYXAiLCJOT1JNQUwiLCJQT1NJVElPTiIsIlRFWENPT1JEXzAiLCJURVhDT09SRF8xIiwiV0VJR0hUU18wIiwiSk9JTlRTXzAiLCJiYXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJsYXN0SW5kZXhPZiIsIl9sb2FkR2x0ZiIsInRoZW4iLCJfbG9hZEJpbiIsIl9nZXRCdWZmZXJWaWV3RGF0YSIsIl9sb2FkVGV4dHVyZXMiLCJfcGFyc2VNZXNoIiwiX3BhcnNlTm9kZXMiLCJnbHRmSW5mbyIsImNhdGNoIiwiZ2x0ZiIsIm5vZGVzIiwibm9kZUluZm8iLCJpbmNsdWRlQ2FtZXJhIiwiZ2VvbWV0cmllcyIsIm91dHB1dCIsInNjZW5lIiwicHJpbWl0aXZlcyIsImdlb21ldHJ5IiwicHJpbWl0aXZlSW5mbyIsInNlbWFudGljcyIsImtleXMiLCJzZW1hbnRpYyIsImFjY2Vzc29ySWR4IiwiYXR0cmlidXRlSW5mbyIsImFjY2Vzc29ycyIsImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGVBcnJheSIsIl9nZXRBY2Nlc3NvckRhdGEiLCJidWZmZXJWaWV3cyIsImJ1ZmZlclZpZXdJbmZvIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJKU09OIiwidXJsQmluIiwidXJpIiwibUdsdGZJbmZvIiwibUJpbiIsImlzSW5kaWNlcyIsImFjY2Vzc29ySW5mbyIsImJ1ZmZlclZpZXciLCJBcnJheUN0b3IiLCJjb21wb25lbnRUeXBlIiwiYXJyIiwicXVhbnRpemVFeHRlbnNpb24iLCJkZWNvZGVkQXJyIiwiZGVjb2RlTWF0cml4IiwiZGVjb2RlT2Zmc2V0IiwiZGVjb2RlU2NhbGUiLCJyZXEiLCJfcmV0dXJuVGV4dHVyZSIsInBhc3NlcyIsImFkZFBhc3MiLCJmYm9UYXJnZXQiLCJoYXNGYm8iLCJmYm8iLCJfZmJvVGFyZ2V0IiwicmVuZGVyIiwiZ2V0VGV4dHVyZSIsIl9mYm9DdXJyZW50IiwiX2N1cnJlbnQiLCJ2Qmx1ciIsImhCbHVyIiwidnMiLCJjb2xvcnMiLCJjb2xvciIsIm9wYWNpdHkiLCJtUG9zaXRpb25BIiwibVBvc2l0aW9uQiIsInNlZyIsIl9jaGlsZHJlbiIsIl9tYXRyaXhJZGVudGl0eSIsIl9pbml0Vmlld3MiLCJyZXNpemUiLCJzZXRBc3BlY3RSYXRpbyIsImFzcGVjdFJhdGlvIiwibUNoaWxkIiwiY2hpbGQiLCJ0b1JlbmRlciIsIm9yYml0YWxDb250cm9sIiwiY2FtZXJhT3J0aG8iLCJzZXRNYXRyaWNlcyIsInVwZGF0ZSIsIl9yZW5kZXJDaGlsZHJlbiIsIm1TdHJWZXJ0ZXgiLCJtU3RyRnJhZyIsIl9tYXRyaXhUZW1wIiwiQXNzZXRzIiwiX2Fzc2V0cyIsImdldEFzc2V0IiwiYXNzZXRzIiwiZmlsZSIsIm1GaWxlIiwiaW5pdCIsImhkckN1YmVtYXBzIiwiY3ViZW1hcE5hbWUiLCJvQXNzZXQiLCJnZXQiLCJkZWJ1ZyIsInRhYmxlIiwibUlkIiwiYXNzZXRzVG9Mb2FkIiwicXVlcnlTdHJpbmciLCJlbmFibGVkIiwicmVsb2FkIiwibG9jYXRpb24iLCJocmVmIiwicGF0aG5hbWUiLCJzdHJpbmdpZnkiLCJyZWZyZXNoIiwiaGlzdG9yeSIsInB1c2hTdGF0ZSIsImRlbGF5SW5kZXgiLCJkZWxheVJlbG9hZCIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJtRW5hYmxlZCIsInBhcnNlZCIsInNlYXJjaCIsInF1ZXJ5IiwiY29uZmlnIiwib0NvbmZpZyIsImJvZHkiLCJjbGFzc0xpc3QiLCJvbiIsInF1ZXJ5U2VsZWN0b3IiLCJzdHlsZSIsIl9vbkltYWdlTG9hZGVkIiwic3RhcnQiLCJfaW5pdDNEIiwicmVtb3ZlIiwiY2xhc3NOYW1lIiwiYXBwZW5kQ2hpbGQiLCJpZ25vcmVXZWJnbDIiLCJndWkiLCJTY2VuZUFwcCIsIl9iQ29weSIsIl9iQXhpcyIsIl9iRG90cyIsIl9iU2t5IiwiX3ZNaWNybyIsImVudiIsImVudnMiLCJfdXBkYXRlRW52TWFwIiwib25GaW5pc2hDaGFuZ2UiLCJ0ZXh0dXJlSXJyIiwidGV4dHVyZVJhZCIsImRldmljZVBpeGVsUmF0aW8iLCJkZWZpbmVzVG9TdHJpbmciLCJkZWZpbmVzIiwib3V0U3RyIiwiZGVmIiwiVmlld01pY3JvIiwiZGVmaW5lU3RyIiwib25DaGFuZ2UiLCJ0ZXh0dXJlQnJkZiIsInRleHR1cmVDb2xvciIsInRleHR1cmVNZXRhbEdsb3NzIiwidGV4dHVyZUFPIiwidGV4dHVyZU5vcm1hbCIsImJhc2VDb2xvciIsInJvdWdobmVzcyIsIm1ldGFsbGljIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUEyRDtBQUMzRDtBQUNBO0FBQ0EsV0FBRzs7QUFFSCxvREFBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3REFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFNO0FBQ047QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0EsY0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGVBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJO0FBQ0o7Ozs7QUFJQTtBQUNBLHNEQUE4QztBQUM5QztBQUNBO0FBQ0Esb0NBQTRCO0FBQzVCLHFDQUE2QjtBQUM3Qix5Q0FBaUM7O0FBRWpDLCtDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBc0M7QUFDdEM7QUFDQTtBQUNBLHFDQUE2QjtBQUM3QixxQ0FBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGFBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQWlCLDhCQUE4QjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJO0FBQ0o7O0FBRUEsNERBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQSxjQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQWEsNEJBQTRCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNCQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBZ0IsdUNBQXVDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBZ0IsdUNBQXVDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxnQkFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBYSx3Q0FBd0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxl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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBSztBQUNmLFVBQVUsS0FBSztBQUNmO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEtBQUs7QUFDZixVQUFVLEtBQUs7QUFDZjtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1dkJBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7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Q0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxL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O0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdB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QTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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SztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlFQUF5QyxhQUFhOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQixZQUFZLEtBQUs7QUFDakIsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE1BQU07QUFDakIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEI7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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S0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtB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QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE1BQU07QUFDakIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUIsb0JBQW9CO0FBQ3BCO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7OztrQkNya0J1QmtlLG9CO0FBRnhCOztBQUVlLFNBQVNBLG9CQUFULENBQThCbmhDLEVBQTlCLEVBQWtDc0wsSUFBbEMsRUFBd0M7QUFDdEQsS0FBTTNELE1BQU0zSCxHQUFHeUMsWUFBSCxDQUFnQjZJLElBQWhCLENBQVo7QUFDQSxLQUFJLENBQUMzRCxHQUFMLEVBQVU7QUFDVCxTQUFPLEtBQVA7QUFDQTtBQUNELEtBQU15NUIsU0FBUzkxQixLQUFLbkMsS0FBTCxDQUFXLEdBQVgsRUFBZ0IsQ0FBaEIsQ0FBZjtBQUNBLEtBQU1rNEIsV0FBVyxJQUFJQyxNQUFKLENBQWNGLE1BQWQsT0FBakI7O0FBRUEsTUFBSyxJQUFNRyxHQUFYLElBQWtCNTVCLEdBQWxCLEVBQXVCO0FBQ3RCLE1BQU02NUIsTUFBTTc1QixJQUFJNDVCLEdBQUosQ0FBWjtBQUNBLE1BQUksT0FBT0MsR0FBUCxLQUFnQixVQUFwQixFQUFnQztBQUMvQixPQUFNQyxnQkFBZ0JGLElBQUlHLE9BQUosQ0FBWUwsUUFBWixFQUFzQixFQUF0QixDQUF0QjtBQUNBLE9BQUlFLElBQUlJLFNBQVIsRUFBbUI7QUFDbEIzaEMsT0FBR3loQyxhQUFILElBQW9COTVCLElBQUk0NUIsR0FBSixFQUFTdjhCLElBQVQsQ0FBYzJDLEdBQWQsQ0FBcEI7QUFDQTtBQUNBO0FBQ0Q7QUFDRDs7QUFFRCxRQUFPLElBQVA7QUFDQSxDOzs7Ozs7Ozs7Ozs7O0FDcEJEOzs7O0FBQ0E7Ozs7OztBQUhBOztBQUtBLElBQU1pNkIsbUJBQW1CLFNBQW5CQSxnQkFBbUIsR0FBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLLElBQU14b0IsQ0FBWCwwQkFBNEI7QUFDM0IsTUFBRyxDQUFDLGlCQUFHQSxDQUFILENBQUosRUFBVztBQUNWLG9CQUFHQSxDQUFILElBQVEscUJBQVdBLENBQVgsQ0FBUjtBQUNBLEdBRkQsTUFFTztBQUNOM1gsV0FBUVUsR0FBUixDQUFZLGtCQUFaLEVBQWdDaVgsQ0FBaEM7QUFDQTtBQUVEO0FBQ0QsQ0E3QkQ7O2tCQWdDZXdvQixnQjs7Ozs7Ozs7Ozs7OztrQkNiQSxZQUFZO0FBQzFCLEtBQUcsQ0FBQ0MsVUFBSixFQUFnQjtBQUNmQyxXQUFTQyxZQUFUO0FBQ0E7O0FBR0QsUUFBT0QsTUFBUDtBQUNBLEM7O0FBN0JEOzs7Ozs7QUFFQSxJQUFJRCxhQUFhLEtBQWpCLEMsQ0FKQTs7QUFLQSxJQUFJQyxlQUFKOztBQUdBLFNBQVNDLFVBQVQsR0FBc0I7QUFDckIsS0FBRyxpQkFBRzMvQixNQUFOLEVBQWM7QUFDYixTQUFPLGlCQUFHcEMsRUFBSCxDQUFNNlEsS0FBYjtBQUNBLEVBRkQsTUFFTztBQUNOLE1BQU1teEIsV0FBVyxpQkFBR3YvQixZQUFILENBQWdCLG1CQUFoQixDQUFqQjtBQUNBLE1BQUd1L0IsUUFBSCxFQUFhO0FBQ1osVUFBTyxpQkFBR2hpQyxFQUFILENBQU02USxLQUFiO0FBQ0EsR0FGRCxNQUVPO0FBQ05wUCxXQUFRcUwsSUFBUixDQUFhLGlEQUFiO0FBQ0EsVUFBTyxpQkFBRzlNLEVBQUgsQ0FBTW1aLGFBQWI7QUFDQTtBQUNEOztBQUVEMG9CLGNBQWEsSUFBYjtBQUNBLEU7Ozs7Ozs7Ozs7Ozs7a0JDQ2MsWUFBWTtBQUMxQixLQUFHLENBQUNBLFVBQUosRUFBZ0I7QUFDZkksY0FBWUMsZ0JBQVo7QUFDQTs7QUFFRCxRQUFPRCxTQUFQO0FBQ0EsQzs7QUEzQkQ7Ozs7OztBQUVBLElBQUlKLGFBQWEsS0FBakIsQyxDQUpBOztBQUtBLElBQUlJLGtCQUFKOztBQUVBLFNBQVNDLGNBQVQsR0FBMEI7QUFDekIsS0FBRyxpQkFBRzkvQixNQUFOLEVBQWM7QUFDYixTQUFPLGlCQUFHcEMsRUFBSCxDQUFNbWlDLFVBQWI7QUFDQSxFQUZELE1BRU87QUFDTixNQUFNQyxlQUFlLGlCQUFHMy9CLFlBQUgsQ0FBZ0Isd0JBQWhCLENBQXJCO0FBQ0EsTUFBRzIvQixZQUFILEVBQWlCO0FBQ2hCLFVBQU9BLGFBQWFDLGNBQXBCO0FBQ0EsR0FGRCxNQUVPO0FBQ041Z0MsV0FBUXFMLElBQVIsQ0FBYSwyREFBYjtBQUNBLFVBQU8saUJBQUc5TSxFQUFILENBQU1tWixhQUFiO0FBQ0E7QUFDRDs7QUFFRDBvQixjQUFhLElBQWI7QUFDQSxFOzs7Ozs7Ozs7Ozs7QUNyQkQ7O2tCQUVlLENBQ2Qsd0JBRGMsRUFFZCxVQUZjLEVBR2QsZ0JBSGMsRUFJZCxtQkFKYyxFQUtkLHdCQUxjLEVBTWQsMEJBTmMsRUFPZCwrQkFQYyxFQVFkLDBCQVJjLEVBU2QscUJBVGMsRUFVZCxnQ0FWYyxFQVdkLHlCQVhjLEVBWWQsd0JBWmMsRUFhZCxvQkFiYyxDOzs7Ozs7QUNGZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1RBLDhGQUE4RixnREFBZ0QscUJBQXFCLCtCQUErQixxQkFBcUIsbUVBQW1FLEdBQUcsQzs7Ozs7Ozs7Ozs7OztBQ0U3Ujs7Ozs7O0FBRUEsU0FBU25OLFlBQVQsQ0FBc0IzeEIsQ0FBdEIsRUFBeUI7QUFDeEIsUUFBUUEsTUFBTSxDQUFQLElBQWMsRUFBRUEsSUFBS0EsSUFBSSxDQUFYLENBQXJCO0FBQ0EsQyxDQU5EOztBQU1DOztBQUVELElBQU11L0IsdUJBQXVCLFNBQXZCQSxvQkFBdUIsQ0FBVTVzQixPQUFWLEVBQW1CRCxPQUFuQixFQUE0QnJPLE1BQTVCLEVBQW9DQyxPQUFwQyxFQUE2QztBQUN6RSxLQUFHLENBQUNxTyxRQUFRK0MsU0FBWixFQUF1QjtBQUN0QixNQUFJQSxZQUFZLGlCQUFHQyxNQUFuQjtBQUNBLE1BQUd0UixVQUFVQSxNQUFiLEVBQXFCO0FBQ3BCLE9BQUdzdEIsYUFBYXR0QixNQUFiLEtBQXdCc3RCLGFBQWFydEIsT0FBYixDQUEzQixFQUFrRDtBQUNqRG9SLGdCQUFZLGlCQUFHOFMscUJBQWY7QUFDQTtBQUNEOztBQUVEN1YsVUFBUStDLFNBQVIsR0FBb0JBLFNBQXBCO0FBQ0E7O0FBR0QvQyxTQUFRNmlCLE1BQVIsR0FBaUI3aUIsUUFBUTZpQixNQUFSLElBQWtCLElBQW5DO0FBQ0E3aUIsU0FBUStELFNBQVIsR0FBb0IvRCxRQUFRK0QsU0FBUixJQUFxQixpQkFBR2YsTUFBNUM7QUFDQWhELFNBQVFnRSxLQUFSLEdBQWdCaEUsUUFBUWdFLEtBQVIsSUFBaUIsaUJBQUc0TCxhQUFwQztBQUNBNVAsU0FBUWlFLEtBQVIsR0FBZ0JqRSxRQUFRaUUsS0FBUixJQUFpQixpQkFBRzJMLGFBQXBDO0FBQ0E1UCxTQUFRc0QsY0FBUixHQUF5QnRELFFBQVFzRCxjQUFSLElBQTBCLGlCQUFHQyxJQUF0RDtBQUNBdkQsU0FBUXdELE1BQVIsR0FBaUJ4RCxRQUFRd0QsTUFBUixJQUFrQixpQkFBR0QsSUFBdEM7QUFDQXZELFNBQVFzaUIsZ0JBQVIsR0FBMkJ0aUIsUUFBUXNpQixnQkFBUixJQUE0QixLQUF2RDtBQUNBdGlCLFNBQVF3aUIsS0FBUixHQUFnQnhpQixRQUFRd2lCLEtBQVIsSUFBaUIsQ0FBakM7QUFDQXhpQixTQUFRdWlCLFVBQVIsR0FBcUJ2aUIsUUFBUXVpQixVQUFSLElBQXNCLENBQTNDO0FBQ0EsUUFBT3ZpQixPQUFQO0FBQ0EsQ0F2QkQ7O2tCQTBCZTRzQixvQjs7Ozs7O0FDbENmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxtQkFBbUIsaUJBQWlCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuTEE7O0FBRUE7Ozs7Ozs7O0FBRUE7Ozs7QUFDQTs7Ozs7Ozs7QUFFQSxJQUFJdGlDLFdBQUo7O0lBR01taEIsZTtBQUVMLDBCQUFZbE4sSUFBWixFQUFvQztBQUFBLE1BQWxCMVMsV0FBa0IsdUVBQUosRUFBSTs7QUFBQTs7QUFDbkN2QixPQUFLLGlCQUFHQSxFQUFSO0FBQ0EsT0FBS3VpQyxLQUFMLEdBQWF0dUIsSUFBYjtBQUNBLE9BQUt3RixTQUFMLEdBQWlCbFksWUFBWWtZLFNBQVosSUFBeUJ6WixHQUFHMFksTUFBN0M7QUFDQSxPQUFLRCxTQUFMLEdBQWlCbFgsWUFBWWtYLFNBQVosSUFBeUJ6WSxHQUFHMFksTUFBN0M7QUFDQSxPQUFLZ0IsS0FBTCxHQUFpQm5ZLFlBQVltWSxLQUFaLElBQXFCMVosR0FBR3NsQixhQUF6QztBQUNBLE9BQUszTCxLQUFMLEdBQWlCcFksWUFBWW9ZLEtBQVosSUFBcUIzWixHQUFHc2xCLGFBQXpDOztBQUVBLE9BQUsxTyxLQUFMO0FBQ0E7Ozs7MEJBR087QUFDUCxRQUFLWixPQUFMLEdBQWlCaFcsR0FBR2sxQixhQUFILEVBQWpCO0FBQ0EsUUFBS3NOLFNBQUwsR0FBaUIsNEJBQWtCLEtBQUt4c0IsT0FBdkIsRUFBZ0MsRUFBaEMsRUFBb0MsSUFBcEMsQ0FBakI7O0FBRUFoVyxNQUFHK1gsV0FBSCxDQUFlL1gsR0FBR3N5QixnQkFBbEIsRUFBb0MsS0FBS3RjLE9BQXpDO0FBQ0FoVyxNQUFHODFCLGFBQUgsQ0FBaUI5MUIsR0FBR3N5QixnQkFBcEIsRUFBc0N0eUIsR0FBRzZ5QixrQkFBekMsRUFBNkQsS0FBS3BaLFNBQWxFO0FBQ0F6WixNQUFHODFCLGFBQUgsQ0FBaUI5MUIsR0FBR3N5QixnQkFBcEIsRUFBc0N0eUIsR0FBRzh5QixrQkFBekMsRUFBNkQsS0FBS3JhLFNBQWxFO0FBQ0F6WSxNQUFHODFCLGFBQUgsQ0FBaUI5MUIsR0FBR3N5QixnQkFBcEIsRUFBc0N0eUIsR0FBRyt5QixjQUF6QyxFQUF5RCxLQUFLclosS0FBOUQ7QUFDQTFaLE1BQUc4MUIsYUFBSCxDQUFpQjkxQixHQUFHc3lCLGdCQUFwQixFQUFzQ3R5QixHQUFHZ3pCLGNBQXpDLEVBQXlELEtBQUtyWixLQUE5RDs7QUFFQSxPQUFNc2YsVUFBVSxDQUNmajVCLEdBQUcweUIsMkJBRFksRUFDaUIxeUIsR0FBR3V5QiwyQkFEcEIsRUFFZnZ5QixHQUFHMnlCLDJCQUZZLEVBRWlCM3lCLEdBQUd3eUIsMkJBRnBCLEVBR2Z4eUIsR0FBRzR5QiwyQkFIWSxFQUdpQjV5QixHQUFHeXlCLDJCQUhwQixDQUFoQjs7QUFNQSxRQUFJLElBQUlsd0IsSUFBSSxDQUFaLEVBQWVBLElBQUkwMkIsUUFBUXoyQixNQUEzQixFQUFtQ0QsR0FBbkMsRUFBd0M7QUFDdkN2QyxPQUFHMDFCLFdBQUgsQ0FBZTExQixHQUFHc3pCLG1CQUFsQixFQUF1QyxLQUF2QztBQUNBdHpCLE9BQUc0MUIsVUFBSCxDQUFjcUQsUUFBUTEyQixDQUFSLENBQWQsRUFBMEIsQ0FBMUIsRUFBNkJ2QyxHQUFHaVosSUFBaEMsRUFBc0MsS0FBS3pSLEtBQTNDLEVBQWtELEtBQUtDLE1BQXZELEVBQStELENBQS9ELEVBQWtFekgsR0FBR2laLElBQXJFLEVBQTJFalosR0FBRzZRLEtBQTlFLEVBQXFGLElBQXJGO0FBQ0E7O0FBR0QsUUFBSzR4QixhQUFMLEdBQXFCLEVBQXJCO0FBQ0EsUUFBSSxJQUFJbGdDLEtBQUksQ0FBWixFQUFlQSxLQUFJMDJCLFFBQVF6MkIsTUFBM0IsRUFBbUNELElBQW5DLEVBQXdDO0FBQ3ZDLFFBQU11VSxjQUFjOVcsR0FBRytXLGlCQUFILEVBQXBCO0FBQ0EvVyxPQUFHZ1gsZUFBSCxDQUFtQmhYLEdBQUdpWCxXQUF0QixFQUFtQ0gsV0FBbkM7QUFDQTlXLE9BQUdtWCxvQkFBSCxDQUF3Qm5YLEdBQUdpWCxXQUEzQixFQUF3Q2pYLEdBQUdxWCxpQkFBM0MsRUFBOEQ0aEIsUUFBUTEyQixFQUFSLENBQTlELEVBQTBFLEtBQUt5VCxPQUEvRSxFQUF3RixDQUF4Rjs7QUFFQSxRQUFNMHNCLFNBQVMxaUMsR0FBRzZYLHNCQUFILENBQTBCN1gsR0FBR2lYLFdBQTdCLENBQWY7QUFDQSxRQUFJeXJCLFdBQVcxaUMsR0FBRzhYLG9CQUFsQixFQUF3QztBQUN2Q3JXLGFBQVFVLEdBQVIsK0NBQXNEdWdDLE1BQXREO0FBQ0E7O0FBRUQsU0FBS0QsYUFBTCxDQUFtQnQ2QixJQUFuQixDQUF3QjJPLFdBQXhCO0FBQ0E7O0FBRUQ7QUFDQTlXLE1BQUdnWCxlQUFILENBQW1CaFgsR0FBR2lYLFdBQXRCLEVBQW1DLElBQW5DO0FBQ0FqWCxNQUFHZ1ksZ0JBQUgsQ0FBb0JoWSxHQUFHaVksWUFBdkIsRUFBcUMsSUFBckM7QUFDQWpZLE1BQUcrWCxXQUFILENBQWUvWCxHQUFHc3lCLGdCQUFsQixFQUFvQyxJQUFwQztBQUNBOzs7dUJBR0lxUSxZLEVBQWM7O0FBRWxCO0FBQ0Esb0JBQUd2L0IsUUFBSCxDQUFZLENBQVosRUFBZSxDQUFmLEVBQWtCLEtBQUtvRSxLQUF2QixFQUE4QixLQUFLQyxNQUFuQztBQUNBekgsTUFBR2dYLGVBQUgsQ0FBbUJoWCxHQUFHaVgsV0FBdEIsRUFBbUMsS0FBS3dyQixhQUFMLENBQW1CRSxZQUFuQixDQUFuQztBQUNBOzs7MkJBRVE7QUFDUjNpQyxNQUFHZ1gsZUFBSCxDQUFtQmhYLEdBQUdpWCxXQUF0QixFQUFtQyxJQUFuQztBQUNBLG9CQUFHN1QsUUFBSCxDQUFZLENBQVosRUFBZSxDQUFmLEVBQWtCLGlCQUFHb0UsS0FBckIsRUFBNEIsaUJBQUdDLE1BQS9CO0FBQ0E7O0FBRUQ7Ozs7K0JBRWE7QUFDWixVQUFPLEtBQUsrNkIsU0FBWjtBQUNBOztBQUVEOzs7O3NCQUVZO0FBQ1gsVUFBTyxLQUFLRCxLQUFaO0FBQ0E7OztzQkFFWTtBQUNaLFVBQU8sS0FBS0EsS0FBWjtBQUNBOzs7Ozs7a0JBSWFwaEIsZTs7Ozs7Ozs7Ozs7OztxakJDakdmOztBQUVBOzs7O0FBQ0E7Ozs7Ozs7O0FBRUEsSUFBSW5oQixXQUFKOztBQUVBLFNBQVMwMEIsWUFBVCxDQUFzQjN4QixDQUF0QixFQUF5QjtBQUN4QixRQUFRQSxNQUFNLENBQVAsSUFBYyxFQUFFQSxJQUFLQSxJQUFJLENBQVgsQ0FBckI7QUFDQTs7SUFFS29nQixzQjtBQUNMLGlDQUFZL2IsTUFBWixFQUFvQkMsT0FBcEIsRUFBK0M7QUFBQSxNQUFsQjlGLFdBQWtCLHVFQUFKLEVBQUk7O0FBQUE7O0FBQzlDdkIsT0FBSyxpQkFBR0EsRUFBUjs7QUFFQSxPQUFLd0gsS0FBTCxHQUF3QkosTUFBeEI7QUFDQSxPQUFLSyxNQUFMLEdBQXdCSixPQUF4Qjs7QUFFQSxPQUFLb1MsU0FBTCxHQUFrQmxZLFlBQVlrWSxTQUFaLElBQTBCelosR0FBRzBZLE1BQS9DO0FBQ0EsT0FBS0QsU0FBTCxHQUFrQmxYLFlBQVlrWCxTQUFaLElBQTBCelksR0FBRzBZLE1BQS9DO0FBQ0EsT0FBS2dCLEtBQUwsR0FBa0JuWSxZQUFZbVksS0FBWixJQUF1QjFaLEdBQUdzbEIsYUFBNUM7QUFDQSxPQUFLM0wsS0FBTCxHQUFrQnBZLFlBQVlvWSxLQUFaLElBQXVCM1osR0FBR3NsQixhQUE1QztBQUNBLE9BQUtzZCxRQUFMLEdBQWtCcmhDLFlBQVlxaEMsUUFBWixJQUEwQixJQUE1QztBQUNBLE9BQUtDLFVBQUwsR0FBa0J0aEMsWUFBWXNoQyxVQUFaLElBQTJCLEtBQTdDO0FBQ0EsT0FBS3hLLFNBQUwsR0FBa0I5MkIsWUFBWWtLLElBQTlCO0FBQ0EsT0FBS3EzQixVQUFMLEdBQWtCdmhDLFlBQVl3aEMsU0FBWixJQUEwQixDQUE1Qzs7QUFFQSxNQUFHLENBQUNyTyxhQUFhLEtBQUtsdEIsS0FBbEIsQ0FBRCxJQUE2QixDQUFDa3RCLGFBQWEsS0FBS2p0QixNQUFsQixDQUFqQyxFQUE0RDtBQUMzRCxRQUFLaVMsS0FBTCxHQUFhLEtBQUtDLEtBQUwsR0FBYTNaLEdBQUdzbEIsYUFBN0I7O0FBRUEsT0FBRyxLQUFLN00sU0FBTCxLQUFtQnpZLEdBQUc4cEIscUJBQXpCLEVBQWdEO0FBQy9DLFNBQUtyUixTQUFMLEdBQWlCelksR0FBRzBZLE1BQXBCO0FBQ0E7QUFDRDs7QUFFRCxPQUFLOUIsS0FBTDtBQUNBOzs7OzBCQUVPO0FBQ1AsT0FBSXloQixZQUFZcjRCLEdBQUdtWixhQUFuQjtBQUNBLE9BQUksS0FBS2tmLFNBQVQsRUFBb0I7QUFDbkJBLGdCQUFZLEtBQUtBLFNBQWpCO0FBQ0E7O0FBRUQsUUFBS0EsU0FBTCxHQUFpQkEsU0FBakI7O0FBRUEsUUFBS3ZoQixXQUFMLEdBQTBCOVcsR0FBRytXLGlCQUFILEVBQTFCO0FBQ0EsUUFBS2lzQixnQkFBTCxHQUEwQmhqQyxHQUFHK1csaUJBQUgsRUFBMUI7QUFDQSxRQUFLa3NCLGlCQUFMLEdBQTBCampDLEdBQUdrakMsa0JBQUgsRUFBMUI7QUFDQSxRQUFLQyxpQkFBTCxHQUEwQm5qQyxHQUFHa2pDLGtCQUFILEVBQTFCO0FBQ0EsUUFBS1YsU0FBTCxHQUFvQixLQUFLbHFCLGNBQUwsRUFBcEI7QUFDQSxRQUFLWixjQUFMLEdBQXVCLEtBQUtZLGNBQUwsQ0FBb0J0WSxHQUFHdVksaUJBQXZCLEVBQTBDdlksR0FBR3dGLGNBQTdDLEVBQTZEeEYsR0FBR3dZLGVBQWhFLEVBQWlGLElBQWpGLENBQXZCOztBQUVBeFksTUFBR2dZLGdCQUFILENBQW9CaFksR0FBR2lZLFlBQXZCLEVBQXFDLEtBQUtnckIsaUJBQTFDO0FBQ0FqakMsTUFBR29qQyw4QkFBSCxDQUFrQ3BqQyxHQUFHaVksWUFBckMsRUFBbUQsS0FBSzZxQixVQUF4RCxFQUFvRTlpQyxHQUFHcWpDLEtBQXZFLEVBQThFLEtBQUs3N0IsS0FBbkYsRUFBMEYsS0FBS0MsTUFBL0Y7O0FBRUF6SCxNQUFHZ1ksZ0JBQUgsQ0FBb0JoWSxHQUFHaVksWUFBdkIsRUFBcUMsS0FBS2tyQixpQkFBMUM7QUFDQW5qQyxNQUFHb2pDLDhCQUFILENBQWtDcGpDLEdBQUdpWSxZQUFyQyxFQUFtRCxLQUFLNnFCLFVBQXhELEVBQW9FOWlDLEdBQUd1WSxpQkFBdkUsRUFBMEYsS0FBSy9RLEtBQS9GLEVBQXNHLEtBQUtDLE1BQTNHOztBQUVBekgsTUFBR2dYLGVBQUgsQ0FBbUJoWCxHQUFHaVgsV0FBdEIsRUFBbUMsS0FBS0gsV0FBeEM7QUFDQTlXLE1BQUdzakMsdUJBQUgsQ0FBMkJ0akMsR0FBR2lYLFdBQTlCLEVBQTJDalgsR0FBR3FYLGlCQUE5QyxFQUFpRXJYLEdBQUdpWSxZQUFwRSxFQUFrRixLQUFLZ3JCLGlCQUF2RjtBQUNBampDLE1BQUdzakMsdUJBQUgsQ0FBMkJ0akMsR0FBR2lYLFdBQTlCLEVBQTJDalgsR0FBR3lYLGdCQUE5QyxFQUFnRXpYLEdBQUdpWSxZQUFuRSxFQUFpRixLQUFLa3JCLGlCQUF0RjtBQUNBbmpDLE1BQUdnWCxlQUFILENBQW1CaFgsR0FBR2lYLFdBQXRCLEVBQW1DLElBQW5DOztBQUVBalgsTUFBR2dYLGVBQUgsQ0FBbUJoWCxHQUFHaVgsV0FBdEIsRUFBbUMsS0FBSytyQixnQkFBeEM7QUFDQWhqQyxNQUFHbVgsb0JBQUgsQ0FBd0JuWCxHQUFHaVgsV0FBM0IsRUFBd0NqWCxHQUFHcVgsaUJBQTNDLEVBQThEclgsR0FBR3NYLFVBQWpFLEVBQTZFLEtBQUtrckIsU0FBTCxDQUFleHNCLE9BQTVGLEVBQXFHLENBQXJHO0FBQ0E7QUFDQWhXLE1BQUdnWCxlQUFILENBQW1CaFgsR0FBR2lYLFdBQXRCLEVBQW1DLElBQW5DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7aUNBRWMwQixlLEVBQWlCQyxVLEVBQVlDLE8sRUFBK0I7QUFBQSxPQUF0QjBxQixZQUFzQix1RUFBUCxLQUFPOztBQUMxRSxPQUFHNXFCLG9CQUFvQm5YLFNBQXZCLEVBQWtDO0FBQUVtWCxzQkFBa0IzWSxHQUFHaVosSUFBckI7QUFBNEI7QUFDaEUsT0FBR0wsZUFBZXBYLFNBQWxCLEVBQTZCO0FBQUVvWCxpQkFBYSxLQUFLeWYsU0FBbEI7QUFBOEI7QUFDN0QsT0FBRyxDQUFDeGYsT0FBSixFQUFhO0FBQUVBLGNBQVVGLGVBQVY7QUFBNEI7O0FBRTNDLE9BQU1oRSxJQUFJM1UsR0FBR2sxQixhQUFILEVBQVY7QUFDQSxPQUFNN2MsTUFBTSx3QkFBYzFELENBQWQsRUFBaUIsSUFBakIsQ0FBWjtBQUNBLE9BQU04RSxZQUFZOHBCLGVBQWUsaUJBQUdqWSxPQUFsQixHQUE0QixLQUFLN1IsU0FBbkQ7QUFDQSxPQUFNaEIsWUFBWThxQixlQUFlLGlCQUFHalksT0FBbEIsR0FBNEIsS0FBSzdTLFNBQW5EOztBQUVBelksTUFBRytYLFdBQUgsQ0FBZS9YLEdBQUdzWCxVQUFsQixFQUE4QjNDLENBQTlCO0FBQ0EzVSxNQUFHODFCLGFBQUgsQ0FBaUI5MUIsR0FBR3NYLFVBQXBCLEVBQWdDdFgsR0FBRzZ5QixrQkFBbkMsRUFBdURwWixTQUF2RDtBQUNBelosTUFBRzgxQixhQUFILENBQWlCOTFCLEdBQUdzWCxVQUFwQixFQUFnQ3RYLEdBQUc4eUIsa0JBQW5DLEVBQXVEcmEsU0FBdkQ7QUFDQXpZLE1BQUc4MUIsYUFBSCxDQUFpQjkxQixHQUFHc1gsVUFBcEIsRUFBZ0N0WCxHQUFHK3lCLGNBQW5DLEVBQW1ELEtBQUtyWixLQUF4RDtBQUNBMVosTUFBRzgxQixhQUFILENBQWlCOTFCLEdBQUdzWCxVQUFwQixFQUFnQ3RYLEdBQUdnekIsY0FBbkMsRUFBbUQsS0FBS3JaLEtBQXhEO0FBQ0EzWixNQUFHNDFCLFVBQUgsQ0FBYzUxQixHQUFHc1gsVUFBakIsRUFBNkIsQ0FBN0IsRUFBZ0NxQixlQUFoQyxFQUFpRCxLQUFLblIsS0FBdEQsRUFBNkQsS0FBS0MsTUFBbEUsRUFBMEUsQ0FBMUUsRUFBNkVvUixPQUE3RSxFQUFzRkQsVUFBdEYsRUFBa0csSUFBbEc7QUFDQTVZLE1BQUcrWCxXQUFILENBQWUvWCxHQUFHc1gsVUFBbEIsRUFBOEIsSUFBOUI7O0FBRUEsVUFBT2UsR0FBUDtBQUNBOzs7eUJBRzJCO0FBQUEsT0FBdkJnQixnQkFBdUIsdUVBQU4sSUFBTTs7QUFDM0IsT0FBR0EsZ0JBQUgsRUFBcUI7QUFDcEIscUJBQUdqVyxRQUFILENBQVksQ0FBWixFQUFlLENBQWYsRUFBa0IsS0FBS29FLEtBQXZCLEVBQThCLEtBQUtDLE1BQW5DO0FBQ0E7QUFDRHpILE1BQUdnWCxlQUFILENBQW1CaFgsR0FBR2lYLFdBQXRCLEVBQW1DLEtBQUtILFdBQXhDO0FBQ0E7OzsyQkFHNkI7QUFBQSxPQUF2QnVDLGdCQUF1Qix1RUFBTixJQUFNOztBQUM3QixPQUFHQSxnQkFBSCxFQUFxQjtBQUNwQixxQkFBR2pXLFFBQUgsQ0FBWSxDQUFaLEVBQWUsQ0FBZixFQUFrQixpQkFBR29FLEtBQXJCLEVBQTRCLGlCQUFHQyxNQUEvQjtBQUNBOztBQUg0QixPQUtyQkQsS0FMcUIsR0FLSCxJQUxHLENBS3JCQSxLQUxxQjtBQUFBLE9BS2RDLE1BTGMsR0FLSCxJQUxHLENBS2RBLE1BTGM7OztBQU83QnpILE1BQUdnWCxlQUFILENBQW1CaFgsR0FBR2lYLFdBQXRCLEVBQW1DLElBQW5DOztBQUVBalgsTUFBR2dYLGVBQUgsQ0FBbUJoWCxHQUFHd2pDLGdCQUF0QixFQUF3QyxLQUFLMXNCLFdBQTdDO0FBQ0E5VyxNQUFHZ1gsZUFBSCxDQUFtQmhYLEdBQUdvWCxnQkFBdEIsRUFBd0MsS0FBSzRyQixnQkFBN0M7QUFDQWhqQyxNQUFHeWpDLGFBQUgsQ0FBaUJ6akMsR0FBRzBqQyxLQUFwQixFQUEyQixDQUEzQixFQUE4QixDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWCxFQUFnQixHQUFoQixDQUE5QjtBQUNBMWpDLE1BQUcyakMsZUFBSCxDQUNDLENBREQsRUFDSSxDQURKLEVBQ09uOEIsS0FEUCxFQUNjQyxNQURkLEVBRUMsQ0FGRCxFQUVJLENBRkosRUFFT0QsS0FGUCxFQUVjQyxNQUZkLEVBR0N6SCxHQUFHNEQsZ0JBSEosRUFHc0IsaUJBQUcwbkIsT0FIekI7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUF0ckIsTUFBR2dYLGVBQUgsQ0FBbUJoWCxHQUFHaVgsV0FBdEIsRUFBbUMsSUFBbkM7QUFDQTs7OytCQUdzQjtBQUFBLE9BQVpzQyxNQUFZLHVFQUFILENBQUc7O0FBQ3RCLFVBQU8sS0FBS2lwQixTQUFaO0FBQ0E7OztvQ0FHaUI7QUFDakIsVUFBTyxLQUFLOXFCLGNBQVo7QUFDQTs7Ozs7O2tCQUtheUwsc0I7Ozs7Ozs7Ozs7Ozs7cWpCQ3hKZjs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7O0FBRUEsSUFBSW5qQixXQUFKOztJQUVNb2pCLHVCO0FBR0wsa0NBQVloWixlQUFaLEVBQTZCQyxpQkFBN0IsRUFBZ0Q7QUFBQTs7QUFDL0NySyxPQUFLLGlCQUFHQSxFQUFSO0FBQ0EsT0FBSzRqQyxHQUFMLEdBQVd4NUIsZUFBWDtBQUNBLE9BQUt5NUIsR0FBTCxHQUFXeDVCLGlCQUFYOztBQUVBLE9BQUt1TSxLQUFMO0FBQ0E7Ozs7MEJBR087QUFDUCxRQUFLa3RCLFlBQUwsR0FBb0Isb0JBQXBCO0FBQ0EsUUFBS0MsV0FBTCxHQUFtQixvQkFBbkI7QUFDQSxRQUFLQyxVQUFMLEdBQWtCLENBQUMsQ0FBbkI7O0FBRUEsUUFBS3Y1QixTQUFMLEdBQWlCLEVBQWpCO0FBQ0EsUUFBS3RFLGlCQUFMLEdBQXlCbkcsR0FBR2lrQyx1QkFBSCxFQUF6QjtBQUNBOzs7NkJBR1VuMkIsSyxFQUFPL0MsSyxFQUFPbTVCLFksRUFBYztBQUN0QyxPQUFNQyxzQkFBc0IsQ0FBQyxDQUFDRCxZQUE5QjtBQUNBemlDLFdBQVFVLEdBQVIsQ0FBWSx5QkFBWixFQUF1QzRJLEtBQXZDLEVBQThDbzVCLG1CQUE5QztBQUNBLFFBQUtMLFlBQUwsQ0FBa0I1MEIsVUFBbEIsQ0FBNkJwQixLQUE3QixFQUFvQy9DLEtBQXBDLEVBQTJDLElBQTNDLEVBQWlEL0ssR0FBR29rQyxXQUFwRCxFQUFpRSxLQUFqRTtBQUNBLFFBQUtMLFdBQUwsQ0FBaUI3MEIsVUFBakIsQ0FBNEJwQixLQUE1QixFQUFtQy9DLEtBQW5DLEVBQTBDLElBQTFDLEVBQWdEL0ssR0FBR29rQyxXQUFuRCxFQUFnRSxLQUFoRTs7QUFFQSxPQUFHRCxtQkFBSCxFQUF3QjtBQUN2QixTQUFLMTVCLFNBQUwsQ0FBZXRDLElBQWYsQ0FBb0IrN0IsWUFBcEI7O0FBRUEsUUFBRyxLQUFLRixVQUFMLEdBQWtCLENBQXJCLEVBQXdCO0FBQ3ZCLFVBQUtBLFVBQUwsR0FBa0JsMkIsTUFBTXRMLE1BQXhCO0FBQ0E7QUFDRDtBQUNEOzs7OEJBRVdnTixhLEVBQWU7QUFDMUIsUUFBS3MwQixZQUFMLENBQWtCL3ZCLFdBQWxCLENBQThCdkUsYUFBOUI7QUFDQSxRQUFLdTBCLFdBQUwsQ0FBaUJod0IsV0FBakIsQ0FBNkJ2RSxhQUE3QjtBQUNBOzs7MEJBR096RSxLLEVBQU9DLEssRUFBT2xILE0sRUFBUTtBQUM3QixPQUFHLEtBQUtNLE1BQVIsRUFBZ0I7QUFDZixTQUFLQSxNQUFMLENBQVlhLE9BQVosQ0FBb0I4RixLQUFwQixFQUEyQkMsS0FBM0IsRUFBa0NsSCxNQUFsQztBQUNBO0FBRUQ7Ozs2QkFFVTtBQUNWLFFBQUtNLE1BQUwsR0FBYyx1QkFBYSxLQUFLdy9CLEdBQWxCLEVBQXVCLEtBQUtDLEdBQTVCLEVBQWlDLEtBQUtwNUIsU0FBdEMsQ0FBZDtBQUNBOzs7MkJBRVE7QUFDUixPQUFHLENBQUMsS0FBS3JHLE1BQVQsRUFBaUI7QUFBRSxTQUFLaWdDLFFBQUw7QUFBa0I7O0FBRXJDLFFBQUtqZ0MsTUFBTCxDQUFZWSxJQUFaO0FBQ0Esb0JBQUdzL0IscUJBQUgsQ0FBeUIsSUFBekI7O0FBRUEsUUFBS0MsS0FBTDtBQUNBOzs7MEJBRU87QUFDUCxPQUFNcDRCLE1BQWUsS0FBSzIzQixZQUExQjtBQUNBLFFBQUtBLFlBQUwsR0FBb0IsS0FBS0MsV0FBekI7QUFDQSxRQUFLQSxXQUFMLEdBQW9CNTNCLEdBQXBCO0FBQ0E7OztzQkFFZTtBQUFFLFVBQU8sS0FBSzYzQixVQUFaO0FBQXlCOzs7c0JBQ3pCO0FBQUUsVUFBTyxLQUFLRixZQUFaO0FBQTJCOzs7c0JBQzlCO0FBQUUsVUFBTyxLQUFLQyxXQUFaO0FBQTBCOzs7c0JBQzVCO0FBQUUsVUFBTyxLQUFLRCxZQUFaO0FBQTJCOzs7c0JBQ3hCO0FBQUUsVUFBTyxLQUFLQyxXQUFaO0FBQTBCOzs7Ozs7a0JBSXBDM2dCLHVCOzs7Ozs7O0FDckZmOztBQUVBOzs7Ozs7OztBQUVBOzs7Ozs7OztBQUVBLElBQU1vaEIsU0FBUztBQUNkQyxTQUFRO0FBQ1BDLE1BRE8sZ0JBQ0ZDLENBREUsRUFDQztBQUNQLFVBQU9BLENBQVA7QUFDQTtBQUhNLEVBRE07QUFNZEMsWUFBVztBQUNWQyxJQURVLGNBQ1BGLENBRE8sRUFDSjtBQUNMLFVBQU9BLElBQUlBLENBQVg7QUFDQSxHQUhTO0FBSVZHLEtBSlUsZUFJTkgsQ0FKTSxFQUlIO0FBQ04sVUFBT0EsS0FBSyxJQUFJQSxDQUFULENBQVA7QUFDQSxHQU5TO0FBT1ZJLE9BUFUsaUJBT0pKLENBUEksRUFPRDtBQUNSLE9BQUksQ0FBQ0EsS0FBSyxDQUFOLElBQVcsQ0FBZixFQUFrQjtBQUNqQixXQUFPLE1BQU1BLENBQU4sR0FBVUEsQ0FBakI7QUFDQTtBQUNELFVBQU8sQ0FBRSxHQUFGLElBQVMsRUFBRUEsQ0FBRixJQUFPQSxJQUFJLENBQVgsSUFBZ0IsQ0FBekIsQ0FBUDtBQUNBO0FBWlMsRUFORztBQW9CZEssUUFBTztBQUNOSCxJQURNLGNBQ0hGLENBREcsRUFDQTtBQUNMLFVBQU9BLElBQUlBLENBQUosR0FBUUEsQ0FBZjtBQUNBLEdBSEs7QUFJTkcsS0FKTSxlQUlGSCxDQUpFLEVBSUM7QUFDTixVQUFPLEVBQUVBLENBQUYsR0FBTUEsQ0FBTixHQUFVQSxDQUFWLEdBQWMsQ0FBckI7QUFDQSxHQU5LO0FBT05JLE9BUE0saUJBT0FKLENBUEEsRUFPRztBQUNSLE9BQUksQ0FBQ0EsS0FBSyxDQUFOLElBQVcsQ0FBZixFQUFrQjtBQUNqQixXQUFPLE1BQU1BLENBQU4sR0FBVUEsQ0FBVixHQUFjQSxDQUFyQjtBQUNBO0FBQ0QsVUFBTyxPQUFPLENBQUNBLEtBQUssQ0FBTixJQUFXQSxDQUFYLEdBQWVBLENBQWYsR0FBbUIsQ0FBMUIsQ0FBUDtBQUNBO0FBWkssRUFwQk87QUFrQ2RNLFVBQVM7QUFDUkosSUFEUSxjQUNMRixDQURLLEVBQ0Y7QUFDTCxVQUFPQSxJQUFJQSxDQUFKLEdBQVFBLENBQVIsR0FBWUEsQ0FBbkI7QUFDQSxHQUhPO0FBSVJHLEtBSlEsZUFJSkgsQ0FKSSxFQUlEO0FBQ04sVUFBTyxJQUFLLEVBQUVBLENBQUYsR0FBTUEsQ0FBTixHQUFVQSxDQUFWLEdBQWNBLENBQTFCO0FBQ0EsR0FOTztBQU9SSSxPQVBRLGlCQU9GSixDQVBFLEVBT0M7QUFDUixPQUFJLENBQUNBLEtBQUssQ0FBTixJQUFXLENBQWYsRUFBa0I7QUFDakIsV0FBTyxNQUFNQSxDQUFOLEdBQVVBLENBQVYsR0FBY0EsQ0FBZCxHQUFrQkEsQ0FBekI7QUFDQTtBQUNELFVBQU8sQ0FBRSxHQUFGLElBQVMsQ0FBQ0EsS0FBSyxDQUFOLElBQVdBLENBQVgsR0FBZUEsQ0FBZixHQUFtQkEsQ0FBbkIsR0FBdUIsQ0FBaEMsQ0FBUDtBQUNBO0FBWk8sRUFsQ0s7QUFnRGRPLFVBQVM7QUFDUkwsSUFEUSxjQUNMRixDQURLLEVBQ0Y7QUFDTCxVQUFPQSxJQUFJQSxDQUFKLEdBQVFBLENBQVIsR0FBWUEsQ0FBWixHQUFnQkEsQ0FBdkI7QUFDQSxHQUhPO0FBSVJHLEtBSlEsZUFJSkgsQ0FKSSxFQUlEO0FBQ04sVUFBTyxFQUFFQSxDQUFGLEdBQU1BLENBQU4sR0FBVUEsQ0FBVixHQUFjQSxDQUFkLEdBQWtCQSxDQUFsQixHQUFzQixDQUE3QjtBQUNBLEdBTk87QUFPUkksT0FQUSxpQkFPRkosQ0FQRSxFQU9DO0FBQ1IsT0FBSSxDQUFDQSxLQUFLLENBQU4sSUFBVyxDQUFmLEVBQWtCO0FBQ2pCLFdBQU8sTUFBTUEsQ0FBTixHQUFVQSxDQUFWLEdBQWNBLENBQWQsR0FBa0JBLENBQWxCLEdBQXNCQSxDQUE3QjtBQUNBO0FBQ0QsVUFBTyxPQUFPLENBQUNBLEtBQUssQ0FBTixJQUFXQSxDQUFYLEdBQWVBLENBQWYsR0FBbUJBLENBQW5CLEdBQXVCQSxDQUF2QixHQUEyQixDQUFsQyxDQUFQO0FBQ0E7QUFaTyxFQWhESztBQThEZFEsYUFBWTtBQUNYTixJQURXLGNBQ1JGLENBRFEsRUFDTDtBQUNMLFVBQU8sSUFBSXJ3QixLQUFLTSxHQUFMLENBQVMrdkIsSUFBSXJ3QixLQUFLQyxFQUFULEdBQWMsQ0FBdkIsQ0FBWDtBQUNBLEdBSFU7QUFJWHV3QixLQUpXLGVBSVBILENBSk8sRUFJSjtBQUNOLFVBQU9yd0IsS0FBS0ksR0FBTCxDQUFTaXdCLElBQUlyd0IsS0FBS0MsRUFBVCxHQUFjLENBQXZCLENBQVA7QUFDQSxHQU5VO0FBT1h3d0IsT0FQVyxpQkFPTEosQ0FQSyxFQU9GO0FBQ1IsVUFBTyxPQUFPLElBQUlyd0IsS0FBS00sR0FBTCxDQUFTTixLQUFLQyxFQUFMLEdBQVVvd0IsQ0FBbkIsQ0FBWCxDQUFQO0FBQ0E7QUFUVSxFQTlERTtBQXlFZFMsY0FBYTtBQUNaUCxJQURZLGNBQ1RGLENBRFMsRUFDTjtBQUNMLFVBQU9BLE1BQU0sQ0FBTixHQUFVLENBQVYsR0FBY3J3QixLQUFLK3dCLEdBQUwsQ0FBUyxJQUFULEVBQWVWLElBQUksQ0FBbkIsQ0FBckI7QUFDQSxHQUhXO0FBSVpHLEtBSlksZUFJUkgsQ0FKUSxFQUlMO0FBQ04sVUFBT0EsTUFBTSxDQUFOLEdBQVUsQ0FBVixHQUFjLElBQUlyd0IsS0FBSyt3QixHQUFMLENBQVMsQ0FBVCxFQUFZLENBQUUsRUFBRixHQUFPVixDQUFuQixDQUF6QjtBQUNBLEdBTlc7QUFPWkksT0FQWSxpQkFPTkosQ0FQTSxFQU9IO0FBQ1IsT0FBSUEsTUFBTSxDQUFWLEVBQWE7QUFDWixXQUFPLENBQVA7QUFDQTtBQUNELE9BQUlBLE1BQU0sQ0FBVixFQUFhO0FBQ1osV0FBTyxDQUFQO0FBQ0E7QUFDRCxPQUFJLENBQUNBLEtBQUssQ0FBTixJQUFXLENBQWYsRUFBa0I7QUFDakIsV0FBTyxNQUFNcndCLEtBQUsrd0IsR0FBTCxDQUFTLElBQVQsRUFBZVYsSUFBSSxDQUFuQixDQUFiO0FBQ0E7QUFDRCxVQUFPLE9BQU8sQ0FBRXJ3QixLQUFLK3dCLEdBQUwsQ0FBUyxDQUFULEVBQVksQ0FBRSxFQUFGLElBQVFWLElBQUksQ0FBWixDQUFaLENBQUYsR0FBZ0MsQ0FBdkMsQ0FBUDtBQUNBO0FBbEJXLEVBekVDO0FBNkZkVyxXQUFVO0FBQ1RULElBRFMsY0FDTkYsQ0FETSxFQUNIO0FBQ0wsVUFBTyxJQUFJcndCLEtBQUt5SCxJQUFMLENBQVUsSUFBSTRvQixJQUFJQSxDQUFsQixDQUFYO0FBQ0EsR0FIUTtBQUlURyxLQUpTLGVBSUxILENBSkssRUFJRjtBQUNOLFVBQU9yd0IsS0FBS3lILElBQUwsQ0FBVSxJQUFLLEVBQUU0b0IsQ0FBRixHQUFNQSxDQUFyQixDQUFQO0FBQ0EsR0FOUTtBQU9USSxPQVBTLGlCQU9ISixDQVBHLEVBT0E7QUFDUixPQUFJLENBQUNBLEtBQUssQ0FBTixJQUFXLENBQWYsRUFBa0I7QUFDakIsV0FBTyxDQUFFLEdBQUYsSUFBU3J3QixLQUFLeUgsSUFBTCxDQUFVLElBQUk0b0IsSUFBSUEsQ0FBbEIsSUFBdUIsQ0FBaEMsQ0FBUDtBQUNBO0FBQ0QsVUFBTyxPQUFPcndCLEtBQUt5SCxJQUFMLENBQVUsSUFBSSxDQUFDNG9CLEtBQUssQ0FBTixJQUFXQSxDQUF6QixJQUE4QixDQUFyQyxDQUFQO0FBQ0E7QUFaUSxFQTdGSTtBQTJHZFksVUFBUztBQUNSVixJQURRLGNBQ0xGLENBREssRUFDRjtBQUNMLE9BQUl2ckIsVUFBSjtBQUNBLE9BQUkzVixJQUFJLEdBQVI7QUFDQSxPQUFNK2hDLElBQUksR0FBVjtBQUNBLE9BQUliLE1BQU0sQ0FBVixFQUFhO0FBQ1osV0FBTyxDQUFQO0FBQ0E7QUFDRCxPQUFJQSxNQUFNLENBQVYsRUFBYTtBQUNaLFdBQU8sQ0FBUDtBQUNBO0FBQ0QsT0FBSSxDQUFDbGhDLENBQUQsSUFBTUEsSUFBSSxDQUFkLEVBQWlCO0FBQ2hCQSxRQUFJLENBQUo7QUFDQTJWLFFBQUlvc0IsSUFBSSxDQUFSO0FBQ0EsSUFIRCxNQUdPO0FBQ05wc0IsUUFBSW9zQixJQUFJbHhCLEtBQUtteEIsSUFBTCxDQUFVLElBQUloaUMsQ0FBZCxDQUFKLElBQXdCLElBQUk2USxLQUFLQyxFQUFqQyxDQUFKO0FBQ0E7QUFDRCxVQUFPLEVBQUc5USxJQUFJNlEsS0FBSyt3QixHQUFMLENBQVMsQ0FBVCxFQUFZLE1BQU1WLEtBQUssQ0FBWCxDQUFaLENBQUosR0FBaUNyd0IsS0FBS0ksR0FBTCxDQUFTLENBQUNpd0IsSUFBSXZyQixDQUFMLEtBQVcsSUFBSTlFLEtBQUtDLEVBQXBCLElBQTBCaXhCLENBQW5DLENBQXBDLENBQVA7QUFDQSxHQWxCTztBQW1CUlYsS0FuQlEsZUFtQkpILENBbkJJLEVBbUJEO0FBQ04sT0FBSXZyQixVQUFKO0FBQ0EsT0FBSTNWLElBQUksR0FBUjtBQUNBLE9BQU0raEMsSUFBSSxHQUFWO0FBQ0EsT0FBSWIsTUFBTSxDQUFWLEVBQWE7QUFDWixXQUFPLENBQVA7QUFDQTtBQUNELE9BQUlBLE1BQU0sQ0FBVixFQUFhO0FBQ1osV0FBTyxDQUFQO0FBQ0E7QUFDRCxPQUFJLENBQUNsaEMsQ0FBRCxJQUFNQSxJQUFJLENBQWQsRUFBaUI7QUFDaEJBLFFBQUksQ0FBSjtBQUNBMlYsUUFBSW9zQixJQUFJLENBQVI7QUFDQSxJQUhELE1BR087QUFDTnBzQixRQUFJb3NCLElBQUlseEIsS0FBS214QixJQUFMLENBQVUsSUFBSWhpQyxDQUFkLENBQUosSUFBd0IsSUFBSTZRLEtBQUtDLEVBQWpDLENBQUo7QUFDQTtBQUNELFVBQVE5USxJQUFJNlEsS0FBSyt3QixHQUFMLENBQVMsQ0FBVCxFQUFZLENBQUUsRUFBRixHQUFPVixDQUFuQixDQUFKLEdBQTRCcndCLEtBQUtJLEdBQUwsQ0FBUyxDQUFDaXdCLElBQUl2ckIsQ0FBTCxLQUFXLElBQUk5RSxLQUFLQyxFQUFwQixJQUEwQml4QixDQUFuQyxDQUE1QixHQUFvRSxDQUE1RTtBQUNBLEdBcENPO0FBcUNSVCxPQXJDUSxpQkFxQ0ZKLENBckNFLEVBcUNDO0FBQ1IsT0FBSXZyQixVQUFKO0FBQ0EsT0FBSTNWLElBQUksR0FBUjtBQUNBLE9BQU0raEMsSUFBSSxHQUFWO0FBQ0EsT0FBSWIsTUFBTSxDQUFWLEVBQWE7QUFDWixXQUFPLENBQVA7QUFDQTtBQUNELE9BQUlBLE1BQU0sQ0FBVixFQUFhO0FBQ1osV0FBTyxDQUFQO0FBQ0E7QUFDRCxPQUFJLENBQUNsaEMsQ0FBRCxJQUFNQSxJQUFJLENBQWQsRUFBaUI7QUFDaEJBLFFBQUksQ0FBSjtBQUNBMlYsUUFBSW9zQixJQUFJLENBQVI7QUFDQSxJQUhELE1BR087QUFDTnBzQixRQUFJb3NCLElBQUlseEIsS0FBS214QixJQUFMLENBQVUsSUFBSWhpQyxDQUFkLENBQUosSUFBd0IsSUFBSTZRLEtBQUtDLEVBQWpDLENBQUo7QUFDQTtBQUNELE9BQUksQ0FBQ293QixLQUFLLENBQU4sSUFBVyxDQUFmLEVBQWtCO0FBQ2pCLFdBQU8sQ0FBRSxHQUFGLElBQVNsaEMsSUFBSTZRLEtBQUsrd0IsR0FBTCxDQUFTLENBQVQsRUFBWSxNQUFNVixLQUFLLENBQVgsQ0FBWixDQUFKLEdBQWlDcndCLEtBQUtJLEdBQUwsQ0FBUyxDQUFDaXdCLElBQUl2ckIsQ0FBTCxLQUFXLElBQUk5RSxLQUFLQyxFQUFwQixJQUEwQml4QixDQUFuQyxDQUExQyxDQUFQO0FBQ0E7QUFDRCxVQUFPL2hDLElBQUk2USxLQUFLK3dCLEdBQUwsQ0FBUyxDQUFULEVBQVksQ0FBQyxFQUFELElBQU9WLEtBQUssQ0FBWixDQUFaLENBQUosR0FBa0Nyd0IsS0FBS0ksR0FBTCxDQUFTLENBQUNpd0IsSUFBSXZyQixDQUFMLEtBQVcsSUFBSTlFLEtBQUtDLEVBQXBCLElBQTBCaXhCLENBQW5DLENBQWxDLEdBQTBFLEdBQTFFLEdBQWdGLENBQXZGO0FBQ0E7QUF6RE8sRUEzR0s7QUFzS2RFLE9BQU07QUFDTGIsSUFESyxjQUNGRixDQURFLEVBQ0M7QUFDTCxPQUFNdnJCLElBQUksT0FBVjtBQUNBLFVBQU91ckIsSUFBSUEsQ0FBSixJQUFTLENBQUN2ckIsSUFBSSxDQUFMLElBQVV1ckIsQ0FBVixHQUFjdnJCLENBQXZCLENBQVA7QUFDQSxHQUpJO0FBS0wwckIsS0FMSyxlQUtESCxDQUxDLEVBS0U7QUFDTixPQUFNdnJCLElBQUksT0FBVjtBQUNBLFVBQU8sRUFBRXVyQixDQUFGLEdBQU1BLENBQU4sSUFBVyxDQUFDdnJCLElBQUksQ0FBTCxJQUFVdXJCLENBQVYsR0FBY3ZyQixDQUF6QixJQUE4QixDQUFyQztBQUNBLEdBUkk7QUFTTDJyQixPQVRLLGlCQVNDSixDQVRELEVBU0k7QUFDUixPQUFNdnJCLElBQUksVUFBVSxLQUFwQjtBQUNBLE9BQUksQ0FBQ3VyQixLQUFLLENBQU4sSUFBVyxDQUFmLEVBQWtCO0FBQ2pCLFdBQU8sT0FBT0EsSUFBSUEsQ0FBSixJQUFTLENBQUN2ckIsSUFBSSxDQUFMLElBQVV1ckIsQ0FBVixHQUFjdnJCLENBQXZCLENBQVAsQ0FBUDtBQUNBO0FBQ0QsVUFBTyxPQUFPLENBQUN1ckIsS0FBSyxDQUFOLElBQVdBLENBQVgsSUFBZ0IsQ0FBQ3ZyQixJQUFJLENBQUwsSUFBVXVyQixDQUFWLEdBQWN2ckIsQ0FBOUIsSUFBbUMsQ0FBMUMsQ0FBUDtBQUNBO0FBZkksRUF0S1E7QUF1TGR1c0IsU0FBUTtBQUNQQyxJQURPLGVBQ0pqQixDQURJLEVBQ0Q7QUFDTCxVQUFPLElBQUlILE9BQU9tQixNQUFQLENBQWNFLEdBQWQsQ0FBa0IsSUFBSWxCLENBQXRCLENBQVg7QUFDQSxHQUhNO0FBSVBrQixLQUpPLGVBSUhsQixDQUpHLEVBSUE7QUFDTixPQUFJQSxJQUFLLElBQUksSUFBYixFQUFvQjtBQUNuQixXQUFPLFNBQVNBLENBQVQsR0FBYUEsQ0FBcEI7QUFDQSxJQUZELE1BRU8sSUFBSUEsSUFBSyxJQUFJLElBQWIsRUFBb0I7QUFDMUIsV0FBTyxVQUFVQSxLQUFNLE1BQU0sSUFBdEIsSUFBK0JBLENBQS9CLEdBQW1DLElBQTFDO0FBQ0EsSUFGTSxNQUVBLElBQUlBLElBQUssTUFBTSxJQUFmLEVBQXNCO0FBQzVCLFdBQU8sVUFBVUEsS0FBTSxPQUFPLElBQXZCLElBQWdDQSxDQUFoQyxHQUFvQyxNQUEzQztBQUNBLElBRk0sTUFFQTtBQUNOLFdBQU8sVUFBVUEsS0FBTSxRQUFRLElBQXhCLElBQWlDQSxDQUFqQyxHQUFxQyxRQUE1QztBQUNBO0FBQ0QsR0FkTTtBQWVQbUIsT0FmTyxpQkFlRG5CLENBZkMsRUFlRTtBQUNSLE9BQUlBLElBQUksR0FBUixFQUFhO0FBQ1osV0FBT0gsT0FBT21CLE1BQVAsQ0FBY0MsRUFBZCxDQUFpQmpCLElBQUksQ0FBckIsSUFBMEIsR0FBakM7QUFDQTtBQUNELFVBQU9ILE9BQU9tQixNQUFQLENBQWNFLEdBQWQsQ0FBa0JsQixJQUFJLENBQUosR0FBUSxDQUExQixJQUErQixHQUEvQixHQUFxQyxHQUE1QztBQUNBO0FBcEJNO0FBdkxNLENBQWY7O0FBK01BLFNBQVNvQixPQUFULENBQWlCbHNCLE9BQWpCLEVBQTBCO0FBQ3pCLFNBQVFBLE9BQVI7QUFDQTtBQUNBLE9BQUssUUFBTDtBQUNDLFVBQU8ycUIsT0FBT0MsTUFBUCxDQUFjQyxJQUFyQjtBQUNELE9BQUssT0FBTDtBQUNDLFVBQU9GLE9BQU9ZLFdBQVAsQ0FBbUJQLEVBQTFCO0FBQ0QsT0FBSyxRQUFMO0FBQ0MsVUFBT0wsT0FBT1ksV0FBUCxDQUFtQk4sR0FBMUI7QUFDRCxPQUFLLFVBQUw7QUFDQyxVQUFPTixPQUFPWSxXQUFQLENBQW1CTCxLQUExQjs7QUFFRCxPQUFLLFNBQUw7QUFDQyxVQUFPUCxPQUFPUSxLQUFQLENBQWFILEVBQXBCO0FBQ0QsT0FBSyxVQUFMO0FBQ0MsVUFBT0wsT0FBT1EsS0FBUCxDQUFhRixHQUFwQjtBQUNELE9BQUssWUFBTDtBQUNDLFVBQU9OLE9BQU9RLEtBQVAsQ0FBYUQsS0FBcEI7O0FBRUQsT0FBSyxXQUFMO0FBQ0MsVUFBT1AsT0FBT1MsT0FBUCxDQUFlSixFQUF0QjtBQUNELE9BQUssWUFBTDtBQUNDLFVBQU9MLE9BQU9TLE9BQVAsQ0FBZUgsR0FBdEI7QUFDRCxPQUFLLGNBQUw7QUFDQyxVQUFPTixPQUFPUyxPQUFQLENBQWVGLEtBQXRCOztBQUVELE9BQUssV0FBTDtBQUNDLFVBQU9QLE9BQU9VLE9BQVAsQ0FBZUwsRUFBdEI7QUFDRCxPQUFLLFlBQUw7QUFDQyxVQUFPTCxPQUFPVSxPQUFQLENBQWVKLEdBQXRCO0FBQ0QsT0FBSyxjQUFMO0FBQ0MsVUFBT04sT0FBT1UsT0FBUCxDQUFlSCxLQUF0Qjs7QUFFRCxPQUFLLGNBQUw7QUFDQyxVQUFPUCxPQUFPVyxVQUFQLENBQWtCTixFQUF6QjtBQUNELE9BQUssZUFBTDtBQUNDLFVBQU9MLE9BQU9XLFVBQVAsQ0FBa0JMLEdBQXpCO0FBQ0QsT0FBSyxpQkFBTDtBQUNDLFVBQU9OLE9BQU9XLFVBQVAsQ0FBa0JKLEtBQXpCOztBQUVELE9BQUssWUFBTDtBQUNDLFVBQU9QLE9BQU9jLFFBQVAsQ0FBZ0JULEVBQXZCO0FBQ0QsT0FBSyxhQUFMO0FBQ0MsVUFBT0wsT0FBT2MsUUFBUCxDQUFnQlIsR0FBdkI7QUFDRCxPQUFLLGVBQUw7QUFDQyxVQUFPTixPQUFPYyxRQUFQLENBQWdCUCxLQUF2Qjs7QUFFRCxPQUFLLFdBQUw7QUFDQyxVQUFPUCxPQUFPZSxPQUFQLENBQWVWLEVBQXRCO0FBQ0QsT0FBSyxZQUFMO0FBQ0MsVUFBT0wsT0FBT2UsT0FBUCxDQUFlVCxHQUF0QjtBQUNELE9BQUssY0FBTDtBQUNDLFVBQU9OLE9BQU9lLE9BQVAsQ0FBZVIsS0FBdEI7O0FBRUQsT0FBSyxRQUFMO0FBQ0MsVUFBT1AsT0FBT2tCLElBQVAsQ0FBWWIsRUFBbkI7QUFDRCxPQUFLLFNBQUw7QUFDQyxVQUFPTCxPQUFPa0IsSUFBUCxDQUFZWixHQUFuQjtBQUNELE9BQUssV0FBTDtBQUNDLFVBQU9OLE9BQU9rQixJQUFQLENBQVlYLEtBQW5COztBQUVELE9BQUssVUFBTDtBQUNDLFVBQU9QLE9BQU9tQixNQUFQLENBQWNDLEVBQXJCO0FBQ0QsT0FBSyxXQUFMO0FBQ0MsVUFBT3BCLE9BQU9tQixNQUFQLENBQWNFLEdBQXJCO0FBQ0QsT0FBSyxhQUFMO0FBQ0MsVUFBT3JCLE9BQU9tQixNQUFQLENBQWNHLEtBQXJCO0FBakVEO0FBbUVBOztJQUVLeGtCLFc7QUFDTCxzQkFBWXhkLE1BQVosRUFBdUQ7QUFBQTs7QUFBQSxNQUFuQytWLE9BQW1DLHVFQUF6QixRQUF5QjtBQUFBLE1BQWZtc0IsTUFBZSx1RUFBTixJQUFNOztBQUFBOztBQUN0RCxPQUFLanNCLE1BQUwsR0FBY2pXLE1BQWQ7QUFDQSxPQUFLbWlDLFdBQUwsR0FBbUJuaUMsTUFBbkI7QUFDQSxPQUFLa1csWUFBTCxHQUFvQmxXLE1BQXBCO0FBQ0EsT0FBS29pQyxRQUFMLEdBQWdCLENBQWhCO0FBQ0EsT0FBS0MsS0FBTCxHQUFhSCxNQUFiO0FBQ0EsT0FBS2xzQixNQUFMLEdBQWNELE9BQWQ7QUFDQSxPQUFLb2xCLFdBQUwsR0FBbUIsSUFBbkI7O0FBRUEsT0FBS2hsQixRQUFMLEdBQW9CLHFCQUFVQyxLQUFWLENBQWdCO0FBQUEsVUFBSyxNQUFLQyxPQUFMLEVBQUw7QUFBQSxHQUFoQixDQUFwQjtBQUNBOzs7OzRCQUdTO0FBQ1QsT0FBSWlzQixhQUFhLEtBQUtGLFFBQUwsR0FBZ0IsS0FBS0MsS0FBdEM7QUFDQSxPQUFHQyxhQUFhLENBQWhCLEVBQW1CO0FBQUVBLGlCQUFhLENBQWI7QUFBaUI7QUFDdEMsT0FBRyxLQUFLRixRQUFMLEtBQWtCRSxVQUFyQixFQUFpQztBQUNoQyxTQUFLbkgsV0FBTCxHQUFtQixLQUFuQjtBQUNBO0FBQ0E7O0FBRUQsUUFBS2lILFFBQUwsR0FBZ0JFLFVBQWhCO0FBQ0EsUUFBS25ILFdBQUwsR0FBbUIsSUFBbkI7QUFDQTs7O3dCQUdLemtCLEksRUFBTUMsSSxFQUFNO0FBQ2pCLE9BQUdELE9BQU9DLElBQVYsRUFBZ0I7QUFDZixTQUFLQyxLQUFMLENBQVdELElBQVgsRUFBaUJELElBQWpCO0FBQ0E7QUFDQTs7QUFFRCxRQUFLRyxJQUFMLEdBQVlILElBQVo7QUFDQSxRQUFLSSxJQUFMLEdBQVlILElBQVo7O0FBRUEsUUFBS0osV0FBTDtBQUNBOzs7d0JBRUt2VyxNLEVBQVE7QUFDYixRQUFLaVcsTUFBTCxHQUFjalcsTUFBZDtBQUNBLFFBQUtrVyxZQUFMLEdBQW9CbFcsTUFBcEI7QUFDQSxRQUFLb2lDLFFBQUwsR0FBZ0IsQ0FBaEI7QUFDQTs7O2dDQUdhO0FBQ2IsT0FBRyxLQUFLdnJCLElBQUwsS0FBY25aLFNBQWQsSUFBMkIsS0FBS3dZLFlBQUwsR0FBb0IsS0FBS1csSUFBdkQsRUFBNkQ7QUFDNUQsU0FBS1gsWUFBTCxHQUFvQixLQUFLVyxJQUF6QjtBQUNBOztBQUVELE9BQUcsS0FBS0MsSUFBTCxLQUFjcFosU0FBZCxJQUEyQixLQUFLd1ksWUFBTCxHQUFvQixLQUFLWSxJQUF2RCxFQUE2RDtBQUM1RCxTQUFLWixZQUFMLEdBQW9CLEtBQUtZLElBQXpCO0FBQ0E7QUFDRDs7OzRCQUdTO0FBQ1Qsd0JBQVVDLFFBQVYsQ0FBbUIsS0FBS1osUUFBeEI7QUFDQTs7QUFFRDs7OztvQkFFVW5XLE0sRUFBUTtBQUNqQixRQUFLbWlDLFdBQUwsR0FBbUIsS0FBS2xzQixNQUF4QjtBQUNBLFFBQUtDLFlBQUwsR0FBb0JsVyxNQUFwQjtBQUNBLFFBQUt1VyxXQUFMO0FBQ0EsUUFBSzZyQixRQUFMLEdBQWdCLENBQWhCO0FBQ0EsRztzQkFFVztBQUNYLE9BQUcsS0FBS2pILFdBQVIsRUFBcUI7QUFDcEIsUUFBTW9ILElBQUlOLFFBQVEsS0FBS2pzQixNQUFiLENBQVY7QUFDQSxRQUFNMHJCLElBQUlhLEVBQUUsS0FBS0gsUUFBUCxDQUFWO0FBQ0EsU0FBS25zQixNQUFMLEdBQWMsS0FBS2tzQixXQUFMLEdBQW1CVCxLQUFLLEtBQUt4ckIsWUFBTCxHQUFvQixLQUFLaXNCLFdBQTlCLENBQWpDO0FBQ0EsU0FBS2hILFdBQUwsR0FBbUIsS0FBbkI7QUFDQTtBQUNELFVBQU8sS0FBS2xsQixNQUFaO0FBQ0E7OztzQkFFaUI7QUFDakIsVUFBTyxLQUFLQyxZQUFaO0FBQ0E7Ozs7OztrQkFJYXNILFc7Ozs7Ozs7QUNqWGY7O0FBRUE7Ozs7Ozs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7OztBQUVBLElBQU11YSxXQUFXLFNBQVhBLFFBQVcsQ0FBVUMsTUFBVixFQUFrQnJnQixPQUFsQixFQUEyQjs7QUFFM0MsS0FBTXhOLElBQUl3TixXQUFXLEVBQXJCO0FBQ0EsS0FBR3FnQixPQUFPQyxPQUFWLEVBQW1CO0FBQ2xCOXRCLElBQUVsTCxDQUFGLEdBQU0rNEIsT0FBT0MsT0FBUCxDQUFlLENBQWYsRUFBa0JDLEtBQXhCO0FBQ0EvdEIsSUFBRWpMLENBQUYsR0FBTTg0QixPQUFPQyxPQUFQLENBQWUsQ0FBZixFQUFrQkUsS0FBeEI7QUFDQSxFQUhELE1BR087QUFDTmh1QixJQUFFbEwsQ0FBRixHQUFNKzRCLE9BQU9JLE9BQWI7QUFDQWp1QixJQUFFakwsQ0FBRixHQUFNODRCLE9BQU9LLE9BQWI7QUFDQTs7QUFFRCxRQUFPbHVCLENBQVA7QUFDQSxDQVpEOztJQWNNeVQsWTtBQUNMLHVCQUFZakcsT0FBWixFQUE4RDtBQUFBOztBQUFBLE1BQXpDMmdCLGVBQXlDLHVFQUF2QnY2QixNQUF1QjtBQUFBLE1BQWZnWSxPQUFlLHVFQUFMLEdBQUs7O0FBQUE7O0FBRTdELE9BQUt3aUIsT0FBTCxHQUF1QjVnQixPQUF2QjtBQUNBLE9BQUs2Z0IsZUFBTCxHQUF1QkYsZUFBdkI7O0FBRUEsT0FBSzMzQixNQUFMLEdBQXVCLG1CQUFJeUYsSUFBSixDQUFTNUosTUFBVCxFQUF2QjtBQUNBLE9BQUtnbUMsQ0FBTCxHQUF1QixtQkFBSXA4QixJQUFKLENBQVM1SixNQUFULEVBQXZCO0FBQ0EsT0FBS2ltQyxPQUFMLEdBQXVCLG1CQUFJejhCLElBQUosQ0FBUzVCLEtBQVQsQ0FBZSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFmLENBQXZCO0FBQ0EsT0FBS3MrQixNQUFMLEdBQXVCLG1CQUFJMThCLElBQUosQ0FBUzVCLEtBQVQsQ0FBZSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFmLENBQXZCO0FBQ0EsT0FBS3UrQixRQUFMLEdBQXVCLEVBQUUxakMsR0FBRSxDQUFKLEVBQU9DLEdBQUUsQ0FBVCxFQUF2QjtBQUNBLE9BQUswakMsS0FBTCxHQUF1QixFQUFFM2pDLEdBQUUsQ0FBSixFQUFPQyxHQUFFLENBQVQsRUFBdkI7QUFDQSxPQUFLKzZCLFlBQUwsR0FBdUIsS0FBdkI7QUFDQSxPQUFLNEIsU0FBTCxHQUF1QixtQkFBSWdILElBQUosQ0FBU3JtQyxNQUFULEVBQXZCO0FBQ0EsT0FBS3NtQyxZQUFMLEdBQXVCLG1CQUFJRCxJQUFKLENBQVNybUMsTUFBVCxFQUF2QjtBQUNBLE9BQUt1bUMsY0FBTCxHQUF1QixDQUF2QjtBQUNBLE9BQUtDLE9BQUwsR0FBdUIsS0FBdkI7QUFDQSxPQUFLQyxNQUFMLEdBQXVCLENBQUMsQ0FBeEI7QUFDQSxPQUFLQyxTQUFMLEdBQXVCLEtBQXZCOztBQUVBLE9BQUtDLE1BQUwsR0FBdUIseUJBQWUsQ0FBZixFQUFrQnB0QixPQUFsQixDQUF2QjtBQUNBLE9BQUtxdEIsTUFBTCxHQUF1Qix5QkFBZSxDQUFmLEVBQWtCcnRCLE9BQWxCLENBQXZCOztBQUVBLE9BQUt5aUIsZUFBTCxDQUFxQnBjLGdCQUFyQixDQUFzQyxXQUF0QyxFQUFtRCxVQUFDelgsQ0FBRDtBQUFBLFVBQU8sTUFBSyswQixPQUFMLENBQWEvMEIsQ0FBYixDQUFQO0FBQUEsR0FBbkQ7QUFDQSxPQUFLNnpCLGVBQUwsQ0FBcUJwYyxnQkFBckIsQ0FBc0MsWUFBdEMsRUFBb0QsVUFBQ3pYLENBQUQ7QUFBQSxVQUFPLE1BQUsrMEIsT0FBTCxDQUFhLzBCLENBQWIsQ0FBUDtBQUFBLEdBQXBEO0FBQ0EsT0FBSzZ6QixlQUFMLENBQXFCcGMsZ0JBQXJCLENBQXNDLFdBQXRDLEVBQW1ELFVBQUN6WCxDQUFEO0FBQUEsVUFBTyxNQUFLaTFCLE9BQUwsQ0FBYWoxQixDQUFiLENBQVA7QUFBQSxHQUFuRDtBQUNBLE9BQUs2ekIsZUFBTCxDQUFxQnBjLGdCQUFyQixDQUFzQyxXQUF0QyxFQUFtRCxVQUFDelgsQ0FBRDtBQUFBLFVBQU8sTUFBS2kxQixPQUFMLENBQWFqMUIsQ0FBYixDQUFQO0FBQUEsR0FBbkQ7QUFDQTVHLFNBQU9xZSxnQkFBUCxDQUF3QixVQUF4QixFQUFvQztBQUFBLFVBQU0sTUFBSzBkLEtBQUwsRUFBTjtBQUFBLEdBQXBDO0FBQ0EvN0IsU0FBT3FlLGdCQUFQLENBQXdCLFNBQXhCLEVBQW1DO0FBQUEsVUFBTSxNQUFLMGQsS0FBTCxFQUFOO0FBQUEsR0FBbkM7O0FBRUEsdUJBQVUxakIsS0FBVixDQUFnQjtBQUFBLFVBQU0sTUFBSzBkLEtBQUwsRUFBTjtBQUFBLEdBQWhCO0FBQ0E7O0FBRUQ7Ozs7bUNBRWdDO0FBQUEsT0FBakIxakIsUUFBaUIsdUVBQU4sSUFBTTs7QUFDL0IsUUFBS2lwQixTQUFMLEdBQWlCanBCLFFBQWpCO0FBQ0E7Ozt5QkFFbUI7QUFBQSxPQUFmcFEsTUFBZSx1RUFBTixJQUFNOztBQUNuQixRQUFLa2pDLFNBQUwsR0FBaUJsakMsTUFBakI7QUFDQTs7OytCQUVZczhCLEssRUFBb0I7QUFBQSxPQUFiK0YsS0FBYSx1RUFBTCxHQUFLOztBQUNoQyxRQUFLcnNCLE1BQUwsR0FBY3FzQixLQUFkO0FBQ0EsT0FBRyxLQUFLWSxNQUFMLEdBQWMsQ0FBakIsRUFBb0I7QUFBRTtBQUFTOztBQUUvQixPQUFNSCxlQUFnQixtQkFBSUQsSUFBSixDQUFTeitCLEtBQVQsQ0FBZSxLQUFLeTNCLFNBQXBCLENBQXRCO0FBQ0EsUUFBS3dILGVBQUwsQ0FBcUJQLFlBQXJCO0FBQ0EsUUFBS2pILFNBQUwsR0FBb0IsbUJBQUlnSCxJQUFKLENBQVN6K0IsS0FBVCxDQUFlMCtCLFlBQWYsQ0FBcEI7QUFDQSxRQUFLUSxVQUFMLEdBQW9CLEtBQUtsSixLQUFMLEdBQWEsQ0FBakM7QUFDQSxRQUFLbUosVUFBTCxHQUFvQixLQUFLbEosS0FBTCxHQUFhLENBQWpDOztBQUVBLFFBQUtKLFlBQUwsR0FBb0IsS0FBcEI7QUFDQSxRQUFLdUosVUFBTCxHQUFvQixDQUFwQjs7QUFFQSxRQUFLQyxXQUFMLEdBQW9CLG1CQUFJWixJQUFKLENBQVN6K0IsS0FBVCxDQUFlazRCLEtBQWYsQ0FBcEI7QUFDQSxRQUFLMkcsTUFBTCxHQUFvQixDQUFwQjtBQUNBOzs7OEJBRVc7QUFDWCxRQUFLcEgsU0FBTCxHQUFvQixtQkFBSWdILElBQUosQ0FBU3orQixLQUFULENBQWUsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLENBQWYsQ0FBcEI7QUFDQSxRQUFLMCtCLFlBQUwsR0FBb0IsbUJBQUlELElBQUosQ0FBU3orQixLQUFULENBQWUsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLENBQWYsQ0FBcEI7QUFDQSxRQUFLcS9CLFdBQUwsR0FBb0IvbEMsU0FBcEI7QUFDQSxRQUFLdWxDLE1BQUwsR0FBb0IsQ0FBQyxDQUFyQjtBQUNBOztBQUVEOzs7OzBCQUVRakwsTSxFQUFRO0FBQ2YsT0FBRyxLQUFLa0wsU0FBUixFQUFtQjtBQUFFO0FBQVM7O0FBRTlCLE9BQU1OLFFBQVE3SyxTQUFTQyxNQUFULENBQWQ7QUFDQSxPQUFNOEssZUFBZSxtQkFBSUQsSUFBSixDQUFTeitCLEtBQVQsQ0FBZSxLQUFLeTNCLFNBQXBCLENBQXJCO0FBQ0EsUUFBS3dILGVBQUwsQ0FBcUJQLFlBQXJCO0FBQ0EsUUFBS2pILFNBQUwsR0FBaUJpSCxZQUFqQjs7QUFFQSxRQUFLN0ksWUFBTCxHQUFvQixJQUFwQjtBQUNBLFFBQUt1SixVQUFMLEdBQWtCLENBQWxCO0FBQ0EsUUFBS2IsUUFBTCxHQUFnQixFQUFFMWpDLEdBQUUyakMsTUFBTTNqQyxDQUFWLEVBQWFDLEdBQUUwakMsTUFBTTFqQyxDQUFyQixFQUFoQjs7QUFFQSxPQUFHMGpDLE1BQU0xakMsQ0FBTixHQUFVLEtBQUs2akMsY0FBZixJQUFpQ0gsTUFBTTFqQyxDQUFOLEdBQVduQixPQUFPRSxXQUFQLEdBQXFCLEtBQUs4a0MsY0FBekUsRUFBMEY7QUFDekYsU0FBS1MsVUFBTCxHQUFrQixDQUFsQjtBQUNBLElBRkQsTUFFTyxJQUFHWixNQUFNM2pDLENBQU4sR0FBVSxLQUFLOGpDLGNBQWYsSUFBaUNILE1BQU0zakMsQ0FBTixHQUFXbEIsT0FBT0MsVUFBUCxHQUFvQixLQUFLK2tDLGNBQXhFLEVBQXlGO0FBQy9GLFNBQUtTLFVBQUwsR0FBa0IsQ0FBbEI7QUFDQTs7QUFFRCxRQUFLTCxNQUFMLENBQVlPLEtBQVosQ0FBa0IsQ0FBbEI7QUFDQSxRQUFLTixNQUFMLENBQVlNLEtBQVosQ0FBa0IsQ0FBbEI7QUFDQTs7OzBCQUdPMUwsTSxFQUFRO0FBQ2YsT0FBRyxLQUFLa0wsU0FBUixFQUFtQjtBQUFFO0FBQVM7QUFDOUJuTCxZQUFTQyxNQUFULEVBQWlCLEtBQUs0SyxLQUF0QjtBQUNBOzs7MEJBR087QUFDUCxPQUFHLEtBQUtNLFNBQVIsRUFBbUI7QUFBRTtBQUFTO0FBQzlCLFFBQUtqSixZQUFMLEdBQW9CLEtBQXBCO0FBQ0E7O0FBR0Q7Ozs7a0NBRWdCMEosYSxFQUFlO0FBQzlCLE9BQUcsS0FBSzFKLFlBQUwsSUFBcUIsQ0FBQyxLQUFLaUosU0FBOUIsRUFBeUM7QUFDeEMsU0FBS0MsTUFBTCxDQUFZdjdCLEtBQVosR0FBb0IsRUFBRSxLQUFLZzdCLEtBQUwsQ0FBVzNqQyxDQUFYLEdBQWUsS0FBSzBqQyxRQUFMLENBQWMxakMsQ0FBL0IsQ0FBcEI7QUFDQSxTQUFLbWtDLE1BQUwsQ0FBWXg3QixLQUFaLEdBQXNCLEtBQUtnN0IsS0FBTCxDQUFXMWpDLENBQVgsR0FBZSxLQUFLeWpDLFFBQUwsQ0FBY3pqQyxDQUFuRDs7QUFFQSxRQUFHLEtBQUttNkIsU0FBUixFQUFtQjtBQUNsQixVQUFLOEosTUFBTCxDQUFZdjdCLEtBQVosR0FBb0IsQ0FBQyxLQUFLdTdCLE1BQUwsQ0FBWWpKLFdBQWpDO0FBQ0EsVUFBS2tKLE1BQUwsQ0FBWXg3QixLQUFaLEdBQW9CLENBQUMsS0FBS3c3QixNQUFMLENBQVlsSixXQUFqQztBQUNBO0FBQ0Q7O0FBRUQsT0FBSTBKLGNBQUo7QUFBQSxPQUFXL3BCLGNBQVg7O0FBRUEsT0FBRyxLQUFLMnBCLFVBQUwsR0FBa0IsQ0FBckIsRUFBd0I7QUFDdkIsUUFBRyxLQUFLQSxVQUFMLEtBQW9CLENBQXZCLEVBQTBCO0FBQ3pCSSxhQUFRLENBQUMsS0FBS1QsTUFBTCxDQUFZdjdCLEtBQWIsR0FBcUIsS0FBS283QixPQUFsQztBQUNBWSxjQUFVLEtBQUtqQixRQUFMLENBQWN6akMsQ0FBZCxHQUFrQixLQUFLNmpDLGNBQXhCLEdBQTBDLENBQUMsQ0FBM0MsR0FBK0MsQ0FBeEQ7QUFDQWxwQixhQUFRLG1CQUFJZ3BCLElBQUosQ0FBU3orQixLQUFULENBQWUsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPb00sS0FBS0ksR0FBTCxDQUFTZ3pCLEtBQVQsQ0FBUCxFQUF3QnB6QixLQUFLTSxHQUFMLENBQVM4eUIsS0FBVCxDQUF4QixDQUFmLENBQVI7QUFDQSx3QkFBSWYsSUFBSixDQUFTbmlDLFFBQVQsQ0FBa0JtWixLQUFsQixFQUF5QjhwQixhQUF6QixFQUF3QzlwQixLQUF4QztBQUNBLEtBTEQsTUFLTztBQUNOK3BCLGFBQVEsQ0FBQyxLQUFLUixNQUFMLENBQVl4N0IsS0FBYixHQUFxQixLQUFLbzdCLE9BQWxDO0FBQ0FZLGNBQVUsS0FBS2pCLFFBQUwsQ0FBYzFqQyxDQUFkLEdBQWtCLEtBQUs4akMsY0FBeEIsR0FBMEMsQ0FBMUMsR0FBOEMsQ0FBQyxDQUF4RDtBQUNBbHBCLGFBQVEsbUJBQUlncEIsSUFBSixDQUFTeitCLEtBQVQsQ0FBZSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU9vTSxLQUFLSSxHQUFMLENBQVNnekIsS0FBVCxDQUFQLEVBQXdCcHpCLEtBQUtNLEdBQUwsQ0FBUzh5QixLQUFULENBQXhCLENBQWYsQ0FBUjtBQUNBLHdCQUFJZixJQUFKLENBQVNuaUMsUUFBVCxDQUFrQm1aLEtBQWxCLEVBQXlCOHBCLGFBQXpCLEVBQXdDOXBCLEtBQXhDO0FBQ0E7QUFDRCxJQVpELE1BWU87QUFDTixRQUFNL0osSUFBSSxtQkFBSTlKLElBQUosQ0FBUzVCLEtBQVQsQ0FBZSxDQUFDLEtBQUsrK0IsTUFBTCxDQUFZdjdCLEtBQWIsRUFBb0IsS0FBS3c3QixNQUFMLENBQVl4N0IsS0FBaEMsRUFBdUMsQ0FBdkMsQ0FBZixDQUFWO0FBQ0EsUUFBTXNILE9BQU8sbUJBQUlsSixJQUFKLENBQVN4SixNQUFULEVBQWI7QUFDQSx1QkFBSXdKLElBQUosQ0FBU3NULEtBQVQsQ0FBZXBLLElBQWYsRUFBcUJZLENBQXJCLEVBQXdCLEtBQUs0eUIsTUFBN0I7QUFDQSx1QkFBSTE4QixJQUFKLENBQVNnSSxTQUFULENBQW1Ca0IsSUFBbkIsRUFBeUJBLElBQXpCO0FBQ0EwMEIsWUFBUSxtQkFBSTU5QixJQUFKLENBQVN0SCxNQUFULENBQWdCb1IsQ0FBaEIsSUFBcUIsS0FBS2t6QixPQUFsQztBQUNBbnBCLFlBQVEsbUJBQUlncEIsSUFBSixDQUFTeitCLEtBQVQsQ0FBZSxDQUFDb00sS0FBS0ksR0FBTCxDQUFTZ3pCLEtBQVQsSUFBa0IxMEIsS0FBSyxDQUFMLENBQW5CLEVBQTRCc0IsS0FBS0ksR0FBTCxDQUFTZ3pCLEtBQVQsSUFBa0IxMEIsS0FBSyxDQUFMLENBQTlDLEVBQXVEc0IsS0FBS0ksR0FBTCxDQUFTZ3pCLEtBQVQsSUFBa0IxMEIsS0FBSyxDQUFMLENBQXpFLEVBQWtGc0IsS0FBS00sR0FBTCxDQUFTOHlCLEtBQVQsQ0FBbEYsQ0FBZixDQUFSO0FBQ0EsdUJBQUlmLElBQUosQ0FBU25pQyxRQUFULENBQWtCaWpDLGFBQWxCLEVBQWlDOXBCLEtBQWpDLEVBQXdDOHBCLGFBQXhDO0FBQ0E7QUFDRDs7OzBCQUVPO0FBQ1Asc0JBQUl2OUIsSUFBSixDQUFTakosUUFBVCxDQUFrQixLQUFLcWxDLENBQXZCOztBQUVBLE9BQUcsS0FBS2lCLFdBQUwsS0FBcUIvbEMsU0FBeEIsRUFBbUM7QUFDbEMsdUJBQUltbEMsSUFBSixDQUFTOTBCLEdBQVQsQ0FBYSxLQUFLKzBCLFlBQWxCLEVBQWdDLEtBQUtqSCxTQUFMLENBQWUsQ0FBZixDQUFoQyxFQUFtRCxLQUFLQSxTQUFMLENBQWUsQ0FBZixDQUFuRCxFQUFzRSxLQUFLQSxTQUFMLENBQWUsQ0FBZixDQUF0RSxFQUF5RixLQUFLQSxTQUFMLENBQWUsQ0FBZixDQUF6RjtBQUNBLFNBQUt3SCxlQUFMLENBQXFCLEtBQUtQLFlBQTFCO0FBQ0EsSUFIRCxNQUdPO0FBQ04sU0FBS0csTUFBTCxJQUFlLENBQUMsSUFBSSxLQUFLQSxNQUFWLElBQW9CLEdBQW5DOztBQUVBLFFBQUcsS0FBS0EsTUFBTCxHQUFjLE1BQWpCLEVBQXlCO0FBQ3hCLHdCQUFJSixJQUFKLENBQVNwaUMsSUFBVCxDQUFjLEtBQUtvN0IsU0FBbkIsRUFBOEIsS0FBSzRILFdBQW5DO0FBQ0Esd0JBQUlaLElBQUosQ0FBU3BpQyxJQUFULENBQWMsS0FBS3FpQyxZQUFuQixFQUFpQyxLQUFLVyxXQUF0QztBQUNBLFVBQUtBLFdBQUwsR0FBbUIvbEMsU0FBbkI7QUFDQSxVQUFLeWxDLE1BQUwsQ0FBWU8sS0FBWixDQUFrQixDQUFsQjtBQUNBLFVBQUtOLE1BQUwsQ0FBWU0sS0FBWixDQUFrQixDQUFsQjtBQUNBLFVBQUtULE1BQUwsR0FBYyxDQUFDLENBQWY7QUFDQSxLQVBELE1BT087QUFDTix3QkFBSUosSUFBSixDQUFTOTBCLEdBQVQsQ0FBYSxLQUFLKzBCLFlBQWxCLEVBQWdDLENBQWhDLEVBQW1DLENBQW5DLEVBQXNDLENBQXRDLEVBQXlDLENBQXpDO0FBQ0Esd0JBQUlELElBQUosQ0FBU2dCLEtBQVQsQ0FBZSxLQUFLZixZQUFwQixFQUFrQyxLQUFLVyxXQUF2QyxFQUFvRCxLQUFLNUgsU0FBekQsRUFBb0UsS0FBS29ILE1BQXpFO0FBQ0E7QUFDRDs7QUFFRCxzQkFBSWo5QixJQUFKLENBQVM4OUIsYUFBVCxDQUF1QixLQUFLckIsT0FBNUIsRUFBcUMsS0FBS0EsT0FBMUMsRUFBbUQsS0FBS0ssWUFBeEQ7O0FBRUEsc0JBQUkxOEIsSUFBSixDQUFTbVUsUUFBVCxDQUFrQixLQUFLNVosTUFBdkIsRUFBK0IsS0FBS21pQyxZQUFwQztBQUNBOztBQUdEOzs7O29CQUVXOWlDLE0sRUFBUTtBQUNsQixRQUFLbWpDLE1BQUwsQ0FBWW50QixNQUFaLEdBQXFCaFcsTUFBckI7QUFDQSxRQUFLb2pDLE1BQUwsQ0FBWXB0QixNQUFaLEdBQXFCaFcsTUFBckI7QUFDQSxHO3NCQUVZO0FBQ1osVUFBTyxLQUFLbWpDLE1BQUwsQ0FBWW50QixNQUFuQjtBQUNBOzs7Ozs7a0JBR2E0SCxZOzs7Ozs7Ozs7Ozs7Ozs7QUMzTWY7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7K2VBSkE7OztBQU1BLFNBQVNtbUIsUUFBVCxDQUFrQnBrQyxDQUFsQixFQUFxQkQsQ0FBckIsRUFBd0I7QUFDdkIsS0FBTXNrQyxLQUFLcmtDLEVBQUVWLENBQUYsR0FBTVMsRUFBRVQsQ0FBbkI7QUFDQSxLQUFNZ2xDLEtBQUt0a0MsRUFBRVQsQ0FBRixHQUFNUSxFQUFFUixDQUFuQjtBQUNBLFFBQU9zUixLQUFLeUgsSUFBTCxDQUFVK3JCLEtBQUtBLEVBQUwsR0FBVUMsS0FBS0EsRUFBekIsQ0FBUDtBQUNBOztJQUVLemtCLGE7OztBQUNMLHdCQUFZemUsS0FBWixFQUFtQmIsT0FBbkIsRUFBMEU7QUFBQSxNQUE5Q2drQyxjQUE4Qyx1RUFBL0IsS0FBK0I7QUFBQSxNQUF4QjVMLGVBQXdCLHVFQUFSdjZCLE1BQVE7O0FBQUE7O0FBQUE7O0FBR3pFLFFBQUs0USxLQUFMLEdBQWE1TixLQUFiO0FBQ0EsUUFBSzROLEtBQUwsQ0FBV3JCLGFBQVg7QUFDQSxRQUFLNjJCLE9BQUwsR0FBZWprQyxPQUFmO0FBQ0EsUUFBS2trQyxZQUFMLEdBQW9CcmpDLE1BQU1zakMsS0FBTixDQUFZdE8sR0FBWixDQUFnQixVQUFDcm9CLElBQUQ7QUFBQSxVQUFTQSxLQUFLcEMsUUFBZDtBQUFBLEdBQWhCLENBQXBCO0FBQ0EsUUFBS2c1QixjQUFMLEdBQXNCLENBQXRCOztBQUVBLFFBQUtDLElBQUwsR0FBWSxrQkFBUSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFSLEVBQW1CLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFDLENBQVIsQ0FBbkIsQ0FBWjtBQUNBLFFBQUtDLElBQUwsR0FBWXgrQixLQUFLNnlCLFVBQUwsQ0FBZ0IsQ0FBQyxHQUFqQixFQUFzQixDQUFDLEdBQXZCLEVBQTRCLENBQUMsR0FBN0IsQ0FBWjtBQUNBLFFBQUs0TCxRQUFMO0FBQ0EsUUFBS0MsU0FBTDtBQUNBLFFBQUtDLFFBQUwsR0FBZ0J2K0IsS0FBSzVKLE1BQUwsRUFBaEI7O0FBRUEsUUFBS2c4QixlQUFMLEdBQXVCRixlQUF2QjtBQUNBLFFBQUtzTSxhQUFMLEdBQXFCVixjQUFyQjs7QUFFQSxRQUFLVyxXQUFMLEdBQW1CLFVBQUNsZ0MsQ0FBRDtBQUFBLFVBQU8sTUFBS2kxQixPQUFMLENBQWFqMUIsQ0FBYixDQUFQO0FBQUEsR0FBbkI7QUFDQSxRQUFLbWdDLFdBQUwsR0FBbUIsVUFBQ25nQyxDQUFEO0FBQUEsVUFBTyxNQUFLKzBCLE9BQUwsQ0FBYS8wQixDQUFiLENBQVA7QUFBQSxHQUFuQjtBQUNBLFFBQUtvZ0MsU0FBTCxHQUFpQjtBQUFBLFVBQU0sTUFBS2pMLEtBQUwsRUFBTjtBQUFBLEdBQWpCOztBQUVBLFFBQUtDLE9BQUw7QUF0QnlFO0FBdUJ6RTs7Ozs0QkFFUztBQUNULFFBQUt2QixlQUFMLENBQXFCcGMsZ0JBQXJCLENBQXNDLFdBQXRDLEVBQW1ELEtBQUswb0IsV0FBeEQ7QUFDQSxRQUFLdE0sZUFBTCxDQUFxQnBjLGdCQUFyQixDQUFzQyxXQUF0QyxFQUFtRCxLQUFLeW9CLFdBQXhEO0FBQ0EsUUFBS3JNLGVBQUwsQ0FBcUJwYyxnQkFBckIsQ0FBc0MsU0FBdEMsRUFBaUQsS0FBSzJvQixTQUF0RDtBQUNBOzs7K0JBRVk7QUFDWixRQUFLdk0sZUFBTCxDQUFxQjVCLG1CQUFyQixDQUF5QyxXQUF6QyxFQUFzRCxLQUFLa08sV0FBM0Q7QUFDQSxRQUFLdE0sZUFBTCxDQUFxQjVCLG1CQUFyQixDQUF5QyxXQUF6QyxFQUFzRCxLQUFLaU8sV0FBM0Q7QUFDQSxRQUFLck0sZUFBTCxDQUFxQjVCLG1CQUFyQixDQUF5QyxTQUF6QyxFQUFvRCxLQUFLbU8sU0FBekQ7QUFDQTs7OzhCQUd3QjtBQUFBOztBQUFBLE9BQWY3OUIsS0FBZSx1RUFBVCxPQUFTOztBQUN4QixPQUFNL0csU0FBUyxLQUFLZ2tDLE9BQXBCO0FBQ0EsT0FBRyxDQUFDaGtDLE1BQUosRUFBWTtBQUNYO0FBQ0E7O0FBR0QsT0FBTTZrQyxLQUFNLEtBQUtQLFFBQUwsQ0FBY3hsQyxDQUFkLEdBQWtCLGlCQUFHeUUsS0FBdEIsR0FBK0IsR0FBL0IsR0FBcUMsR0FBaEQ7QUFDQSxPQUFNdWhDLEtBQUssRUFBRyxLQUFLUixRQUFMLENBQWN2bEMsQ0FBZCxHQUFrQixpQkFBR3lFLE1BQXhCLElBQWtDLEdBQWxDLEdBQXdDLEdBQW5EOztBQUVBeEQsVUFBTytrQyxXQUFQLENBQW1CLENBQUNGLEVBQUQsRUFBS0MsRUFBTCxFQUFTLENBQVQsQ0FBbkIsRUFBZ0MsS0FBS1YsSUFBckM7O0FBRUEsT0FBSVksWUFBSjtBQUNBLE9BQU1DLEtBQUtwL0IsS0FBS3hKLE1BQUwsRUFBWDtBQUNBLE9BQU0yYixLQUFLblMsS0FBS3hKLE1BQUwsRUFBWDtBQUNBLE9BQU02b0MsS0FBS3IvQixLQUFLeEosTUFBTCxFQUFYO0FBQ0EsT0FBSThvQyxPQUFPLENBQVg7O0FBRUEsT0FBTUMsWUFBWSxTQUFaQSxTQUFZLENBQUN6MUIsQ0FBRCxFQUFJa0gsTUFBSixFQUFlO0FBQ2hDaFIsU0FBSytWLGFBQUwsQ0FBbUIvRSxNQUFuQixFQUEyQmxILENBQTNCLEVBQThCLE9BQUs2MEIsUUFBbkM7QUFDQSxJQUZEOztBQUlBLFFBQUksSUFBSWxtQyxJQUFJLENBQVosRUFBZUEsSUFBSSxLQUFLMmxDLFlBQUwsQ0FBa0IxbEMsTUFBckMsRUFBNkNELEdBQTdDLEVBQWtEO0FBQ2pELFFBQU02TSxXQUFXLEtBQUs4NEIsWUFBTCxDQUFrQjNsQyxDQUFsQixDQUFqQjtBQUNBOG1DLGNBQVVqNkIsU0FBUyxDQUFULENBQVYsRUFBdUI4NUIsRUFBdkI7QUFDQUcsY0FBVWo2QixTQUFTLENBQVQsQ0FBVixFQUF1QjZNLEVBQXZCO0FBQ0FvdEIsY0FBVWo2QixTQUFTLENBQVQsQ0FBVixFQUF1Qis1QixFQUF2QjtBQUNBLFFBQU14MEIsSUFBSSxLQUFLMHpCLElBQUwsQ0FBVWlCLGlCQUFWLENBQTRCSixFQUE1QixFQUFnQ2p0QixFQUFoQyxFQUFvQ2t0QixFQUFwQyxDQUFWOztBQUVBLFFBQUd4MEIsQ0FBSCxFQUFNO0FBQ0wsU0FBR3MwQixHQUFILEVBQVE7QUFDUCxVQUFNTSxZQUFZei9CLEtBQUtzL0IsSUFBTCxDQUFVejBCLENBQVYsRUFBYTFRLE9BQU82WixRQUFwQixDQUFsQjtBQUNBLFVBQUd5ckIsWUFBWUgsSUFBZixFQUFxQjtBQUNwQkgsYUFBTW4vQixLQUFLNUIsS0FBTCxDQUFXeU0sQ0FBWCxDQUFOO0FBQ0F5MEIsY0FBT0csU0FBUDtBQUNBO0FBQ0QsTUFORCxNQU1PO0FBQ05OLFlBQU1uL0IsS0FBSzVCLEtBQUwsQ0FBV3lNLENBQVgsQ0FBTjtBQUNBeTBCLGFBQU90L0IsS0FBS3MvQixJQUFMLENBQVVILEdBQVYsRUFBZWhsQyxPQUFPNlosUUFBdEIsQ0FBUDtBQUNBO0FBQ0Q7QUFDRDs7QUFHRCxPQUFHbXJCLEdBQUgsRUFBUTtBQUNQLFNBQUtYLElBQUwsR0FBWXgrQixLQUFLNUIsS0FBTCxDQUFXK2dDLEdBQVgsQ0FBWjtBQUNBLFNBQUt4TixtQkFBTCxDQUF5Qnp3QixLQUF6QixFQUFnQyxFQUFFaStCLFFBQUYsRUFBaEM7QUFDQSxJQUhELE1BR087QUFDTixTQUFLeE4sbUJBQUwsQ0FBeUIsTUFBekI7QUFDQTtBQUNEOzs7MEJBR09oekIsQyxFQUFHO0FBQ1YsUUFBSysvQixTQUFMLEdBQWlCLHdCQUFTLy9CLENBQVQsQ0FBakI7QUFDQSxRQUFLOC9CLFFBQUwsR0FBZ0Isd0JBQVM5L0IsQ0FBVCxDQUFoQjtBQUNBLFFBQUsrZ0MsU0FBTCxDQUFlLFFBQWY7QUFDQTs7OzBCQUVPL2dDLEMsRUFBRztBQUNWLFFBQUs4L0IsUUFBTCxHQUFnQix3QkFBUzkvQixDQUFULENBQWhCO0FBQ0EsT0FBRyxDQUFDLEtBQUtpZ0MsYUFBVCxFQUF3QjtBQUN2QixTQUFLYyxTQUFMO0FBQ0E7QUFDRDs7OzBCQUVPO0FBQ1AsT0FBTUosT0FBT3ZCLFNBQVMsS0FBS1csU0FBZCxFQUF5QixLQUFLRCxRQUE5QixDQUFiO0FBQ0EsT0FBR2EsT0FBTyxLQUFLaEIsY0FBZixFQUErQjtBQUM5QixTQUFLb0IsU0FBTDtBQUNBO0FBRUQ7Ozs7OztrQkFJYWxtQixhOzs7Ozs7Ozs7Ozs7O2tCQzdIQSxVQUFVN2EsQ0FBVixFQUFhO0FBQzNCLEtBQUkxRixVQUFKO0FBQUEsS0FBT0MsVUFBUDs7QUFFQSxLQUFHeUYsRUFBRXN6QixPQUFMLEVBQWM7QUFDYmg1QixNQUFJMEYsRUFBRXN6QixPQUFGLENBQVUsQ0FBVixFQUFhQyxLQUFqQjtBQUNBaDVCLE1BQUl5RixFQUFFc3pCLE9BQUYsQ0FBVSxDQUFWLEVBQWFFLEtBQWpCO0FBQ0EsRUFIRCxNQUdPO0FBQ05sNUIsTUFBSTBGLEVBQUV5ekIsT0FBTjtBQUNBbDVCLE1BQUl5RixFQUFFMHpCLE9BQU47QUFDQTs7QUFHRCxRQUFPO0FBQ05wNUIsTUFETSxFQUNIQztBQURHLEVBQVA7QUFHQSxDOzs7Ozs7O0FDakJEOztBQUVBOzs7Ozs7OztBQUVBOzs7O0FBQ0E7Ozs7Ozs7Ozs7QUFFQSxJQUFNeW1DLGtCQUFrQixDQUN2QixDQUFDLGVBQUs5TSxVQUFMLENBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQXRCLENBQUQsRUFBMkIsZUFBS0EsVUFBTCxDQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQixDQUF0QixDQUEzQixFQUFxRCxlQUFLQSxVQUFMLENBQWdCLENBQWhCLEVBQW1CLENBQUMsQ0FBcEIsRUFBdUIsQ0FBdkIsQ0FBckQsQ0FEdUIsRUFFdkIsQ0FBQyxlQUFLQSxVQUFMLENBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQXRCLENBQUQsRUFBMkIsZUFBS0EsVUFBTCxDQUFnQixDQUFDLENBQWpCLEVBQW9CLENBQXBCLEVBQXVCLENBQXZCLENBQTNCLEVBQXNELGVBQUtBLFVBQUwsQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBQyxDQUFwQixFQUF1QixDQUF2QixDQUF0RCxDQUZ1QixFQUd2QixDQUFDLGVBQUtBLFVBQUwsQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsQ0FBRCxFQUEyQixlQUFLQSxVQUFMLENBQWdCLENBQWhCLEVBQW9CLENBQXBCLEVBQXVCLENBQXZCLENBQTNCLEVBQXNELGVBQUtBLFVBQUwsQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsRUFBdUIsQ0FBdkIsQ0FBdEQsQ0FIdUIsRUFJdkIsQ0FBQyxlQUFLQSxVQUFMLENBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQXRCLENBQUQsRUFBMkIsZUFBS0EsVUFBTCxDQUFnQixDQUFoQixFQUFtQixDQUFDLENBQXBCLEVBQXVCLENBQXZCLENBQTNCLEVBQXNELGVBQUtBLFVBQUwsQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsRUFBc0IsQ0FBQyxDQUF2QixDQUF0RCxDQUp1QixFQUt2QixDQUFDLGVBQUtBLFVBQUwsQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsQ0FBRCxFQUEyQixlQUFLQSxVQUFMLENBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXVCLENBQXZCLENBQTNCLEVBQXNELGVBQUtBLFVBQUwsQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBQyxDQUFwQixFQUF1QixDQUF2QixDQUF0RCxDQUx1QixFQU12QixDQUFDLGVBQUtBLFVBQUwsQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsQ0FBRCxFQUEyQixlQUFLQSxVQUFMLENBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQUMsQ0FBdkIsQ0FBM0IsRUFBc0QsZUFBS0EsVUFBTCxDQUFnQixDQUFoQixFQUFtQixDQUFDLENBQXBCLEVBQXVCLENBQXZCLENBQXRELENBTnVCLENBQXhCOztJQVNNbmIsVTs7O0FBRUwsdUJBQWM7QUFBQTs7QUFBQTs7QUFHYixRQUFLa29CLGNBQUwsQ0FBb0JwMUIsS0FBS0MsRUFBTCxHQUFVLENBQTlCLEVBQWlDLENBQWpDLEVBQW9DLEdBQXBDLEVBQXlDLElBQXpDO0FBSGE7QUFJYjs7Ozt1QkFHSWdGLE0sRUFBUTtBQUNaLE9BQU10TCxJQUFJdzdCLGdCQUFnQmx3QixNQUFoQixDQUFWO0FBQ0EsUUFBSzZFLE1BQUwsQ0FBWW5RLEVBQUUsQ0FBRixDQUFaLEVBQWtCQSxFQUFFLENBQUYsQ0FBbEIsRUFBd0JBLEVBQUUsQ0FBRixDQUF4QjtBQUNBOzs7Ozs7a0JBSWF1VCxVOzs7Ozs7O0FDaENmOztBQUVBOzs7Ozs7Ozs7O0FBRUE7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0lBRU1HLFM7Ozs7Ozs7Ozs7O3VCQUVBckIsRyxFQUFLQyxRLEVBQXdCO0FBQUEsT0FBZHBiLFFBQWMsdUVBQUgsQ0FBRzs7QUFDakMsUUFBS3VLLFNBQUwsR0FBaUJ2SyxRQUFqQjtBQUNBLDhHQUFXbWIsR0FBWCxFQUFnQkMsUUFBaEI7QUFDQTs7OzhCQUVXO0FBQ1gsUUFBS29wQixRQUFMLENBQWMsS0FBSzNwQixJQUFMLENBQVVXLFFBQXhCO0FBQ0E7OzsyQkFFUWlwQixNLEVBQVE7QUFDaEIsT0FBTTFnQyxRQUFRMGdDLE9BQU96Z0MsS0FBUCxDQUFhLElBQWIsQ0FBZDs7QUFFQSxPQUFNOEosWUFBZSxFQUFyQjtBQUNBLE9BQU1DLFNBQWUsRUFBckI7QUFDQSxPQUFNMjJCLGVBQWUsRUFBckI7QUFDQSxPQUFNejZCLFdBQWUsRUFBckI7QUFDQSxPQUFNRCxVQUFlLEVBQXJCO0FBQ0EsT0FBTTI2QixNQUFlLEVBQXJCO0FBQ0EsT0FBTW40QixVQUFlLEVBQXJCO0FBQ0EsT0FBSXdELFFBQWUsQ0FBbkI7QUFDQSxPQUFJeUcsZUFBSjs7QUFFQTtBQUNBLE9BQU1tdUIsZ0JBQWdCLHFFQUF0Qjs7QUFFQTtBQUNBLE9BQU1DLGdCQUFnQixzRUFBdEI7O0FBRUE7QUFDQSxPQUFNQyxZQUFZLGdEQUFsQjs7QUFFQTtBQUNBLE9BQU1DLGVBQWUsd0NBQXJCOztBQUVBO0FBQ0EsT0FBTUMsZUFBZSxvRkFBckI7O0FBRUE7QUFDQSxPQUFNQyxlQUFlLHdIQUFyQjs7QUFFQTtBQUNBLE9BQU1DLGVBQWUsNEZBQXJCOztBQUdBLFlBQVNDLGdCQUFULENBQTBCNStCLEtBQTFCLEVBQWlDO0FBQ2hDLFFBQU04SCxRQUFRKzJCLFNBQVM3K0IsS0FBVCxDQUFkO0FBQ0EsV0FBTyxDQUFDOEgsU0FBUyxDQUFULEdBQWFBLFFBQVEsQ0FBckIsR0FBeUJBLFFBQVFwRSxTQUFTNU0sTUFBVCxHQUFrQixDQUFwRCxJQUF5RCxDQUFoRTtBQUNBOztBQUVELFlBQVNnb0MsZ0JBQVQsQ0FBMEI5K0IsS0FBMUIsRUFBaUM7QUFDaEMsUUFBTThILFFBQVErMkIsU0FBUzcrQixLQUFULENBQWQ7QUFDQSxXQUFPLENBQUM4SCxTQUFTLENBQVQsR0FBYUEsUUFBUSxDQUFyQixHQUF5QkEsUUFBUXJFLFFBQVEzTSxNQUFSLEdBQWlCLENBQW5ELElBQXdELENBQS9EO0FBQ0E7O0FBRUQsWUFBU2lvQyxZQUFULENBQXNCLytCLEtBQXRCLEVBQTZCO0FBQzVCLFFBQU04SCxRQUFRKzJCLFNBQVM3K0IsS0FBVCxDQUFkO0FBQ0EsV0FBTyxDQUFDOEgsU0FBUyxDQUFULEdBQWFBLFFBQVEsQ0FBckIsR0FBeUJBLFFBQVFzMkIsSUFBSXRuQyxNQUFKLEdBQWEsQ0FBL0MsSUFBb0QsQ0FBM0Q7QUFDQTs7QUFHRCxZQUFTa29DLFNBQVQsQ0FBbUJqbkMsQ0FBbkIsRUFBc0JELENBQXRCLEVBQXlCME8sQ0FBekIsRUFBNEI7QUFDM0JlLGNBQVU5SyxJQUFWLENBQWUsQ0FBQ2lILFNBQVMzTCxDQUFULENBQUQsRUFBYzJMLFNBQVMzTCxJQUFJLENBQWIsQ0FBZCxFQUErQjJMLFNBQVMzTCxJQUFJLENBQWIsQ0FBL0IsQ0FBZjtBQUNBd1AsY0FBVTlLLElBQVYsQ0FBZSxDQUFDaUgsU0FBUzVMLENBQVQsQ0FBRCxFQUFjNEwsU0FBUzVMLElBQUksQ0FBYixDQUFkLEVBQStCNEwsU0FBUzVMLElBQUksQ0FBYixDQUEvQixDQUFmO0FBQ0F5UCxjQUFVOUssSUFBVixDQUFlLENBQUNpSCxTQUFTOEMsQ0FBVCxDQUFELEVBQWM5QyxTQUFTOEMsSUFBSSxDQUFiLENBQWQsRUFBK0I5QyxTQUFTOEMsSUFBSSxDQUFiLENBQS9CLENBQWY7O0FBRUFQLFlBQVF4SixJQUFSLENBQWFnTixRQUFRLENBQVIsR0FBWSxDQUF6QjtBQUNBeEQsWUFBUXhKLElBQVIsQ0FBYWdOLFFBQVEsQ0FBUixHQUFZLENBQXpCO0FBQ0F4RCxZQUFReEosSUFBUixDQUFhZ04sUUFBUSxDQUFSLEdBQVksQ0FBekI7O0FBRUFBO0FBQ0E7O0FBR0QsWUFBU3cxQixLQUFULENBQWVsbkMsQ0FBZixFQUFrQkQsQ0FBbEIsRUFBcUIwTyxDQUFyQixFQUF3QjtBQUN2QmdCLFdBQU8vSyxJQUFQLENBQVksQ0FBQzJoQyxJQUFJcm1DLENBQUosQ0FBRCxFQUFTcW1DLElBQUlybUMsSUFBSSxDQUFSLENBQVQsQ0FBWjtBQUNBeVAsV0FBTy9LLElBQVAsQ0FBWSxDQUFDMmhDLElBQUl0bUMsQ0FBSixDQUFELEVBQVNzbUMsSUFBSXRtQyxJQUFJLENBQVIsQ0FBVCxDQUFaO0FBQ0EwUCxXQUFPL0ssSUFBUCxDQUFZLENBQUMyaEMsSUFBSTUzQixDQUFKLENBQUQsRUFBUzQzQixJQUFJNTNCLElBQUksQ0FBUixDQUFULENBQVo7QUFDQTs7QUFHRCxZQUFTMDRCLFNBQVQsQ0FBbUJubkMsQ0FBbkIsRUFBc0JELENBQXRCLEVBQXlCME8sQ0FBekIsRUFBNEI7QUFDM0IyM0IsaUJBQWExaEMsSUFBYixDQUFrQixDQUFDZ0gsUUFBUTFMLENBQVIsQ0FBRCxFQUFhMEwsUUFBUTFMLElBQUksQ0FBWixDQUFiLEVBQTZCMEwsUUFBUTFMLElBQUksQ0FBWixDQUE3QixDQUFsQjtBQUNBb21DLGlCQUFhMWhDLElBQWIsQ0FBa0IsQ0FBQ2dILFFBQVEzTCxDQUFSLENBQUQsRUFBYTJMLFFBQVEzTCxJQUFJLENBQVosQ0FBYixFQUE2QjJMLFFBQVEzTCxJQUFJLENBQVosQ0FBN0IsQ0FBbEI7QUFDQXFtQyxpQkFBYTFoQyxJQUFiLENBQWtCLENBQUNnSCxRQUFRK0MsQ0FBUixDQUFELEVBQWEvQyxRQUFRK0MsSUFBSSxDQUFaLENBQWIsRUFBNkIvQyxRQUFRK0MsSUFBSSxDQUFaLENBQTdCLENBQWxCO0FBQ0E7O0FBRUQsWUFBUzI0QixPQUFULENBQWlCcG5DLENBQWpCLEVBQW9CRCxDQUFwQixFQUF1QjBPLENBQXZCLEVBQTBCK0MsQ0FBMUIsRUFBOEI2MUIsRUFBOUIsRUFBa0NDLEVBQWxDLEVBQXNDQyxFQUF0QyxFQUEwQ0MsRUFBMUMsRUFBK0NDLEVBQS9DLEVBQW1EQyxFQUFuRCxFQUF1REMsRUFBdkQsRUFBMkRDLEVBQTNELEVBQStEO0FBQzlELFFBQUl0NUIsS0FBS3U0QixpQkFBaUI3bUMsQ0FBakIsQ0FBVDtBQUNBLFFBQUl1TyxLQUFLczRCLGlCQUFpQjltQyxDQUFqQixDQUFUO0FBQ0EsUUFBSXlPLEtBQUtxNEIsaUJBQWlCcDRCLENBQWpCLENBQVQ7QUFDQSxRQUFJbzVCLFdBQUo7O0FBRUEsUUFBSXIyQixNQUFNelQsU0FBVixFQUFxQjs7QUFFcEJrcEMsZUFBVTM0QixFQUFWLEVBQWNDLEVBQWQsRUFBa0JDLEVBQWxCO0FBRUEsS0FKRCxNQUlPOztBQUVOcTVCLFVBQUtoQixpQkFBaUJyMUIsQ0FBakIsQ0FBTDs7QUFFQXkxQixlQUFVMzRCLEVBQVYsRUFBY0MsRUFBZCxFQUFrQnM1QixFQUFsQjtBQUNBWixlQUFVMTRCLEVBQVYsRUFBY0MsRUFBZCxFQUFrQnE1QixFQUFsQjtBQUVBOztBQUdELFFBQUlSLE9BQU90cEMsU0FBWCxFQUFzQjs7QUFFckJ1USxVQUFLMDRCLGFBQWFLLEVBQWIsQ0FBTDtBQUNBOTRCLFVBQUt5NEIsYUFBYU0sRUFBYixDQUFMO0FBQ0E5NEIsVUFBS3c0QixhQUFhTyxFQUFiLENBQUw7O0FBRUEsU0FBSS8xQixNQUFNelQsU0FBVixFQUFxQjs7QUFFcEJtcEMsWUFBTTU0QixFQUFOLEVBQVVDLEVBQVYsRUFBY0MsRUFBZDtBQUVBLE1BSkQsTUFJTzs7QUFFTnE1QixXQUFLYixhQUFhUSxFQUFiLENBQUw7O0FBRUFOLFlBQU01NEIsRUFBTixFQUFVQyxFQUFWLEVBQWNzNUIsRUFBZDtBQUNBWCxZQUFNMzRCLEVBQU4sRUFBVUMsRUFBVixFQUFjcTVCLEVBQWQ7QUFFQTtBQUVEOztBQUVELFFBQUlKLE9BQU8xcEMsU0FBWCxFQUFzQjs7QUFFckJ1USxVQUFLeTRCLGlCQUFpQlUsRUFBakIsQ0FBTDtBQUNBbDVCLFVBQUt3NEIsaUJBQWlCVyxFQUFqQixDQUFMO0FBQ0FsNUIsVUFBS3U0QixpQkFBaUJZLEVBQWpCLENBQUw7O0FBRUEsU0FBSW4yQixNQUFNelQsU0FBVixFQUFxQjs7QUFFcEJvcEMsZ0JBQVU3NEIsRUFBVixFQUFjQyxFQUFkLEVBQWtCQyxFQUFsQjtBQUVBLE1BSkQsTUFJTzs7QUFFTnE1QixXQUFLZCxpQkFBaUJhLEVBQWpCLENBQUw7O0FBRUFULGdCQUFVNzRCLEVBQVYsRUFBY0MsRUFBZCxFQUFrQnM1QixFQUFsQjtBQUNBVixnQkFBVTU0QixFQUFWLEVBQWNDLEVBQWQsRUFBa0JxNUIsRUFBbEI7QUFFQTtBQUVEO0FBQ0Q7O0FBR0QsUUFBSyxJQUFJL29DLElBQUksQ0FBYixFQUFnQkEsSUFBSTJHLE1BQU0xRyxNQUExQixFQUFrQ0QsR0FBbEMsRUFBd0M7QUFDdkMsUUFBSWdwQyxPQUFPcmlDLE1BQU0zRyxDQUFOLENBQVg7QUFDQWdwQyxXQUFPQSxLQUFLQyxJQUFMLEVBQVA7O0FBRUEsUUFBSUQsS0FBSy9vQyxNQUFMLEtBQWdCLENBQWhCLElBQXFCK29DLEtBQUtFLE1BQUwsQ0FBWSxDQUFaLE1BQW1CLEdBQTVDLEVBQWlEOztBQUVoRDtBQUVBLEtBSkQsTUFJTyxJQUFJLENBQUM3dkIsU0FBU211QixjQUFjMkIsSUFBZCxDQUFtQkgsSUFBbkIsQ0FBVixNQUF3QyxJQUE1QyxFQUFrRDs7QUFFeERuOEIsY0FBU2pILElBQVQsQ0FDQ3dqQyxXQUFXL3ZCLE9BQU8sQ0FBUCxDQUFYLENBREQsRUFFQyt2QixXQUFXL3ZCLE9BQU8sQ0FBUCxDQUFYLENBRkQsRUFHQyt2QixXQUFXL3ZCLE9BQU8sQ0FBUCxDQUFYLENBSEQ7QUFNQSxLQVJNLE1BUUEsSUFBSSxDQUFDQSxTQUFTb3VCLGNBQWMwQixJQUFkLENBQW1CSCxJQUFuQixDQUFWLE1BQXdDLElBQTVDLEVBQWtEOztBQUV4RHA4QixhQUFRaEgsSUFBUixDQUNDd2pDLFdBQVcvdkIsT0FBTyxDQUFQLENBQVgsQ0FERCxFQUVDK3ZCLFdBQVcvdkIsT0FBTyxDQUFQLENBQVgsQ0FGRCxFQUdDK3ZCLFdBQVcvdkIsT0FBTyxDQUFQLENBQVgsQ0FIRDtBQU1BLEtBUk0sTUFRQSxJQUFJLENBQUNBLFNBQVNxdUIsVUFBVXlCLElBQVYsQ0FBZUgsSUFBZixDQUFWLE1BQW9DLElBQXhDLEVBQThDOztBQUVwRHpCLFNBQUkzaEMsSUFBSixDQUNDd2pDLFdBQVcvdkIsT0FBTyxDQUFQLENBQVgsQ0FERCxFQUVDK3ZCLFdBQVcvdkIsT0FBTyxDQUFQLENBQVgsQ0FGRDtBQUtBLEtBUE0sTUFPQSxJQUFJLENBQUNBLFNBQVNzdUIsYUFBYXdCLElBQWIsQ0FBa0JILElBQWxCLENBQVYsTUFBdUMsSUFBM0MsRUFBaUQ7O0FBRXZEVixhQUNDanZCLE9BQU8sQ0FBUCxDQURELEVBQ1lBLE9BQU8sQ0FBUCxDQURaLEVBQ3VCQSxPQUFPLENBQVAsQ0FEdkIsRUFDa0NBLE9BQU8sQ0FBUCxDQURsQztBQUlBLEtBTk0sTUFNQSxJQUFJLENBQUNBLFNBQVN1dUIsYUFBYXVCLElBQWIsQ0FBa0JILElBQWxCLENBQVYsTUFBdUMsSUFBM0MsRUFBaUQ7O0FBRXZEVixhQUNDanZCLE9BQU8sQ0FBUCxDQURELEVBQ1lBLE9BQU8sQ0FBUCxDQURaLEVBQ3VCQSxPQUFPLENBQVAsQ0FEdkIsRUFDa0NBLE9BQU8sRUFBUCxDQURsQyxFQUVDQSxPQUFPLENBQVAsQ0FGRCxFQUVZQSxPQUFPLENBQVAsQ0FGWixFQUV1QkEsT0FBTyxDQUFQLENBRnZCLEVBRWtDQSxPQUFPLEVBQVAsQ0FGbEM7QUFLQSxLQVBNLE1BT0EsSUFBSSxDQUFDQSxTQUFTd3VCLGFBQWFzQixJQUFiLENBQWtCSCxJQUFsQixDQUFWLE1BQXVDLElBQTNDLEVBQWlEO0FBQ3ZEVixhQUNDanZCLE9BQU8sQ0FBUCxDQURELEVBQ1lBLE9BQU8sQ0FBUCxDQURaLEVBQ3VCQSxPQUFPLEVBQVAsQ0FEdkIsRUFDbUNBLE9BQU8sRUFBUCxDQURuQyxFQUVDQSxPQUFPLENBQVAsQ0FGRCxFQUVZQSxPQUFPLENBQVAsQ0FGWixFQUV1QkEsT0FBTyxFQUFQLENBRnZCLEVBRW1DQSxPQUFPLEVBQVAsQ0FGbkMsRUFHQ0EsT0FBTyxDQUFQLENBSEQsRUFHWUEsT0FBTyxDQUFQLENBSFosRUFHdUJBLE9BQU8sRUFBUCxDQUh2QixFQUdtQ0EsT0FBTyxFQUFQLENBSG5DO0FBTUEsS0FQTSxNQU9BLElBQUksQ0FBQ0EsU0FBU3l1QixhQUFhcUIsSUFBYixDQUFrQkgsSUFBbEIsQ0FBVixNQUF1QyxJQUEzQyxFQUFpRDtBQUN2RFYsYUFDQ2p2QixPQUFPLENBQVAsQ0FERCxFQUNZQSxPQUFPLENBQVAsQ0FEWixFQUN1QkEsT0FBTyxDQUFQLENBRHZCLEVBQ2tDQSxPQUFPLEVBQVAsQ0FEbEMsRUFFQ3BhLFNBRkQsRUFFWUEsU0FGWixFQUV1QkEsU0FGdkIsRUFFa0NBLFNBRmxDLEVBR0NvYSxPQUFPLENBQVAsQ0FIRCxFQUdZQSxPQUFPLENBQVAsQ0FIWixFQUd1QkEsT0FBTyxDQUFQLENBSHZCLEVBR2tDQSxPQUFPLEVBQVAsQ0FIbEM7QUFNQTtBQUNEOztBQUVELFVBQU8sS0FBS2d3QixlQUFMLENBQXFCO0FBQzNCMzRCLHdCQUQyQjtBQUUzQkMsa0JBRjJCO0FBRzNCL0QsYUFBUTA2QixZQUhtQjtBQUkzQmw0QjtBQUoyQixJQUFyQixDQUFQO0FBT0E7OztrQ0FFZTFELEMsRUFBRztBQUNsQixPQUFNNDlCLGlCQUFpQixLQUF2QjtBQUNBLE9BQU1DLGFBQWE3OUIsRUFBRWtCLE9BQUYsQ0FBVTNNLE1BQVYsR0FBbUIsQ0FBdEM7QUFDQSxPQUFNdXBDLFNBQVM5OUIsRUFBRWlGLE1BQUYsQ0FBUzFRLE1BQVQsR0FBa0IsQ0FBakM7QUFDQSxPQUFJbVEsYUFBSjs7QUFFQSxPQUFHMUUsRUFBRWdGLFNBQUYsQ0FBWXpRLE1BQVosR0FBcUJxcEMsY0FBeEIsRUFBd0M7QUFDdkMsUUFBTUcsU0FBUyxFQUFmO0FBQ0EsUUFBSUMsWUFBWSxDQUFoQjs7QUFFQSxRQUFNQyxRQUFjLEVBQXBCO0FBQ0FBLFVBQU1qNUIsU0FBTixHQUFrQmhGLEVBQUVnRixTQUFGLENBQVkvRyxNQUFaLEVBQWxCO0FBQ0FnZ0MsVUFBTWg1QixNQUFOLEdBQWtCakYsRUFBRWlGLE1BQUYsQ0FBU2hILE1BQVQsRUFBbEI7QUFDQWdnQyxVQUFNdjZCLE9BQU4sR0FBa0IxRCxFQUFFMEQsT0FBRixDQUFVekYsTUFBVixFQUFsQjtBQUNBZ2dDLFVBQU0vOEIsT0FBTixHQUFrQmxCLEVBQUVrQixPQUFGLENBQVVqRCxNQUFWLEVBQWxCOztBQUVBLFdBQU0rQixFQUFFMEQsT0FBRixDQUFVblAsTUFBVixHQUFtQixDQUF6QixFQUE0Qjs7QUFFM0IsU0FBTTJwQyxXQUFZNzNCLEtBQUs2akIsR0FBTCxDQUFTMFQsY0FBVCxFQUF5QjU5QixFQUFFZ0YsU0FBRixDQUFZelEsTUFBckMsQ0FBbEI7QUFDQSxTQUFNbVAsVUFBWTFELEVBQUUwRCxPQUFGLENBQVU4b0IsTUFBVixDQUFpQixDQUFqQixFQUFvQjBSLFFBQXBCLENBQWxCO0FBQ0EsU0FBTWw1QixZQUFZLEVBQWxCO0FBQ0EsU0FBTUMsU0FBWSxFQUFsQjtBQUNBLFNBQU0vRCxVQUFZLEVBQWxCO0FBQ0EsU0FBSXFFLGNBQUo7QUFBQSxTQUFXNDRCLFdBQVcsQ0FBdEI7O0FBRUEsVUFBSSxJQUFJN3BDLElBQUksQ0FBWixFQUFlQSxJQUFJb1AsUUFBUW5QLE1BQTNCLEVBQW1DRCxHQUFuQyxFQUF3QztBQUN2QyxVQUFHb1AsUUFBUXBQLENBQVIsSUFBYTZwQyxRQUFoQixFQUEwQjtBQUN6QkEsa0JBQVd6NkIsUUFBUXBQLENBQVIsQ0FBWDtBQUNBOztBQUVEaVIsY0FBUTdCLFFBQVFwUCxDQUFSLENBQVI7O0FBRUEwUSxnQkFBVTlLLElBQVYsQ0FBZStqQyxNQUFNajVCLFNBQU4sQ0FBZ0JPLEtBQWhCLENBQWY7QUFDQSxVQUFHdTRCLE1BQUgsRUFBVztBQUNWNzRCLGNBQU8vSyxJQUFQLENBQVkrakMsTUFBTWg1QixNQUFOLENBQWFNLEtBQWIsQ0FBWjtBQUNBO0FBQ0QsVUFBR3M0QixVQUFILEVBQWU7QUFDZDM4QixlQUFRaEgsSUFBUixDQUFhK2pDLE1BQU0vOEIsT0FBTixDQUFjcUUsS0FBZCxDQUFiO0FBQ0E7O0FBRUQ3QixjQUFRcFAsQ0FBUixLQUFjMHBDLFNBQWQ7QUFDQTs7QUFFREEsaUJBQVlHLFdBQVcsQ0FBdkI7O0FBRUF6NUIsWUFBTyxtQkFBUyxLQUFLakQsU0FBZCxDQUFQO0FBQ0FpRCxVQUFLa0IsWUFBTCxDQUFrQlosU0FBbEI7QUFDQSxTQUFHODRCLE1BQUgsRUFBVztBQUNWcDVCLFdBQUttQixjQUFMLENBQW9CWixNQUFwQjtBQUNBOztBQUVEUCxVQUFLb0IsV0FBTCxDQUFpQnBDLE9BQWpCO0FBQ0EsU0FBR202QixVQUFILEVBQWU7QUFDZG41QixXQUFLdEQsWUFBTCxDQUFrQkYsT0FBbEI7QUFDQTs7QUFFRDY4QixZQUFPN2pDLElBQVAsQ0FBWXdLLElBQVo7QUFDQTs7QUFFRCxRQUFHLEtBQUs2TixTQUFSLEVBQW1CO0FBQ2xCLFVBQUtBLFNBQUwsQ0FBZXdyQixNQUFmLEVBQXVCRSxLQUF2QjtBQUNBOztBQUVELFdBQU9GLE1BQVA7QUFDQSxJQTFERCxNQTBETztBQUNOcjVCLFdBQU8sbUJBQVMsS0FBS2pELFNBQWQsQ0FBUDtBQUNBaUQsU0FBS2tCLFlBQUwsQ0FBa0I1RixFQUFFZ0YsU0FBcEI7QUFDQSxRQUFHODRCLE1BQUgsRUFBVztBQUNWcDVCLFVBQUttQixjQUFMLENBQW9CN0YsRUFBRWlGLE1BQXRCO0FBQ0E7QUFDRFAsU0FBS29CLFdBQUwsQ0FBaUI5RixFQUFFMEQsT0FBbkI7QUFDQSxRQUFHbTZCLFVBQUgsRUFBZTtBQUNkbjVCLFVBQUt0RCxZQUFMLENBQWtCcEIsRUFBRWtCLE9BQXBCO0FBQ0E7O0FBRUQsUUFBRyxLQUFLcVIsU0FBUixFQUFtQjtBQUNsQixVQUFLQSxTQUFMLENBQWU3TixJQUFmLEVBQXFCMUUsQ0FBckI7QUFDQTs7QUFFRCxXQUFPMEUsSUFBUDtBQUNBOztBQUVELFVBQU8sSUFBUDtBQUNBOzs7Ozs7QUFJRmdQLFVBQVUwcUIsS0FBVixHQUFrQixVQUFVekMsTUFBVixFQUFrQjtBQUNuQyxLQUFNMEMsU0FBUyxJQUFJM3FCLFNBQUosRUFBZjtBQUNBLFFBQU8ycUIsT0FBTzNDLFFBQVAsQ0FBZ0JDLE1BQWhCLENBQVA7QUFDQSxDQUhEOztrQkFLZWpvQixTOzs7Ozs7O0FDalVmOztBQUVBOzs7Ozs7OztBQUVBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztJQUVNRSxTOzs7QUFDTCxzQkFBYztBQUFBOztBQUFBLCtHQUNQLElBRE87QUFFYjs7Ozt3QkFFS3dYLFksRUFBYztBQUNuQixVQUFPLHlCQUFVQSxZQUFWLENBQVA7QUFDQTs7OzhCQUVXO0FBQ1gsT0FBTXByQixJQUFJLEtBQUtvK0IsS0FBTCxDQUFXLEtBQUtyc0IsSUFBTCxDQUFVVyxRQUFyQixDQUFWO0FBQ0EsT0FBRyxLQUFLSCxTQUFSLEVBQW1CO0FBQ2xCLFNBQUtBLFNBQUwsQ0FBZXZTLENBQWY7QUFDQTtBQUNEOzs7Ozs7QUFLRjRULFVBQVV3cUIsS0FBVixHQUFrQixVQUFVaFQsWUFBVixFQUF3QjtBQUN6QyxRQUFPLHlCQUFVQSxZQUFWLENBQVA7QUFDQSxDQUZEOztrQkFJZXhYLFM7Ozs7Ozs7QUM5QmY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUNBLElBQU0wcUIsa0JBQWtCLGNBQXhCO0FBQ0EsSUFBTUMsaUJBQWlCLEtBQXZCO0FBQ0E7QUFDQSxJQUFNQyxrQkFBa0IsZ0NBQXhCO0FBQ0EsSUFBTUMsZ0JBQWdCLHdCQUF0QjtBQUNBLElBQU1DLHFCQUFxQiwyQkFBM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBU0MsZ0JBQVQsQ0FBMEJobUMsTUFBMUIsRUFBa0NvSixJQUFsQyxFQUF3Q2dxQixNQUF4QyxFQUFnRDZTLFVBQWhELEVBQTREQyxhQUE1RCxFQUEyRUMsWUFBM0UsRUFBeUY7QUFDeEYsS0FBTUMsT0FBTyxJQUFJcDlCLEtBQUosQ0FBVSxDQUFWLENBQWI7QUFDQSxLQUFJcTlCLGlCQUFpQixJQUFyQjtBQUNBLEtBQUlDLFlBQUo7QUFDQSxLQUFJQyxlQUFKO0FBQ0EsS0FBSWg0QixjQUFKO0FBQ0EsS0FBTWk0QixNQUFNLElBQUl4OUIsS0FBSixDQUFVLENBQVYsQ0FBWjtBQUNBLEtBQU15OUIsZUFBZXptQyxPQUFPcEUsTUFBNUI7O0FBRUEsVUFBUzhxQyxPQUFULENBQWlCRixHQUFqQixFQUFzQjtBQUNyQixNQUFJRyxZQUFZLENBQWhCO0FBQ0EsS0FBRztBQUNGSCxPQUFJRyxXQUFKLElBQW1CM21DLE9BQU9pbUMsVUFBUCxDQUFuQjtBQUNBLEdBRkQsUUFFUSxFQUFFQSxVQUFGLEdBQWVRLFlBQWYsSUFBK0JFLFlBQVlILElBQUk1cUMsTUFGdkQ7QUFHQSxTQUFPK3FDLFNBQVA7QUFDQTs7QUFFRCxVQUFTQyxhQUFULENBQXVCSixHQUF2QixFQUE0QnBULE1BQTVCLEVBQW9DeDNCLE1BQXBDLEVBQTRDO0FBQzNDLE1BQUkrcUMsWUFBWSxDQUFoQjtBQUNBLEtBQUc7QUFDRkgsT0FBSXBULFNBQVN1VCxXQUFiLElBQTRCM21DLE9BQU9pbUMsVUFBUCxDQUE1QjtBQUNBLEdBRkQsUUFFUSxFQUFFQSxVQUFGLEdBQWVRLFlBQWYsSUFBK0JFLFlBQVkvcUMsTUFGbkQ7QUFHQSxTQUFPK3FDLFNBQVA7QUFDQTs7QUFFRCxVQUFTRSxhQUFULENBQXVCN21DLE1BQXZCLEVBQStCb0osSUFBL0IsRUFBcUNncUIsTUFBckMsRUFBNkMwVCxTQUE3QyxFQUF3RDtBQUN2RCxNQUFNQyxjQUFjLElBQUlELFNBQXhCO0FBQ0EsTUFBTUUsVUFBVUosY0FBY3g5QixJQUFkLEVBQW9CZ3FCLE1BQXBCLEVBQTRCMlQsV0FBNUIsQ0FBaEI7QUFDQSxNQUFJQyxVQUFVRCxXQUFkLEVBQTJCO0FBQzFCLFNBQU0sSUFBSUUsS0FBSixvQ0FBMkNELE9BQTNDLHlCQUFzRUQsV0FBdEUsQ0FBTjtBQUNBO0FBQ0Q7O0FBRUQsUUFBT1osZUFBZSxDQUF0QixFQUF5QjtBQUN4QixNQUFJTyxRQUFRTixJQUFSLElBQWdCQSxLQUFLeHFDLE1BQXpCLEVBQWlDO0FBQ2hDLFNBQU0sSUFBSXFyQyxLQUFKLG9DQUEyQ2IsS0FBS3hxQyxNQUFoRCxDQUFOO0FBQ0E7O0FBRUQsTUFBS3dxQyxLQUFLLENBQUwsTUFBWSxDQUFiLElBQW9CQSxLQUFLLENBQUwsTUFBWSxDQUFoQyxJQUF1QyxDQUFDQSxLQUFLLENBQUwsSUFBVSxJQUFYLE1BQXFCLENBQWhFLEVBQW9FO0FBQ25FO0FBQ0FoOUIsUUFBS2dxQixRQUFMLElBQWlCZ1QsS0FBSyxDQUFMLENBQWpCO0FBQ0FoOUIsUUFBS2dxQixRQUFMLElBQWlCZ1QsS0FBSyxDQUFMLENBQWpCO0FBQ0FoOUIsUUFBS2dxQixRQUFMLElBQWlCZ1QsS0FBSyxDQUFMLENBQWpCO0FBQ0FoOUIsUUFBS2dxQixRQUFMLElBQWlCZ1QsS0FBSyxDQUFMLENBQWpCO0FBQ0FTLGlCQUFjN21DLE1BQWQsRUFBc0JvSixJQUF0QixFQUE0QmdxQixNQUE1QixFQUFvQzhTLGdCQUFnQkMsWUFBaEIsR0FBK0IsQ0FBbkU7QUFDQTtBQUNBOztBQUVELE1BQUksQ0FBRSxDQUFDQyxLQUFLLENBQUwsSUFBVSxJQUFYLEtBQW9CLENBQXJCLEdBQTJCQSxLQUFLLENBQUwsSUFBVSxJQUF0QyxNQUFpREYsYUFBckQsRUFBb0U7QUFDbkUsU0FBTSxJQUFJZSxLQUFKLDRCQUFvQyxDQUFDYixLQUFLLENBQUwsSUFBVSxJQUFYLEtBQW9CLENBQXJCLEdBQTJCQSxLQUFLLENBQUwsSUFBVSxJQUF4RSxvQkFBNEZGLGFBQTVGLENBQU47QUFDQTs7QUFFRCxNQUFJRyxtQkFBbUIsSUFBdkIsRUFBNkI7QUFDNUJBLG9CQUFpQixJQUFJcjlCLEtBQUosQ0FBVSxJQUFJazlCLGFBQWQsQ0FBakI7QUFDQTs7QUFFREksUUFBTSxDQUFOO0FBQ0E7QUFDQSxPQUFLLElBQUkzcUMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJLENBQXBCLEVBQXVCQSxHQUF2QixFQUE0QjtBQUMzQjRxQyxZQUFTLENBQUM1cUMsSUFBSSxDQUFMLElBQVV1cUMsYUFBbkI7QUFDQSxVQUFNSSxNQUFNQyxNQUFaLEVBQW9CO0FBQ25CLFFBQUlHLFFBQVFGLEdBQVIsSUFBZUEsSUFBSTVxQyxNQUF2QixFQUErQjtBQUM5QixXQUFNLElBQUlxckMsS0FBSixDQUFVLDZCQUFWLENBQU47QUFDQTtBQUNELFFBQUksQ0FBQ1QsSUFBSSxDQUFKLElBQVMsSUFBVixJQUFrQixHQUF0QixFQUEyQjtBQUMxQjtBQUNBajRCLGFBQVEsQ0FBQ2k0QixJQUFJLENBQUosSUFBUyxJQUFWLElBQWtCLEdBQTFCO0FBQ0EsU0FBS2o0QixVQUFVLENBQVgsSUFBa0JBLFFBQVFnNEIsU0FBU0QsR0FBdkMsRUFBNkM7QUFDNUMsWUFBTSxJQUFJVyxLQUFKLENBQVUsbUJBQVYsQ0FBTjtBQUNBO0FBQ0QsWUFBTTE0QixVQUFVLENBQWhCLEVBQW1CO0FBQ2xCODNCLHFCQUFlQyxLQUFmLElBQXdCRSxJQUFJLENBQUosQ0FBeEI7QUFDQTtBQUNELEtBVEQsTUFTTztBQUNOO0FBQ0FqNEIsYUFBUWk0QixJQUFJLENBQUosSUFBUyxJQUFqQjtBQUNBLFNBQUtqNEIsVUFBVSxDQUFYLElBQWtCQSxRQUFRZzRCLFNBQVNELEdBQXZDLEVBQTZDO0FBQzVDLFlBQU0sSUFBSVcsS0FBSixDQUFVLG1CQUFWLENBQU47QUFDQTtBQUNEWixvQkFBZUMsS0FBZixJQUF3QkUsSUFBSSxDQUFKLENBQXhCO0FBQ0EsU0FBSSxFQUFFajRCLEtBQUYsR0FBVSxDQUFkLEVBQWlCO0FBQ2hCLFVBQUlxNEIsY0FBY1AsY0FBZCxFQUE4QkMsR0FBOUIsRUFBbUMvM0IsS0FBbkMsSUFBNENBLEtBQWhELEVBQXVEO0FBQ3RELGFBQU0sSUFBSTA0QixLQUFKLENBQVUsNEJBQVYsQ0FBTjtBQUNBO0FBQ0RYLGFBQU8vM0IsS0FBUDtBQUNBO0FBQ0Q7QUFDRDtBQUNEOztBQUVEO0FBQ0EsT0FBSSxJQUFJNVMsS0FBSSxDQUFaLEVBQWVBLEtBQUl1cUMsYUFBbkIsRUFBa0N2cUMsSUFBbEMsRUFBdUM7QUFDdEN5TixRQUFLZ3FCLFNBQVMsQ0FBZCxJQUFtQmlULGVBQWUxcUMsRUFBZixDQUFuQjtBQUNBeU4sUUFBS2dxQixTQUFTLENBQWQsSUFBbUJpVCxlQUFlMXFDLEtBQUl1cUMsYUFBbkIsQ0FBbkI7QUFDQTk4QixRQUFLZ3FCLFNBQVMsQ0FBZCxJQUFtQmlULGVBQWUxcUMsS0FBSSxJQUFJdXFDLGFBQXZCLENBQW5CO0FBQ0E5OEIsUUFBS2dxQixTQUFTLENBQWQsSUFBbUJpVCxlQUFlMXFDLEtBQUksSUFBSXVxQyxhQUF2QixDQUFuQjtBQUNBOVMsYUFBVSxDQUFWO0FBQ0E7O0FBRUQrUztBQUNBO0FBRUQ7O0FBRUQ7QUFDQSxTQUFTZSxRQUFULENBQWtCbG5DLE1BQWxCLEVBQTBCO0FBQ3pCLEtBQUlBLGtCQUFrQm1uQyxXQUF0QixFQUFtQztBQUNsQ25uQyxXQUFTLElBQUkweEIsVUFBSixDQUFlMXhCLE1BQWYsQ0FBVDtBQUNBOztBQUVELEtBQUlpbUMsYUFBYSxDQUFqQjtBQUNBLEtBQU1RLGVBQWV6bUMsT0FBT3BFLE1BQTVCOztBQUVBLEtBQU13ckMsV0FBVyxFQUFqQjs7QUFFQSxVQUFTQyxRQUFULEdBQW9CO0FBQ25CLE1BQUliLE1BQU0sRUFBVjtBQUNBLEtBQUc7QUFDRixPQUFNNXBDLElBQUlvRCxPQUFPaW1DLFVBQVAsQ0FBVjtBQUNBLE9BQUlycEMsTUFBTXdxQyxRQUFWLEVBQW9CO0FBQ25CLE1BQUVuQixVQUFGO0FBQ0E7QUFDQTtBQUNETyxVQUFPYyxPQUFPQyxZQUFQLENBQW9CM3FDLENBQXBCLENBQVA7QUFDQSxHQVBELFFBT1EsRUFBRXFwQyxVQUFGLEdBQWVRLFlBUHZCO0FBUUEsU0FBT0QsR0FBUDtBQUNBOztBQUVELEtBQUk1bEMsUUFBUSxDQUFaO0FBQ0EsS0FBSUMsU0FBUyxDQUFiO0FBQ0EsS0FBSWt1QixXQUFXLENBQWY7QUFDQSxLQUFNeVksUUFBUSxDQUFkO0FBQ0EsS0FBSUMsTUFBTSxLQUFWOztBQUVBLE1BQUksSUFBSTlyQyxJQUFJLENBQVosRUFBZUEsSUFBSSxFQUFuQixFQUF1QkEsR0FBdkIsRUFBNEI7QUFDM0IsTUFBTWdwQyxPQUFPMEMsVUFBYjtBQUNBLE1BQUlLLGNBQUo7QUFDQSxNQUFJQSxRQUFRL0MsS0FBSytDLEtBQUwsQ0FBVy9CLGVBQVgsQ0FBWixFQUF5QyxDQUN4QyxDQURELE1BQ08sSUFBSStCLFFBQVEvQyxLQUFLK0MsS0FBTCxDQUFXNUIsYUFBWCxDQUFaLEVBQXVDO0FBQzdDMkIsU0FBTSxJQUFOO0FBQ0EsR0FGTSxNQUVBLElBQUlDLFFBQVEvQyxLQUFLK0MsS0FBTCxDQUFXN0IsZUFBWCxDQUFaLEVBQXlDO0FBQy9DOVcsY0FBVzRZLE9BQU9ELE1BQU0sQ0FBTixDQUFQLENBQVg7QUFDQSxHQUZNLE1BRUEsSUFBSUEsUUFBUS9DLEtBQUsrQyxLQUFMLENBQVc5QixjQUFYLENBQVosRUFBd0MsQ0FDOUMsQ0FETSxNQUNBLElBQUk4QixRQUFRL0MsS0FBSytDLEtBQUwsQ0FBVzNCLGtCQUFYLENBQVosRUFBNEM7QUFDbERsbEMsWUFBUzhtQyxPQUFPRCxNQUFNLENBQU4sQ0FBUCxDQUFUO0FBQ0E5bUMsV0FBUSttQyxPQUFPRCxNQUFNLENBQU4sQ0FBUCxDQUFSO0FBQ0E7QUFDQTtBQUNEOztBQUVELEtBQUksQ0FBQ0QsR0FBTCxFQUFVO0FBQ1QsUUFBTSxJQUFJUixLQUFKLENBQVUsaUNBQVYsQ0FBTjtBQUNBOztBQUVELEtBQU03OUIsT0FBTyxJQUFJc29CLFVBQUosQ0FBZTl3QixRQUFRQyxNQUFSLEdBQWlCLENBQWhDLENBQWI7QUFDQSxLQUFNcWxDLGdCQUFnQnRsQyxLQUF0QjtBQUNBLEtBQU11bEMsZUFBZXRsQyxNQUFyQjs7QUFFQW1sQyxrQkFBaUJobUMsTUFBakIsRUFBeUJvSixJQUF6QixFQUErQixDQUEvQixFQUFrQzY4QixVQUFsQyxFQUE4Q0MsYUFBOUMsRUFBNkRDLFlBQTdEOztBQUVBO0FBQ0EsS0FBTXlCLFlBQVksSUFBSWhsQyxZQUFKLENBQWlCaEMsUUFBUUMsTUFBUixHQUFpQixDQUFsQyxDQUFsQjtBQUNBLE1BQUksSUFBSXV5QixTQUFTLENBQWpCLEVBQW9CQSxTQUFTaHFCLEtBQUt4TixNQUFsQyxFQUEwQ3czQixVQUFVLENBQXBELEVBQXVEO0FBQ3RELE1BQUkxMkIsSUFBSTBNLEtBQUtncUIsU0FBUyxDQUFkLElBQW1CLEdBQTNCO0FBQ0EsTUFBSXoyQixJQUFJeU0sS0FBS2dxQixTQUFTLENBQWQsSUFBbUIsR0FBM0I7QUFDQSxNQUFJeDJCLElBQUl3TSxLQUFLZ3FCLFNBQVMsQ0FBZCxJQUFtQixHQUEzQjtBQUNBLE1BQU12eEIsSUFBSXVILEtBQUtncUIsU0FBUyxDQUFkLENBQVY7QUFDQSxNQUFNcU0sSUFBSS94QixLQUFLK3dCLEdBQUwsQ0FBUyxHQUFULEVBQWM1OEIsSUFBSSxLQUFsQixDQUFWOztBQUVBbkYsT0FBSytpQyxDQUFMO0FBQ0E5aUMsT0FBSzhpQyxDQUFMO0FBQ0E3aUMsT0FBSzZpQyxDQUFMOztBQUVBLE1BQU1vSSxjQUFjelUsTUFBcEI7O0FBRUF3VSxZQUFVQyxjQUFjLENBQXhCLElBQTZCbnJDLENBQTdCO0FBQ0FrckMsWUFBVUMsY0FBYyxDQUF4QixJQUE2QmxyQyxDQUE3QjtBQUNBaXJDLFlBQVVDLGNBQWMsQ0FBeEIsSUFBNkJqckMsQ0FBN0I7QUFDQWdyQyxZQUFVQyxjQUFjLENBQXhCLElBQTZCLEdBQTdCO0FBQ0E7O0FBRUQsUUFBTztBQUNONVksU0FBTyxDQUFDcnVCLEtBQUQsRUFBUUMsTUFBUixDQUREO0FBRU5rdUIsb0JBRk07QUFHTnlZLGNBSE07QUFJTnArQixRQUFNdytCO0FBSkEsRUFBUDtBQU1BOztrQkFHY1YsUTs7Ozs7Ozs7Ozs7OztBQy9NZjs7OztBQUNBOzs7Ozs7QUFIQTs7QUFNQSxJQUFNWSxlQUFlLFNBQWZBLFlBQWUsQ0FBVTFDLE1BQVYsRUFBa0I7QUFDdEMsS0FBTTJDLFNBQVMsRUFBZjs7QUFFQTNDLFFBQU94bEMsT0FBUCxDQUFlLFVBQUNtTSxJQUFELEVBQVM7QUFBQSxtQkFDZ0NBLEtBQUtBLElBRHJDO0FBQUEsTUFDZnZELFFBRGUsY0FDZkEsUUFEZTtBQUFBLE1BQ0xELE9BREssY0FDTEEsT0FESztBQUFBLE1BQ0krRCxNQURKLGNBQ0lBLE1BREo7QUFBQSxNQUNZMDdCLFNBRFosY0FDWUEsU0FEWjtBQUFBLE1BQ3VCdGpDLElBRHZCLGNBQ3VCQSxJQUR2Qjs7QUFFdkIsTUFBRyxDQUFDcWpDLE9BQU9yakMsSUFBUCxDQUFKLEVBQWtCO0FBQ2pCLE9BQU11akMsU0FBUyxxQkFDYkMsaUJBRGEsQ0FDSzEvQixRQURMLEVBQ2UsaUJBRGYsRUFDa0MsQ0FEbEMsRUFFYjAvQixpQkFGYSxDQUVLNTdCLE1BRkwsRUFFYSxlQUZiLEVBRThCLENBRjlCLEVBR2I0N0IsaUJBSGEsQ0FHSzMvQixPQUhMLEVBR2MsU0FIZCxFQUd5QixDQUh6QixFQUliNEUsV0FKYSxDQUlENjZCLFNBSkMsQ0FBZjs7QUFNQUQsVUFBT3JqQyxJQUFQLElBQWV1akMsTUFBZjtBQUNBOztBQUVEbDhCLE9BQUtrOEIsTUFBTCxHQUFjRixPQUFPcmpDLElBQVAsQ0FBZDtBQUNBLEVBYkQ7QUFjQSxDQWpCRDs7QUFtQkEsSUFBTStnQyxRQUFRLFNBQVJBLEtBQVEsQ0FBVXYrQixLQUFWLEVBQWlCO0FBQzlCLEtBQU1rK0IsU0FBUyx3QkFBT0ssS0FBUCxDQUFhditCLEtBQWIsQ0FBZjtBQUNBNGdDLGNBQWExQyxNQUFiOztBQUVBLFFBQU9BLE1BQVA7QUFDQSxDQUxEOztBQU9BLElBQU0rQyxPQUFPLFNBQVBBLElBQU8sQ0FBVUMsS0FBVixFQUFpQkMsU0FBakIsRUFBNEI7QUFDeEMseUJBQU9GLElBQVAsQ0FBWUMsS0FBWixFQUFtQixVQUFDaEQsTUFBRCxFQUFXO0FBQzdCMEMsZUFBYTFDLE1BQWI7QUFDQWlELFlBQVVqRCxNQUFWO0FBQ0EsRUFIRDtBQUlBLENBTEQ7O0FBT0EsSUFBTXBxQixnQkFBZ0I7QUFDckJ5cUIsYUFEcUI7QUFFckIwQztBQUZxQixDQUF0Qjs7a0JBTWVudEIsYTs7Ozs7OztBQzdDZjs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDOzs7Ozs7OzhDQ3ZIQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSw2Q0FBNkM7O0FBRTdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFCQUFxQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdDQUFnQyxFQUFFO0FBQ3BFO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0EsU0FBUztBQUNUOztBQUVBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixhQUFhO0FBQ2IsZ0JBQWdCO0FBQ2hCLFVBQVUsZUFBZTtBQUN6QixxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDLGlCQUFpQiwrQkFBK0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsZ0NBQWdDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLCtCQUErQjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLCtCQUErQjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBO0FBQ0EseUJBQXlCLHFDQUFxQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlCQUF5Qjs7QUFFMUM7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixnQ0FBZ0M7QUFDakQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBLDhGQUE4RjtBQUM5RixFQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyQkFBMkI7QUFDckQ7QUFDQTtBQUNBLEdBQUc7QUFDSCxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0Esa0JBQWtCLDRCQUE0QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0EsSUFBSTtBQUNKLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQiwrQkFBK0I7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUIsK0JBQStCO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFVBQVU7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixVQUFVO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsVUFBVTtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFVBQVU7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixVQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7O0FBR0E7QUFDQSxZQUFZLEtBQUs7O0FBRWpCOzs7O0FBSUEsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0IsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3BpQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztzRENwRkE7QUFD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SDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFBQTtBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNwaEJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxTQUFTO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxVQUFVLFNBQVM7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDclpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDeEdBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDTEE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUMxT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0gsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDN1NBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7Ozs7Ozs7O0FDeFRBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiJhc3NldHMvanMvYXBwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0ZnVuY3Rpb24gaG90RGlzcG9zZUNodW5rKGNodW5rSWQpIHtcbiBcdFx0ZGVsZXRlIGluc3RhbGxlZENodW5rc1tjaHVua0lkXTtcbiBcdH1cbiBcdHZhciBwYXJlbnRIb3RVcGRhdGVDYWxsYmFjayA9IHdpbmRvd1tcIndlYnBhY2tIb3RVcGRhdGVcIl07XG4gXHR3aW5kb3dbXCJ3ZWJwYWNrSG90VXBkYXRlXCJdID0gXHJcbiBcdGZ1bmN0aW9uIHdlYnBhY2tIb3RVcGRhdGVDYWxsYmFjayhjaHVua0lkLCBtb3JlTW9kdWxlcykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdFx0aG90QWRkVXBkYXRlQ2h1bmsoY2h1bmtJZCwgbW9yZU1vZHVsZXMpO1xyXG4gXHRcdGlmKHBhcmVudEhvdFVwZGF0ZUNhbGxiYWNrKSBwYXJlbnRIb3RVcGRhdGVDYWxsYmFjayhjaHVua0lkLCBtb3JlTW9kdWxlcyk7XHJcbiBcdH0gO1xyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90RG93bmxvYWRVcGRhdGVDaHVuayhjaHVua0lkKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHR2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcclxuIFx0XHR2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcclxuIFx0XHRzY3JpcHQudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XHJcbiBcdFx0c2NyaXB0LmNoYXJzZXQgPSBcInV0Zi04XCI7XHJcbiBcdFx0c2NyaXB0LnNyYyA9IF9fd2VicGFja19yZXF1aXJlX18ucCArIFwiXCIgKyBjaHVua0lkICsgXCIuXCIgKyBob3RDdXJyZW50SGFzaCArIFwiLmhvdC11cGRhdGUuanNcIjtcclxuIFx0XHQ7XHJcbiBcdFx0aGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3REb3dubG9hZE1hbmlmZXN0KHJlcXVlc3RUaW1lb3V0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHRyZXF1ZXN0VGltZW91dCA9IHJlcXVlc3RUaW1lb3V0IHx8IDEwMDAwO1xyXG4gXHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuIFx0XHRcdGlmKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCA9PT0gXCJ1bmRlZmluZWRcIilcclxuIFx0XHRcdFx0cmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJObyBicm93c2VyIHN1cHBvcnRcIikpO1xyXG4gXHRcdFx0dHJ5IHtcclxuIFx0XHRcdFx0dmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuIFx0XHRcdFx0dmFyIHJlcXVlc3RQYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgXCJcIiArIGhvdEN1cnJlbnRIYXNoICsgXCIuaG90LXVwZGF0ZS5qc29uXCI7XHJcbiBcdFx0XHRcdHJlcXVlc3Qub3BlbihcIkdFVFwiLCByZXF1ZXN0UGF0aCwgdHJ1ZSk7XHJcbiBcdFx0XHRcdHJlcXVlc3QudGltZW91dCA9IHJlcXVlc3RUaW1lb3V0O1xyXG4gXHRcdFx0XHRyZXF1ZXN0LnNlbmQobnVsbCk7XHJcbiBcdFx0XHR9IGNhdGNoKGVycikge1xyXG4gXHRcdFx0XHRyZXR1cm4gcmVqZWN0KGVycik7XHJcbiBcdFx0XHR9XHJcbiBcdFx0XHRyZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xyXG4gXHRcdFx0XHRpZihyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHJldHVybjtcclxuIFx0XHRcdFx0aWYocmVxdWVzdC5zdGF0dXMgPT09IDApIHtcclxuIFx0XHRcdFx0XHQvLyB0aW1lb3V0XHJcbiBcdFx0XHRcdFx0cmVqZWN0KG5ldyBFcnJvcihcIk1hbmlmZXN0IHJlcXVlc3QgdG8gXCIgKyByZXF1ZXN0UGF0aCArIFwiIHRpbWVkIG91dC5cIikpO1xyXG4gXHRcdFx0XHR9IGVsc2UgaWYocmVxdWVzdC5zdGF0dXMgPT09IDQwNCkge1xyXG4gXHRcdFx0XHRcdC8vIG5vIHVwZGF0ZSBhdmFpbGFibGVcclxuIFx0XHRcdFx0XHRyZXNvbHZlKCk7XHJcbiBcdFx0XHRcdH0gZWxzZSBpZihyZXF1ZXN0LnN0YXR1cyAhPT0gMjAwICYmIHJlcXVlc3Quc3RhdHVzICE9PSAzMDQpIHtcclxuIFx0XHRcdFx0XHQvLyBvdGhlciBmYWlsdXJlXHJcbiBcdFx0XHRcdFx0cmVqZWN0KG5ldyBFcnJvcihcIk1hbmlmZXN0IHJlcXVlc3QgdG8gXCIgKyByZXF1ZXN0UGF0aCArIFwiIGZhaWxlZC5cIikpO1xyXG4gXHRcdFx0XHR9IGVsc2Uge1xyXG4gXHRcdFx0XHRcdC8vIHN1Y2Nlc3NcclxuIFx0XHRcdFx0XHR0cnkge1xyXG4gXHRcdFx0XHRcdFx0dmFyIHVwZGF0ZSA9IEpTT04ucGFyc2UocmVxdWVzdC5yZXNwb25zZVRleHQpO1xyXG4gXHRcdFx0XHRcdH0gY2F0Y2goZSkge1xyXG4gXHRcdFx0XHRcdFx0cmVqZWN0KGUpO1xyXG4gXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRyZXNvbHZlKHVwZGF0ZSk7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH07XHJcbiBcdFx0fSk7XHJcbiBcdH1cclxuXG4gXHRcclxuIFx0XHJcbiBcdHZhciBob3RBcHBseU9uVXBkYXRlID0gdHJ1ZTtcclxuIFx0dmFyIGhvdEN1cnJlbnRIYXNoID0gXCJhYWM0YmM3NTQzZGM3MTNkNGQ1MVwiOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdHZhciBob3RSZXF1ZXN0VGltZW91dCA9IDEwMDAwO1xyXG4gXHR2YXIgaG90Q3VycmVudE1vZHVsZURhdGEgPSB7fTtcclxuIFx0dmFyIGhvdEN1cnJlbnRDaGlsZE1vZHVsZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHR2YXIgaG90Q3VycmVudFBhcmVudHMgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHR2YXIgaG90Q3VycmVudFBhcmVudHNUZW1wID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdENyZWF0ZVJlcXVpcmUobW9kdWxlSWQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHRcdHZhciBtZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xyXG4gXHRcdGlmKCFtZSkgcmV0dXJuIF9fd2VicGFja19yZXF1aXJlX187XHJcbiBcdFx0dmFyIGZuID0gZnVuY3Rpb24ocmVxdWVzdCkge1xyXG4gXHRcdFx0aWYobWUuaG90LmFjdGl2ZSkge1xyXG4gXHRcdFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW3JlcXVlc3RdKSB7XHJcbiBcdFx0XHRcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XS5wYXJlbnRzLmluZGV4T2YobW9kdWxlSWQpIDwgMClcclxuIFx0XHRcdFx0XHRcdGluc3RhbGxlZE1vZHVsZXNbcmVxdWVzdF0ucGFyZW50cy5wdXNoKG1vZHVsZUlkKTtcclxuIFx0XHRcdFx0fSBlbHNlIHtcclxuIFx0XHRcdFx0XHRob3RDdXJyZW50UGFyZW50cyA9IFttb2R1bGVJZF07XHJcbiBcdFx0XHRcdFx0aG90Q3VycmVudENoaWxkTW9kdWxlID0gcmVxdWVzdDtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRpZihtZS5jaGlsZHJlbi5pbmRleE9mKHJlcXVlc3QpIDwgMClcclxuIFx0XHRcdFx0XHRtZS5jaGlsZHJlbi5wdXNoKHJlcXVlc3QpO1xyXG4gXHRcdFx0fSBlbHNlIHtcclxuIFx0XHRcdFx0Y29uc29sZS53YXJuKFwiW0hNUl0gdW5leHBlY3RlZCByZXF1aXJlKFwiICsgcmVxdWVzdCArIFwiKSBmcm9tIGRpc3Bvc2VkIG1vZHVsZSBcIiArIG1vZHVsZUlkKTtcclxuIFx0XHRcdFx0aG90Q3VycmVudFBhcmVudHMgPSBbXTtcclxuIFx0XHRcdH1cclxuIFx0XHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKHJlcXVlc3QpO1xyXG4gXHRcdH07XHJcbiBcdFx0dmFyIE9iamVjdEZhY3RvcnkgPSBmdW5jdGlvbiBPYmplY3RGYWN0b3J5KG5hbWUpIHtcclxuIFx0XHRcdHJldHVybiB7XHJcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuIFx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuIFx0XHRcdFx0XHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfX1tuYW1lXTtcclxuIFx0XHRcdFx0fSxcclxuIFx0XHRcdFx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gXHRcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX19bbmFtZV0gPSB2YWx1ZTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fTtcclxuIFx0XHR9O1xyXG4gXHRcdGZvcih2YXIgbmFtZSBpbiBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX193ZWJwYWNrX3JlcXVpcmVfXywgbmFtZSkgJiYgbmFtZSAhPT0gXCJlXCIpIHtcclxuIFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBuYW1lLCBPYmplY3RGYWN0b3J5KG5hbWUpKTtcclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFx0Zm4uZSA9IGZ1bmN0aW9uKGNodW5rSWQpIHtcclxuIFx0XHRcdGlmKGhvdFN0YXR1cyA9PT0gXCJyZWFkeVwiKVxyXG4gXHRcdFx0XHRob3RTZXRTdGF0dXMoXCJwcmVwYXJlXCIpO1xyXG4gXHRcdFx0aG90Q2h1bmtzTG9hZGluZysrO1xyXG4gXHRcdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18uZShjaHVua0lkKS50aGVuKGZpbmlzaENodW5rTG9hZGluZywgZnVuY3Rpb24oZXJyKSB7XHJcbiBcdFx0XHRcdGZpbmlzaENodW5rTG9hZGluZygpO1xyXG4gXHRcdFx0XHR0aHJvdyBlcnI7XHJcbiBcdFx0XHR9KTtcclxuIFx0XHJcbiBcdFx0XHRmdW5jdGlvbiBmaW5pc2hDaHVua0xvYWRpbmcoKSB7XHJcbiBcdFx0XHRcdGhvdENodW5rc0xvYWRpbmctLTtcclxuIFx0XHRcdFx0aWYoaG90U3RhdHVzID09PSBcInByZXBhcmVcIikge1xyXG4gXHRcdFx0XHRcdGlmKCFob3RXYWl0aW5nRmlsZXNNYXBbY2h1bmtJZF0pIHtcclxuIFx0XHRcdFx0XHRcdGhvdEVuc3VyZVVwZGF0ZUNodW5rKGNodW5rSWQpO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRpZihob3RDaHVua3NMb2FkaW5nID09PSAwICYmIGhvdFdhaXRpbmdGaWxlcyA9PT0gMCkge1xyXG4gXHRcdFx0XHRcdFx0aG90VXBkYXRlRG93bmxvYWRlZCgpO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcdH07XHJcbiBcdFx0cmV0dXJuIGZuO1xyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RDcmVhdGVNb2R1bGUobW9kdWxlSWQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHRcdHZhciBob3QgPSB7XHJcbiBcdFx0XHQvLyBwcml2YXRlIHN0dWZmXHJcbiBcdFx0XHRfYWNjZXB0ZWREZXBlbmRlbmNpZXM6IHt9LFxyXG4gXHRcdFx0X2RlY2xpbmVkRGVwZW5kZW5jaWVzOiB7fSxcclxuIFx0XHRcdF9zZWxmQWNjZXB0ZWQ6IGZhbHNlLFxyXG4gXHRcdFx0X3NlbGZEZWNsaW5lZDogZmFsc2UsXHJcbiBcdFx0XHRfZGlzcG9zZUhhbmRsZXJzOiBbXSxcclxuIFx0XHRcdF9tYWluOiBob3RDdXJyZW50Q2hpbGRNb2R1bGUgIT09IG1vZHVsZUlkLFxyXG4gXHRcclxuIFx0XHRcdC8vIE1vZHVsZSBBUElcclxuIFx0XHRcdGFjdGl2ZTogdHJ1ZSxcclxuIFx0XHRcdGFjY2VwdDogZnVuY3Rpb24oZGVwLCBjYWxsYmFjaykge1xyXG4gXHRcdFx0XHRpZih0eXBlb2YgZGVwID09PSBcInVuZGVmaW5lZFwiKVxyXG4gXHRcdFx0XHRcdGhvdC5fc2VsZkFjY2VwdGVkID0gdHJ1ZTtcclxuIFx0XHRcdFx0ZWxzZSBpZih0eXBlb2YgZGVwID09PSBcImZ1bmN0aW9uXCIpXHJcbiBcdFx0XHRcdFx0aG90Ll9zZWxmQWNjZXB0ZWQgPSBkZXA7XHJcbiBcdFx0XHRcdGVsc2UgaWYodHlwZW9mIGRlcCA9PT0gXCJvYmplY3RcIilcclxuIFx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgZGVwLmxlbmd0aDsgaSsrKVxyXG4gXHRcdFx0XHRcdFx0aG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1tkZXBbaV1dID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcclxuIFx0XHRcdFx0ZWxzZVxyXG4gXHRcdFx0XHRcdGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XHJcbiBcdFx0XHR9LFxyXG4gXHRcdFx0ZGVjbGluZTogZnVuY3Rpb24oZGVwKSB7XHJcbiBcdFx0XHRcdGlmKHR5cGVvZiBkZXAgPT09IFwidW5kZWZpbmVkXCIpXHJcbiBcdFx0XHRcdFx0aG90Ll9zZWxmRGVjbGluZWQgPSB0cnVlO1xyXG4gXHRcdFx0XHRlbHNlIGlmKHR5cGVvZiBkZXAgPT09IFwib2JqZWN0XCIpXHJcbiBcdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGRlcC5sZW5ndGg7IGkrKylcclxuIFx0XHRcdFx0XHRcdGhvdC5fZGVjbGluZWREZXBlbmRlbmNpZXNbZGVwW2ldXSA9IHRydWU7XHJcbiBcdFx0XHRcdGVsc2VcclxuIFx0XHRcdFx0XHRob3QuX2RlY2xpbmVkRGVwZW5kZW5jaWVzW2RlcF0gPSB0cnVlO1xyXG4gXHRcdFx0fSxcclxuIFx0XHRcdGRpc3Bvc2U6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiBcdFx0XHRcdGhvdC5fZGlzcG9zZUhhbmRsZXJzLnB1c2goY2FsbGJhY2spO1xyXG4gXHRcdFx0fSxcclxuIFx0XHRcdGFkZERpc3Bvc2VIYW5kbGVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gXHRcdFx0XHRob3QuX2Rpc3Bvc2VIYW5kbGVycy5wdXNoKGNhbGxiYWNrKTtcclxuIFx0XHRcdH0sXHJcbiBcdFx0XHRyZW1vdmVEaXNwb3NlSGFuZGxlcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuIFx0XHRcdFx0dmFyIGlkeCA9IGhvdC5fZGlzcG9zZUhhbmRsZXJzLmluZGV4T2YoY2FsbGJhY2spO1xyXG4gXHRcdFx0XHRpZihpZHggPj0gMCkgaG90Ll9kaXNwb3NlSGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XHJcbiBcdFx0XHR9LFxyXG4gXHRcclxuIFx0XHRcdC8vIE1hbmFnZW1lbnQgQVBJXHJcbiBcdFx0XHRjaGVjazogaG90Q2hlY2ssXHJcbiBcdFx0XHRhcHBseTogaG90QXBwbHksXHJcbiBcdFx0XHRzdGF0dXM6IGZ1bmN0aW9uKGwpIHtcclxuIFx0XHRcdFx0aWYoIWwpIHJldHVybiBob3RTdGF0dXM7XHJcbiBcdFx0XHRcdGhvdFN0YXR1c0hhbmRsZXJzLnB1c2gobCk7XHJcbiBcdFx0XHR9LFxyXG4gXHRcdFx0YWRkU3RhdHVzSGFuZGxlcjogZnVuY3Rpb24obCkge1xyXG4gXHRcdFx0XHRob3RTdGF0dXNIYW5kbGVycy5wdXNoKGwpO1xyXG4gXHRcdFx0fSxcclxuIFx0XHRcdHJlbW92ZVN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uKGwpIHtcclxuIFx0XHRcdFx0dmFyIGlkeCA9IGhvdFN0YXR1c0hhbmRsZXJzLmluZGV4T2YobCk7XHJcbiBcdFx0XHRcdGlmKGlkeCA+PSAwKSBob3RTdGF0dXNIYW5kbGVycy5zcGxpY2UoaWR4LCAxKTtcclxuIFx0XHRcdH0sXHJcbiBcdFxyXG4gXHRcdFx0Ly9pbmhlcml0IGZyb20gcHJldmlvdXMgZGlzcG9zZSBjYWxsXHJcbiBcdFx0XHRkYXRhOiBob3RDdXJyZW50TW9kdWxlRGF0YVttb2R1bGVJZF1cclxuIFx0XHR9O1xyXG4gXHRcdGhvdEN1cnJlbnRDaGlsZE1vZHVsZSA9IHVuZGVmaW5lZDtcclxuIFx0XHRyZXR1cm4gaG90O1xyXG4gXHR9XHJcbiBcdFxyXG4gXHR2YXIgaG90U3RhdHVzSGFuZGxlcnMgPSBbXTtcclxuIFx0dmFyIGhvdFN0YXR1cyA9IFwiaWRsZVwiO1xyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90U2V0U3RhdHVzKG5ld1N0YXR1cykge1xyXG4gXHRcdGhvdFN0YXR1cyA9IG5ld1N0YXR1cztcclxuIFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgaG90U3RhdHVzSGFuZGxlcnMubGVuZ3RoOyBpKyspXHJcbiBcdFx0XHRob3RTdGF0dXNIYW5kbGVyc1tpXS5jYWxsKG51bGwsIG5ld1N0YXR1cyk7XHJcbiBcdH1cclxuIFx0XHJcbiBcdC8vIHdoaWxlIGRvd25sb2FkaW5nXHJcbiBcdHZhciBob3RXYWl0aW5nRmlsZXMgPSAwO1xyXG4gXHR2YXIgaG90Q2h1bmtzTG9hZGluZyA9IDA7XHJcbiBcdHZhciBob3RXYWl0aW5nRmlsZXNNYXAgPSB7fTtcclxuIFx0dmFyIGhvdFJlcXVlc3RlZEZpbGVzTWFwID0ge307XHJcbiBcdHZhciBob3RBdmFpbGFibGVGaWxlc01hcCA9IHt9O1xyXG4gXHR2YXIgaG90RGVmZXJyZWQ7XHJcbiBcdFxyXG4gXHQvLyBUaGUgdXBkYXRlIGluZm9cclxuIFx0dmFyIGhvdFVwZGF0ZSwgaG90VXBkYXRlTmV3SGFzaDtcclxuIFx0XHJcbiBcdGZ1bmN0aW9uIHRvTW9kdWxlSWQoaWQpIHtcclxuIFx0XHR2YXIgaXNOdW1iZXIgPSAoK2lkKSArIFwiXCIgPT09IGlkO1xyXG4gXHRcdHJldHVybiBpc051bWJlciA/ICtpZCA6IGlkO1xyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RDaGVjayhhcHBseSkge1xyXG4gXHRcdGlmKGhvdFN0YXR1cyAhPT0gXCJpZGxlXCIpIHRocm93IG5ldyBFcnJvcihcImNoZWNrKCkgaXMgb25seSBhbGxvd2VkIGluIGlkbGUgc3RhdHVzXCIpO1xyXG4gXHRcdGhvdEFwcGx5T25VcGRhdGUgPSBhcHBseTtcclxuIFx0XHRob3RTZXRTdGF0dXMoXCJjaGVja1wiKTtcclxuIFx0XHRyZXR1cm4gaG90RG93bmxvYWRNYW5pZmVzdChob3RSZXF1ZXN0VGltZW91dCkudGhlbihmdW5jdGlvbih1cGRhdGUpIHtcclxuIFx0XHRcdGlmKCF1cGRhdGUpIHtcclxuIFx0XHRcdFx0aG90U2V0U3RhdHVzKFwiaWRsZVwiKTtcclxuIFx0XHRcdFx0cmV0dXJuIG51bGw7XHJcbiBcdFx0XHR9XHJcbiBcdFx0XHRob3RSZXF1ZXN0ZWRGaWxlc01hcCA9IHt9O1xyXG4gXHRcdFx0aG90V2FpdGluZ0ZpbGVzTWFwID0ge307XHJcbiBcdFx0XHRob3RBdmFpbGFibGVGaWxlc01hcCA9IHVwZGF0ZS5jO1xyXG4gXHRcdFx0aG90VXBkYXRlTmV3SGFzaCA9IHVwZGF0ZS5oO1xyXG4gXHRcclxuIFx0XHRcdGhvdFNldFN0YXR1cyhcInByZXBhcmVcIik7XHJcbiBcdFx0XHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gXHRcdFx0XHRob3REZWZlcnJlZCA9IHtcclxuIFx0XHRcdFx0XHRyZXNvbHZlOiByZXNvbHZlLFxyXG4gXHRcdFx0XHRcdHJlamVjdDogcmVqZWN0XHJcbiBcdFx0XHRcdH07XHJcbiBcdFx0XHR9KTtcclxuIFx0XHRcdGhvdFVwZGF0ZSA9IHt9O1xyXG4gXHRcdFx0dmFyIGNodW5rSWQgPSAwO1xyXG4gXHRcdFx0eyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWxvbmUtYmxvY2tzXHJcbiBcdFx0XHRcdC8qZ2xvYmFscyBjaHVua0lkICovXHJcbiBcdFx0XHRcdGhvdEVuc3VyZVVwZGF0ZUNodW5rKGNodW5rSWQpO1xyXG4gXHRcdFx0fVxyXG4gXHRcdFx0aWYoaG90U3RhdHVzID09PSBcInByZXBhcmVcIiAmJiBob3RDaHVua3NMb2FkaW5nID09PSAwICYmIGhvdFdhaXRpbmdGaWxlcyA9PT0gMCkge1xyXG4gXHRcdFx0XHRob3RVcGRhdGVEb3dubG9hZGVkKCk7XHJcbiBcdFx0XHR9XHJcbiBcdFx0XHRyZXR1cm4gcHJvbWlzZTtcclxuIFx0XHR9KTtcclxuIFx0fVxyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90QWRkVXBkYXRlQ2h1bmsoY2h1bmtJZCwgbW9yZU1vZHVsZXMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHRcdGlmKCFob3RBdmFpbGFibGVGaWxlc01hcFtjaHVua0lkXSB8fCAhaG90UmVxdWVzdGVkRmlsZXNNYXBbY2h1bmtJZF0pXHJcbiBcdFx0XHRyZXR1cm47XHJcbiBcdFx0aG90UmVxdWVzdGVkRmlsZXNNYXBbY2h1bmtJZF0gPSBmYWxzZTtcclxuIFx0XHRmb3IodmFyIG1vZHVsZUlkIGluIG1vcmVNb2R1bGVzKSB7XHJcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9yZU1vZHVsZXMsIG1vZHVsZUlkKSkge1xyXG4gXHRcdFx0XHRob3RVcGRhdGVbbW9kdWxlSWRdID0gbW9yZU1vZHVsZXNbbW9kdWxlSWRdO1xyXG4gXHRcdFx0fVxyXG4gXHRcdH1cclxuIFx0XHRpZigtLWhvdFdhaXRpbmdGaWxlcyA9PT0gMCAmJiBob3RDaHVua3NMb2FkaW5nID09PSAwKSB7XHJcbiBcdFx0XHRob3RVcGRhdGVEb3dubG9hZGVkKCk7XHJcbiBcdFx0fVxyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKSB7XHJcbiBcdFx0aWYoIWhvdEF2YWlsYWJsZUZpbGVzTWFwW2NodW5rSWRdKSB7XHJcbiBcdFx0XHRob3RXYWl0aW5nRmlsZXNNYXBbY2h1bmtJZF0gPSB0cnVlO1xyXG4gXHRcdH0gZWxzZSB7XHJcbiBcdFx0XHRob3RSZXF1ZXN0ZWRGaWxlc01hcFtjaHVua0lkXSA9IHRydWU7XHJcbiBcdFx0XHRob3RXYWl0aW5nRmlsZXMrKztcclxuIFx0XHRcdGhvdERvd25sb2FkVXBkYXRlQ2h1bmsoY2h1bmtJZCk7XHJcbiBcdFx0fVxyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RVcGRhdGVEb3dubG9hZGVkKCkge1xyXG4gXHRcdGhvdFNldFN0YXR1cyhcInJlYWR5XCIpO1xyXG4gXHRcdHZhciBkZWZlcnJlZCA9IGhvdERlZmVycmVkO1xyXG4gXHRcdGhvdERlZmVycmVkID0gbnVsbDtcclxuIFx0XHRpZighZGVmZXJyZWQpIHJldHVybjtcclxuIFx0XHRpZihob3RBcHBseU9uVXBkYXRlKSB7XHJcbiBcdFx0XHQvLyBXcmFwIGRlZmVycmVkIG9iamVjdCBpbiBQcm9taXNlIHRvIG1hcmsgaXQgYXMgYSB3ZWxsLWhhbmRsZWQgUHJvbWlzZSB0b1xyXG4gXHRcdFx0Ly8gYXZvaWQgdHJpZ2dlcmluZyB1bmNhdWdodCBleGNlcHRpb24gd2FybmluZyBpbiBDaHJvbWUuXHJcbiBcdFx0XHQvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDY1NjY2XHJcbiBcdFx0XHRQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xyXG4gXHRcdFx0XHRyZXR1cm4gaG90QXBwbHkoaG90QXBwbHlPblVwZGF0ZSk7XHJcbiBcdFx0XHR9KS50aGVuKFxyXG4gXHRcdFx0XHRmdW5jdGlvbihyZXN1bHQpIHtcclxuIFx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XHJcbiBcdFx0XHRcdH0sXHJcbiBcdFx0XHRcdGZ1bmN0aW9uKGVycikge1xyXG4gXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdChlcnIpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHQpO1xyXG4gXHRcdH0gZWxzZSB7XHJcbiBcdFx0XHR2YXIgb3V0ZGF0ZWRNb2R1bGVzID0gW107XHJcbiBcdFx0XHRmb3IodmFyIGlkIGluIGhvdFVwZGF0ZSkge1xyXG4gXHRcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaG90VXBkYXRlLCBpZCkpIHtcclxuIFx0XHRcdFx0XHRvdXRkYXRlZE1vZHVsZXMucHVzaCh0b01vZHVsZUlkKGlkKSk7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH1cclxuIFx0XHRcdGRlZmVycmVkLnJlc29sdmUob3V0ZGF0ZWRNb2R1bGVzKTtcclxuIFx0XHR9XHJcbiBcdH1cclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdEFwcGx5KG9wdGlvbnMpIHtcclxuIFx0XHRpZihob3RTdGF0dXMgIT09IFwicmVhZHlcIikgdGhyb3cgbmV3IEVycm9yKFwiYXBwbHkoKSBpcyBvbmx5IGFsbG93ZWQgaW4gcmVhZHkgc3RhdHVzXCIpO1xyXG4gXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gXHRcclxuIFx0XHR2YXIgY2I7XHJcbiBcdFx0dmFyIGk7XHJcbiBcdFx0dmFyIGo7XHJcbiBcdFx0dmFyIG1vZHVsZTtcclxuIFx0XHR2YXIgbW9kdWxlSWQ7XHJcbiBcdFxyXG4gXHRcdGZ1bmN0aW9uIGdldEFmZmVjdGVkU3R1ZmYodXBkYXRlTW9kdWxlSWQpIHtcclxuIFx0XHRcdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbdXBkYXRlTW9kdWxlSWRdO1xyXG4gXHRcdFx0dmFyIG91dGRhdGVkRGVwZW5kZW5jaWVzID0ge307XHJcbiBcdFxyXG4gXHRcdFx0dmFyIHF1ZXVlID0gb3V0ZGF0ZWRNb2R1bGVzLnNsaWNlKCkubWFwKGZ1bmN0aW9uKGlkKSB7XHJcbiBcdFx0XHRcdHJldHVybiB7XHJcbiBcdFx0XHRcdFx0Y2hhaW46IFtpZF0sXHJcbiBcdFx0XHRcdFx0aWQ6IGlkXHJcbiBcdFx0XHRcdH07XHJcbiBcdFx0XHR9KTtcclxuIFx0XHRcdHdoaWxlKHF1ZXVlLmxlbmd0aCA+IDApIHtcclxuIFx0XHRcdFx0dmFyIHF1ZXVlSXRlbSA9IHF1ZXVlLnBvcCgpO1xyXG4gXHRcdFx0XHR2YXIgbW9kdWxlSWQgPSBxdWV1ZUl0ZW0uaWQ7XHJcbiBcdFx0XHRcdHZhciBjaGFpbiA9IHF1ZXVlSXRlbS5jaGFpbjtcclxuIFx0XHRcdFx0bW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcbiBcdFx0XHRcdGlmKCFtb2R1bGUgfHwgbW9kdWxlLmhvdC5fc2VsZkFjY2VwdGVkKVxyXG4gXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG4gXHRcdFx0XHRpZihtb2R1bGUuaG90Ll9zZWxmRGVjbGluZWQpIHtcclxuIFx0XHRcdFx0XHRyZXR1cm4ge1xyXG4gXHRcdFx0XHRcdFx0dHlwZTogXCJzZWxmLWRlY2xpbmVkXCIsXHJcbiBcdFx0XHRcdFx0XHRjaGFpbjogY2hhaW4sXHJcbiBcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWRcclxuIFx0XHRcdFx0XHR9O1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdGlmKG1vZHVsZS5ob3QuX21haW4pIHtcclxuIFx0XHRcdFx0XHRyZXR1cm4ge1xyXG4gXHRcdFx0XHRcdFx0dHlwZTogXCJ1bmFjY2VwdGVkXCIsXHJcbiBcdFx0XHRcdFx0XHRjaGFpbjogY2hhaW4sXHJcbiBcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWRcclxuIFx0XHRcdFx0XHR9O1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtb2R1bGUucGFyZW50cy5sZW5ndGg7IGkrKykge1xyXG4gXHRcdFx0XHRcdHZhciBwYXJlbnRJZCA9IG1vZHVsZS5wYXJlbnRzW2ldO1xyXG4gXHRcdFx0XHRcdHZhciBwYXJlbnQgPSBpbnN0YWxsZWRNb2R1bGVzW3BhcmVudElkXTtcclxuIFx0XHRcdFx0XHRpZighcGFyZW50KSBjb250aW51ZTtcclxuIFx0XHRcdFx0XHRpZihwYXJlbnQuaG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pIHtcclxuIFx0XHRcdFx0XHRcdHJldHVybiB7XHJcbiBcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZGVjbGluZWRcIixcclxuIFx0XHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLmNvbmNhdChbcGFyZW50SWRdKSxcclxuIFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxyXG4gXHRcdFx0XHRcdFx0XHRwYXJlbnRJZDogcGFyZW50SWRcclxuIFx0XHRcdFx0XHRcdH07XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdGlmKG91dGRhdGVkTW9kdWxlcy5pbmRleE9mKHBhcmVudElkKSA+PSAwKSBjb250aW51ZTtcclxuIFx0XHRcdFx0XHRpZihwYXJlbnQuaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pIHtcclxuIFx0XHRcdFx0XHRcdGlmKCFvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0pXHJcbiBcdFx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXSA9IFtdO1xyXG4gXHRcdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdLCBbbW9kdWxlSWRdKTtcclxuIFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRkZWxldGUgb3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdO1xyXG4gXHRcdFx0XHRcdG91dGRhdGVkTW9kdWxlcy5wdXNoKHBhcmVudElkKTtcclxuIFx0XHRcdFx0XHRxdWV1ZS5wdXNoKHtcclxuIFx0XHRcdFx0XHRcdGNoYWluOiBjaGFpbi5jb25jYXQoW3BhcmVudElkXSksXHJcbiBcdFx0XHRcdFx0XHRpZDogcGFyZW50SWRcclxuIFx0XHRcdFx0XHR9KTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcclxuIFx0XHRcdHJldHVybiB7XHJcbiBcdFx0XHRcdHR5cGU6IFwiYWNjZXB0ZWRcIixcclxuIFx0XHRcdFx0bW9kdWxlSWQ6IHVwZGF0ZU1vZHVsZUlkLFxyXG4gXHRcdFx0XHRvdXRkYXRlZE1vZHVsZXM6IG91dGRhdGVkTW9kdWxlcyxcclxuIFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXM6IG91dGRhdGVkRGVwZW5kZW5jaWVzXHJcbiBcdFx0XHR9O1xyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0ZnVuY3Rpb24gYWRkQWxsVG9TZXQoYSwgYikge1xyXG4gXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcclxuIFx0XHRcdFx0dmFyIGl0ZW0gPSBiW2ldO1xyXG4gXHRcdFx0XHRpZihhLmluZGV4T2YoaXRlbSkgPCAwKVxyXG4gXHRcdFx0XHRcdGEucHVzaChpdGVtKTtcclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdC8vIGF0IGJlZ2luIGFsbCB1cGRhdGVzIG1vZHVsZXMgYXJlIG91dGRhdGVkXHJcbiBcdFx0Ly8gdGhlIFwib3V0ZGF0ZWRcIiBzdGF0dXMgY2FuIHByb3BhZ2F0ZSB0byBwYXJlbnRzIGlmIHRoZXkgZG9uJ3QgYWNjZXB0IHRoZSBjaGlsZHJlblxyXG4gXHRcdHZhciBvdXRkYXRlZERlcGVuZGVuY2llcyA9IHt9O1xyXG4gXHRcdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbXTtcclxuIFx0XHR2YXIgYXBwbGllZFVwZGF0ZSA9IHt9O1xyXG4gXHRcclxuIFx0XHR2YXIgd2FyblVuZXhwZWN0ZWRSZXF1aXJlID0gZnVuY3Rpb24gd2FyblVuZXhwZWN0ZWRSZXF1aXJlKCkge1xyXG4gXHRcdFx0Y29uc29sZS53YXJuKFwiW0hNUl0gdW5leHBlY3RlZCByZXF1aXJlKFwiICsgcmVzdWx0Lm1vZHVsZUlkICsgXCIpIHRvIGRpc3Bvc2VkIG1vZHVsZVwiKTtcclxuIFx0XHR9O1xyXG4gXHRcclxuIFx0XHRmb3IodmFyIGlkIGluIGhvdFVwZGF0ZSkge1xyXG4gXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhvdFVwZGF0ZSwgaWQpKSB7XHJcbiBcdFx0XHRcdG1vZHVsZUlkID0gdG9Nb2R1bGVJZChpZCk7XHJcbiBcdFx0XHRcdHZhciByZXN1bHQ7XHJcbiBcdFx0XHRcdGlmKGhvdFVwZGF0ZVtpZF0pIHtcclxuIFx0XHRcdFx0XHRyZXN1bHQgPSBnZXRBZmZlY3RlZFN0dWZmKG1vZHVsZUlkKTtcclxuIFx0XHRcdFx0fSBlbHNlIHtcclxuIFx0XHRcdFx0XHRyZXN1bHQgPSB7XHJcbiBcdFx0XHRcdFx0XHR0eXBlOiBcImRpc3Bvc2VkXCIsXHJcbiBcdFx0XHRcdFx0XHRtb2R1bGVJZDogaWRcclxuIFx0XHRcdFx0XHR9O1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdHZhciBhYm9ydEVycm9yID0gZmFsc2U7XHJcbiBcdFx0XHRcdHZhciBkb0FwcGx5ID0gZmFsc2U7XHJcbiBcdFx0XHRcdHZhciBkb0Rpc3Bvc2UgPSBmYWxzZTtcclxuIFx0XHRcdFx0dmFyIGNoYWluSW5mbyA9IFwiXCI7XHJcbiBcdFx0XHRcdGlmKHJlc3VsdC5jaGFpbikge1xyXG4gXHRcdFx0XHRcdGNoYWluSW5mbyA9IFwiXFxuVXBkYXRlIHByb3BhZ2F0aW9uOiBcIiArIHJlc3VsdC5jaGFpbi5qb2luKFwiIC0+IFwiKTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRzd2l0Y2gocmVzdWx0LnR5cGUpIHtcclxuIFx0XHRcdFx0XHRjYXNlIFwic2VsZi1kZWNsaW5lZFwiOlxyXG4gXHRcdFx0XHRcdFx0aWYob3B0aW9ucy5vbkRlY2xpbmVkKVxyXG4gXHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRGVjbGluZWQocmVzdWx0KTtcclxuIFx0XHRcdFx0XHRcdGlmKCFvcHRpb25zLmlnbm9yZURlY2xpbmVkKVxyXG4gXHRcdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFwiQWJvcnRlZCBiZWNhdXNlIG9mIHNlbGYgZGVjbGluZTogXCIgKyByZXN1bHQubW9kdWxlSWQgKyBjaGFpbkluZm8pO1xyXG4gXHRcdFx0XHRcdFx0YnJlYWs7XHJcbiBcdFx0XHRcdFx0Y2FzZSBcImRlY2xpbmVkXCI6XHJcbiBcdFx0XHRcdFx0XHRpZihvcHRpb25zLm9uRGVjbGluZWQpXHJcbiBcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25EZWNsaW5lZChyZXN1bHQpO1xyXG4gXHRcdFx0XHRcdFx0aWYoIW9wdGlvbnMuaWdub3JlRGVjbGluZWQpXHJcbiBcdFx0XHRcdFx0XHRcdGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoXCJBYm9ydGVkIGJlY2F1c2Ugb2YgZGVjbGluZWQgZGVwZW5kZW5jeTogXCIgKyByZXN1bHQubW9kdWxlSWQgKyBcIiBpbiBcIiArIHJlc3VsdC5wYXJlbnRJZCArIGNoYWluSW5mbyk7XHJcbiBcdFx0XHRcdFx0XHRicmVhaztcclxuIFx0XHRcdFx0XHRjYXNlIFwidW5hY2NlcHRlZFwiOlxyXG4gXHRcdFx0XHRcdFx0aWYob3B0aW9ucy5vblVuYWNjZXB0ZWQpXHJcbiBcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25VbmFjY2VwdGVkKHJlc3VsdCk7XHJcbiBcdFx0XHRcdFx0XHRpZighb3B0aW9ucy5pZ25vcmVVbmFjY2VwdGVkKVxyXG4gXHRcdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFwiQWJvcnRlZCBiZWNhdXNlIFwiICsgbW9kdWxlSWQgKyBcIiBpcyBub3QgYWNjZXB0ZWRcIiArIGNoYWluSW5mbyk7XHJcbiBcdFx0XHRcdFx0XHRicmVhaztcclxuIFx0XHRcdFx0XHRjYXNlIFwiYWNjZXB0ZWRcIjpcclxuIFx0XHRcdFx0XHRcdGlmKG9wdGlvbnMub25BY2NlcHRlZClcclxuIFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkFjY2VwdGVkKHJlc3VsdCk7XHJcbiBcdFx0XHRcdFx0XHRkb0FwcGx5ID0gdHJ1ZTtcclxuIFx0XHRcdFx0XHRcdGJyZWFrO1xyXG4gXHRcdFx0XHRcdGNhc2UgXCJkaXNwb3NlZFwiOlxyXG4gXHRcdFx0XHRcdFx0aWYob3B0aW9ucy5vbkRpc3Bvc2VkKVxyXG4gXHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRGlzcG9zZWQocmVzdWx0KTtcclxuIFx0XHRcdFx0XHRcdGRvRGlzcG9zZSA9IHRydWU7XHJcbiBcdFx0XHRcdFx0XHRicmVhaztcclxuIFx0XHRcdFx0XHRkZWZhdWx0OlxyXG4gXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5leGNlcHRpb24gdHlwZSBcIiArIHJlc3VsdC50eXBlKTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRpZihhYm9ydEVycm9yKSB7XHJcbiBcdFx0XHRcdFx0aG90U2V0U3RhdHVzKFwiYWJvcnRcIik7XHJcbiBcdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KGFib3J0RXJyb3IpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdGlmKGRvQXBwbHkpIHtcclxuIFx0XHRcdFx0XHRhcHBsaWVkVXBkYXRlW21vZHVsZUlkXSA9IGhvdFVwZGF0ZVttb2R1bGVJZF07XHJcbiBcdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWRNb2R1bGVzLCByZXN1bHQub3V0ZGF0ZWRNb2R1bGVzKTtcclxuIFx0XHRcdFx0XHRmb3IobW9kdWxlSWQgaW4gcmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XHJcbiBcdFx0XHRcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzLCBtb2R1bGVJZCkpIHtcclxuIFx0XHRcdFx0XHRcdFx0aWYoIW91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSlcclxuIFx0XHRcdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0gPSBbXTtcclxuIFx0XHRcdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdLCByZXN1bHQub3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKTtcclxuIFx0XHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdFx0aWYoZG9EaXNwb3NlKSB7XHJcbiBcdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWRNb2R1bGVzLCBbcmVzdWx0Lm1vZHVsZUlkXSk7XHJcbiBcdFx0XHRcdFx0YXBwbGllZFVwZGF0ZVttb2R1bGVJZF0gPSB3YXJuVW5leHBlY3RlZFJlcXVpcmU7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdC8vIFN0b3JlIHNlbGYgYWNjZXB0ZWQgb3V0ZGF0ZWQgbW9kdWxlcyB0byByZXF1aXJlIHRoZW0gbGF0ZXIgYnkgdGhlIG1vZHVsZSBzeXN0ZW1cclxuIFx0XHR2YXIgb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzID0gW107XHJcbiBcdFx0Zm9yKGkgPSAwOyBpIDwgb3V0ZGF0ZWRNb2R1bGVzLmxlbmd0aDsgaSsrKSB7XHJcbiBcdFx0XHRtb2R1bGVJZCA9IG91dGRhdGVkTW9kdWxlc1tpXTtcclxuIFx0XHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdICYmIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmhvdC5fc2VsZkFjY2VwdGVkKVxyXG4gXHRcdFx0XHRvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXMucHVzaCh7XHJcbiBcdFx0XHRcdFx0bW9kdWxlOiBtb2R1bGVJZCxcclxuIFx0XHRcdFx0XHRlcnJvckhhbmRsZXI6IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmhvdC5fc2VsZkFjY2VwdGVkXHJcbiBcdFx0XHRcdH0pO1xyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0Ly8gTm93IGluIFwiZGlzcG9zZVwiIHBoYXNlXHJcbiBcdFx0aG90U2V0U3RhdHVzKFwiZGlzcG9zZVwiKTtcclxuIFx0XHRPYmplY3Qua2V5cyhob3RBdmFpbGFibGVGaWxlc01hcCkuZm9yRWFjaChmdW5jdGlvbihjaHVua0lkKSB7XHJcbiBcdFx0XHRpZihob3RBdmFpbGFibGVGaWxlc01hcFtjaHVua0lkXSA9PT0gZmFsc2UpIHtcclxuIFx0XHRcdFx0aG90RGlzcG9zZUNodW5rKGNodW5rSWQpO1xyXG4gXHRcdFx0fVxyXG4gXHRcdH0pO1xyXG4gXHRcclxuIFx0XHR2YXIgaWR4O1xyXG4gXHRcdHZhciBxdWV1ZSA9IG91dGRhdGVkTW9kdWxlcy5zbGljZSgpO1xyXG4gXHRcdHdoaWxlKHF1ZXVlLmxlbmd0aCA+IDApIHtcclxuIFx0XHRcdG1vZHVsZUlkID0gcXVldWUucG9wKCk7XHJcbiBcdFx0XHRtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcclxuIFx0XHRcdGlmKCFtb2R1bGUpIGNvbnRpbnVlO1xyXG4gXHRcclxuIFx0XHRcdHZhciBkYXRhID0ge307XHJcbiBcdFxyXG4gXHRcdFx0Ly8gQ2FsbCBkaXNwb3NlIGhhbmRsZXJzXHJcbiBcdFx0XHR2YXIgZGlzcG9zZUhhbmRsZXJzID0gbW9kdWxlLmhvdC5fZGlzcG9zZUhhbmRsZXJzO1xyXG4gXHRcdFx0Zm9yKGogPSAwOyBqIDwgZGlzcG9zZUhhbmRsZXJzLmxlbmd0aDsgaisrKSB7XHJcbiBcdFx0XHRcdGNiID0gZGlzcG9zZUhhbmRsZXJzW2pdO1xyXG4gXHRcdFx0XHRjYihkYXRhKTtcclxuIFx0XHRcdH1cclxuIFx0XHRcdGhvdEN1cnJlbnRNb2R1bGVEYXRhW21vZHVsZUlkXSA9IGRhdGE7XHJcbiBcdFxyXG4gXHRcdFx0Ly8gZGlzYWJsZSBtb2R1bGUgKHRoaXMgZGlzYWJsZXMgcmVxdWlyZXMgZnJvbSB0aGlzIG1vZHVsZSlcclxuIFx0XHRcdG1vZHVsZS5ob3QuYWN0aXZlID0gZmFsc2U7XHJcbiBcdFxyXG4gXHRcdFx0Ly8gcmVtb3ZlIG1vZHVsZSBmcm9tIGNhY2hlXHJcbiBcdFx0XHRkZWxldGUgaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcbiBcdFxyXG4gXHRcdFx0Ly8gd2hlbiBkaXNwb3NpbmcgdGhlcmUgaXMgbm8gbmVlZCB0byBjYWxsIGRpc3Bvc2UgaGFuZGxlclxyXG4gXHRcdFx0ZGVsZXRlIG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXTtcclxuIFx0XHJcbiBcdFx0XHQvLyByZW1vdmUgXCJwYXJlbnRzXCIgcmVmZXJlbmNlcyBmcm9tIGFsbCBjaGlsZHJlblxyXG4gXHRcdFx0Zm9yKGogPSAwOyBqIDwgbW9kdWxlLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XHJcbiBcdFx0XHRcdHZhciBjaGlsZCA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlLmNoaWxkcmVuW2pdXTtcclxuIFx0XHRcdFx0aWYoIWNoaWxkKSBjb250aW51ZTtcclxuIFx0XHRcdFx0aWR4ID0gY2hpbGQucGFyZW50cy5pbmRleE9mKG1vZHVsZUlkKTtcclxuIFx0XHRcdFx0aWYoaWR4ID49IDApIHtcclxuIFx0XHRcdFx0XHRjaGlsZC5wYXJlbnRzLnNwbGljZShpZHgsIDEpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyByZW1vdmUgb3V0ZGF0ZWQgZGVwZW5kZW5jeSBmcm9tIG1vZHVsZSBjaGlsZHJlblxyXG4gXHRcdHZhciBkZXBlbmRlbmN5O1xyXG4gXHRcdHZhciBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcztcclxuIFx0XHRmb3IobW9kdWxlSWQgaW4gb3V0ZGF0ZWREZXBlbmRlbmNpZXMpIHtcclxuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvdXRkYXRlZERlcGVuZGVuY2llcywgbW9kdWxlSWQpKSB7XHJcbiBcdFx0XHRcdG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xyXG4gXHRcdFx0XHRpZihtb2R1bGUpIHtcclxuIFx0XHRcdFx0XHRtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyA9IG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXTtcclxuIFx0XHRcdFx0XHRmb3IoaiA9IDA7IGogPCBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcy5sZW5ndGg7IGorKykge1xyXG4gXHRcdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzW2pdO1xyXG4gXHRcdFx0XHRcdFx0aWR4ID0gbW9kdWxlLmNoaWxkcmVuLmluZGV4T2YoZGVwZW5kZW5jeSk7XHJcbiBcdFx0XHRcdFx0XHRpZihpZHggPj0gMCkgbW9kdWxlLmNoaWxkcmVuLnNwbGljZShpZHgsIDEpO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0Ly8gTm90IGluIFwiYXBwbHlcIiBwaGFzZVxyXG4gXHRcdGhvdFNldFN0YXR1cyhcImFwcGx5XCIpO1xyXG4gXHRcclxuIFx0XHRob3RDdXJyZW50SGFzaCA9IGhvdFVwZGF0ZU5ld0hhc2g7XHJcbiBcdFxyXG4gXHRcdC8vIGluc2VydCBuZXcgY29kZVxyXG4gXHRcdGZvcihtb2R1bGVJZCBpbiBhcHBsaWVkVXBkYXRlKSB7XHJcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXBwbGllZFVwZGF0ZSwgbW9kdWxlSWQpKSB7XHJcbiBcdFx0XHRcdG1vZHVsZXNbbW9kdWxlSWRdID0gYXBwbGllZFVwZGF0ZVttb2R1bGVJZF07XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBjYWxsIGFjY2VwdCBoYW5kbGVyc1xyXG4gXHRcdHZhciBlcnJvciA9IG51bGw7XHJcbiBcdFx0Zm9yKG1vZHVsZUlkIGluIG91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XHJcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3V0ZGF0ZWREZXBlbmRlbmNpZXMsIG1vZHVsZUlkKSkge1xyXG4gXHRcdFx0XHRtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcclxuIFx0XHRcdFx0aWYobW9kdWxlKSB7XHJcbiBcdFx0XHRcdFx0bW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSBvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF07XHJcbiBcdFx0XHRcdFx0dmFyIGNhbGxiYWNrcyA9IFtdO1xyXG4gXHRcdFx0XHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiBcdFx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXNbaV07XHJcbiBcdFx0XHRcdFx0XHRjYiA9IG1vZHVsZS5ob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW2RlcGVuZGVuY3ldO1xyXG4gXHRcdFx0XHRcdFx0aWYoY2IpIHtcclxuIFx0XHRcdFx0XHRcdFx0aWYoY2FsbGJhY2tzLmluZGV4T2YoY2IpID49IDApIGNvbnRpbnVlO1xyXG4gXHRcdFx0XHRcdFx0XHRjYWxsYmFja3MucHVzaChjYik7XHJcbiBcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdGZvcihpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gXHRcdFx0XHRcdFx0Y2IgPSBjYWxsYmFja3NbaV07XHJcbiBcdFx0XHRcdFx0XHR0cnkge1xyXG4gXHRcdFx0XHRcdFx0XHRjYihtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyk7XHJcbiBcdFx0XHRcdFx0XHR9IGNhdGNoKGVycikge1xyXG4gXHRcdFx0XHRcdFx0XHRpZihvcHRpb25zLm9uRXJyb3JlZCkge1xyXG4gXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcclxuIFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYWNjZXB0LWVycm9yZWRcIixcclxuIFx0XHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcclxuIFx0XHRcdFx0XHRcdFx0XHRcdGRlcGVuZGVuY3lJZDogbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXNbaV0sXHJcbiBcdFx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyXHJcbiBcdFx0XHRcdFx0XHRcdFx0fSk7XHJcbiBcdFx0XHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRcdFx0aWYoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xyXG4gXHRcdFx0XHRcdFx0XHRcdGlmKCFlcnJvcilcclxuIFx0XHRcdFx0XHRcdFx0XHRcdGVycm9yID0gZXJyO1xyXG4gXHRcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBMb2FkIHNlbGYgYWNjZXB0ZWQgbW9kdWxlc1xyXG4gXHRcdGZvcihpID0gMDsgaSA8IG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG4gXHRcdFx0dmFyIGl0ZW0gPSBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXNbaV07XHJcbiBcdFx0XHRtb2R1bGVJZCA9IGl0ZW0ubW9kdWxlO1xyXG4gXHRcdFx0aG90Q3VycmVudFBhcmVudHMgPSBbbW9kdWxlSWRdO1xyXG4gXHRcdFx0dHJ5IHtcclxuIFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCk7XHJcbiBcdFx0XHR9IGNhdGNoKGVycikge1xyXG4gXHRcdFx0XHRpZih0eXBlb2YgaXRlbS5lcnJvckhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gXHRcdFx0XHRcdHRyeSB7XHJcbiBcdFx0XHRcdFx0XHRpdGVtLmVycm9ySGFuZGxlcihlcnIpO1xyXG4gXHRcdFx0XHRcdH0gY2F0Y2goZXJyMikge1xyXG4gXHRcdFx0XHRcdFx0aWYob3B0aW9ucy5vbkVycm9yZWQpIHtcclxuIFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xyXG4gXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic2VsZi1hY2NlcHQtZXJyb3ItaGFuZGxlci1lcnJvcmVkXCIsXHJcbiBcdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxyXG4gXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnIyLFxyXG4gXHRcdFx0XHRcdFx0XHRcdG9yZ2luYWxFcnJvcjogZXJyLCAvLyBUT0RPIHJlbW92ZSBpbiB3ZWJwYWNrIDRcclxuIFx0XHRcdFx0XHRcdFx0XHRvcmlnaW5hbEVycm9yOiBlcnJcclxuIFx0XHRcdFx0XHRcdFx0fSk7XHJcbiBcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0XHRpZighb3B0aW9ucy5pZ25vcmVFcnJvcmVkKSB7XHJcbiBcdFx0XHRcdFx0XHRcdGlmKCFlcnJvcilcclxuIFx0XHRcdFx0XHRcdFx0XHRlcnJvciA9IGVycjI7XHJcbiBcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0XHRpZighZXJyb3IpXHJcbiBcdFx0XHRcdFx0XHRcdGVycm9yID0gZXJyO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0fSBlbHNlIHtcclxuIFx0XHRcdFx0XHRpZihvcHRpb25zLm9uRXJyb3JlZCkge1xyXG4gXHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xyXG4gXHRcdFx0XHRcdFx0XHR0eXBlOiBcInNlbGYtYWNjZXB0LWVycm9yZWRcIixcclxuIFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxyXG4gXHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyXHJcbiBcdFx0XHRcdFx0XHR9KTtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0aWYoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xyXG4gXHRcdFx0XHRcdFx0aWYoIWVycm9yKVxyXG4gXHRcdFx0XHRcdFx0XHRlcnJvciA9IGVycjtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdC8vIGhhbmRsZSBlcnJvcnMgaW4gYWNjZXB0IGhhbmRsZXJzIGFuZCBzZWxmIGFjY2VwdGVkIG1vZHVsZSBsb2FkXHJcbiBcdFx0aWYoZXJyb3IpIHtcclxuIFx0XHRcdGhvdFNldFN0YXR1cyhcImZhaWxcIik7XHJcbiBcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0aG90U2V0U3RhdHVzKFwiaWRsZVwiKTtcclxuIFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xyXG4gXHRcdFx0cmVzb2x2ZShvdXRkYXRlZE1vZHVsZXMpO1xyXG4gXHRcdH0pO1xyXG4gXHR9XHJcblxuIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aG90OiBob3RDcmVhdGVNb2R1bGUobW9kdWxlSWQpLFxuIFx0XHRcdHBhcmVudHM6IChob3RDdXJyZW50UGFyZW50c1RlbXAgPSBob3RDdXJyZW50UGFyZW50cywgaG90Q3VycmVudFBhcmVudHMgPSBbXSwgaG90Q3VycmVudFBhcmVudHNUZW1wKSxcbiBcdFx0XHRjaGlsZHJlbjogW11cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgaG90Q3JlYXRlUmVxdWlyZShtb2R1bGVJZCkpO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBfX3dlYnBhY2tfaGFzaF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmggPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhvdEN1cnJlbnRIYXNoOyB9O1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBob3RDcmVhdGVSZXF1aXJlKDEwMSkoX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMTAxKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBhYWM0YmM3NTQzZGM3MTNkNGQ1MSIsIi8vIEdMVG9vbC5qc1xuXG5pbXBvcnQgeyBtYXQ0LCBtYXQzIH0gZnJvbSAnZ2wtbWF0cml4JztcblxuaW1wb3J0IGdldEFuZEFwcGx5RXh0ZW5zaW9uIGZyb20gJy4vdXRpbHMvZ2V0QW5kQXBwbHlFeHRlbnNpb24nO1xuaW1wb3J0IGV4cG9zZUF0dHJpYnV0ZXMgZnJvbSAnLi91dGlscy9leHBvc2VBdHRyaWJ1dGVzJztcbmltcG9ydCBnZXRGbG9hdCBmcm9tICcuL3V0aWxzL2dldEZsb2F0JztcbmltcG9ydCBnZXRIYWxmRmxvYXQgZnJvbSAnLi91dGlscy9nZXRIYWxmRmxvYXQnO1xuaW1wb3J0IGdldEF0dHJpYkxvYyBmcm9tICcuL3V0aWxzL2dldEF0dHJpYkxvYyc7XG5pbXBvcnQgRXh0ZW5zaW9uc0xpc3QgZnJvbSAnLi91dGlscy9FeHRlbnNpb25zTGlzdCc7XG5cbmxldCBnbDtcblxuY2xhc3MgR0xUb29sIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLmNhbnZhcztcblx0XHR0aGlzLl92aWV3cG9ydCAgICAgICAgICAgICAgID0gWzAsIDAsIDAsIDBdO1xuXHRcdHRoaXMuX2VuYWJsZWRWZXJ0ZXhBdHRyaWJ1dGUgPSBbXTtcblx0XHR0aGlzLmlkZW50aXR5TWF0cml4ICAgICAgICAgID0gbWF0NC5jcmVhdGUoKTtcblx0XHR0aGlzLl9ub3JtYWxNYXRyaXggICAgICAgICAgID0gbWF0My5jcmVhdGUoKTtcblx0XHR0aGlzLl9pbnZlcnNlTW9kZWxWaWV3TWF0cml4ID0gbWF0My5jcmVhdGUoKTtcblx0XHR0aGlzLl9tb2RlbE1hdHJpeCAgICAgICAgICAgID0gbWF0NC5jcmVhdGUoKTtcblx0XHR0aGlzLl9tYXRyaXggICAgICAgICAgICAgICAgID0gbWF0NC5jcmVhdGUoKTtcblx0XHR0aGlzLl9tYXRyaXhTdGFja3MgXHRcdFx0ID0gW107XG5cdFx0dGhpcy5fbGFzdE1lc2hcdFx0XHRcdCA9IG51bGw7XG5cdFx0dGhpcy5fdXNlV2ViR0wyIFx0XHRcdCA9IGZhbHNlO1xuXHRcdHRoaXMuX2hhc0FycmF5SW5zdGFuY2U7XG5cdFx0dGhpcy5fZXh0QXJyYXlJbnN0YW5jZTtcblx0XHR0aGlzLl9oYXNDaGVja2VkRXh0ID0gZmFsc2U7XG5cdFx0bWF0NC5pZGVudGl0eSh0aGlzLmlkZW50aXR5TWF0cml4LCB0aGlzLmlkZW50aXR5TWF0cml4KTtcblxuXHRcdHRoaXMuaXNNb2JpbGUgPSBmYWxzZTtcblx0XHRpZigvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcblx0XHRcdHRoaXMuaXNNb2JpbGUgPSB0cnVlO1xuXHRcdH1cblx0fVxuXG5cdC8vXHRJTklUSUFMSVpFXG5cblx0aW5pdChtQ2FudmFzLCBtUGFyYW1ldGVycyA9IHt9KSB7XG5cblx0XHRpZihtQ2FudmFzID09PSBudWxsIHx8IG1DYW52YXMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y29uc29sZS5lcnJvcignQ2FudmFzIG5vdCBleGlzdCcpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRcblx0XHRpZih0aGlzLmNhbnZhcyAhPT0gdW5kZWZpbmVkICYmIHRoaXMuY2FudmFzICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLmRlc3Ryb3koKTtcblx0XHR9XG5cdFx0XG5cdFx0dGhpcy5jYW52YXMgPSBtQ2FudmFzO1xuXHRcdHRoaXMuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcblxuXHRcdG1QYXJhbWV0ZXJzLnVzZVdlYmdsMiA9IG1QYXJhbWV0ZXJzLnVzZVdlYmdsMiB8fCBmYWxzZTtcblxuXHRcdGxldCBjdHg7XG5cdFx0aWYobVBhcmFtZXRlcnMudXNlV2ViZ2wyKSB7XG5cdFx0XHRjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wyJywgbVBhcmFtZXRlcnMpIHx8IHRoaXMuY2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicsIG1QYXJhbWV0ZXJzKTtcblxuXHRcdFx0aWYoIWN0eCkge1xuXHRcdFx0XHRjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIG1QYXJhbWV0ZXJzKSB8fCB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBtUGFyYW1ldGVycyk7XHRcblx0XHRcdFx0dGhpcy5fdXNlV2ViR0wyID0gZmFsc2U7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl91c2VXZWJHTDIgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbDInLCBtUGFyYW1ldGVycykgfHwgdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJywgbVBhcmFtZXRlcnMpO1xuXHRcdFx0Ly8gaWYoY3R4KSB7XG5cdFx0XHQvLyBcdHRoaXMuX3VzZVdlYkdMMiA9IHRydWU7XG5cdFx0XHQvLyB9IGVsc2Uge1xuXHRcdFx0Ly8gXHRjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIG1QYXJhbWV0ZXJzKSB8fCB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBtUGFyYW1ldGVycyk7XG5cdFx0XHQvLyB9XG5cblx0XHRcdGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgbVBhcmFtZXRlcnMpIHx8IHRoaXMuY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIG1QYXJhbWV0ZXJzKTtcdFxuXHRcdFx0dGhpcy5fdXNlV2ViR0wyID0gZmFsc2U7XG5cdFx0XHRcblx0XHR9XG5cblx0XHRjb25zb2xlLmxvZygnVXNpbmcgV2ViR0wgMiA/JywgdGhpcy53ZWJnbDIpO1xuXG5cdFx0Ly9cdGV4dGVuc2lvbnNcblx0XHR0aGlzLmluaXRXaXRoR0woY3R4KTtcblx0fVxuXG5cdGluaXRXaXRoR0woY3R4KSB7XG5cdFx0aWYoIXRoaXMuY2FudmFzKSB7XHR0aGlzLmNhbnZhcyA9IGN0eC5jYW52YXM7XHR9XG5cdFx0Z2wgPSB0aGlzLmdsID0gY3R4O1xuXG5cdFx0dGhpcy5leHRlbnNpb25zID0ge307XG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IEV4dGVuc2lvbnNMaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0aGlzLmV4dGVuc2lvbnNbRXh0ZW5zaW9uc0xpc3RbaV1dID0gZ2wuZ2V0RXh0ZW5zaW9uKEV4dGVuc2lvbnNMaXN0W2ldKTtcblx0XHR9XG5cdFx0XG5cdFx0Ly9cdENvcHkgZ2wgQXR0cmlidXRlc1xuXHRcdGV4cG9zZUF0dHJpYnV0ZXMoKTtcblx0XHRnZXRBbmRBcHBseUV4dGVuc2lvbihnbCwgJ09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0Jyk7XG5cdFx0Z2V0QW5kQXBwbHlFeHRlbnNpb24oZ2wsICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyk7XG5cdFx0Z2V0QW5kQXBwbHlFeHRlbnNpb24oZ2wsICdXRUJHTF9kcmF3X2J1ZmZlcnMnKTtcblx0XHRcblx0XHR0aGlzLmVuYWJsZSh0aGlzLkRFUFRIX1RFU1QpO1xuXHRcdHRoaXMuZW5hYmxlKHRoaXMuQ1VMTF9GQUNFKTtcblx0XHR0aGlzLmVuYWJsZSh0aGlzLkJMRU5EKTtcblx0XHR0aGlzLmVuYWJsZUFscGhhQmxlbmRpbmcoKTtcblx0fSBcblxuXG5cblx0Ly9cdFBVQkxJQyBNRVRIT0RTXG5cblx0c2V0Vmlld3BvcnQoeCwgeSwgdywgaCkge1xuXHRcdGxldCBoYXNDaGFuZ2VkID0gZmFsc2U7XG5cdFx0aWYoeCAhPT0gdGhpcy5fdmlld3BvcnRbMF0pIHsgaGFzQ2hhbmdlZCA9IHRydWU7IH1cblx0XHRpZih5ICE9PSB0aGlzLl92aWV3cG9ydFsxXSkgeyBoYXNDaGFuZ2VkID0gdHJ1ZTsgfVxuXHRcdGlmKHcgIT09IHRoaXMuX3ZpZXdwb3J0WzJdKSB7IGhhc0NoYW5nZWQgPSB0cnVlOyB9XG5cdFx0aWYoaCAhPT0gdGhpcy5fdmlld3BvcnRbM10pIHsgaGFzQ2hhbmdlZCA9IHRydWU7IH1cblxuXHRcdGlmKGhhc0NoYW5nZWQpIHtcblx0XHRcdGdsLnZpZXdwb3J0KHgsIHksIHcsIGgpO1xuXHRcdFx0dGhpcy5fdmlld3BvcnQgPSBbeCwgeSwgdywgaF07XG5cdFx0fVxuXHR9XG5cblx0c2Npc3Nvcih4LCB5LCB3LCBoKSB7XG5cdFx0Z2wuc2Npc3Nvcih4LCB5LCB3LCBoKTtcblx0fVxuXG5cblx0Y2xlYXIociwgZywgYiwgYSkge1xuXHRcdGdsLmNsZWFyQ29sb3IociwgZywgYiwgYSk7XG5cdFx0Z2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xuXHR9XG5cblxuXHRjdWxsRmFjZShtVmFsdWUpIHtcblx0XHRnbC5jdWxsRmFjZShtVmFsdWUpO1xuXHR9XG5cblxuXHRzZXRNYXRyaWNlcyhtQ2FtZXJhKSB7XG5cdFx0dGhpcy5jYW1lcmEgPSBtQ2FtZXJhO1xuXHRcdHRoaXMucm90YXRlKHRoaXMuaWRlbnRpdHlNYXRyaXgpO1xuXHR9XG5cblxuXHR1c2VTaGFkZXIobVNoYWRlcikge1xuXHRcdHRoaXMuc2hhZGVyID0gbVNoYWRlcjtcblx0XHR0aGlzLnNoYWRlclByb2dyYW0gPSB0aGlzLnNoYWRlci5zaGFkZXJQcm9ncmFtO1xuXHR9XG5cblxuXHRyb3RhdGUobVJvdGF0aW9uKSB7XG5cdFx0bWF0NC5jb3B5KHRoaXMuX21vZGVsTWF0cml4LCBtUm90YXRpb24pO1xuXHRcdG1hdDQubXVsdGlwbHkodGhpcy5fbWF0cml4LCB0aGlzLmNhbWVyYS5tYXRyaXgsIHRoaXMuX21vZGVsTWF0cml4KTtcblx0XHRtYXQzLmZyb21NYXQ0KHRoaXMuX25vcm1hbE1hdHJpeCwgdGhpcy5fbWF0cml4KTtcblx0XHRtYXQzLmludmVydCh0aGlzLl9ub3JtYWxNYXRyaXgsIHRoaXMuX25vcm1hbE1hdHJpeCk7XG5cdFx0bWF0My50cmFuc3Bvc2UodGhpcy5fbm9ybWFsTWF0cml4LCB0aGlzLl9ub3JtYWxNYXRyaXgpO1xuXHRcdFxuXG5cdFx0bWF0My5mcm9tTWF0NCh0aGlzLl9pbnZlcnNlTW9kZWxWaWV3TWF0cml4LCB0aGlzLl9tYXRyaXgpO1xuXHRcdG1hdDMuaW52ZXJ0KHRoaXMuX2ludmVyc2VNb2RlbFZpZXdNYXRyaXgsIHRoaXMuX2ludmVyc2VNb2RlbFZpZXdNYXRyaXgpO1xuXHR9XG5cblxuXHRkcmF3KG1NZXNoLCBtRHJhd2luZ1R5cGUpIHtcblx0XHRpZihtTWVzaC5sZW5ndGgpIHtcblx0XHRcdGZvcihsZXQgaSA9IDA7IGkgPCBtTWVzaC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLmRyYXcobU1lc2hbaV0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG1NZXNoLmJpbmQodGhpcy5zaGFkZXJQcm9ncmFtKTtcblxuXHRcdC8vXHRERUZBVUxUIFVOSUZPUk1TXG5cdFx0aWYodGhpcy5jYW1lcmEgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgndVByb2plY3Rpb25NYXRyaXgnLCAnbWF0NCcsIHRoaXMuY2FtZXJhLnByb2plY3Rpb24pO1x0XG5cdFx0XHR0aGlzLnNoYWRlci51bmlmb3JtKCd1Vmlld01hdHJpeCcsICdtYXQ0JywgdGhpcy5jYW1lcmEubWF0cml4KTtcblx0XHR9XG5cdFx0XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgndU1vZGVsTWF0cml4JywgJ21hdDQnLCB0aGlzLl9tb2RlbE1hdHJpeCk7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgndU5vcm1hbE1hdHJpeCcsICdtYXQzJywgdGhpcy5fbm9ybWFsTWF0cml4KTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKCd1TW9kZWxWaWV3TWF0cml4SW52ZXJzZScsICdtYXQzJywgdGhpcy5faW52ZXJzZU1vZGVsVmlld01hdHJpeCk7XG5cblx0XHRsZXQgZHJhd1R5cGUgPSBtTWVzaC5kcmF3VHlwZTtcblx0XHRpZihtRHJhd2luZ1R5cGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0ZHJhd1R5cGUgPSBtRHJhd2luZ1R5cGU7XG5cdFx0fVxuXG5cdFx0aWYobU1lc2guaXNJbnN0YW5jZWQpIHtcblx0XHRcdC8vXHREUkFXSU5HXG5cdFx0XHRnbC5kcmF3RWxlbWVudHNJbnN0YW5jZWQobU1lc2guZHJhd1R5cGUsIG1NZXNoLmlCdWZmZXIubnVtSXRlbXMsIGdsLlVOU0lHTkVEX1NIT1JULCAwLCBtTWVzaC5udW1JbnN0YW5jZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmKGRyYXdUeXBlID09PSBnbC5QT0lOVFMpIHtcblx0XHRcdFx0Z2wuZHJhd0FycmF5cyhkcmF3VHlwZSwgMCwgbU1lc2gudmVydGV4U2l6ZSk7XHRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGdsLmRyYXdFbGVtZW50cyhkcmF3VHlwZSwgbU1lc2guaUJ1ZmZlci5udW1JdGVtcywgZ2wuVU5TSUdORURfU0hPUlQsIDApO1x0XG5cdFx0XHR9XHRcblx0XHR9XG5cblx0XHRtTWVzaC51bmJpbmQoKTtcblx0fVxuXG5cblx0ZHJhd1RyYW5zZm9ybUZlZWRiYWNrKG1UcmFuc2Zvcm1PYmplY3QpIHtcblxuXHRcdGNvbnN0IHsgbWVzaFNvdXJjZSwgbWVzaERlc3RpbmF0aW9uLCBudW1Qb2ludHMsIHRyYW5zZm9ybUZlZWRiYWNrIH0gPSBtVHJhbnNmb3JtT2JqZWN0O1xuXHRcdFxuXHRcdC8vXHRCSU5EIFNPVVJDRSBCVUZGRVJTIC0+IHNldHVwVmVydGV4QXR0cihzb3VyY2VWQU8pXG5cdFx0bWVzaFNvdXJjZS5iaW5kKHRoaXMuc2hhZGVyUHJvZ3JhbSk7XG5cdFx0bWVzaERlc3RpbmF0aW9uLmdlbmVyYXRlQnVmZmVycyh0aGlzLnNoYWRlclByb2dyYW0pO1xuXG5cdFx0Ly9cdEJJTkQgREVTVElOQVRJT04gQlVGRkVSU1xuXHRcdGdsLmJpbmRUcmFuc2Zvcm1GZWVkYmFjayhnbC5UUkFOU0ZPUk1fRkVFREJBQ0ssIHRyYW5zZm9ybUZlZWRiYWNrKTtcblxuXHRcdG1lc2hEZXN0aW5hdGlvbi5hdHRyaWJ1dGVzLmZvckVhY2goKGF0dHIsIGkpPT4ge1xuXHRcdFx0Z2wuYmluZEJ1ZmZlckJhc2UoZ2wuVFJBTlNGT1JNX0ZFRURCQUNLX0JVRkZFUiwgaSwgYXR0ci5idWZmZXIpO1xuXHRcdH0pO1xuXG5cdFx0Z2wuZW5hYmxlKGdsLlJBU1RFUklaRVJfRElTQ0FSRCk7XG5cblx0XHRnbC5iZWdpblRyYW5zZm9ybUZlZWRiYWNrKGdsLlBPSU5UUyk7XG5cdFx0Z2wuZHJhd0FycmF5cyhnbC5QT0lOVFMsIDAsIG51bVBvaW50cyk7XG5cdFx0Z2wuZW5kVHJhbnNmb3JtRmVlZGJhY2soKTtcdFxuXHRcdFxuXG5cdFx0Ly9cdHJlc2V0IHN0YXRlXG5cdFx0Z2wuZGlzYWJsZShnbC5SQVNURVJJWkVSX0RJU0NBUkQpO1xuXHRcdGdsLnVzZVByb2dyYW0obnVsbCk7XG5cdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpO1xuXHRcdG1lc2hEZXN0aW5hdGlvbi5hdHRyaWJ1dGVzLmZvckVhY2goKGF0dHIsIGkpPT4ge1xuXHRcdFx0Z2wuYmluZEJ1ZmZlckJhc2UoZ2wuVFJBTlNGT1JNX0ZFRURCQUNLX0JVRkZFUiwgaSwgbnVsbCk7XG5cdFx0fSk7XG5cdFx0Z2wuYmluZFRyYW5zZm9ybUZlZWRiYWNrKGdsLlRSQU5TRk9STV9GRUVEQkFDSywgbnVsbCk7XG5cblx0XHRtZXNoU291cmNlLnVuYmluZCgpO1xuXHR9XG5cblxuXHRzZXRTaXplKG1XaWR0aCwgbUhlaWdodCkge1xuXHRcdHRoaXMuX3dpZHRoICAgICAgICA9IG1XaWR0aDtcblx0XHR0aGlzLl9oZWlnaHQgICAgICAgPSBtSGVpZ2h0O1xuXHRcdHRoaXMuY2FudmFzLndpZHRoICA9IHRoaXMuX3dpZHRoO1xuXHRcdHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuX2hlaWdodDtcblx0XHR0aGlzLl9hc3BlY3RSYXRpbyAgPSB0aGlzLl93aWR0aCAvIHRoaXMuX2hlaWdodDtcblxuXHRcdGlmKGdsKSB7XG5cdFx0XHR0aGlzLnZpZXdwb3J0KDAsIDAsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1x0XG5cdFx0fVxuXHR9XG5cblxuXHRzaG93RXh0ZW5zaW9ucygpIHtcblx0XHRjb25zb2xlLmxvZygnRXh0ZW5zaW9ucyA6ICcsIHRoaXMuZXh0ZW5zaW9ucyk7XG5cdFx0Zm9yKGNvbnN0IGV4dCBpbiB0aGlzLmV4dGVuc2lvbnMpIHtcblx0XHRcdGlmKHRoaXMuZXh0ZW5zaW9uc1tleHRdKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGV4dCwgJzonLCB0aGlzLmV4dGVuc2lvbnNbZXh0XSk7XHRcblx0XHRcdH1cblx0XHR9XHRcblx0fVxuXG5cdGNoZWNrRXh0ZW5zaW9uKG1FeHRlbnNpb24pIHtcblx0XHRyZXR1cm4gISF0aGlzLmV4dGVuc2lvbnNbbUV4dGVuc2lvbl07XG5cdH1cblxuXG5cdGdldEV4dGVuc2lvbihtRXh0ZW5zaW9uKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9uc1ttRXh0ZW5zaW9uXTtcblx0fVxuXG5cdC8vXHRCTEVORCBNT0RFU1xuXG5cdGVuYWJsZUFscGhhQmxlbmRpbmcoKSB7XG5cdFx0Z2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XHRcblx0fVxuXG5cdGVuYWJsZUFkZGl0aXZlQmxlbmRpbmcoKSB7XG5cdFx0Z2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FKTtcblx0fVxuXG5cdC8vXHRtYXRyaWNlc1xuXG5cdHB1c2hNYXRyaXgoKSB7XG5cdFx0Y29uc3QgbXR4ID0gbWF0NC5jbG9uZSh0aGlzLl9tb2RlbE1hdHJpeCk7XG5cdFx0dGhpcy5fbWF0cml4U3RhY2tzLnB1c2gobXR4KTtcblx0fVxuXG5cblx0cG9wTWF0cml4KCkge1xuXHRcdGlmKHRoaXMuX21hdHJpeFN0YWNrcy5sZW5ndGggPT0gMCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdGNvbnN0IG10eCA9IHRoaXMuX21hdHJpeFN0YWNrcy5wb3AoKTtcblx0XHR0aGlzLnJvdGF0ZShtdHgpO1xuXHR9XG5cblxuXHQvL1x0R0wgTkFUSVZFIEZVTkNUSU9OU1xuXG5cdGVuYWJsZShtUGFyYW1ldGVyKSB7XHRnbC5lbmFibGUobVBhcmFtZXRlcik7XHRcdH1cblxuXHRkaXNhYmxlKG1QYXJhbWV0ZXIpIHtcdGdsLmRpc2FibGUobVBhcmFtZXRlcik7XHR9XG5cblx0dmlld3BvcnQoeCwgeSwgdywgaCkge1x0dGhpcy5zZXRWaWV3cG9ydCh4LCB5LCB3LCBoKTtcdH1cblxuXG5cdC8vXHRHRVRURVIgQU5EIFNFVFRFUlNcblxuXHRnZXQgRkxPQVQoKSB7IHJldHVybiBnZXRGbG9hdCgpOyB9XG5cdFxuXHRnZXQgSEFMRl9GTE9BVCgpIHsgcmV0dXJuIGdldEhhbGZGbG9hdCgpOyB9XG5cblx0Z2V0IHdpZHRoKCkge1x0cmV0dXJuIHRoaXMuX3dpZHRoO1x0XHR9XG5cblx0Z2V0IGhlaWdodCgpIHtcdHJldHVybiB0aGlzLl9oZWlnaHQ7XHR9XG5cblx0Z2V0IGFzcGVjdFJhdGlvKCkge1x0cmV0dXJuIHRoaXMuX2FzcGVjdFJhdGlvO1x0fVxuXG5cdGdldCB3ZWJnbDIoKSB7XHRyZXR1cm4gdGhpcy5fdXNlV2ViR0wyO1x0fVxuXG5cdC8vXHRERVNUUk9ZXG5cblx0ZGVzdHJveSgpIHtcblx0XHRcblx0XHRpZih0aGlzLmNhbnZhcy5wYXJlbnROb2RlKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR0aGlzLmNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY2FudmFzKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ0Vycm9yIDogJywgZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5jYW52YXMgPSBudWxsO1xuXHR9XG59XG5cbmNvbnN0IEdMID0gbmV3IEdMVG9vbCgpO1xuXG5leHBvcnQgZGVmYXVsdCBHTDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL0dMVG9vbC5qcyIsIi8qKlxuICogQGZpbGVvdmVydmlldyBnbC1tYXRyaXggLSBIaWdoIHBlcmZvcm1hbmNlIG1hdHJpeCBhbmQgdmVjdG9yIG9wZXJhdGlvbnNcbiAqIEBhdXRob3IgQnJhbmRvbiBKb25lc1xuICogQGF1dGhvciBDb2xpbiBNYWNLZW56aWUgSVZcbiAqIEB2ZXJzaW9uIDIuNC4wXG4gKi9cblxuLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cbi8vIEVORCBIRUFERVJcblxuaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vZ2wtbWF0cml4L2NvbW1vblwiO1xuaW1wb3J0ICogYXMgbWF0MiBmcm9tIFwiLi9nbC1tYXRyaXgvbWF0MlwiO1xuaW1wb3J0ICogYXMgbWF0MmQgZnJvbSBcIi4vZ2wtbWF0cml4L21hdDJkXCI7XG5pbXBvcnQgKiBhcyBtYXQzIGZyb20gXCIuL2dsLW1hdHJpeC9tYXQzXCI7XG5pbXBvcnQgKiBhcyBtYXQ0IGZyb20gXCIuL2dsLW1hdHJpeC9tYXQ0XCI7XG5pbXBvcnQgKiBhcyBxdWF0IGZyb20gXCIuL2dsLW1hdHJpeC9xdWF0XCI7XG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gXCIuL2dsLW1hdHJpeC92ZWMyXCI7XG5pbXBvcnQgKiBhcyB2ZWMzIGZyb20gXCIuL2dsLW1hdHJpeC92ZWMzXCI7XG5pbXBvcnQgKiBhcyB2ZWM0IGZyb20gXCIuL2dsLW1hdHJpeC92ZWM0XCI7XG5cbmV4cG9ydCB7XG4gIGdsTWF0cml4LFxuICBtYXQyLCBtYXQyZCwgbWF0MywgbWF0NCxcbiAgcXVhdCxcbiAgdmVjMiwgdmVjMywgdmVjNCxcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXguanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBHTFNoYWRlci5qc1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBHTCBmcm9tICcuL0dMVG9vbCc7XG5jb25zdCBnbHNsaWZ5ID0gcmVxdWlyZSgnZ2xzbGlmeScpO1xuY29uc3QgaXNTYW1lID0gKGFycmF5MSwgYXJyYXkyKSA9PiB7XG5cdGlmKGFycmF5MS5sZW5ndGggIT09IGFycmF5Mi5sZW5ndGgpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRmb3IobGV0IGkgPSAwOyBpIDwgYXJyYXkxLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYoYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGFkZExpbmVOdW1iZXJzID0gKHN0cmluZykgPT4ge1xuXHRjb25zdCBsaW5lcyA9IHN0cmluZy5zcGxpdCgnXFxuJyk7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICsrKSB7XG5cdFx0bGluZXNbaV0gPSBgJHsoaSArIDEpfTogJHtsaW5lc1tpXX1gO1xuXHR9XG5cdHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcbn07XG5cblxuY29uc3QgY2xvbmVBcnJheSA9IChtQXJyYXkpID0+IHtcblx0aWYobUFycmF5LnNsaWNlKSB7XG5cdFx0cmV0dXJuIG1BcnJheS5zbGljZSgwKTsgXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkobUFycmF5KTtcblx0fVxufTtcblxubGV0IGdsO1xuY29uc3QgZGVmYXVsdFZlcnRleFNoYWRlciA9IHJlcXVpcmUoJy4vc2hhZGVycy9iYXNpYy52ZXJ0Jyk7XG5jb25zdCBkZWZhdWx0RnJhZ21lbnRTaGFkZXIgPSByZXF1aXJlKCcuL3NoYWRlcnMvYmFzaWMuZnJhZycpO1xuXG5jb25zdCB1bmlmb3JtTWFwcGluZyA9IHtcblx0ZmxvYXQ6ICd1bmlmb3JtMWYnLFxuXHR2ZWMyOiAndW5pZm9ybTJmdicsXG5cdHZlYzM6ICd1bmlmb3JtM2Z2Jyxcblx0dmVjNDogJ3VuaWZvcm00ZnYnLFxuXHRpbnQ6ICd1bmlmb3JtMWknLFxuXHRtYXQzOiAndW5pZm9ybU1hdHJpeDNmdicsXG5cdG1hdDQ6ICd1bmlmb3JtTWF0cml4NGZ2J1xufTtcblxuY2xhc3MgR0xTaGFkZXIge1xuXHRjb25zdHJ1Y3RvcihzdHJWZXJ0ZXhTaGFkZXIgPSBkZWZhdWx0VmVydGV4U2hhZGVyLCBzdHJGcmFnbWVudFNoYWRlciA9IGRlZmF1bHRGcmFnbWVudFNoYWRlciwgbVZhcnlpbmdzKSB7XG5cblx0XHRnbCAgICAgICAgICAgICAgICAgICA9IEdMLmdsO1xuXHRcdHRoaXMucGFyYW1ldGVycyAgICAgID0gW107XG5cdFx0dGhpcy51bmlmb3JtVGV4dHVyZXMgPSBbXTtcblx0XHR0aGlzLl92YXJ5aW5ncyBcdFx0ID0gbVZhcnlpbmdzO1xuXG5cdFx0aWYoIXN0clZlcnRleFNoYWRlcikgeyBzdHJWZXJ0ZXhTaGFkZXIgPSBkZWZhdWx0VmVydGV4U2hhZGVyOyB9XG5cdFx0aWYoIXN0ckZyYWdtZW50U2hhZGVyKSB7IHN0ckZyYWdtZW50U2hhZGVyID0gZGVmYXVsdFZlcnRleFNoYWRlcjsgfVxuXG5cdFx0Y29uc3QgdnNTaGFkZXIgPSB0aGlzLl9jcmVhdGVTaGFkZXJQcm9ncmFtKHN0clZlcnRleFNoYWRlciwgdHJ1ZSk7XG5cdFx0Y29uc3QgZnNTaGFkZXIgPSB0aGlzLl9jcmVhdGVTaGFkZXJQcm9ncmFtKHN0ckZyYWdtZW50U2hhZGVyLCBmYWxzZSk7XG5cdFx0dGhpcy5fYXR0YWNoU2hhZGVyUHJvZ3JhbSh2c1NoYWRlciwgZnNTaGFkZXIpO1xuXG5cdH1cblxuXG5cdGJpbmQoKSB7XG5cblx0XHRpZihHTC5zaGFkZXIgPT09IHRoaXMpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Z2wudXNlUHJvZ3JhbSh0aGlzLnNoYWRlclByb2dyYW0pO1xuXHRcdEdMLnVzZVNoYWRlcih0aGlzKTtcblx0XHR0aGlzLnVuaWZvcm1UZXh0dXJlcyA9IFtdO1xuXG5cdH1cblxuXG5cdHVuaWZvcm0obU5hbWUsIG1UeXBlLCBtVmFsdWUpIHtcblx0XHRpZih0eXBlb2YgbU5hbWUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHR0aGlzLnVuaWZvcm1PYmplY3QobU5hbWUpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHQvKlxuXHRcdGlmKCEhbVZhbHVlID09PSB1bmRlZmluZWQgfHwgbVZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ21WYWx1ZSBFcnJvcjonLCBtTmFtZSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHQqL1xuXHRcdGNvbnN0IHVuaWZvcm1UeXBlID0gdW5pZm9ybU1hcHBpbmdbbVR5cGVdIHx8IG1UeXBlO1xuXHRcdFxuXHRcdGxldCBoYXNVbmlmb3JtID0gZmFsc2U7XG5cdFx0bGV0IG9Vbmlmb3JtO1xuXHRcdGxldCBwYXJhbWV0ZXJJbmRleCA9IC0xO1xuXG5cblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRvVW5pZm9ybSA9IHRoaXMucGFyYW1ldGVyc1tpXTtcblx0XHRcdGlmKG9Vbmlmb3JtLm5hbWUgPT09IG1OYW1lKSB7XG5cdFx0XHRcdGhhc1VuaWZvcm0gPSB0cnVlO1xuXHRcdFx0XHRwYXJhbWV0ZXJJbmRleCA9IGk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGxldCBpc051bWJlciA9IGZhbHNlO1xuXG5cdFx0aWYoIWhhc1VuaWZvcm0pIHtcblx0XHRcdGlzTnVtYmVyID0gdW5pZm9ybVR5cGUgPT09ICd1bmlmb3JtMWknIHx8IHVuaWZvcm1UeXBlID09PSAndW5pZm9ybTFmJztcblx0XHRcdHRoaXMuc2hhZGVyUHJvZ3JhbVttTmFtZV0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5zaGFkZXJQcm9ncmFtLCBtTmFtZSk7XG5cdFx0XHRpZihpc051bWJlcikge1xuXHRcdFx0XHR0aGlzLnBhcmFtZXRlcnMucHVzaCh7IG5hbWUgOiBtTmFtZSwgdHlwZTogdW5pZm9ybVR5cGUsIHZhbHVlOiBtVmFsdWUsIHVuaWZvcm1Mb2M6IHRoaXMuc2hhZGVyUHJvZ3JhbVttTmFtZV0sIGlzTnVtYmVyIH0pO1x0XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnBhcmFtZXRlcnMucHVzaCh7IG5hbWUgOiBtTmFtZSwgdHlwZTogdW5pZm9ybVR5cGUsIHZhbHVlOiBjbG9uZUFycmF5KG1WYWx1ZSksIHVuaWZvcm1Mb2M6IHRoaXMuc2hhZGVyUHJvZ3JhbVttTmFtZV0sIGlzTnVtYmVyIH0pO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRwYXJhbWV0ZXJJbmRleCA9IHRoaXMucGFyYW1ldGVycy5sZW5ndGggLSAxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNoYWRlclByb2dyYW1bbU5hbWVdID0gb1VuaWZvcm0udW5pZm9ybUxvYztcblx0XHRcdGlzTnVtYmVyID0gb1VuaWZvcm0uaXNOdW1iZXI7XG5cdFx0fVxuXG5cblx0XHRpZighdGhpcy5wYXJhbWV0ZXJzW3BhcmFtZXRlckluZGV4XS51bmlmb3JtTG9jKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cblx0XHRpZih1bmlmb3JtVHlwZS5pbmRleE9mKCdNYXRyaXgnKSA9PT0gLTEpIHtcblx0XHRcdGlmKCFpc051bWJlcikge1xuXHRcdFx0XHRpZighaXNTYW1lKHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJJbmRleF0udmFsdWUsIG1WYWx1ZSkgfHwgIWhhc1VuaWZvcm0pIHtcblx0XHRcdFx0XHRnbFt1bmlmb3JtVHlwZV0odGhpcy5zaGFkZXJQcm9ncmFtW21OYW1lXSwgbVZhbHVlKTtcdFxuXHRcdFx0XHRcdHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJJbmRleF0udmFsdWUgPSBjbG9uZUFycmF5KG1WYWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnN0IG5lZWRVcGRhdGUgPSAodGhpcy5wYXJhbWV0ZXJzW3BhcmFtZXRlckluZGV4XS52YWx1ZSAhPT0gbVZhbHVlIHx8ICFoYXNVbmlmb3JtKTtcblx0XHRcdFx0aWYobmVlZFVwZGF0ZSkge1xuXHRcdFx0XHRcdGdsW3VuaWZvcm1UeXBlXSh0aGlzLnNoYWRlclByb2dyYW1bbU5hbWVdLCBtVmFsdWUpO1x0XG5cdFx0XHRcdFx0dGhpcy5wYXJhbWV0ZXJzW3BhcmFtZXRlckluZGV4XS52YWx1ZSA9IG1WYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmKCFpc1NhbWUodGhpcy5wYXJhbWV0ZXJzW3BhcmFtZXRlckluZGV4XS52YWx1ZSwgbVZhbHVlKSB8fCAhaGFzVW5pZm9ybSkge1xuXHRcdFx0XHRnbFt1bmlmb3JtVHlwZV0odGhpcy5zaGFkZXJQcm9ncmFtW21OYW1lXSwgZmFsc2UsIG1WYWx1ZSk7XHRcblx0XHRcdFx0dGhpcy5wYXJhbWV0ZXJzW3BhcmFtZXRlckluZGV4XS52YWx1ZSA9IGNsb25lQXJyYXkobVZhbHVlKTtcblxuXHRcdFx0fVxuXHRcdH1cblxuXHR9XG5cblx0dW5pZm9ybU9iamVjdChtVW5pZm9ybU9iaikge1xuXHRcdGZvcihjb25zdCB1bmlmb3JtTmFtZSBpbiBtVW5pZm9ybU9iaikge1xuXHRcdFx0bGV0IHVuaWZvcm1WYWx1ZSA9IG1Vbmlmb3JtT2JqW3VuaWZvcm1OYW1lXTtcblx0XHRcdGNvbnN0IHVuaWZvcm1UeXBlID0gR0xTaGFkZXIuZ2V0VW5pZm9ybVR5cGUodW5pZm9ybVZhbHVlKTtcblxuXHRcdFx0aWYodW5pZm9ybVZhbHVlLmNvbmNhdCAmJiB1bmlmb3JtVmFsdWVbMF0uY29uY2F0KSB7XG5cdFx0XHRcdGxldCB0bXAgPSBbXTtcblx0XHRcdFx0Zm9yKGxldCBpPTA7IGk8dW5pZm9ybVZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmNvbmNhdCh1bmlmb3JtVmFsdWVbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHVuaWZvcm1WYWx1ZSA9IHRtcDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy51bmlmb3JtKHVuaWZvcm1OYW1lLCB1bmlmb3JtVHlwZSwgdW5pZm9ybVZhbHVlKTtcblx0XHR9XG5cblx0fVxuXG5cblx0X2NyZWF0ZVNoYWRlclByb2dyYW0obVNoYWRlclN0ciwgaXNWZXJ0ZXhTaGFkZXIpIHtcblx0XHRcblx0XHRjb25zdCBzaGFkZXJUeXBlID0gaXNWZXJ0ZXhTaGFkZXIgPyBHTC5WRVJURVhfU0hBREVSIDogR0wuRlJBR01FTlRfU0hBREVSO1xuXHRcdGNvbnN0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihzaGFkZXJUeXBlKTtcblxuXHRcdGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIG1TaGFkZXJTdHIpO1xuXHRcdGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcblxuXHRcdGlmKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcblx0XHRcdGNvbnNvbGUud2FybignRXJyb3IgaW4gU2hhZGVyIDogJywgZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcblx0XHRcdGNvbnNvbGUubG9nKGFkZExpbmVOdW1iZXJzKG1TaGFkZXJTdHIpKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHJldHVybiBzaGFkZXI7XG5cdH1cblxuXHRfYXR0YWNoU2hhZGVyUHJvZ3JhbShtVmVydGV4U2hhZGVyLCBtRnJhZ21lbnRTaGFkZXIpIHtcblxuXHRcdHRoaXMuc2hhZGVyUHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcblx0XHRnbC5hdHRhY2hTaGFkZXIodGhpcy5zaGFkZXJQcm9ncmFtLCBtVmVydGV4U2hhZGVyKTtcblx0XHRnbC5hdHRhY2hTaGFkZXIodGhpcy5zaGFkZXJQcm9ncmFtLCBtRnJhZ21lbnRTaGFkZXIpO1xuXG5cdFx0Z2wuZGVsZXRlU2hhZGVyKG1WZXJ0ZXhTaGFkZXIpO1xuXHRcdGdsLmRlbGV0ZVNoYWRlcihtRnJhZ21lbnRTaGFkZXIpO1xuXG5cdFx0aWYodGhpcy5fdmFyeWluZ3MpIHtcblx0XHRcdGNvbnNvbGUubG9nKCdUcmFuc2Zvcm0gZmVlZGJhY2sgc2V0dXAgOiAnLCB0aGlzLl92YXJ5aW5ncyk7XG5cdFx0XHRnbC50cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzKHRoaXMuc2hhZGVyUHJvZ3JhbSwgdGhpcy5fdmFyeWluZ3MsIGdsLlNFUEFSQVRFX0FUVFJJQlMpO1xuXHRcdH1cblxuXHRcdGdsLmxpbmtQcm9ncmFtKHRoaXMuc2hhZGVyUHJvZ3JhbSk7XG5cblx0fVxuXG59XG5cbkdMU2hhZGVyLmdldFVuaWZvcm1UeXBlID0gZnVuY3Rpb24gKG1WYWx1ZSkge1xuXHRjb25zdCBpc0FycmF5ID0gISFtVmFsdWUuY29uY2F0O1xuXG5cdGNvbnN0IGdldEFycmF5VW5pZm9ybVR5cGUgPSBmdW5jdGlvbiAobVZhbHVlKSB7XG5cdFx0aWYobVZhbHVlLmxlbmd0aCA9PT0gOSkge1xuXHRcdFx0cmV0dXJuICd1bmlmb3JtTWF0cml4M2Z2Jztcblx0XHR9IGVsc2UgaWYobVZhbHVlLmxlbmd0aCA9PT0gMTYpIHtcblx0XHRcdHJldHVybiAndW5pZm9ybU1hdHJpeDRmdic7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBgdmVjJHttVmFsdWUubGVuZ3RofWA7XHRcblx0XHR9XG5cdH07XG5cblx0aWYoIWlzQXJyYXkpIHtcblx0XHRyZXR1cm4gJ2Zsb2F0Jztcblx0fSBlbHNlIHtcblx0XHRpZiAoIW1WYWx1ZVswXS5jb25jYXQpIHtcblx0XHRcdHJldHVybiBnZXRBcnJheVVuaWZvcm1UeXBlKG1WYWx1ZSk7XHRcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGdldEFycmF5VW5pZm9ybVR5cGUobVZhbHVlWzBdKTtcblx0XHR9XG5cdH1cbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgR0xTaGFkZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvR0xTaGFkZXIuanMiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG4vKipcbiAqIENvbW1vbiB1dGlsaXRpZXNcbiAqIEBtb2R1bGUgZ2xNYXRyaXhcbiAqL1xuXG4vLyBDb25maWd1cmF0aW9uIENvbnN0YW50c1xuZXhwb3J0IGNvbnN0IEVQU0lMT04gPSAwLjAwMDAwMTtcbmV4cG9ydCBsZXQgQVJSQVlfVFlQRSA9ICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSAndW5kZWZpbmVkJykgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcbmV4cG9ydCBjb25zdCBSQU5ET00gPSBNYXRoLnJhbmRvbTtcblxuLyoqXG4gKiBTZXRzIHRoZSB0eXBlIG9mIGFycmF5IHVzZWQgd2hlbiBjcmVhdGluZyBuZXcgdmVjdG9ycyBhbmQgbWF0cmljZXNcbiAqXG4gKiBAcGFyYW0ge1R5cGV9IHR5cGUgQXJyYXkgdHlwZSwgc3VjaCBhcyBGbG9hdDMyQXJyYXkgb3IgQXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldE1hdHJpeEFycmF5VHlwZSh0eXBlKSB7XG4gIEFSUkFZX1RZUEUgPSB0eXBlO1xufVxuXG5jb25zdCBkZWdyZWUgPSBNYXRoLlBJIC8gMTgwO1xuXG4vKipcbiAqIENvbnZlcnQgRGVncmVlIFRvIFJhZGlhblxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIEFuZ2xlIGluIERlZ3JlZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUmFkaWFuKGEpIHtcbiAgcmV0dXJuIGEgKiBkZWdyZWU7XG59XG5cbi8qKlxuICogVGVzdHMgd2hldGhlciBvciBub3QgdGhlIGFyZ3VtZW50cyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgdmFsdWUsIHdpdGhpbiBhbiBhYnNvbHV0ZVxuICogb3IgcmVsYXRpdmUgdG9sZXJhbmNlIG9mIGdsTWF0cml4LkVQU0lMT04gKGFuIGFic29sdXRlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciB2YWx1ZXMgbGVzc1xuICogdGhhbiBvciBlcXVhbCB0byAxLjAsIGFuZCBhIHJlbGF0aXZlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciBsYXJnZXIgdmFsdWVzKVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCBudW1iZXIgdG8gdGVzdC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBzZWNvbmQgbnVtYmVyIHRvIHRlc3QuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbnVtYmVycyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8PSBFUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYSksIE1hdGguYWJzKGIpKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L2NvbW1vbi5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEdMIGZyb20gJy4vR0xUb29sJztcbmltcG9ydCB7IHZlYzMgfSBmcm9tICdnbC1tYXRyaXgnO1xuaW1wb3J0IGdldEF0dHJpYkxvYyBmcm9tICcuL3V0aWxzL2dldEF0dHJpYkxvYyc7XG5cbmxldCBnbDtcbmNvbnN0IFNUQVRJQ19EUkFXID0gMzUwNDQ7XG5cbmNvbnN0IGdldEJ1ZmZlciA9IGZ1bmN0aW9uIChhdHRyKSB7XG5cdGxldCBidWZmZXI7XG5cdFxuXHRpZihhdHRyLmJ1ZmZlciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0YnVmZmVyID0gYXR0ci5idWZmZXI7XHRcblx0fSBlbHNlIHtcblx0XHRidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblx0XHRhdHRyLmJ1ZmZlciA9IGJ1ZmZlcjtcblx0fVxuXG5cdHJldHVybiBidWZmZXI7XG59O1xuXG5cbmNvbnN0IGZvcm1CdWZmZXIgPSBmdW5jdGlvbiAobURhdGEsIG1OdW0pIHtcblx0Y29uc3QgYXJ5ID0gW107XG5cblx0Zm9yKGxldCBpPTA7IGk8bURhdGEubGVuZ3RoOyBpKz0gbU51bSkge1xuXHRcdGNvbnN0IG8gPSBbXTtcblx0XHRmb3IobGV0IGo9MDsgajxtTnVtOyBqKyspIHtcblx0XHRcdG8ucHVzaChtRGF0YVtpK2pdKTtcblx0XHR9XG5cblx0XHRhcnkucHVzaChvKTtcblx0fVxuXG5cdHJldHVybiBhcnk7XG59O1xuXG5jbGFzcyBNZXNoIHtcblx0Y29uc3RydWN0b3IobURyYXdpbmdUeXBlID0gNCwgbVVzZVZhbyA9IHRydWUpIHtcblx0XHRnbCAgICAgICAgICAgICAgICAgICAgICAgICAgID0gR0wuZ2w7XG5cdFx0dGhpcy5kcmF3VHlwZSAgICAgICAgICAgICAgICA9IG1EcmF3aW5nVHlwZTtcblx0XHR0aGlzLl9hdHRyaWJ1dGVzICAgICAgICAgICAgID0gW107XG5cdFx0dGhpcy5fbnVtSW5zdGFuY2UgXHRcdFx0ID0gLTE7XG5cdFx0dGhpcy5fZW5hYmxlZFZlcnRleEF0dHJpYnV0ZSA9IFtdO1xuXHRcdFxuXHRcdHRoaXMuX2luZGljZXMgICAgICAgICAgICAgICAgPSBbXTtcblx0XHR0aGlzLl9mYWNlcyAgICAgICAgICAgICAgICAgID0gW107XG5cdFx0dGhpcy5fYnVmZmVyQ2hhbmdlZCAgICAgICAgICA9IFtdO1xuXHRcdHRoaXMuX2hhc0luZGV4QnVmZmVyQ2hhbmdlZCAgPSBmYWxzZTtcblx0XHR0aGlzLl9oYXNWQU8gICAgICAgICAgICAgICAgID0gZmFsc2U7XG5cdFx0dGhpcy5faXNJbnN0YW5jZWQgXHRcdFx0ID0gZmFsc2U7XG5cdFx0XG5cdFx0dGhpcy5fZXh0VkFPICAgICAgICAgICAgICAgICA9ICEhR0wuZ2wuY3JlYXRlVmVydGV4QXJyYXk7XG5cdFx0dGhpcy5fdXNlVkFPICAgICAgICAgICAgIFx0ID0gISF0aGlzLl9leHRWQU8gJiYgbVVzZVZhbztcblx0XHQvLyB0aGlzLl91c2VWQU8gPSBmYWxzZTtcblx0fVxuXG5cblx0YnVmZmVyVmVydGV4KG1BcnJheVZlcnRpY2VzLCBtRHJhd1R5cGUgPSBTVEFUSUNfRFJBVykge1xuXG5cdFx0dGhpcy5idWZmZXJEYXRhKG1BcnJheVZlcnRpY2VzLCAnYVZlcnRleFBvc2l0aW9uJywgMywgbURyYXdUeXBlKTtcblxuXHRcdGlmICh0aGlzLm5vcm1hbHMubGVuZ3RoIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGgpIHtcblx0XHRcdHRoaXMuYnVmZmVyTm9ybWFsKG1BcnJheVZlcnRpY2VzLCBtRHJhd1R5cGUpO1x0XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXG5cdGJ1ZmZlclRleENvb3JkKG1BcnJheVRleENvb3JkcywgbURyYXdUeXBlID0gU1RBVElDX0RSQVcpIHtcblxuXHRcdHRoaXMuYnVmZmVyRGF0YShtQXJyYXlUZXhDb29yZHMsICdhVGV4dHVyZUNvb3JkJywgMiwgbURyYXdUeXBlKTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblxuXHRidWZmZXJOb3JtYWwobU5vcm1hbHMsIG1EcmF3VHlwZSA9IFNUQVRJQ19EUkFXKSB7XG5cblx0XHR0aGlzLmJ1ZmZlckRhdGEobU5vcm1hbHMsICdhTm9ybWFsJywgMywgbURyYXdUeXBlKTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblxuXHRidWZmZXJJbmRleChtQXJyYXlJbmRpY2VzLCBpc0R5bmFtaWMgPSBmYWxzZSkge1xuXHRcdHRoaXMuX2RyYXdUeXBlICAgICAgICA9IGlzRHluYW1pYyA/IGdsLkRZTkFNSUNfRFJBVyA6IGdsLlNUQVRJQ19EUkFXO1xuXHRcdGlmKG1BcnJheUluZGljZXMgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0dGhpcy5faW5kaWNlc1x0ICA9IG5ldyBVaW50MTZBcnJheShtQXJyYXlJbmRpY2VzKTtcdFxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9pbmRpY2VzID0gbUFycmF5SW5kaWNlcztcblx0XHR9XG5cdFx0XG5cdFx0dGhpcy5fbnVtSXRlbXMgXHRcdCAgPSB0aGlzLl9pbmRpY2VzLmxlbmd0aDtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YnVmZmVyRmxhdHRlbkRhdGEobURhdGEsIG1OYW1lLCBtSXRlbVNpemUsIG1EcmF3VHlwZSA9IFNUQVRJQ19EUkFXLCBpc0luc3RhbmNlZCA9IGZhbHNlKSB7XG5cdFx0XG5cdFx0Y29uc3QgZGF0YSA9IGZvcm1CdWZmZXIobURhdGEsIG1JdGVtU2l6ZSk7XG5cdFx0dGhpcy5idWZmZXJEYXRhKGRhdGEsIG1OYW1lLCBtSXRlbVNpemUsIG1EcmF3VHlwZSA9IFNUQVRJQ19EUkFXLCBpc0luc3RhbmNlZCA9IGZhbHNlKTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YnVmZmVyRGF0YShtRGF0YSwgbU5hbWUsIG1JdGVtU2l6ZSwgbURyYXdUeXBlID0gU1RBVElDX0RSQVcsIGlzSW5zdGFuY2VkID0gZmFsc2UpIHtcblx0XHRsZXQgaSA9IDA7XG5cdFx0Y29uc3QgZHJhd1R5cGUgICA9IG1EcmF3VHlwZTtcblx0XHRpZighZHJhd1R5cGUpIGRlYnVnZ2VyO1xuXG5cdFx0Y29uc3QgYnVmZmVyRGF0YSA9IFtdO1xuXHRcdGlmICghbUl0ZW1TaXplKSB7XHRtSXRlbVNpemUgPSBtRGF0YVswXS5sZW5ndGg7IH1cblx0XHR0aGlzLl9pc0luc3RhbmNlZCA9IGlzSW5zdGFuY2VkIHx8IHRoaXMuX2lzSW5zdGFuY2VkO1xuXG5cdFx0Ly9cdGZsYXR0ZW4gYnVmZmVyIGRhdGFcdFx0XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbURhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdGZvcihsZXQgaiA9IDA7IGogPCBtRGF0YVtpXS5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRidWZmZXJEYXRhLnB1c2gobURhdGFbaV1bal0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjb25zdCBkYXRhQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlckRhdGEpO1xuXHRcdGNvbnN0IGF0dHJpYnV0ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKG1OYW1lKTtcblxuXHRcdFxuXHRcdGlmKGF0dHJpYnV0ZSkge1x0XG5cdFx0XHQvL1x0YXR0cmlidXRlIGV4aXN0ZWQsIHJlcGxhY2Ugd2l0aCBuZXcgZGF0YVxuXHRcdFx0YXR0cmlidXRlLml0ZW1TaXplID0gbUl0ZW1TaXplO1xuXHRcdFx0YXR0cmlidXRlLmRhdGFBcnJheSA9IGRhdGFBcnJheTtcblx0XHRcdGF0dHJpYnV0ZS5zb3VyY2UgPSBtRGF0YTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly9cdGF0dHJpYnV0ZSBub3QgZXhpc3QgeWV0LCBjcmVhdGUgbmV3IGF0dHJpYnV0ZSBvYmplY3Rcblx0XHRcdHRoaXMuX2F0dHJpYnV0ZXMucHVzaCh7IG5hbWU6bU5hbWUsIHNvdXJjZTptRGF0YSwgaXRlbVNpemU6IG1JdGVtU2l6ZSwgZHJhd1R5cGUsIGRhdGFBcnJheSwgaXNJbnN0YW5jZWQgfSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fYnVmZmVyQ2hhbmdlZC5wdXNoKG1OYW1lKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGJ1ZmZlckluc3RhbmNlKG1EYXRhLCBtTmFtZSkge1xuXHRcdGlmICghR0wuZ2wudmVydGV4QXR0cmliRGl2aXNvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXh0ZW5zaW9uIDogQU5HTEVfaW5zdGFuY2VkX2FycmF5cyBpcyBub3Qgc3VwcG9ydGVkIHdpdGggdGhpcyBkZXZpY2UgIScpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IGl0ZW1TaXplID0gbURhdGFbMF0ubGVuZ3RoO1xuXHRcdHRoaXMuX251bUluc3RhbmNlID0gbURhdGEubGVuZ3RoO1xuXHRcdHRoaXMuYnVmZmVyRGF0YShtRGF0YSwgbU5hbWUsIGl0ZW1TaXplLCBTVEFUSUNfRFJBVywgdHJ1ZSk7XG5cdH1cblxuXG5cdGJpbmQobVNoYWRlclByb2dyYW0pIHtcblx0XHR0aGlzLmdlbmVyYXRlQnVmZmVycyhtU2hhZGVyUHJvZ3JhbSk7XG5cblx0XHRpZih0aGlzLmhhc1ZBTykge1xuXHRcdFx0Z2wuYmluZFZlcnRleEFycmF5KHRoaXMudmFvKTsgXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuYXR0cmlidXRlcy5mb3JFYWNoKChhdHRyaWJ1dGUpPT4ge1xuXHRcdFx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYXR0cmlidXRlLmJ1ZmZlcik7XG5cdFx0XHRcdGNvbnN0IGF0dHJQb3NpdGlvbiA9IGF0dHJpYnV0ZS5hdHRyUG9zaXRpb247XG5cdFx0XHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYXR0clBvc2l0aW9uLCBhdHRyaWJ1dGUuaXRlbVNpemUsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG5cblx0XHRcdFx0aWYoYXR0cmlidXRlLmlzSW5zdGFuY2VkKSB7XG5cdFx0XHRcdFx0Z2wudmVydGV4QXR0cmliRGl2aXNvcihhdHRyUG9zaXRpb24sIDEpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0pO1xuXG5cdFx0XHQvL1x0QklORCBJTkRFWCBCVUZGRVJcblx0XHRcdGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaUJ1ZmZlcik7XHRcblx0XHR9XG5cdH1cblxuXHRnZW5lcmF0ZUJ1ZmZlcnMobVNoYWRlclByb2dyYW0pIHtcblx0XHRpZih0aGlzLl9idWZmZXJDaGFuZ2VkLmxlbmd0aCA9PSAwKSB7IHJldHVybjsgfVxuXG5cdFx0aWYodGhpcy5fdXNlVkFPKSB7IC8vXHRJRiBTVVBQT1JURUQsIENSRUFURSBWQU9cblxuXHRcdFx0Ly9cdENSRUFURSAmIEJJTkQgVkFPXG5cdFx0XHRpZighdGhpcy5fdmFvKSB7XG5cdFx0XHRcdHRoaXMuX3ZhbyA9IGdsLmNyZWF0ZVZlcnRleEFycmF5KCk7XHRcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Z2wuYmluZFZlcnRleEFycmF5KHRoaXMuX3Zhbyk7XG5cblx0XHRcdC8vXHRVUERBVEUgQlVGRkVSU1xuXHRcdFx0dGhpcy5fYXR0cmlidXRlcy5mb3JFYWNoKChhdHRyT2JqKSA9PiB7XG5cblx0XHRcdFx0aWYodGhpcy5fYnVmZmVyQ2hhbmdlZC5pbmRleE9mKGF0dHJPYmoubmFtZSkgIT09IC0xKSB7XG5cdFx0XHRcdFx0Y29uc3QgYnVmZmVyID0gZ2V0QnVmZmVyKGF0dHJPYmopO1xuXHRcdFx0XHRcdGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuXHRcdFx0XHRcdGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBhdHRyT2JqLmRhdGFBcnJheSwgYXR0ck9iai5kcmF3VHlwZSk7XG5cblx0XHRcdFx0XHRjb25zdCBhdHRyUG9zaXRpb24gPSBnZXRBdHRyaWJMb2MoZ2wsIG1TaGFkZXJQcm9ncmFtLCBhdHRyT2JqLm5hbWUpO1xuXHRcdFx0XHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJQb3NpdGlvbik7IFxuXHRcdFx0XHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYXR0clBvc2l0aW9uLCBhdHRyT2JqLml0ZW1TaXplLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuXHRcdFx0XHRcdGF0dHJPYmouYXR0clBvc2l0aW9uID0gYXR0clBvc2l0aW9uO1xuXG5cdFx0XHRcdFx0aWYoYXR0ck9iai5pc0luc3RhbmNlZCkge1xuXHRcdFx0XHRcdFx0Z2wudmVydGV4QXR0cmliRGl2aXNvcihhdHRyUG9zaXRpb24sIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdH0pO1xuXHRcdFx0XHRcblx0XHRcdC8vXHRjaGVjayBpbmRleCBidWZmZXJcblx0XHRcdHRoaXMuX3VwZGF0ZUluZGV4QnVmZmVyKCk7XG5cblx0XHRcdC8vXHRVTkJJTkQgVkFPXG5cdFx0XHRnbC5iaW5kVmVydGV4QXJyYXkobnVsbCk7XHRcblx0XHRcdFxuXHRcdFx0dGhpcy5faGFzVkFPID0gdHJ1ZTtcblxuXHRcdH0gZWxzZSB7IC8vXHRFTFNFLCBVU0UgVFJBRElUSU9OQUwgTUVUSE9EXG5cblx0XHRcdHRoaXMuX2F0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0ck9iaikgPT4ge1xuXHRcdFx0XHQvL1x0U0tJUCBJRiBCVUZGRVIgSEFTTidUIENIQU5HRURcblx0XHRcdFx0aWYodGhpcy5fYnVmZmVyQ2hhbmdlZC5pbmRleE9mKGF0dHJPYmoubmFtZSkgIT09IC0xKSB7XG5cdFx0XHRcdFx0Y29uc3QgYnVmZmVyID0gZ2V0QnVmZmVyKGF0dHJPYmopO1xuXHRcdFx0XHRcdGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuXHRcdFx0XHRcdGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBhdHRyT2JqLmRhdGFBcnJheSwgYXR0ck9iai5kcmF3VHlwZSk7XG5cblx0XHRcdFx0XHRjb25zdCBhdHRyUG9zaXRpb24gPSBnZXRBdHRyaWJMb2MoZ2wsIG1TaGFkZXJQcm9ncmFtLCBhdHRyT2JqLm5hbWUpO1xuXHRcdFx0XHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJQb3NpdGlvbik7XG5cdFx0XHRcdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlcihhdHRyUG9zaXRpb24sIGF0dHJPYmouaXRlbVNpemUsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG5cdFx0XHRcdFx0YXR0ck9iai5hdHRyUG9zaXRpb24gPSBhdHRyUG9zaXRpb247XG5cblx0XHRcdFx0XHRpZihhdHRyT2JqLmlzSW5zdGFuY2VkKSB7XG5cdFx0XHRcdFx0XHRnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGF0dHJQb3NpdGlvbiwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5fdXBkYXRlSW5kZXhCdWZmZXIoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9oYXNJbmRleEJ1ZmZlckNoYW5nZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9idWZmZXJDaGFuZ2VkID0gW107XG5cdH1cblxuXG5cdHVuYmluZCgpIHtcblx0XHRpZih0aGlzLl91c2VWQU8pIHtcblx0XHRcdGdsLmJpbmRWZXJ0ZXhBcnJheShudWxsKTtcdFxuXHRcdH1cblx0XHRcblx0XHR0aGlzLl9hdHRyaWJ1dGVzLmZvckVhY2goKGF0dHJpYnV0ZSk9PiB7XG5cdFx0XHRpZihhdHRyaWJ1dGUuaXNJbnN0YW5jZWQpIHtcblx0XHRcdFx0Z2wudmVydGV4QXR0cmliRGl2aXNvcihhdHRyaWJ1dGUuYXR0clBvc2l0aW9uLCAwKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cblx0X3VwZGF0ZUluZGV4QnVmZmVyKCkge1xuXHRcdGlmKCF0aGlzLl9oYXNJbmRleEJ1ZmZlckNoYW5nZWQpIHtcblx0XHRcdGlmICghdGhpcy5pQnVmZmVyKSB7IHRoaXMuaUJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1x0IH1cblx0XHRcdGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaUJ1ZmZlcik7XG5cdFx0XHRnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLl9pbmRpY2VzLCB0aGlzLl9kcmF3VHlwZSk7XG5cdFx0XHR0aGlzLmlCdWZmZXIuaXRlbVNpemUgPSAxO1xuXHRcdFx0dGhpcy5pQnVmZmVyLm51bUl0ZW1zID0gdGhpcy5fbnVtSXRlbXM7XG5cdFx0fVxuXHR9XG5cblxuXHRjb21wdXRlTm9ybWFscyh1c2luZ0ZhY2VOb3JtYWxzID0gZmFsc2UpIHtcblxuXHRcdHRoaXMuZ2VuZXJhdGVGYWNlcygpO1xuXG5cdFx0aWYodXNpbmdGYWNlTm9ybWFscykge1xuXHRcdFx0dGhpcy5fY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2NvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cdFx0fVxuXHR9XG5cblx0Ly9cdFBSSVZBVEUgTUVUSE9EU1xuXG5cdF9jb21wdXRlRmFjZU5vcm1hbHMoKSB7XG5cblx0XHRsZXQgZmFjZUluZGV4O1xuXHRcdGxldCBmYWNlO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblxuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLl9pbmRpY2VzLmxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHRmYWNlSW5kZXggPSBpIC8gMztcblx0XHRcdGZhY2UgPSB0aGlzLl9mYWNlc1tmYWNlSW5kZXhdO1xuXHRcdFx0Y29uc3QgTiA9IGZhY2Uubm9ybWFsO1xuXG5cdFx0XHRub3JtYWxzW2ZhY2UuaW5kaWNlc1swXV0gPSBOO1xuXHRcdFx0bm9ybWFsc1tmYWNlLmluZGljZXNbMV1dID0gTjtcblx0XHRcdG5vcm1hbHNbZmFjZS5pbmRpY2VzWzJdXSA9IE47XG5cdFx0fVxuXG5cdFx0dGhpcy5idWZmZXJOb3JtYWwobm9ybWFscyk7XG5cdH1cblxuXG5cdF9jb21wdXRlVmVydGV4Tm9ybWFscygpIHtcblx0XHQvL1x0bG9vcCB0aHJvdWdoIGFsbCB2ZXJ0aWNlc1xuXHRcdGxldCBmYWNlO1xuXHRcdGNvbnN0IHN1bU5vcm1hbCA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHsgdmVydGljZXMgfSA9IHRoaXM7XG5cblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcblxuXHRcdFx0dmVjMy5zZXQoc3VtTm9ybWFsLCAwLCAwLCAwKTtcblxuXHRcdFx0Zm9yKGxldCBqID0gMDsgaiA8IHRoaXMuX2ZhY2VzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGZhY2UgPSB0aGlzLl9mYWNlc1tqXTtcblxuXHRcdFx0XHQvL1x0aWYgdmVydGV4IGV4aXN0IGluIHRoZSBmYWNlLCBhZGQgdGhlIG5vcm1hbCB0byBzdW0gbm9ybWFsXG5cdFx0XHRcdGlmKGZhY2UuaW5kaWNlcy5pbmRleE9mKGkpID49IDApIHtcblxuXHRcdFx0XHRcdHN1bU5vcm1hbFswXSArPSBmYWNlLm5vcm1hbFswXTtcblx0XHRcdFx0XHRzdW1Ob3JtYWxbMV0gKz0gZmFjZS5ub3JtYWxbMV07XG5cdFx0XHRcdFx0c3VtTm9ybWFsWzJdICs9IGZhY2Uubm9ybWFsWzJdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR2ZWMzLm5vcm1hbGl6ZShzdW1Ob3JtYWwsIHN1bU5vcm1hbCk7XG5cdFx0XHRub3JtYWxzLnB1c2goW3N1bU5vcm1hbFswXSwgc3VtTm9ybWFsWzFdLCBzdW1Ob3JtYWxbMl1dKTtcblx0XHR9XG5cblx0XHR0aGlzLmJ1ZmZlck5vcm1hbChub3JtYWxzKTtcblxuXHR9XG5cblxuXHRnZW5lcmF0ZUZhY2VzKCkge1xuXHRcdGxldCBpYSwgaWIsIGljO1xuXHRcdGxldCBhLCBiLCBjO1xuXHRcdGNvbnN0IHZiYSA9IHZlYzMuY3JlYXRlKCksIHZjYSA9IHZlYzMuY3JlYXRlKCksIHZOb3JtYWwgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdGNvbnN0IHsgdmVydGljZXMgfSA9IHRoaXM7XG5cblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5faW5kaWNlcy5sZW5ndGg7IGkgKz0gMykge1xuXG5cdFx0XHRpYSA9IHRoaXMuX2luZGljZXNbaV07XG5cdFx0XHRpYiA9IHRoaXMuX2luZGljZXNbaSArIDFdO1xuXHRcdFx0aWMgPSB0aGlzLl9pbmRpY2VzW2kgKyAyXTtcblxuXHRcdFx0YSA9IHZlcnRpY2VzW2lhXTtcblx0XHRcdGIgPSB2ZXJ0aWNlc1tpYl07XG5cdFx0XHRjID0gdmVydGljZXNbaWNdO1xuXG5cdFx0XHRjb25zdCBmYWNlID0ge1xuXHRcdFx0XHRpbmRpY2VzOltpYSwgaWIsIGljXSxcblx0XHRcdFx0dmVydGljZXM6W2EsIGIsIGNdLFxuXHRcdFx0fTtcblxuXHRcdFx0dGhpcy5fZmFjZXMucHVzaChmYWNlKTtcblx0XHR9XG5cblx0fVxuXG5cblx0Z2V0QXR0cmlidXRlKG1OYW1lKSB7XHRyZXR1cm4gdGhpcy5fYXR0cmlidXRlcy5maW5kKChhKSA9PiBhLm5hbWUgPT09IG1OYW1lKTtcdH1cblx0Z2V0U291cmNlKG1OYW1lKSB7XG5cdFx0Y29uc3QgYXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKG1OYW1lKTtcblx0XHRyZXR1cm4gYXR0ciA/IGF0dHIuc291cmNlIDogW107XG5cdH1cblxuXG5cdC8vXHRHRVRURVIgQU5EIFNFVFRFUlNcblxuXHRnZXQgdmVydGljZXMoKSB7XHRyZXR1cm4gdGhpcy5nZXRTb3VyY2UoJ2FWZXJ0ZXhQb3NpdGlvbicpO1x0fVxuXG5cdGdldCBub3JtYWxzKCkge1x0XHRyZXR1cm4gdGhpcy5nZXRTb3VyY2UoJ2FOb3JtYWwnKTtcdH1cblxuXHRnZXQgY29vcmRzKCkge1x0XHRyZXR1cm4gdGhpcy5nZXRTb3VyY2UoJ2FUZXh0dXJlQ29vcmQnKTtcdH1cblxuXHRnZXQgaW5kaWNlcygpIHtcdFx0cmV0dXJuIHRoaXMuX2luZGljZXM7XHR9XG5cblx0Z2V0IHZlcnRleFNpemUoKSB7XHRyZXR1cm4gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XHR9XG5cblx0Z2V0IGZhY2VzKCkge1x0cmV0dXJuIHRoaXMuX2ZhY2VzO1x0fVxuXG5cdGdldCBhdHRyaWJ1dGVzKCkge1x0cmV0dXJuIHRoaXMuX2F0dHJpYnV0ZXM7XHR9XG5cblx0Z2V0IGhhc1ZBTygpIHtcdHJldHVybiB0aGlzLl9oYXNWQU87XHR9XG5cblx0Z2V0IHZhbygpIHtcdHJldHVybiB0aGlzLl92YW87XHR9XG5cblx0Z2V0IG51bUluc3RhbmNlKCkge1x0cmV0dXJuIHRoaXMuX251bUluc3RhbmNlO1x0fVxuXG5cdGdldCBpc0luc3RhbmNlZCgpIHsgcmV0dXJuIHRoaXMuX2lzSW5zdGFuY2VkO1x0fVxuXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgTWVzaDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9NZXNoLmpzIiwiLy8gQmF0Y2guanNcblxuaW1wb3J0IEdMIGZyb20gJy4vR0xUb29sJztcblxuY2xhc3MgQmF0Y2gge1xuXG5cdGNvbnN0cnVjdG9yKG1NZXNoLCBtU2hhZGVyKSB7XG5cdFx0dGhpcy5fbWVzaCA9IG1NZXNoO1xuXHRcdHRoaXMuX3NoYWRlciA9IG1TaGFkZXI7XG5cdH1cblxuXG5cdC8vXHRQVUJMSUMgTUVUSE9EU1xuXG5cdGRyYXcoKSB7XG5cdFx0dGhpcy5fc2hhZGVyLmJpbmQoKTtcblx0XHRHTC5kcmF3KHRoaXMubWVzaCk7XG5cdH1cblxuXG5cdC8vXHRHRVRURVIgQU5EIFNFVFRFUlxuXG5cdGdldCBtZXNoKCkge1x0cmV0dXJuIHRoaXMuX21lc2g7XHR9XG5cblx0Z2V0IHNoYWRlcigpIHtcdHJldHVybiB0aGlzLl9zaGFkZXI7XHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhdGNoO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL0JhdGNoLmpzIiwiLy8gU2NoZWR1bGVyLmpzXG5cblxuY2xhc3MgU2NoZWR1bGVyIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLl9kZWxheVRhc2tzID0gW107XG5cdFx0dGhpcy5fbmV4dFRhc2tzID0gW107XG5cdFx0dGhpcy5fZGVmZXJUYXNrcyA9IFtdO1xuXHRcdHRoaXMuX2hpZ2hUYXNrcyA9IFtdO1xuXHRcdHRoaXMuX3VzdXJwVGFzayA9IFtdO1xuXHRcdHRoaXMuX2VudGVyZnJhbWVUYXNrcyA9IFtdO1xuXHRcdHRoaXMuX2lkVGFibGUgPSAwO1xuXHRcdHRoaXMuZnJhbWVSYXRlID0gNjA7XG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cblx0XHR0aGlzLl9kZWx0YVRpbWUgPSAwO1xuXG5cdFx0dGhpcy5fbG9vcCgpO1xuXHR9XG5cblxuXHQvLyAgUFVCTElDIE1FVEhPRFNcblxuXHRhZGRFRihmdW5jLCBwYXJhbXMpIHtcblx0XHRwYXJhbXMgPSBwYXJhbXMgfHwgW107XG5cdFx0Y29uc3QgaWQgPSB0aGlzLl9pZFRhYmxlO1xuXHRcdHRoaXMuX2VudGVyZnJhbWVUYXNrc1tpZF0gPSB7IGZ1bmMsIHBhcmFtcyB9O1xuXHRcdHRoaXMuX2lkVGFibGUgKys7XG5cdFx0cmV0dXJuIGlkO1xuXHR9XG5cblx0cmVtb3ZlRUYoaWQpIHtcblx0XHRpZiAodGhpcy5fZW50ZXJmcmFtZVRhc2tzW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLl9lbnRlcmZyYW1lVGFza3NbaWRdID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9XG5cblx0ZGVsYXkoZnVuYywgcGFyYW1zLCBkZWxheSkge1xuXHRcdGNvbnN0IHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0XHRjb25zdCB0ID0geyBmdW5jLCBwYXJhbXMsIGRlbGF5LCB0aW1lIH07XG5cdFx0dGhpcy5fZGVsYXlUYXNrcy5wdXNoKHQpO1xuXHR9XG5cblx0ZGVmZXIoZnVuYywgcGFyYW1zKSB7XG5cdFx0Y29uc3QgdCA9IHsgZnVuYywgcGFyYW1zIH07XG5cdFx0dGhpcy5fZGVmZXJUYXNrcy5wdXNoKHQpO1xuXHR9XG5cblx0bmV4dChmdW5jLCBwYXJhbXMpIHtcblx0XHRjb25zdCB0ID0geyBmdW5jLCBwYXJhbXMgfTtcblx0XHR0aGlzLl9uZXh0VGFza3MucHVzaCh0KTtcblx0fVxuXG5cdHVzdXJwKGZ1bmMsIHBhcmFtcykge1xuXHRcdGNvbnN0IHQgPSB7IGZ1bmMsIHBhcmFtcyB9O1xuXHRcdHRoaXMuX3VzdXJwVGFzay5wdXNoKHQpO1xuXHR9XG5cblxuXHQvLyAgUFJJVkFURSBNRVRIT0RTXG5cblx0X3Byb2Nlc3MoKSB7XG5cdFx0bGV0IGkgPSAwO1xuXHRcdGxldCB0YXNrO1xuXHRcdGxldCBpbnRlcnZhbDtcblx0XHRsZXQgY3VycmVudDtcblx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5fZW50ZXJmcmFtZVRhc2tzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0YXNrID0gdGhpcy5fZW50ZXJmcmFtZVRhc2tzW2ldO1xuXHRcdFx0aWYgKHRhc2sgIT09IG51bGwgJiYgdGFzayAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRhc2suZnVuYyh0YXNrLnBhcmFtcyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0d2hpbGUgKHRoaXMuX2hpZ2hUYXNrcy5sZW5ndGggPiAwKSB7XG5cdFx0XHR0YXNrID0gdGhpcy5faGlnaFRhc2tzLnBvcCgpO1xuXHRcdFx0dGFzay5mdW5jKHRhc2sucGFyYW1zKTtcblx0XHR9XG5cblxuXHRcdGxldCBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0XHR0aGlzLl9kZWx0YVRpbWUgPSAoc3RhcnRUaW1lIC0gdGhpcy5fc3RhcnRUaW1lKS8xMDAwO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHRoaXMuX2RlbGF5VGFza3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRhc2sgPSB0aGlzLl9kZWxheVRhc2tzW2ldO1xuXHRcdFx0aWYgKHN0YXJ0VGltZSAtIHRhc2sudGltZSA+IHRhc2suZGVsYXkpIHtcblx0XHRcdFx0dGFzay5mdW5jKHRhc2sucGFyYW1zKTtcblx0XHRcdFx0dGhpcy5fZGVsYXlUYXNrcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdFx0dGhpcy5fZGVsdGFUaW1lID0gKHN0YXJ0VGltZSAtIHRoaXMuX3N0YXJ0VGltZSkvMTAwMDtcblx0XHRpbnRlcnZhbCA9IDEwMDAgLyB0aGlzLmZyYW1lUmF0ZTtcblx0XHR3aGlsZSAodGhpcy5fZGVmZXJUYXNrcy5sZW5ndGggPiAwKSB7XG5cdFx0XHR0YXNrID0gdGhpcy5fZGVmZXJUYXNrcy5zaGlmdCgpO1xuXHRcdFx0Y3VycmVudCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHRcdFx0aWYgKGN1cnJlbnQgLSBzdGFydFRpbWUgPCBpbnRlcnZhbCkge1xuXHRcdFx0XHR0YXNrLmZ1bmModGFzay5wYXJhbXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fZGVmZXJUYXNrcy51bnNoaWZ0KHRhc2spO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblxuXHRcdHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHRcdHRoaXMuX2RlbHRhVGltZSA9IChzdGFydFRpbWUgLSB0aGlzLl9zdGFydFRpbWUpLzEwMDA7XG5cdFx0aW50ZXJ2YWwgPSAxMDAwIC8gdGhpcy5mcmFtZVJhdGU7XG5cdFx0d2hpbGUgKHRoaXMuX3VzdXJwVGFzay5sZW5ndGggPiAwKSB7XG5cdFx0XHR0YXNrID0gdGhpcy5fdXN1cnBUYXNrLnNoaWZ0KCk7XG5cdFx0XHRjdXJyZW50ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdFx0XHRpZiAoY3VycmVudCAtIHN0YXJ0VGltZSA8IGludGVydmFsKSB7XG5cdFx0XHRcdHRhc2suZnVuYyh0YXNrLnBhcmFtcyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5faGlnaFRhc2tzID0gdGhpcy5faGlnaFRhc2tzLmNvbmNhdCh0aGlzLl9uZXh0VGFza3MpO1xuXHRcdHRoaXMuX25leHRUYXNrcyA9IFtdO1xuXHRcdHRoaXMuX3VzdXJwVGFzayA9IFtdO1xuXHR9XG5cblxuXHRfbG9vcCgpIHtcblx0XHR0aGlzLl9wcm9jZXNzKCk7XG5cdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLl9sb29wKCkpO1xuXHR9XG5cblx0Z2V0IGRlbHRhVGltZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGVsdGFUaW1lO1xuXHR9XG59XG5cbmNvbnN0IHNjaGVkdWxlciA9IG5ldyBTY2hlZHVsZXIoKTtcblxuZXhwb3J0IGRlZmF1bHQgc2NoZWR1bGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc2NoZWR1bGluZy9zcmMvc2NoZWR1bGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gR2VvbS5qc1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBNZXNoIGZyb20gJy4vTWVzaCc7XG5cbmNvbnN0IEdlb20gPSB7fTtcbmxldCBtZXNoVHJpO1xuXG5HZW9tLnBsYW5lID0gZnVuY3Rpb24gcGxhbmUod2lkdGgsIGhlaWdodCwgbnVtU2VnbWVudHMsIGF4aXMgPSAneHknLCBkcmF3VHlwZSA9IDQpIHtcblx0Y29uc3QgcG9zaXRpb25zID0gW107XG5cdGNvbnN0IGNvb3JkcyAgICA9IFtdO1xuXHRjb25zdCBpbmRpY2VzICAgPSBbXTtcblx0Y29uc3Qgbm9ybWFscyAgID0gW107XG5cblx0Y29uc3QgZ2FwWCAgPSB3aWR0aCAvIG51bVNlZ21lbnRzO1xuXHRjb25zdCBnYXBZICA9IGhlaWdodCAvIG51bVNlZ21lbnRzO1xuXHRjb25zdCBnYXBVViA9IDEgLyBudW1TZWdtZW50cztcblx0Y29uc3Qgc3ggICAgPSAtd2lkdGggKiAwLjU7XG5cdGNvbnN0IHN5ICAgID0gLWhlaWdodCAqIDAuNTtcblx0bGV0IGluZGV4ID0gMDtcblxuXHRmb3IobGV0IGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuXHRcdGZvciAobGV0IGogPSAwOyBqIDwgbnVtU2VnbWVudHM7IGorKykge1xuXHRcdFx0Y29uc3QgdHggPSBnYXBYICogaSArIHN4O1xuXHRcdFx0Y29uc3QgdHkgPSBnYXBZICogaiArIHN5O1xuXG5cdFx0XHRjb25zdCB1ID0gaSAvIG51bVNlZ21lbnRzO1xuXHRcdFx0Y29uc3QgdiA9IGogLyBudW1TZWdtZW50cztcblxuXHRcdFx0aWYoYXhpcyA9PT0gJ3h6Jykge1xuXHRcdFx0XHRwb3NpdGlvbnMucHVzaChbdHgsIFx0XHQwLCBcdCB0eSArIGdhcFldKTtcblx0XHRcdFx0cG9zaXRpb25zLnB1c2goW3R4ICsgZ2FwWCwgXHQwLCBcdCB0eSArIGdhcFldKTtcblx0XHRcdFx0cG9zaXRpb25zLnB1c2goW3R4ICsgZ2FwWCwgXHQwLCBcdCB0eV0pO1xuXHRcdFx0XHRwb3NpdGlvbnMucHVzaChbdHgsIFx0XHQwLCBcdCB0eV0pO1x0XG5cblx0XHRcdFx0Y29vcmRzLnB1c2goW3UsIDEuMCAtICh2ICsgZ2FwVVYpXSk7XG5cdFx0XHRcdGNvb3Jkcy5wdXNoKFt1ICsgZ2FwVVYsIDEuMCAtICh2ICsgZ2FwVVYpXSk7XG5cdFx0XHRcdGNvb3Jkcy5wdXNoKFt1ICsgZ2FwVVYsIDEuMCAtIHZdKTtcblx0XHRcdFx0Y29vcmRzLnB1c2goW3UsIDEuMCAtIHZdKTtcblxuXHRcdFx0XHRub3JtYWxzLnB1c2goWzAsIDEsIDBdKTtcblx0XHRcdFx0bm9ybWFscy5wdXNoKFswLCAxLCAwXSk7XG5cdFx0XHRcdG5vcm1hbHMucHVzaChbMCwgMSwgMF0pO1xuXHRcdFx0XHRub3JtYWxzLnB1c2goWzAsIDEsIDBdKTtcblx0XHRcdH0gZWxzZSBpZihheGlzID09PSAneXonKSB7XG5cdFx0XHRcdHBvc2l0aW9ucy5wdXNoKFswLCB0eSwgdHhdKTtcblx0XHRcdFx0cG9zaXRpb25zLnB1c2goWzAsIHR5LCB0eCArIGdhcFhdKTtcblx0XHRcdFx0cG9zaXRpb25zLnB1c2goWzAsIHR5ICsgZ2FwWSwgdHggKyBnYXBYXSk7XG5cdFx0XHRcdHBvc2l0aW9ucy5wdXNoKFswLCB0eSArIGdhcFksIHR4XSk7XHRcblxuXHRcdFx0XHRjb29yZHMucHVzaChbdSwgdl0pO1xuXHRcdFx0XHRjb29yZHMucHVzaChbdSArIGdhcFVWLCB2XSk7XG5cdFx0XHRcdGNvb3Jkcy5wdXNoKFt1ICsgZ2FwVVYsIHYgKyBnYXBVVl0pO1xuXHRcdFx0XHRjb29yZHMucHVzaChbdSwgdiArIGdhcFVWXSk7XG5cblx0XHRcdFx0bm9ybWFscy5wdXNoKFsxLCAwLCAwXSk7XG5cdFx0XHRcdG5vcm1hbHMucHVzaChbMSwgMCwgMF0pO1xuXHRcdFx0XHRub3JtYWxzLnB1c2goWzEsIDAsIDBdKTtcblx0XHRcdFx0bm9ybWFscy5wdXNoKFsxLCAwLCAwXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwb3NpdGlvbnMucHVzaChbdHgsIFx0XHR0eSwgXHQwXSk7XG5cdFx0XHRcdHBvc2l0aW9ucy5wdXNoKFt0eCArIGdhcFgsIFx0dHksIFx0MF0pO1xuXHRcdFx0XHRwb3NpdGlvbnMucHVzaChbdHggKyBnYXBYLCBcdHR5ICsgZ2FwWSwgXHQwXSk7XG5cdFx0XHRcdHBvc2l0aW9ucy5wdXNoKFt0eCwgXHRcdHR5ICsgZ2FwWSwgXHQwXSk7XHRcblxuXHRcdFx0XHRjb29yZHMucHVzaChbdSwgdl0pO1xuXHRcdFx0XHRjb29yZHMucHVzaChbdSArIGdhcFVWLCB2XSk7XG5cdFx0XHRcdGNvb3Jkcy5wdXNoKFt1ICsgZ2FwVVYsIHYgKyBnYXBVVl0pO1xuXHRcdFx0XHRjb29yZHMucHVzaChbdSwgdiArIGdhcFVWXSk7XG5cblx0XHRcdFx0bm9ybWFscy5wdXNoKFswLCAwLCAxXSk7XG5cdFx0XHRcdG5vcm1hbHMucHVzaChbMCwgMCwgMV0pO1xuXHRcdFx0XHRub3JtYWxzLnB1c2goWzAsIDAsIDFdKTtcblx0XHRcdFx0bm9ybWFscy5wdXNoKFswLCAwLCAxXSk7XG5cdFx0XHR9IFxuXG5cblx0XHRcdGluZGljZXMucHVzaChpbmRleCAqIDQgKyAwKTtcblx0XHRcdGluZGljZXMucHVzaChpbmRleCAqIDQgKyAxKTtcblx0XHRcdGluZGljZXMucHVzaChpbmRleCAqIDQgKyAyKTtcblx0XHRcdGluZGljZXMucHVzaChpbmRleCAqIDQgKyAwKTtcblx0XHRcdGluZGljZXMucHVzaChpbmRleCAqIDQgKyAyKTtcblx0XHRcdGluZGljZXMucHVzaChpbmRleCAqIDQgKyAzKTtcblxuXHRcdFx0aW5kZXgrKztcblx0XHR9XG5cdH1cblxuXHRjb25zdCBtZXNoID0gbmV3IE1lc2goZHJhd1R5cGUpO1xuXHRtZXNoLmJ1ZmZlclZlcnRleChwb3NpdGlvbnMpO1xuXHRtZXNoLmJ1ZmZlclRleENvb3JkKGNvb3Jkcyk7XG5cdG1lc2guYnVmZmVySW5kZXgoaW5kaWNlcyk7XG5cdG1lc2guYnVmZmVyTm9ybWFsKG5vcm1hbHMpO1xuXG5cdHJldHVybiBtZXNoO1xufTtcblxuR2VvbS5zcGhlcmUgPSBmdW5jdGlvbiBzcGhlcmUoc2l6ZSwgbnVtU2VnbWVudHMsIGlzSW52ZXJ0ID0gZmFsc2UsIGRyYXdUeXBlID0gNCkge1xuXHRjb25zdCBwb3NpdGlvbnMgPSBbXTtcblx0Y29uc3QgY29vcmRzICAgID0gW107XG5cdGNvbnN0IGluZGljZXMgICA9IFtdO1xuXHRjb25zdCBub3JtYWxzICAgPSBbXTtcblx0Y29uc3QgZ2FwVVYgICAgID0gMSAvIG51bVNlZ21lbnRzO1xuXHRsZXQgaW5kZXggICAgIFx0PSAwO1xuXHRcblxuXHRmdW5jdGlvbiBnZXRQb3NpdGlvbihpLCBqLCBpc05vcm1hbCA9IGZhbHNlKSB7XHQvL1x0cnggOiAtOTAgfiA5MCAsIHJ5IDogMCB+IDM2MFxuXHRcdGNvbnN0IHJ4ICAgICAgICA9IGkgLyBudW1TZWdtZW50cyAqIE1hdGguUEkgLSBNYXRoLlBJICogMC41O1xuXHRcdGNvbnN0IHJ5ICAgICAgICA9IGogLyBudW1TZWdtZW50cyAqIE1hdGguUEkgKiAyO1xuXHRcdGNvbnN0IHIgICAgICAgICA9IGlzTm9ybWFsID8gMSA6IHNpemU7XG5cdFx0Y29uc3QgcG9zICAgICAgID0gW107XG5cdFx0cG9zWzFdICAgICAgICBcdD0gTWF0aC5zaW4ocngpICogcjtcblx0XHRjb25zdCB0ICAgICAgICAgPSBNYXRoLmNvcyhyeCkgKiByO1xuXHRcdHBvc1swXSAgICAgICAgXHQ9IE1hdGguY29zKHJ5KSAqIHQ7XG5cdFx0cG9zWzJdICAgICAgICBcdD0gTWF0aC5zaW4ocnkpICogdDtcblx0XHRcblx0XHRjb25zdCBwcmVjaXNpb24gPSAxMDAwMDtcblx0XHRwb3NbMF0gICAgICAgID0gTWF0aC5mbG9vcihwb3NbMF0gKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuXHRcdHBvc1sxXSAgICAgICAgPSBNYXRoLmZsb29yKHBvc1sxXSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG5cdFx0cG9zWzJdICAgICAgICA9IE1hdGguZmxvb3IocG9zWzJdICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcblxuXHRcdHJldHVybiBwb3M7XG5cdH07XG5cblx0XG5cdGZvcihsZXQgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG5cdFx0Zm9yKGxldCBqID0gMDsgaiA8IG51bVNlZ21lbnRzOyBqKyspIHtcblx0XHRcdHBvc2l0aW9ucy5wdXNoKGdldFBvc2l0aW9uKGksIGopKTtcblx0XHRcdHBvc2l0aW9ucy5wdXNoKGdldFBvc2l0aW9uKGkgKyAxLCBqKSk7XG5cdFx0XHRwb3NpdGlvbnMucHVzaChnZXRQb3NpdGlvbihpICsgMSwgaiArIDEpKTtcblx0XHRcdHBvc2l0aW9ucy5wdXNoKGdldFBvc2l0aW9uKGksIGogKyAxKSk7XG5cblx0XHRcdG5vcm1hbHMucHVzaChnZXRQb3NpdGlvbihpLCBqLCB0cnVlKSk7XG5cdFx0XHRub3JtYWxzLnB1c2goZ2V0UG9zaXRpb24oaSArIDEsIGosIHRydWUpKTtcblx0XHRcdG5vcm1hbHMucHVzaChnZXRQb3NpdGlvbihpICsgMSwgaiArIDEsIHRydWUpKTtcblx0XHRcdG5vcm1hbHMucHVzaChnZXRQb3NpdGlvbihpLCBqICsgMSwgdHJ1ZSkpO1xuXHRcdFx0XG5cblx0XHRcdGNvbnN0IHUgPSBqIC8gbnVtU2VnbWVudHM7XG5cdFx0XHRjb25zdCB2ID0gaSAvIG51bVNlZ21lbnRzO1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdGNvb3Jkcy5wdXNoKFsxLjAgLSB1LCB2XSk7XG5cdFx0XHRjb29yZHMucHVzaChbMS4wIC0gdSwgdiArIGdhcFVWXSk7XG5cdFx0XHRjb29yZHMucHVzaChbMS4wIC0gdSAtIGdhcFVWLCB2ICsgZ2FwVVZdKTtcblx0XHRcdGNvb3Jkcy5wdXNoKFsxLjAgLSB1IC0gZ2FwVVYsIHZdKTtcblxuXHRcdFx0aW5kaWNlcy5wdXNoKGluZGV4ICogNCArIDApO1xuXHRcdFx0aW5kaWNlcy5wdXNoKGluZGV4ICogNCArIDEpO1xuXHRcdFx0aW5kaWNlcy5wdXNoKGluZGV4ICogNCArIDIpO1xuXHRcdFx0aW5kaWNlcy5wdXNoKGluZGV4ICogNCArIDApO1xuXHRcdFx0aW5kaWNlcy5wdXNoKGluZGV4ICogNCArIDIpO1xuXHRcdFx0aW5kaWNlcy5wdXNoKGluZGV4ICogNCArIDMpO1xuXG5cdFx0XHRpbmRleCsrO1xuXHRcdH1cblx0fVxuXG5cblx0aWYoaXNJbnZlcnQpIHtcblx0XHRpbmRpY2VzLnJldmVyc2UoKTtcblx0fVxuXG5cdGNvbnN0IG1lc2ggPSBuZXcgTWVzaChkcmF3VHlwZSk7XG5cdG1lc2guYnVmZmVyVmVydGV4KHBvc2l0aW9ucyk7XG5cdG1lc2guYnVmZmVyVGV4Q29vcmQoY29vcmRzKTtcblx0bWVzaC5idWZmZXJJbmRleChpbmRpY2VzKTtcblx0bWVzaC5idWZmZXJOb3JtYWwobm9ybWFscyk7XG5cblx0cmV0dXJuIG1lc2g7XG59O1xuXG5HZW9tLmN1YmUgPSBmdW5jdGlvbiBjdWJlKHcsIGgsIGQsIGRyYXdUeXBlID0gNCkge1xuXHRoID0gaCB8fCB3O1xuXHRkID0gZCB8fCB3O1xuXG5cdGNvbnN0IHggPSB3IC8gMjtcblx0Y29uc3QgeSA9IGggLyAyO1xuXHRjb25zdCB6ID0gZCAvIDI7XG5cblx0Y29uc3QgcG9zaXRpb25zID0gW107XG5cdGNvbnN0IGNvb3JkcyAgICA9IFtdO1xuXHRjb25zdCBpbmRpY2VzICAgPSBbXTsgXG5cdGNvbnN0IG5vcm1hbHMgICA9IFtdOyBcblx0bGV0IGNvdW50ICAgICA9IDA7XG5cblxuXHQvLyBCQUNLXG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgIHksIC16XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFt4LCAgeSwgLXpdKTtcblx0cG9zaXRpb25zLnB1c2goW3gsIC15LCAtel0pO1xuXHRwb3NpdGlvbnMucHVzaChbLXgsIC15LCAtel0pO1xuXG5cdG5vcm1hbHMucHVzaChbMCwgMCwgLTFdKTtcblx0bm9ybWFscy5wdXNoKFswLCAwLCAtMV0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDAsIC0xXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMCwgLTFdKTtcblxuXHRjb29yZHMucHVzaChbMCwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMV0pO1xuXHRjb29yZHMucHVzaChbMCwgMV0pO1xuXG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDEpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMyk7XG5cblx0Y291bnQgKys7XG5cblx0Ly8gUklHSFRcblx0cG9zaXRpb25zLnB1c2goW3gsICB5LCAtel0pO1xuXHRwb3NpdGlvbnMucHVzaChbeCwgIHksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFt4LCAteSwgIHpdKTtcblx0cG9zaXRpb25zLnB1c2goW3gsIC15LCAtel0pO1xuXG5cdG5vcm1hbHMucHVzaChbMSwgMCwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzEsIDAsIDBdKTtcblx0bm9ybWFscy5wdXNoKFsxLCAwLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMSwgMCwgMF0pO1xuXG5cdGNvb3Jkcy5wdXNoKFswLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAxXSk7XG5cdGNvb3Jkcy5wdXNoKFswLCAxXSk7XG5cblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMSk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAzKTtcblxuXHRjb3VudCArKztcblxuXHQvLyBGUk9OVFxuXHRwb3NpdGlvbnMucHVzaChbeCwgIHksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgIHksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgLXksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFt4LCAteSwgIHpdKTtcblxuXHRub3JtYWxzLnB1c2goWzAsIDAsIDFdKTtcblx0bm9ybWFscy5wdXNoKFswLCAwLCAxXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMCwgMV0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDAsIDFdKTtcblxuXHRjb29yZHMucHVzaChbMCwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMV0pO1xuXHRjb29yZHMucHVzaChbMCwgMV0pO1xuXG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDEpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMyk7XG5cblx0Y291bnQgKys7XG5cblxuXHQvLyBMRUZUXG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgIHksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgIHksIC16XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgLXksIC16XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgLXksICB6XSk7XG5cblx0bm9ybWFscy5wdXNoKFstMSwgMCwgMF0pO1xuXHRub3JtYWxzLnB1c2goWy0xLCAwLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbLTEsIDAsIDBdKTtcblx0bm9ybWFscy5wdXNoKFstMSwgMCwgMF0pO1xuXG5cdGNvb3Jkcy5wdXNoKFswLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAxXSk7XG5cdGNvb3Jkcy5wdXNoKFswLCAxXSk7XG5cblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMSk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAzKTtcblxuXHRjb3VudCArKztcblxuXHQvLyBUT1Bcblx0cG9zaXRpb25zLnB1c2goW3gsICB5LCAtel0pO1xuXHRwb3NpdGlvbnMucHVzaChbLXgsICB5LCAtel0pO1xuXHRwb3NpdGlvbnMucHVzaChbLXgsICB5LCAgel0pO1xuXHRwb3NpdGlvbnMucHVzaChbeCwgIHksICB6XSk7XG5cblx0bm9ybWFscy5wdXNoKFswLCAxLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMSwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDEsIDBdKTtcblx0bm9ybWFscy5wdXNoKFswLCAxLCAwXSk7XG5cblx0Y29vcmRzLnB1c2goWzAsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDFdKTtcblx0Y29vcmRzLnB1c2goWzAsIDFdKTtcblxuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAxKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDMpO1xuXG5cdGNvdW50ICsrO1xuXG5cdC8vIEJPVFRPTVxuXHRwb3NpdGlvbnMucHVzaChbeCwgLXksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgLXksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgLXksIC16XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFt4LCAteSwgLXpdKTtcblxuXHRub3JtYWxzLnB1c2goWzAsIC0xLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgLTEsIDBdKTtcblx0bm9ybWFscy5wdXNoKFswLCAtMSwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzAsIC0xLCAwXSk7XG5cblx0Y29vcmRzLnB1c2goWzAsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDFdKTtcblx0Y29vcmRzLnB1c2goWzAsIDFdKTtcblxuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAxKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDMpO1xuXG5cdGNvdW50ICsrO1xuXG5cblx0Y29uc3QgbWVzaCA9IG5ldyBNZXNoKGRyYXdUeXBlKTtcblx0bWVzaC5idWZmZXJWZXJ0ZXgocG9zaXRpb25zKTtcblx0bWVzaC5idWZmZXJUZXhDb29yZChjb29yZHMpO1xuXHRtZXNoLmJ1ZmZlckluZGV4KGluZGljZXMpO1xuXHRtZXNoLmJ1ZmZlck5vcm1hbChub3JtYWxzKTtcblxuXHRyZXR1cm4gbWVzaDtcbn07XG5cbkdlb20uc2t5Ym94ID0gZnVuY3Rpb24gc2t5Ym94KHNpemUsIGRyYXdUeXBlID0gNCkge1xuXHRjb25zdCBwb3NpdGlvbnMgPSBbXTtcblx0Y29uc3QgY29vcmRzICAgID0gW107XG5cdGNvbnN0IGluZGljZXMgICA9IFtdOyBcblx0Y29uc3Qgbm9ybWFscyAgID0gW107IFxuXHRsZXQgY291bnQgICAgID0gMDtcblxuXHQvLyBCQUNLXG5cdHBvc2l0aW9ucy5wdXNoKFtzaXplLCAgc2l6ZSwgLXNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goWy1zaXplLCAgc2l6ZSwgLXNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goWy1zaXplLCAtc2l6ZSwgLXNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goW3NpemUsIC1zaXplLCAtc2l6ZV0pO1xuXG5cdG5vcm1hbHMucHVzaChbMCwgMCwgLTFdKTtcblx0bm9ybWFscy5wdXNoKFswLCAwLCAtMV0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDAsIC0xXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMCwgLTFdKTtcblxuXHRjb29yZHMucHVzaChbMCwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMV0pO1xuXHRjb29yZHMucHVzaChbMCwgMV0pO1xuXG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDEpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMyk7XG5cblx0Y291bnQgKys7XG5cblx0Ly8gUklHSFRcblx0cG9zaXRpb25zLnB1c2goW3NpemUsIC1zaXplLCAtc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbc2l6ZSwgLXNpemUsICBzaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFtzaXplLCAgc2l6ZSwgIHNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goW3NpemUsICBzaXplLCAtc2l6ZV0pO1xuXG5cdG5vcm1hbHMucHVzaChbMSwgMCwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzEsIDAsIDBdKTtcblx0bm9ybWFscy5wdXNoKFsxLCAwLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMSwgMCwgMF0pO1xuXG5cdGNvb3Jkcy5wdXNoKFswLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAxXSk7XG5cdGNvb3Jkcy5wdXNoKFswLCAxXSk7XG5cblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMSk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAzKTtcblxuXHRjb3VudCArKztcblxuXHQvLyBGUk9OVFxuXHRwb3NpdGlvbnMucHVzaChbLXNpemUsICBzaXplLCAgc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbc2l6ZSwgIHNpemUsICBzaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFtzaXplLCAtc2l6ZSwgIHNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goWy1zaXplLCAtc2l6ZSwgIHNpemVdKTtcblxuXHRub3JtYWxzLnB1c2goWzAsIDAsIDFdKTtcblx0bm9ybWFscy5wdXNoKFswLCAwLCAxXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMCwgMV0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDAsIDFdKTtcblxuXHRjb29yZHMucHVzaChbMCwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMV0pO1xuXHRjb29yZHMucHVzaChbMCwgMV0pO1xuXG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDEpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMyk7XG5cblx0Y291bnQgKys7XG5cblx0Ly8gTEVGVFxuXHRwb3NpdGlvbnMucHVzaChbLXNpemUsIC1zaXplLCAgc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbLXNpemUsIC1zaXplLCAtc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbLXNpemUsICBzaXplLCAtc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbLXNpemUsICBzaXplLCAgc2l6ZV0pO1xuXG5cdG5vcm1hbHMucHVzaChbLTEsIDAsIDBdKTtcblx0bm9ybWFscy5wdXNoKFstMSwgMCwgMF0pO1xuXHRub3JtYWxzLnB1c2goWy0xLCAwLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbLTEsIDAsIDBdKTtcblxuXHRjb29yZHMucHVzaChbMCwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMV0pO1xuXHRjb29yZHMucHVzaChbMCwgMV0pO1xuXG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDEpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMyk7XG5cblx0Y291bnQgKys7XG5cblx0Ly8gVE9QXG5cdHBvc2l0aW9ucy5wdXNoKFtzaXplLCAgc2l6ZSwgIHNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goWy1zaXplLCAgc2l6ZSwgIHNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goWy1zaXplLCAgc2l6ZSwgLXNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goW3NpemUsICBzaXplLCAtc2l6ZV0pO1xuXG5cdG5vcm1hbHMucHVzaChbMCwgMSwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDEsIDBdKTtcblx0bm9ybWFscy5wdXNoKFswLCAxLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMSwgMF0pO1xuXG5cdGNvb3Jkcy5wdXNoKFswLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAxXSk7XG5cdGNvb3Jkcy5wdXNoKFswLCAxXSk7XG5cblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMSk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAzKTtcblxuXHRjb3VudCArKztcblxuXHQvLyBCT1RUT01cblx0cG9zaXRpb25zLnB1c2goW3NpemUsIC1zaXplLCAtc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbLXNpemUsIC1zaXplLCAtc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbLXNpemUsIC1zaXplLCAgc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbc2l6ZSwgLXNpemUsICBzaXplXSk7XG5cblx0bm9ybWFscy5wdXNoKFswLCAtMSwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzAsIC0xLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgLTEsIDBdKTtcblx0bm9ybWFscy5wdXNoKFswLCAtMSwgMF0pO1xuXG5cdGNvb3Jkcy5wdXNoKFswLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAxXSk7XG5cdGNvb3Jkcy5wdXNoKFswLCAxXSk7XG5cblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMSk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAzKTtcblxuXHRjb25zdCBtZXNoID0gbmV3IE1lc2goZHJhd1R5cGUpO1xuXHRtZXNoLmJ1ZmZlclZlcnRleChwb3NpdGlvbnMpO1xuXHRtZXNoLmJ1ZmZlclRleENvb3JkKGNvb3Jkcyk7XG5cdG1lc2guYnVmZmVySW5kZXgoaW5kaWNlcyk7XG5cdG1lc2guYnVmZmVyTm9ybWFsKG5vcm1hbHMpO1xuXG5cdHJldHVybiBtZXNoO1xufTtcblxuR2VvbS5iaWdUcmlhbmdsZSA9IGZ1bmN0aW9uIGJpZ1RyaWFuZ2xlKCkge1xuXG5cdGlmKCFtZXNoVHJpKSB7XG5cdFx0Y29uc3QgaW5kaWNlcyA9IFsyLCAxLCAwXTtcblx0XHRjb25zdCBwb3NpdGlvbnMgPSBbXG5cdFx0XHRbLTEsIC0xXSwgXG5cdFx0XHRbLTEsIDRdLCBcblx0XHRcdFs0LCAtMV1cblx0XHRdO1xuXHRcdFxuXHRcdG1lc2hUcmkgPSBuZXcgTWVzaCgpO1xuXHRcdG1lc2hUcmkuYnVmZmVyRGF0YShwb3NpdGlvbnMsICdhUG9zaXRpb24nLCAyKTtcblx0XHRtZXNoVHJpLmJ1ZmZlckluZGV4KGluZGljZXMpO1x0XG5cdH1cblx0XG5cblx0cmV0dXJuIG1lc2hUcmk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBHZW9tO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL0dlb20uanMiLCIvLyBzdG9sZW4gdGhlcmUgaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsL2dsLWNvbnN0YW50cyB0aGFua3MgQG1hdHRkZXNsIF5eXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0MDogJ05PTkUnLFxuXHQxOiAnT05FJyxcblx0MjogJ0xJTkVfTE9PUCcsXG5cdDM6ICdMSU5FX1NUUklQJyxcblx0NDogJ1RSSUFOR0xFUycsXG5cdDU6ICdUUklBTkdMRV9TVFJJUCcsXG5cdDY6ICdUUklBTkdMRV9GQU4nLFxuXHQyNTY6ICdERVBUSF9CVUZGRVJfQklUJyxcblx0NTEyOiAnTkVWRVInLFxuXHQ1MTM6ICdMRVNTJyxcblx0NTE0OiAnRVFVQUwnLFxuXHQ1MTU6ICdMRVFVQUwnLFxuXHQ1MTY6ICdHUkVBVEVSJyxcblx0NTE3OiAnTk9URVFVQUwnLFxuXHQ1MTg6ICdHRVFVQUwnLFxuXHQ1MTk6ICdBTFdBWVMnLFxuXHQ3Njg6ICdTUkNfQ09MT1InLFxuXHQ3Njk6ICdPTkVfTUlOVVNfU1JDX0NPTE9SJyxcblx0NzcwOiAnU1JDX0FMUEhBJyxcblx0NzcxOiAnT05FX01JTlVTX1NSQ19BTFBIQScsXG5cdDc3MjogJ0RTVF9BTFBIQScsXG5cdDc3MzogJ09ORV9NSU5VU19EU1RfQUxQSEEnLFxuXHQ3NzQ6ICdEU1RfQ09MT1InLFxuXHQ3NzU6ICdPTkVfTUlOVVNfRFNUX0NPTE9SJyxcblx0Nzc2OiAnU1JDX0FMUEhBX1NBVFVSQVRFJyxcblx0MTAyNDogJ1NURU5DSUxfQlVGRkVSX0JJVCcsXG5cdDEwMjg6ICdGUk9OVCcsXG5cdDEwMjk6ICdCQUNLJyxcblx0MTAzMjogJ0ZST05UX0FORF9CQUNLJyxcblx0MTI4MDogJ0lOVkFMSURfRU5VTScsXG5cdDEyODE6ICdJTlZBTElEX1ZBTFVFJyxcblx0MTI4MjogJ0lOVkFMSURfT1BFUkFUSU9OJyxcblx0MTI4NTogJ09VVF9PRl9NRU1PUlknLFxuXHQxMjg2OiAnSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT04nLFxuXHQyMzA0OiAnQ1cnLFxuXHQyMzA1OiAnQ0NXJyxcblx0Mjg0OTogJ0xJTkVfV0lEVEgnLFxuXHQyODg0OiAnQ1VMTF9GQUNFJyxcblx0Mjg4NTogJ0NVTExfRkFDRV9NT0RFJyxcblx0Mjg4NjogJ0ZST05UX0ZBQ0UnLFxuXHQyOTI4OiAnREVQVEhfUkFOR0UnLFxuXHQyOTI5OiAnREVQVEhfVEVTVCcsXG5cdDI5MzA6ICdERVBUSF9XUklURU1BU0snLFxuXHQyOTMxOiAnREVQVEhfQ0xFQVJfVkFMVUUnLFxuXHQyOTMyOiAnREVQVEhfRlVOQycsXG5cdDI5NjA6ICdTVEVOQ0lMX1RFU1QnLFxuXHQyOTYxOiAnU1RFTkNJTF9DTEVBUl9WQUxVRScsXG5cdDI5NjI6ICdTVEVOQ0lMX0ZVTkMnLFxuXHQyOTYzOiAnU1RFTkNJTF9WQUxVRV9NQVNLJyxcblx0Mjk2NDogJ1NURU5DSUxfRkFJTCcsXG5cdDI5NjU6ICdTVEVOQ0lMX1BBU1NfREVQVEhfRkFJTCcsXG5cdDI5NjY6ICdTVEVOQ0lMX1BBU1NfREVQVEhfUEFTUycsXG5cdDI5Njc6ICdTVEVOQ0lMX1JFRicsXG5cdDI5Njg6ICdTVEVOQ0lMX1dSSVRFTUFTSycsXG5cdDI5Nzg6ICdWSUVXUE9SVCcsXG5cdDMwMjQ6ICdESVRIRVInLFxuXHQzMDQyOiAnQkxFTkQnLFxuXHQzMDg4OiAnU0NJU1NPUl9CT1gnLFxuXHQzMDg5OiAnU0NJU1NPUl9URVNUJyxcblx0MzEwNjogJ0NPTE9SX0NMRUFSX1ZBTFVFJyxcblx0MzEwNzogJ0NPTE9SX1dSSVRFTUFTSycsXG5cdDMzMTc6ICdVTlBBQ0tfQUxJR05NRU5UJyxcblx0MzMzMzogJ1BBQ0tfQUxJR05NRU5UJyxcblx0MzM3OTogJ01BWF9URVhUVVJFX1NJWkUnLFxuXHQzMzg2OiAnTUFYX1ZJRVdQT1JUX0RJTVMnLFxuXHQzNDA4OiAnU1VCUElYRUxfQklUUycsXG5cdDM0MTA6ICdSRURfQklUUycsXG5cdDM0MTE6ICdHUkVFTl9CSVRTJyxcblx0MzQxMjogJ0JMVUVfQklUUycsXG5cdDM0MTM6ICdBTFBIQV9CSVRTJyxcblx0MzQxNDogJ0RFUFRIX0JJVFMnLFxuXHQzNDE1OiAnU1RFTkNJTF9CSVRTJyxcblx0MzU1MzogJ1RFWFRVUkVfMkQnLFxuXHQ0MzUyOiAnRE9OVF9DQVJFJyxcblx0NDM1MzogJ0ZBU1RFU1QnLFxuXHQ0MzU0OiAnTklDRVNUJyxcblx0NTEyMDogJ0JZVEUnLFxuXHQ1MTIxOiAnVU5TSUdORURfQllURScsXG5cdDUxMjI6ICdTSE9SVCcsXG5cdDUxMjM6ICdVTlNJR05FRF9TSE9SVCcsXG5cdDUxMjQ6ICdJTlQnLFxuXHQ1MTI1OiAnVU5TSUdORURfSU5UJyxcblx0NTEyNjogJ0ZMT0FUJyxcblx0NTM4NjogJ0lOVkVSVCcsXG5cdDU4OTA6ICdURVhUVVJFJyxcblx0NjQwMTogJ1NURU5DSUxfSU5ERVgnLFxuXHQ2NDAyOiAnREVQVEhfQ09NUE9ORU5UJyxcblx0NjQwMzogJ1JFRCcsXG5cdDY0MDY6ICdBTFBIQScsXG5cdDY0MDc6ICdSR0InLFxuXHQ2NDA4OiAnUkdCQScsXG5cdDY0MDk6ICdMVU1JTkFOQ0UnLFxuXHQ2NDEwOiAnTFVNSU5BTkNFX0FMUEhBJyxcblx0NzY4MDogJ0tFRVAnLFxuXHQ3NjgxOiAnUkVQTEFDRScsXG5cdDc2ODI6ICdJTkNSJyxcblx0NzY4MzogJ0RFQ1InLFxuXHQ3OTM2OiAnVkVORE9SJyxcblx0NzkzNzogJ1JFTkRFUkVSJyxcblx0NzkzODogJ1ZFUlNJT04nLFxuXHQ5NzI4OiAnTkVBUkVTVCcsXG5cdDk3Mjk6ICdMSU5FQVInLFxuXHQ5OTg0OiAnTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCcsXG5cdDk5ODU6ICdMSU5FQVJfTUlQTUFQX05FQVJFU1QnLFxuXHQ5OTg2OiAnTkVBUkVTVF9NSVBNQVBfTElORUFSJyxcblx0OTk4NzogJ0xJTkVBUl9NSVBNQVBfTElORUFSJyxcblx0MTAyNDA6ICdURVhUVVJFX01BR19GSUxURVInLFxuXHQxMDI0MTogJ1RFWFRVUkVfTUlOX0ZJTFRFUicsXG5cdDEwMjQyOiAnVEVYVFVSRV9XUkFQX1MnLFxuXHQxMDI0MzogJ1RFWFRVUkVfV1JBUF9UJyxcblx0MTA0OTc6ICdSRVBFQVQnLFxuXHQxMDc1MjogJ1BPTFlHT05fT0ZGU0VUX1VOSVRTJyxcblx0MTYzODQ6ICdDT0xPUl9CVUZGRVJfQklUJyxcblx0MzI3Njk6ICdDT05TVEFOVF9DT0xPUicsXG5cdDMyNzcwOiAnT05FX01JTlVTX0NPTlNUQU5UX0NPTE9SJyxcblx0MzI3NzE6ICdDT05TVEFOVF9BTFBIQScsXG5cdDMyNzcyOiAnT05FX01JTlVTX0NPTlNUQU5UX0FMUEhBJyxcblx0MzI3NzM6ICdCTEVORF9DT0xPUicsXG5cdDMyNzc0OiAnRlVOQ19BREQnLFxuXHQzMjc3NzogJ0JMRU5EX0VRVUFUSU9OX1JHQicsXG5cdDMyNzc4OiAnRlVOQ19TVUJUUkFDVCcsXG5cdDMyNzc5OiAnRlVOQ19SRVZFUlNFX1NVQlRSQUNUJyxcblx0MzI4MTk6ICdVTlNJR05FRF9TSE9SVF80XzRfNF80Jyxcblx0MzI4MjA6ICdVTlNJR05FRF9TSE9SVF81XzVfNV8xJyxcblx0MzI4MjM6ICdQT0xZR09OX09GRlNFVF9GSUxMJyxcblx0MzI4MjQ6ICdQT0xZR09OX09GRlNFVF9GQUNUT1InLFxuXHQzMjg1NDogJ1JHQkE0Jyxcblx0MzI4NTU6ICdSR0I1X0ExJyxcblx0MzI4NzM6ICdURVhUVVJFX0JJTkRJTkdfMkQnLFxuXHQzMjkyNjogJ1NBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRScsXG5cdDMyOTI4OiAnU0FNUExFX0NPVkVSQUdFJyxcblx0MzI5MzY6ICdTQU1QTEVfQlVGRkVSUycsXG5cdDMyOTM3OiAnU0FNUExFUycsXG5cdDMyOTM4OiAnU0FNUExFX0NPVkVSQUdFX1ZBTFVFJyxcblx0MzI5Mzk6ICdTQU1QTEVfQ09WRVJBR0VfSU5WRVJUJyxcblx0MzI5Njg6ICdCTEVORF9EU1RfUkdCJyxcblx0MzI5Njk6ICdCTEVORF9TUkNfUkdCJyxcblx0MzI5NzA6ICdCTEVORF9EU1RfQUxQSEEnLFxuXHQzMjk3MTogJ0JMRU5EX1NSQ19BTFBIQScsXG5cdDMzMDcxOiAnQ0xBTVBfVE9fRURHRScsXG5cdDMzMTcwOiAnR0VORVJBVEVfTUlQTUFQX0hJTlQnLFxuXHQzMzE4OTogJ0RFUFRIX0NPTVBPTkVOVDE2Jyxcblx0MzMzMDY6ICdERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQnLFxuXHQzMzMyMTogJ1I4Jyxcblx0MzM2MzU6ICdVTlNJR05FRF9TSE9SVF81XzZfNScsXG5cdDMzNjQ4OiAnTUlSUk9SRURfUkVQRUFUJyxcblx0MzM5MDE6ICdBTElBU0VEX1BPSU5UX1NJWkVfUkFOR0UnLFxuXHQzMzkwMjogJ0FMSUFTRURfTElORV9XSURUSF9SQU5HRScsXG5cdDMzOTg0OiAnVEVYVFVSRTAnLFxuXHQzMzk4NTogJ1RFWFRVUkUxJyxcblx0MzM5ODY6ICdURVhUVVJFMicsXG5cdDMzOTg3OiAnVEVYVFVSRTMnLFxuXHQzMzk4ODogJ1RFWFRVUkU0Jyxcblx0MzM5ODk6ICdURVhUVVJFNScsXG5cdDMzOTkwOiAnVEVYVFVSRTYnLFxuXHQzMzk5MTogJ1RFWFRVUkU3Jyxcblx0MzM5OTI6ICdURVhUVVJFOCcsXG5cdDMzOTkzOiAnVEVYVFVSRTknLFxuXHQzMzk5NDogJ1RFWFRVUkUxMCcsXG5cdDMzOTk1OiAnVEVYVFVSRTExJyxcblx0MzM5OTY6ICdURVhUVVJFMTInLFxuXHQzMzk5NzogJ1RFWFRVUkUxMycsXG5cdDMzOTk4OiAnVEVYVFVSRTE0Jyxcblx0MzM5OTk6ICdURVhUVVJFMTUnLFxuXHQzNDAwMDogJ1RFWFRVUkUxNicsXG5cdDM0MDAxOiAnVEVYVFVSRTE3Jyxcblx0MzQwMDI6ICdURVhUVVJFMTgnLFxuXHQzNDAwMzogJ1RFWFRVUkUxOScsXG5cdDM0MDA0OiAnVEVYVFVSRTIwJyxcblx0MzQwMDU6ICdURVhUVVJFMjEnLFxuXHQzNDAwNjogJ1RFWFRVUkUyMicsXG5cdDM0MDA3OiAnVEVYVFVSRTIzJyxcblx0MzQwMDg6ICdURVhUVVJFMjQnLFxuXHQzNDAwOTogJ1RFWFRVUkUyNScsXG5cdDM0MDEwOiAnVEVYVFVSRTI2Jyxcblx0MzQwMTE6ICdURVhUVVJFMjcnLFxuXHQzNDAxMjogJ1RFWFRVUkUyOCcsXG5cdDM0MDEzOiAnVEVYVFVSRTI5Jyxcblx0MzQwMTQ6ICdURVhUVVJFMzAnLFxuXHQzNDAxNTogJ1RFWFRVUkUzMScsXG5cdDM0MDE2OiAnQUNUSVZFX1RFWFRVUkUnLFxuXHQzNDAyNDogJ01BWF9SRU5ERVJCVUZGRVJfU0laRScsXG5cdDM0MDQxOiAnREVQVEhfU1RFTkNJTCcsXG5cdDM0MDU1OiAnSU5DUl9XUkFQJyxcblx0MzQwNTY6ICdERUNSX1dSQVAnLFxuXHQzNDA2NzogJ1RFWFRVUkVfQ1VCRV9NQVAnLFxuXHQzNDA2ODogJ1RFWFRVUkVfQklORElOR19DVUJFX01BUCcsXG5cdDM0MDY5OiAnVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YJyxcblx0MzQwNzA6ICdURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1gnLFxuXHQzNDA3MTogJ1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWScsXG5cdDM0MDcyOiAnVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZJyxcblx0MzQwNzM6ICdURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1onLFxuXHQzNDA3NDogJ1RFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWicsXG5cdDM0MDc2OiAnTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRScsXG5cdDM0MzM4OiAnVkVSVEVYX0FUVFJJQl9BUlJBWV9FTkFCTEVEJyxcblx0MzQzMzk6ICdWRVJURVhfQVRUUklCX0FSUkFZX1NJWkUnLFxuXHQzNDM0MDogJ1ZFUlRFWF9BVFRSSUJfQVJSQVlfU1RSSURFJyxcblx0MzQzNDE6ICdWRVJURVhfQVRUUklCX0FSUkFZX1RZUEUnLFxuXHQzNDM0MjogJ0NVUlJFTlRfVkVSVEVYX0FUVFJJQicsXG5cdDM0MzczOiAnVkVSVEVYX0FUVFJJQl9BUlJBWV9QT0lOVEVSJyxcblx0MzQ0NjY6ICdOVU1fQ09NUFJFU1NFRF9URVhUVVJFX0ZPUk1BVFMnLFxuXHQzNDQ2NzogJ0NPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTJyxcblx0MzQ2NjA6ICdCVUZGRVJfU0laRScsXG5cdDM0NjYxOiAnQlVGRkVSX1VTQUdFJyxcblx0MzQ4MTY6ICdTVEVOQ0lMX0JBQ0tfRlVOQycsXG5cdDM0ODE3OiAnU1RFTkNJTF9CQUNLX0ZBSUwnLFxuXHQzNDgxODogJ1NURU5DSUxfQkFDS19QQVNTX0RFUFRIX0ZBSUwnLFxuXHQzNDgxOTogJ1NURU5DSUxfQkFDS19QQVNTX0RFUFRIX1BBU1MnLFxuXHQzNDg3NzogJ0JMRU5EX0VRVUFUSU9OX0FMUEhBJyxcblx0MzQ5MjE6ICdNQVhfVkVSVEVYX0FUVFJJQlMnLFxuXHQzNDkyMjogJ1ZFUlRFWF9BVFRSSUJfQVJSQVlfTk9STUFMSVpFRCcsXG5cdDM0OTMwOiAnTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMnLFxuXHQzNDk2MjogJ0FSUkFZX0JVRkZFUicsXG5cdDM0OTYzOiAnRUxFTUVOVF9BUlJBWV9CVUZGRVInLFxuXHQzNDk2NDogJ0FSUkFZX0JVRkZFUl9CSU5ESU5HJyxcblx0MzQ5NjU6ICdFTEVNRU5UX0FSUkFZX0JVRkZFUl9CSU5ESU5HJyxcblx0MzQ5NzU6ICdWRVJURVhfQVRUUklCX0FSUkFZX0JVRkZFUl9CSU5ESU5HJyxcblx0MzUwNDA6ICdTVFJFQU1fRFJBVycsXG5cdDM1MDQ0OiAnU1RBVElDX0RSQVcnLFxuXHQzNTA0ODogJ0RZTkFNSUNfRFJBVycsXG5cdDM1NjMyOiAnRlJBR01FTlRfU0hBREVSJyxcblx0MzU2MzM6ICdWRVJURVhfU0hBREVSJyxcblx0MzU2NjA6ICdNQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMnLFxuXHQzNTY2MTogJ01BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTJyxcblx0MzU2NjM6ICdTSEFERVJfVFlQRScsXG5cdDM1NjY0OiAnRkxPQVRfVkVDMicsXG5cdDM1NjY1OiAnRkxPQVRfVkVDMycsXG5cdDM1NjY2OiAnRkxPQVRfVkVDNCcsXG5cdDM1NjY3OiAnSU5UX1ZFQzInLFxuXHQzNTY2ODogJ0lOVF9WRUMzJyxcblx0MzU2Njk6ICdJTlRfVkVDNCcsXG5cdDM1NjcwOiAnQk9PTCcsXG5cdDM1NjcxOiAnQk9PTF9WRUMyJyxcblx0MzU2NzI6ICdCT09MX1ZFQzMnLFxuXHQzNTY3MzogJ0JPT0xfVkVDNCcsXG5cdDM1Njc0OiAnRkxPQVRfTUFUMicsXG5cdDM1Njc1OiAnRkxPQVRfTUFUMycsXG5cdDM1Njc2OiAnRkxPQVRfTUFUNCcsXG5cdDM1Njc4OiAnU0FNUExFUl8yRCcsXG5cdDM1NjgwOiAnU0FNUExFUl9DVUJFJyxcblx0MzU3MTI6ICdERUxFVEVfU1RBVFVTJyxcblx0MzU3MTM6ICdDT01QSUxFX1NUQVRVUycsXG5cdDM1NzE0OiAnTElOS19TVEFUVVMnLFxuXHQzNTcxNTogJ1ZBTElEQVRFX1NUQVRVUycsXG5cdDM1NzE2OiAnSU5GT19MT0dfTEVOR1RIJyxcblx0MzU3MTc6ICdBVFRBQ0hFRF9TSEFERVJTJyxcblx0MzU3MTg6ICdBQ1RJVkVfVU5JRk9STVMnLFxuXHQzNTcxOTogJ0FDVElWRV9VTklGT1JNX01BWF9MRU5HVEgnLFxuXHQzNTcyMDogJ1NIQURFUl9TT1VSQ0VfTEVOR1RIJyxcblx0MzU3MjE6ICdBQ1RJVkVfQVRUUklCVVRFUycsXG5cdDM1NzIyOiAnQUNUSVZFX0FUVFJJQlVURV9NQVhfTEVOR1RIJyxcblx0MzU3MjQ6ICdTSEFESU5HX0xBTkdVQUdFX1ZFUlNJT04nLFxuXHQzNTcyNTogJ0NVUlJFTlRfUFJPR1JBTScsXG5cdDM2MDAzOiAnU1RFTkNJTF9CQUNLX1JFRicsXG5cdDM2MDA0OiAnU1RFTkNJTF9CQUNLX1ZBTFVFX01BU0snLFxuXHQzNjAwNTogJ1NURU5DSUxfQkFDS19XUklURU1BU0snLFxuXHQzNjAwNjogJ0ZSQU1FQlVGRkVSX0JJTkRJTkcnLFxuXHQzNjAwNzogJ1JFTkRFUkJVRkZFUl9CSU5ESU5HJyxcblx0MzYwNDg6ICdGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX09CSkVDVF9UWVBFJyxcblx0MzYwNDk6ICdGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX09CSkVDVF9OQU1FJyxcblx0MzYwNTA6ICdGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX1RFWFRVUkVfTEVWRUwnLFxuXHQzNjA1MTogJ0ZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfVEVYVFVSRV9DVUJFX01BUF9GQUNFJyxcblx0MzYwNTM6ICdGUkFNRUJVRkZFUl9DT01QTEVURScsXG5cdDM2MDU0OiAnRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UJyxcblx0MzYwNTU6ICdGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVCcsXG5cdDM2MDU3OiAnRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TJyxcblx0MzYwNjE6ICdGUkFNRUJVRkZFUl9VTlNVUFBPUlRFRCcsXG5cdDM2MDY0OiAnQ09MT1JfQVRUQUNITUVOVDAnLFxuXHQzNjA5NjogJ0RFUFRIX0FUVEFDSE1FTlQnLFxuXHQzNjEyODogJ1NURU5DSUxfQVRUQUNITUVOVCcsXG5cdDM2MTYwOiAnRlJBTUVCVUZGRVInLFxuXHQzNjE2MTogJ1JFTkRFUkJVRkZFUicsXG5cdDM2MTYyOiAnUkVOREVSQlVGRkVSX1dJRFRIJyxcblx0MzYxNjM6ICdSRU5ERVJCVUZGRVJfSEVJR0hUJyxcblx0MzYxNjQ6ICdSRU5ERVJCVUZGRVJfSU5URVJOQUxfRk9STUFUJyxcblx0MzYxNjg6ICdTVEVOQ0lMX0lOREVYOCcsXG5cdDM2MTc2OiAnUkVOREVSQlVGRkVSX1JFRF9TSVpFJyxcblx0MzYxNzc6ICdSRU5ERVJCVUZGRVJfR1JFRU5fU0laRScsXG5cdDM2MTc4OiAnUkVOREVSQlVGRkVSX0JMVUVfU0laRScsXG5cdDM2MTc5OiAnUkVOREVSQlVGRkVSX0FMUEhBX1NJWkUnLFxuXHQzNjE4MDogJ1JFTkRFUkJVRkZFUl9ERVBUSF9TSVpFJyxcblx0MzYxODE6ICdSRU5ERVJCVUZGRVJfU1RFTkNJTF9TSVpFJyxcblx0MzYxOTQ6ICdSR0I1NjUnLFxuXHQzNjMzNjogJ0xPV19GTE9BVCcsXG5cdDM2MzM3OiAnTUVESVVNX0ZMT0FUJyxcblx0MzYzMzg6ICdISUdIX0ZMT0FUJyxcblx0MzYzMzk6ICdMT1dfSU5UJyxcblx0MzYzNDA6ICdNRURJVU1fSU5UJyxcblx0MzYzNDE6ICdISUdIX0lOVCcsXG5cdDM2MzQ2OiAnU0hBREVSX0NPTVBJTEVSJyxcblx0MzYzNDc6ICdNQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUycsXG5cdDM2MzQ4OiAnTUFYX1ZBUllJTkdfVkVDVE9SUycsXG5cdDM2MzQ5OiAnTUFYX0ZSQUdNRU5UX1VOSUZPUk1fVkVDVE9SUycsXG5cdDM3NDQwOiAnVU5QQUNLX0ZMSVBfWV9XRUJHTCcsXG5cdDM3NDQxOiAnVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMJyxcblx0Mzc0NDI6ICdDT05URVhUX0xPU1RfV0VCR0wnLFxuXHQzNzQ0MzogJ1VOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0wnLFxuXHQzNzQ0NDogJ0JST1dTRVJfREVGQVVMVF9XRUJHTCdcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvV2ViZ2xOdW1iZXIuanMiLCIvLyBQYXNzLmpzXG5cbmltcG9ydCBHTFNoYWRlciBmcm9tICcuLi9HTFNoYWRlcic7XG5pbXBvcnQgRnJhbWVCdWZmZXIgZnJvbSAnLi4vRnJhbWVCdWZmZXInO1xuaW1wb3J0IFNoYWRlckxpYnMgZnJvbSAnLi4vdXRpbHMvU2hhZGVyTGlicyc7XG5cbmNsYXNzIFBhc3Mge1xuXHRjb25zdHJ1Y3RvcihtU291cmNlLCBtV2lkdGggPSAwLCBtSGVpZ2h0ID0gMCwgbVBhcmFtcyA9IHt9KSB7XG5cdFx0dGhpcy5zaGFkZXIgPSBuZXcgR0xTaGFkZXIoU2hhZGVyTGlicy5iaWdUcmlhbmdsZVZlcnQsIG1Tb3VyY2UpO1xuXG5cdFx0dGhpcy5fd2lkdGggPSBtV2lkdGg7XG5cdFx0dGhpcy5faGVpZ2h0ID0gbUhlaWdodDtcblx0XHR0aGlzLl91bmlmb3JtcyA9IHt9O1xuXHRcdHRoaXMuX2hhc093bkZibyA9IHRoaXMuX3dpZHRoID4gMCAmJiB0aGlzLl93aWR0aCA+IDA7XG5cdFx0dGhpcy5fdW5pZm9ybXMgPSB7fTtcblxuXHRcdGlmICh0aGlzLl9oYXNPd25GYm8pIHtcblx0XHRcdHRoaXMuX2ZibyA9IG5ldyBGcmFtZUJ1ZmZlcih0aGlzLl93aWR0aCwgdGhpcy5oZWlnaHQsIG1QYXJtYXMpO1xuXHRcdH1cblx0fVxuXG5cblx0dW5pZm9ybShtTmFtZSwgbVZhbHVlKSB7XG5cdFx0dGhpcy5fdW5pZm9ybXNbbU5hbWVdID0gbVZhbHVlO1xuXHR9XG5cblxuXHRyZW5kZXIodGV4dHVyZSkge1xuXHRcdHRoaXMuc2hhZGVyLmJpbmQoKTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKCd0ZXh0dXJlJywgJ3VuaWZvcm0xaScsIDApO1xuXHRcdHRleHR1cmUuYmluZCgwKTtcblxuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0odGhpcy5fdW5pZm9ybXMpO1xuXHR9XG5cblx0Z2V0IHdpZHRoKCkge1x0cmV0dXJuIHRoaXMuX3dpZHRoO1x0fVxuXHRnZXQgaGVpZ2h0KCkge1x0cmV0dXJuIHRoaXMuX2hlaWdodDtcdH1cblx0Z2V0IGZibygpIHtcdHJldHVybiB0aGlzLl9mYm87XHR9XG5cdGdldCBoYXNGYm8oKSB7XHRyZXR1cm4gdGhpcy5faGFzT3duRmJvOyB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhc3M7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvcG9zdC9QYXNzLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vIHNpbXBsZUNvbG9yLmZyYWdcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIFNJTVBMRV9DT0xPUlxcblxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudW5pZm9ybSB2ZWMzIGNvbG9yO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCBvcGFjaXR5KTtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3NoYWRlcnMvc2ltcGxlQ29sb3IuZnJhZ1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gYmFzaWMudmVydFxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgQkFTSUNfVkVSVEVYXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuYXR0cmlidXRlIHZlYzMgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuYXR0cmlidXRlIHZlYzMgYU5vcm1hbDtcXG5cXG51bmlmb3JtIG1hdDQgdU1vZGVsTWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1Vmlld01hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVByb2plY3Rpb25NYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIHVWaWV3TWF0cml4ICogdU1vZGVsTWF0cml4ICogdmVjNChhVmVydGV4UG9zaXRpb24sIDEuMCk7XFxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcbiAgICB2Tm9ybWFsID0gYU5vcm1hbDtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3NoYWRlcnMvYmFzaWMudmVydFxuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBGcmFtZUJ1ZmZlci5qc1xuXG5pbXBvcnQgR0wgZnJvbSAnLi9HTFRvb2wnO1xuaW1wb3J0IEdMVGV4dHVyZTIgZnJvbSAnLi9HTFRleHR1cmUyJztcbmltcG9ydCBXZWJnbE51bWJlciBmcm9tICcuL3V0aWxzL1dlYmdsTnVtYmVyJztcblxubGV0IGdsO1xubGV0IHdlYmdsRGVwdGhUZXh0dXJlO1xubGV0IGhhc0NoZWNrZWRNdWx0aVJlbmRlclN1cHBvcnQgPSBmYWxzZTtcbmxldCBleHREcmF3QnVmZmVyO1xuXG5cbmNvbnN0IGNoZWNrTXVsdGlSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG5cdGlmKEdMLndlYmdsMikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGVsc2Uge1xuXHRcdGV4dERyYXdCdWZmZXIgPSBHTC5nZXRFeHRlbnNpb24oJ1dFQkdMX2RyYXdfYnVmZmVycycpO1xuXHRcdHJldHVybiAhIWV4dERyYXdCdWZmZXI7XG5cdH1cblx0XG5cdGhhc0NoZWNrZWRNdWx0aVJlbmRlclN1cHBvcnQgPSB0cnVlO1xufTtcblxuY2xhc3MgRnJhbWVCdWZmZXIge1xuXG5cdGNvbnN0cnVjdG9yKG1XaWR0aCwgbUhlaWdodCwgbVBhcmFtZXRlcnMgPSB7fSwgbU51bVRhcmdldHMgPSAxKSB7XG5cdFx0Z2wgPSBHTC5nbDtcblx0XHR3ZWJnbERlcHRoVGV4dHVyZSA9IEdMLmNoZWNrRXh0ZW5zaW9uKCdXRUJHTF9kZXB0aF90ZXh0dXJlJyk7XG5cblx0XHR0aGlzLndpZHRoICAgICAgICAgICAgPSBtV2lkdGg7XG5cdFx0dGhpcy5oZWlnaHQgICAgICAgICAgID0gbUhlaWdodDtcblx0XHR0aGlzLl9udW1UYXJnZXRzIFx0ICA9IG1OdW1UYXJnZXRzO1xuXHRcdHRoaXMuX211bHRpcGxlVGFyZ2V0cyA9IG1OdW1UYXJnZXRzID4gMTtcblx0XHR0aGlzLl9wYXJhbWV0ZXJzID0gbVBhcmFtZXRlcnM7XG5cblx0XHRpZighaGFzQ2hlY2tlZE11bHRpUmVuZGVyU3VwcG9ydCkge1xuXHRcdFx0Y2hlY2tNdWx0aVJlbmRlcigpO1xuXHRcdH1cblxuXHRcdGlmKHRoaXMuX211bHRpcGxlVGFyZ2V0cykge1xuXHRcdFx0dGhpcy5fY2hlY2tNYXhOdW1SZW5kZXJUYXJnZXQoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9pbml0KCk7XG5cdH1cblxuXG5cdF9pbml0KCkge1xuXHRcdHRoaXMuX2luaXRUZXh0dXJlcygpO1xuXHRcdFxuXHRcdHRoaXMuZnJhbWVCdWZmZXIgICAgICAgID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcdFx0XG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lQnVmZmVyKTtcblxuXHRcdGlmKEdMLndlYmdsMikge1xuXHRcdFx0Ly8gdGhpcy5yZW5kZXJCdWZmZXJEZXB0aCA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuXHRcdFx0Ly8gZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIHRoaXMucmVuZGVyQnVmZmVyRGVwdGgpO1xuXHRcdFx0Ly8gZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIGdsLkRFUFRIX0NPTVBPTkVOVDE2LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cdFx0XHQvLyBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfQVRUQUNITUVOVCwgZ2wuUkVOREVSQlVGRkVSLCB0aGlzLnJlbmRlckJ1ZmZlckRlcHRoKTtcblxuXHRcdFx0Y29uc3QgYnVmZmVycyA9IFtdO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9udW1UYXJnZXRzOyBpKyspIHtcblx0XHRcdFx0Z2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRFJBV19GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpLCBnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlc1tpXS50ZXh0dXJlLCAwKTtcblx0XHRcdFx0YnVmZmVycy5wdXNoKGdsW2BDT0xPUl9BVFRBQ0hNRU5UJHtpfWBdKTtcblx0XHRcdH1cblxuXHRcdFx0Z2wuZHJhd0J1ZmZlcnMoYnVmZmVycyk7XG5cblx0XHRcdGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkRSQVdfRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlRFWFRVUkVfMkQsIHRoaXMuZ2xEZXB0aFRleHR1cmUudGV4dHVyZSwgMCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9udW1UYXJnZXRzOyBpKyspIHtcblx0XHRcdFx0Z2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSwgZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZXNbaV0udGV4dHVyZSwgMCk7XHRcblx0XHRcdH1cblxuXHRcdFx0aWYodGhpcy5fbXVsdGlwbGVUYXJnZXRzKSB7XG5cdFx0XHRcdGNvbnN0IGRyYXdCdWZmZXJzID0gW107XG5cdFx0XHRcdGZvcihsZXQgaT0wOyBpPHRoaXMuX251bVRhcmdldHM7IGkrKykge1xuXHRcdFx0XHRcdGRyYXdCdWZmZXJzLnB1c2goZXh0RHJhd0J1ZmZlcltgQ09MT1JfQVRUQUNITUVOVCR7aX1fV0VCR0xgXSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRleHREcmF3QnVmZmVyLmRyYXdCdWZmZXJzV0VCR0woZHJhd0J1ZmZlcnMpO1x0XG5cdFx0XHR9XG5cblx0XHRcdGlmKHdlYmdsRGVwdGhUZXh0dXJlKSB7XG5cdFx0XHRcdGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9BVFRBQ0hNRU5ULCBnbC5URVhUVVJFXzJELCB0aGlzLmdsRGVwdGhUZXh0dXJlLnRleHR1cmUsIDApO1x0XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXG5cdFx0Ly9cdENIRUNLSU5HIEZCT1xuXHRcdGNvbnN0IEZCT3N0YXR1cyA9IGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpO1xuXHRcdGlmKEZCT3N0YXR1cyAhPSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURSkge1xuXHRcdFx0Y29uc29sZS5lcnJvcignR0xfRlJBTUVCVUZGRVJfQ09NUExFVEUgZmFpbGVkLCBDQU5OT1QgdXNlIEZyYW1lYnVmZmVyJywgV2ViZ2xOdW1iZXJbRkJPc3RhdHVzXSk7XG5cdFx0fVxuXG5cdFx0Ly9cdFVOQklORFxuXG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cdFx0Z2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIG51bGwpO1xuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cblx0XHRcblx0XHQvL1x0Q0xFQVIgRlJBTUVCVUZGRVIgXG5cblx0XHR0aGlzLmNsZWFyKCk7XG5cdH1cblxuXHRfY2hlY2tNYXhOdW1SZW5kZXJUYXJnZXQoKSB7XG5cdFx0Y29uc3QgbWF4TnVtRHJhd0J1ZmZlcnMgPSBHTC5nbC5nZXRQYXJhbWV0ZXIoZXh0RHJhd0J1ZmZlci5NQVhfRFJBV19CVUZGRVJTX1dFQkdMKTtcblx0XHRpZih0aGlzLl9udW1UYXJnZXRzID4gbWF4TnVtRHJhd0J1ZmZlcnMpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ092ZXIgbWF4IG51bWJlciBvZiBkcmF3IGJ1ZmZlcnMgc3VwcG9ydGVkIDogJywgbWF4TnVtRHJhd0J1ZmZlcnMpO1xuXHRcdFx0dGhpcy5fbnVtVGFyZ2V0cyA9IG1heE51bURyYXdCdWZmZXJzO1xuXHRcdH1cblx0fVxuXG5cdF9pbml0VGV4dHVyZXMoKSB7XG5cdFx0dGhpcy5fdGV4dHVyZXMgPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX251bVRhcmdldHM7IGkrKykge1xuXHRcdFx0Y29uc3QgZ2x0ID0gdGhpcy5fY3JlYXRlVGV4dHVyZSgpO1xuXHRcdFx0dGhpcy5fdGV4dHVyZXMucHVzaChnbHQpO1xuXHRcdH1cblxuXHRcdFxuXHRcdGlmKEdMLndlYmdsMikgeyBcblx0XHRcdHRoaXMuZ2xEZXB0aFRleHR1cmUgPSB0aGlzLl9jcmVhdGVUZXh0dXJlKGdsLkRFUFRIX0NPTVBPTkVOVDE2LCBnbC5VTlNJR05FRF9TSE9SVCwgZ2wuREVQVEhfQ09NUE9ORU5ULCB0cnVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5nbERlcHRoVGV4dHVyZSA9IHRoaXMuX2NyZWF0ZVRleHR1cmUoZ2wuREVQVEhfQ09NUE9ORU5ULCBnbC5VTlNJR05FRF9TSE9SVCwgZ2wuREVQVEhfQ09NUE9ORU5ULCB7IG1pbkZpbHRlcjpHTC5MSU5FQVIgfSk7XG5cdFx0fVxuXHR9XG5cblx0X2NyZWF0ZVRleHR1cmUobUludGVybmFsZm9ybWF0LCBtVGV4ZWxUeXBlLCBtRm9ybWF0LCBtUGFyYW1ldGVycyA9IHt9KSB7XG5cdFx0Y29uc3QgcGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX3BhcmFtZXRlcnMpO1xuXHRcdGlmKCFtRm9ybWF0KSB7XHRtRm9ybWF0ID0gbUludGVybmFsZm9ybWF0OyB9XG5cdFx0XG5cdFx0cGFyYW1ldGVycy5pbnRlcm5hbEZvcm1hdCA9IG1JbnRlcm5hbGZvcm1hdCB8fCBnbC5SR0JBO1xuXHRcdHBhcmFtZXRlcnMuZm9ybWF0ID0gbUZvcm1hdDtcblx0XHRwYXJhbWV0ZXJzLnR5cGUgPSBtVGV4ZWxUeXBlIHx8IHBhcmFtZXRlcnMudHlwZSB8fCBHTC5VTlNJR05FRF9CWVRFO1xuXHRcdGZvcihjb25zdCBzIGluIG1QYXJhbWV0ZXJzKSB7XG5cdFx0XHRwYXJhbWV0ZXJzW3NdID0gbVBhcmFtZXRlcnNbc107XG5cdFx0fVxuXG5cdFx0Y29uc3QgdGV4dHVyZSA9IG5ldyBHTFRleHR1cmUyKG51bGwsIHBhcmFtZXRlcnMsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0XHRyZXR1cm4gdGV4dHVyZTtcblx0fVxuXG5cdC8vXHRQVUJMSUMgTUVUSE9EU1xuXG5cdGJpbmQobUF1dG9TZXRWaWV3cG9ydD10cnVlKSB7XG5cdFx0aWYobUF1dG9TZXRWaWV3cG9ydCkge1xuXHRcdFx0R0wudmlld3BvcnQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1x0XG5cdFx0fVxuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZUJ1ZmZlcik7XG5cdH1cblxuXG5cdHVuYmluZChtQXV0b1NldFZpZXdwb3J0PXRydWUpIHtcblx0XHRpZihtQXV0b1NldFZpZXdwb3J0KSB7XG5cdFx0XHRHTC52aWV3cG9ydCgwLCAwLCBHTC53aWR0aCwgR0wuaGVpZ2h0KTtcdFxuXHRcdH1cblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXG5cdFx0dGhpcy5fdGV4dHVyZXMuZm9yRWFjaCh0ZXh0dXJlID0+IHtcblx0XHRcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXAoKTtcblx0XHR9KTtcblx0fVxuXG5cblx0Y2xlYXIociA9IDAsIGcgPSAwLCBiID0gMCwgYSA9IDApIHtcblx0XHR0aGlzLmJpbmQoKTtcblx0XHRHTC5jbGVhcihyLCBnLCBiLCBhKTtcblx0XHR0aGlzLnVuYmluZCgpO1xuXHR9XHRcblxuXG5cdC8vXHRURVhUVVJFU1xuXG5cdGdldFRleHR1cmUobUluZGV4ID0gMCkge1xuXHRcdHJldHVybiB0aGlzLl90ZXh0dXJlc1ttSW5kZXhdO1xuXHR9XG5cblx0Z2V0RGVwdGhUZXh0dXJlKCkge1xuXHRcdHJldHVybiB0aGlzLmdsRGVwdGhUZXh0dXJlO1xuXHR9XG5cblx0Ly9cdFRPVUdIVFMgOiBTaG91bGQgSSByZW1vdmUgdGhlc2UgZnJvbSBmcmFtZSBidWZmZXIgPyBcblx0Ly9cdFNob3VsZG4ndCB0aGVzZSBiZSBzZXQgaW5kaXZpZHVhbGx5IHRvIGVhY2ggdGV4dHVyZSA/IFxuXHQvL1x0ZS5nLiBmYm8uZ2V0VGV4dHVyZSgwKS5taW5GaWx0ZXIgPSBHTC5ORUFSRVNUO1xuXHQvL1x0XHQgZmJvLmdldFRleHR1cmUoMSkubWluRmlsdGVyID0gR0wuTElORUFSOyAuLi4gZXRjID8gXG5cblx0Ly9cdE1JUE1BUCBGSUxURVJcblxuXHRnZXQgbWluRmlsdGVyKCkge1x0cmV0dXJuIHRoaXMuX3RleHR1cmVzWzBdLm1pbkZpbHRlcjtcdH1cblxuXHRzZXQgbWluRmlsdGVyKG1WYWx1ZSkge1xuXHRcdHRoaXMuX3RleHR1cmVzLmZvckVhY2godGV4dHVyZSA9PiB7XG5cdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IG1WYWx1ZTtcblx0XHR9KTtcblx0fVxuXG5cdGdldCBtYWdGaWx0ZXIoKSB7XHRyZXR1cm4gdGhpcy5fdGV4dHVyZXNbMF0ubWFnRmlsdGVyO1x0fVxuXG5cdHNldCBtYWdGaWx0ZXIobVZhbHVlKSB7XG5cdFx0dGhpcy5fdGV4dHVyZXMuZm9yRWFjaCh0ZXh0dXJlID0+IHtcblx0XHRcdHRleHR1cmUubWFnRmlsdGVyID0gbVZhbHVlO1xuXHRcdH0pO1xuXHR9XG5cblxuXHQvL1x0V1JBUFBJTkdcblxuXHRnZXQgd3JhcFMoKSB7XHRyZXR1cm4gdGhpcy5fdGV4dHVyZXNbMF0ud3JhcFM7XHR9XG5cblx0c2V0IHdyYXBTKG1WYWx1ZSkge1xuXHRcdHRoaXMuX3RleHR1cmVzLmZvckVhY2godGV4dHVyZSA9PiB7XG5cdFx0XHR0ZXh0dXJlLndyYXBTID0gbVZhbHVlO1xuXHRcdH0pO1xuXHR9XG5cblxuXHRnZXQgd3JhcFQoKSB7XHRyZXR1cm4gdGhpcy5fdGV4dHVyZXNbMF0ud3JhcFQ7XHR9XG5cblx0c2V0IHdyYXBUKG1WYWx1ZSkge1xuXHRcdHRoaXMuX3RleHR1cmVzLmZvckVhY2godGV4dHVyZSA9PiB7XG5cdFx0XHR0ZXh0dXJlLndyYXBUID0gbVZhbHVlO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly9cdFVUSUxTXG5cblx0c2hvd1BhcmFtZXRlcnMoKSB7XG5cdFx0dGhpcy5fdGV4dHVyZXNbMF0uc2hvd1BhcmFtZXRlcnMoKTtcblx0fVxuXG5cdGdldCBudW1UYXJnZXRzKCkge1x0cmV0dXJuIHRoaXMuX251bVRhcmdldHM7XHR9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgRnJhbWVCdWZmZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvRnJhbWVCdWZmZXIuanMiLCIvLyBFYXNlTnVtYmVyLmpzXG5cbmltcG9ydCBTY2hlZHVsZXIgZnJvbSAnc2NoZWR1bGluZyc7XG5cbmNsYXNzIEVhc2VOdW1iZXIge1xuXHRjb25zdHJ1Y3RvcihtVmFsdWUsIG1FYXNpbmcgPSAwLjEpIHtcblx0XHR0aGlzLmVhc2luZyAgICAgICA9IG1FYXNpbmc7XG5cdFx0dGhpcy5fdmFsdWUgICAgICAgPSBtVmFsdWU7XG5cdFx0dGhpcy5fdGFyZ2V0VmFsdWUgPSBtVmFsdWU7XG5cdFx0dGhpcy5fZWZJbmRleCAgICAgPSBTY2hlZHVsZXIuYWRkRUYoKCk9PiB0aGlzLl91cGRhdGUoKSk7XG5cdH1cblxuXG5cdF91cGRhdGUoKSB7XG5cdFx0Y29uc3QgTUlOX0RJRkYgPSAwLjAwMDE7XG5cdFx0dGhpcy5fY2hlY2tMaW1pdCgpO1xuXHRcdHRoaXMuX3ZhbHVlICs9ICh0aGlzLl90YXJnZXRWYWx1ZSAtIHRoaXMuX3ZhbHVlKSAqIHRoaXMuZWFzaW5nO1x0XG5cdFx0aWYoTWF0aC5hYnModGhpcy5fdGFyZ2V0VmFsdWUgLSB0aGlzLl92YWx1ZSkgPCBNSU5fRElGRikge1xuXHRcdFx0dGhpcy5fdmFsdWUgPSB0aGlzLl90YXJnZXRWYWx1ZTtcblx0XHR9XG5cdH1cblxuXHRzZXRUbyhtVmFsdWUpIHtcblx0XHR0aGlzLl90YXJnZXRWYWx1ZSA9IHRoaXMuX3ZhbHVlID0gbVZhbHVlO1xuXHR9XG5cblxuXHRhZGQobUFkZCkge1xuXHRcdHRoaXMuX3RhcmdldFZhbHVlICs9IG1BZGQ7XG5cdH1cblxuXHRsaW1pdChtTWluLCBtTWF4KSB7XG5cdFx0aWYobU1pbiA+IG1NYXgpIHtcblx0XHRcdHRoaXMubGltaXQobU1heCwgbU1pbik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fbWluID0gbU1pbjtcblx0XHR0aGlzLl9tYXggPSBtTWF4O1xuXG5cdFx0dGhpcy5fY2hlY2tMaW1pdCgpO1xuXHR9XG5cblxuXHRfY2hlY2tMaW1pdCgpIHtcblx0XHRpZih0aGlzLl9taW4gIT09IHVuZGVmaW5lZCAmJiB0aGlzLl90YXJnZXRWYWx1ZSA8IHRoaXMuX21pbikge1xuXHRcdFx0dGhpcy5fdGFyZ2V0VmFsdWUgPSB0aGlzLl9taW47XG5cdFx0fSBcblxuXHRcdGlmKHRoaXMuX21heCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX3RhcmdldFZhbHVlID4gdGhpcy5fbWF4KSB7XG5cdFx0XHR0aGlzLl90YXJnZXRWYWx1ZSA9IHRoaXMuX21heDtcblx0XHR9IFxuXHR9XG5cblxuXHRkZXN0cm95KCkge1xuXHRcdFNjaGVkdWxlci5yZW1vdmVFRih0aGlzLl9lZkluZGV4KTtcblx0fVxuXG5cblx0Ly9cdEdFVFRFUlMgLyBTRVRURVJTXG5cblx0c2V0IHZhbHVlKG1WYWx1ZSkge1xuXHRcdHRoaXMuX3RhcmdldFZhbHVlID0gbVZhbHVlO1xuXHR9XG5cblx0Z2V0IHZhbHVlKCkge1xuXHRcdHJldHVybiB0aGlzLl92YWx1ZTtcblx0fVxuXG5cdGdldCB0YXJnZXRWYWx1ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdGFyZ2V0VmFsdWU7XG5cdH1cblxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IEVhc2VOdW1iZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvRWFzZU51bWJlci5qcyIsIi8vIFJheS5qc1xuXG5pbXBvcnQgeyBtYXQ0LCB2ZWMzIH0gZnJvbSAnZ2wtbWF0cml4JztcblxuXG5jb25zdCBhID0gdmVjMy5jcmVhdGUoKTtcbmNvbnN0IGIgPSB2ZWMzLmNyZWF0ZSgpO1xuY29uc3QgYyA9IHZlYzMuY3JlYXRlKCk7XG5jb25zdCB0YXJnZXQgPSB2ZWMzLmNyZWF0ZSgpO1xuY29uc3QgZWRnZTEgPSB2ZWMzLmNyZWF0ZSgpO1xuY29uc3QgZWRnZTIgPSB2ZWMzLmNyZWF0ZSgpO1xuY29uc3Qgbm9ybWFsID0gdmVjMy5jcmVhdGUoKTtcbmNvbnN0IGRpZmYgPSB2ZWMzLmNyZWF0ZSgpO1xuXG5jbGFzcyBSYXkge1xuXHRjb25zdHJ1Y3RvcihtT3JpZ2luLCBtRGlyZWN0aW9uKSB7XG5cdFx0dGhpcy5vcmlnaW4gPSB2ZWMzLmNsb25lKG1PcmlnaW4pO1xuXHRcdHRoaXMuZGlyZWN0aW9uID0gdmVjMy5jbG9uZShtRGlyZWN0aW9uKTtcblx0fVxuXG5cdGF0KHQpIHtcblx0XHR2ZWMzLmNvcHkodGFyZ2V0LCB0aGlzLmRpcmVjdGlvbik7XG5cdFx0dmVjMy5zY2FsZSh0YXJnZXQsIHRhcmdldCwgdCk7XG5cdFx0dmVjMy5hZGQodGFyZ2V0LCB0YXJnZXQsIHRoaXMub3JpZ2luKTtcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH1cblxuXG5cdGxvb2tBdChtVGFyZ2V0KSB7XG5cdFx0dmVjMy5zdWIodGhpcy5kaXJlY3Rpb24sIG1UYXJnZXQsIHRoaXMub3JpZ2luKTtcblx0XHR2ZWMzLm5vcm1hbGl6ZSh0aGlzLm9yaWdpbiwgdGhpcy5vcmlnaW4pO1xuXHR9XG5cblx0Y2xvc2VzdFBvaW50VG9Qb2ludChtUG9pbnQpIHtcblx0XHRjb25zdCByZXN1bHQgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdHZlYzMuc3ViKG1Qb2ludCwgdGhpcy5vcmlnaW4pO1xuXHRcdGNvbnN0IGRpcmVjdGlvbkRpc3RhbmNlID0gdmVjMy5kb3QocmVzdWx0LCB0aGlzLmRpcmVjdGlvbik7XG5cblx0XHRpZiAoZGlyZWN0aW9uRGlzdGFuY2UgPCAwKSB7XG5cdFx0XHRyZXR1cm4gdmVjMy5jbG9uZSh0aGlzLm9yaWdpbik7XG5cdFx0fVxuXG5cdFx0dmVjMy5jb3B5KHJlc3VsdCwgdGhpcy5kaXJlY3Rpb24pO1xuXHRcdHZlYzMuc2NhbGUocmVzdWx0LCByZXN1bHQsIGRpcmVjdGlvbkRpc3RhbmNlKTtcblx0XHR2ZWMzLmFkZChyZXN1bHQsIHJlc3VsdCwgdGhpcy5vcmlnaW4pO1xuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cblx0ZGlzdGFuY2VUb1BvaW50KG1Qb2ludCkge1xuXHRcdHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0YW5jZVNxVG9Qb2ludChtUG9pbnQpKTtcblx0fVxuXG5cblx0ZGlzdGFuY2VTcVRvUG9pbnQobVBvaW50KSB7XG5cdFx0Y29uc3QgdjEgPSB2ZWMzLmNyZWF0ZSgpO1xuXG5cdFx0dmVjMy5zdWIodjEsIG1Qb2ludCwgdGhpcy5vcmlnaW4pO1xuXHRcdGNvbnN0IGRpcmVjdGlvbkRpc3RhbmNlID0gdmVjMy5kb3QodjEsIHRoaXMuZGlyZWN0aW9uKTtcblxuXHRcdGlmIChkaXJlY3Rpb25EaXN0YW5jZSA8IDApIHtcblx0XHRcdHJldHVybiB2ZWMzLnNxdWFyZWREaXN0YW5jZSh0aGlzLm9yaWdpbiwgbVBvaW50KTtcblx0XHR9XG5cblx0XHR2ZWMzLmNvcHkodjEsIHRoaXMuZGlyZWN0aW9uKTtcblx0XHR2ZWMzLnNjYWxlKHYxLCB2MSwgZGlyZWN0aW9uRGlzdGFuY2UpO1xuXHRcdHZlYzMuYWRkKHYxLCB2MSwgdGhpcy5vcmlnaW4pO1xuXHRcdHJldHVybiB2ZWMzLnNxdWFyZWREaXN0YW5jZSh2MSwgbVBvaW50KTtcblx0fVxuXG5cblx0aW50ZXJzZWN0c1NwaGVyZShtQ2VudGVyLCBtUmFkaXVzKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KG1DZW50ZXIpIDw9IG1SYWRpdXM7XG5cdH1cblxuXG5cdGludGVyc2VjdFNwaGVyZShtQ2VudGVyLCBtUmFkaXVzKSB7XG5cdFx0Y29uc3QgdjEgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdHZlYzMuc3ViKHYxLCBtQ2VudGVyLCB0aGlzLm9yaWdpbik7XG5cdFx0Y29uc3QgdGNhID0gdmVjMy5kb3QodjEsIHRoaXMuZGlyZWN0aW9uKTtcblx0XHRjb25zdCBkMiA9IHZlYzMuZG90KHYxLCB2MSkgLSB0Y2EgKiB0Y2E7XG5cdFx0Y29uc3QgcmFkaXVzMiA9IG1SYWRpdXMgKiBtUmFkaXVzO1xuXG5cdFx0aWYoZDIgPiByYWRpdXMyKSByZXR1cm4gbnVsbDtcblxuXHRcdGNvbnN0IHRoYyA9IE1hdGguc3FydChyYWRpdXMyIC0gZDIpO1xuXG5cdFx0Y29uc3QgdDAgPSB0Y2EgLSB0aGM7XG5cblx0XHRjb25zdCB0MSA9IHRjYSArIHRoYztcblxuXHRcdGlmKHQwIDwgMCAmJiB0MSA8IDApIHJldHVybiBudWxsO1xuXG5cdFx0aWYodDAgPCAwKSByZXR1cm4gdGhpcy5hdCh0MSk7XG5cblx0XHRyZXR1cm4gdGhpcy5hdCh0MCk7XG5cdH1cblxuXG5cdGRpc3RhbmNlVG9QbGFuZShtUGxhbmVDZW50ZXIsIG1Ob3JtYWwpIHtcblx0XHRjb25zdCBkZW5vbWluYXRvciA9IHZlYzMuZG90KG1Ob3JtYWwsIHRoaXMuZGlyZWN0aW9uKTtcblxuXHRcdGlmKGRlbm9taW5hdG9yID09PSAwKSB7XG5cdFx0fVxuXHR9XG5cblxuXHRpbnRlcnNlY3RUcmlhbmdsZShtUEEsIG1QQiwgbVBDLCBiYWNrZmFjZUN1bGxpbmcgPSB0cnVlKSB7XG5cdFx0dmVjMy5jb3B5KGEsIG1QQSk7XG5cdFx0dmVjMy5jb3B5KGIsIG1QQik7XG5cdFx0dmVjMy5jb3B5KGMsIG1QQyk7XG5cblx0XHQvLyBjb25zdCBlZGdlMSA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0Ly8gY29uc3QgZWRnZTIgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdC8vIGNvbnN0IG5vcm1hbCA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0Ly8gY29uc3QgZGlmZiA9IHZlYzMuY3JlYXRlKCk7XG5cblx0XHR2ZWMzLnN1YihlZGdlMSwgYiwgYSk7XG5cdFx0dmVjMy5zdWIoZWRnZTIsIGMsIGEpO1xuXHRcdHZlYzMuY3Jvc3Mobm9ybWFsLCBlZGdlMSwgZWRnZTIpO1xuXG5cdFx0bGV0IERkTiA9IHZlYzMuZG90KHRoaXMuZGlyZWN0aW9uLCBub3JtYWwpO1xuXHRcdGxldCBzaWduO1xuXG5cdFx0aWYgKERkTiA+IDApIHtcblx0XHRcdGlmIChiYWNrZmFjZUN1bGxpbmcpIHtcdHJldHVybiBudWxsO1x0fVxuXHRcdFx0c2lnbiA9IDE7XG5cdFx0fSBlbHNlIGlmIChEZE4gPCAwKSB7XG5cdFx0XHRzaWduID0gLTE7XG5cdFx0XHREZE4gPSAtIERkTjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0dmVjMy5zdWIoZGlmZiwgdGhpcy5vcmlnaW4sIGEpO1xuXG5cdFx0dmVjMy5jcm9zcyhlZGdlMiwgZGlmZiwgZWRnZTIpO1xuXHRcdGNvbnN0IERkUXhFMiA9IHNpZ24gKiB2ZWMzLmRvdCh0aGlzLmRpcmVjdGlvbiwgZWRnZTIpO1xuXHRcdGlmIChEZFF4RTIgPCAwKSB7IFx0cmV0dXJuIG51bGw7IFx0fVxuXG5cdFx0dmVjMy5jcm9zcyhlZGdlMSwgZWRnZTEsIGRpZmYpO1xuXHRcdGNvbnN0IERkRTF4USA9IHNpZ24gKiB2ZWMzLmRvdCh0aGlzLmRpcmVjdGlvbiwgZWRnZTEpO1xuXHRcdGlmIChEZEUxeFEgPCAwKSB7XHRyZXR1cm4gbnVsbDtcdH1cblxuXHRcdGlmKERkUXhFMiArIERkRTF4USA+IERkTikge1x0cmV0dXJuIG51bGw7XHR9XG5cblx0XHRjb25zdCBRZG4gPSAtIHNpZ24gKiB2ZWMzLmRvdChkaWZmLCBub3JtYWwpO1xuXHRcdGlmKFFkbiA8IDApIHtcdHJldHVybiBudWxsO1x0fVxuXG5cdFx0cmV0dXJuIHRoaXMuYXQoUWRuIC8gRGROKTtcblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJheTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL21hdGgvUmF5LmpzIiwiLy8gQ2FtZXJhLmpzXG5cbmltcG9ydCB7IG1hdDQsIG1hdDMsIHF1YXQgfSBmcm9tICdnbC1tYXRyaXgnO1xuXG5jbGFzcyBDYW1lcmEge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHQvL1x0VklFVyBNQVRSSVhcblx0XHR0aGlzLl9tYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuXG5cdFx0Ly9cdEZPUiBUUkFOU0ZPUk0gRlJPTSBPUklFTlRBVElPTlxuXHRcdHRoaXMuX3F1YXQgPSBxdWF0LmNyZWF0ZSgpO1xuXHRcdHRoaXMuX29yaWVudGF0aW9uID0gbWF0NC5jcmVhdGUoKTtcblxuXHRcdC8vXHRQUk9KRUNUSU9OIE1BVFJJWFxuXHRcdHRoaXMuX3Byb2plY3Rpb24gPSBtYXQ0LmNyZWF0ZSgpO1xuXG5cdFx0Ly9cdFBPU0lUSU9OIE9GIENBTUVSQVxuXHRcdHRoaXMucG9zaXRpb24gPSB2ZWMzLmNyZWF0ZSgpO1xuXHR9XG5cblxuXHRsb29rQXQoYUV5ZSwgYUNlbnRlciwgYVVwID0gWzAsIDEsIDBdKSB7XG5cdFx0dGhpcy5fZXllID0gdmVjMy5jbG9uZShhRXllKTtcblx0XHR0aGlzLl9jZW50ZXIgPSB2ZWMzLmNsb25lKGFDZW50ZXIpO1xuXG5cdFx0dmVjMy5jb3B5KHRoaXMucG9zaXRpb24sIGFFeWUpO1xuXHRcdG1hdDQuaWRlbnRpdHkodGhpcy5fbWF0cml4KTtcblx0XHRtYXQ0Lmxvb2tBdCh0aGlzLl9tYXRyaXgsIGFFeWUsIGFDZW50ZXIsIGFVcCk7XG5cdH1cblxuXG5cdHNldEZyb21PcmllbnRhdGlvbih4LCB5LCB6LCB3KSB7XG5cdFx0cXVhdC5zZXQodGhpcy5fcXVhdCwgeCwgeSwgeiwgdyk7XG5cdFx0bWF0NC5mcm9tUXVhdCh0aGlzLl9vcmllbnRhdGlvbiwgdGhpcy5fcXVhdCk7XG5cdFx0bWF0NC50cmFuc2xhdGUodGhpcy5fbWF0cml4LCB0aGlzLl9vcmllbnRhdGlvbiwgdGhpcy5wb3NpdGlvbk9mZnNldCk7XG5cdH1cblxuXG5cdHNldFByb2plY3Rpb24obVByb2opIHtcblx0XHR0aGlzLl9wcm9qZWN0aW9uID0gbWF0NC5jbG9uZShtUHJvaik7XG5cdH1cblxuXG5cdHNldFZpZXcobVZpZXcpIHtcblx0XHR0aGlzLl9tYXRyaXggPSBtYXQ0LmNsb25lKG1WaWV3KTtcblx0fVxuXHRcblxuXHRzZXRGcm9tVmlld1Byb2oobVZpZXcsIG1Qcm9qKSB7XG5cdFx0dGhpcy5zZXRWaWV3KG1WaWV3KTtcblx0XHR0aGlzLnNldFByb2plY3Rpb24obVByb2opO1xuXHR9XG5cblxuXHQvL1x0R0VUVEVSUyBcblxuXHRnZXQgbWF0cml4KCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXRyaXg7XG5cdH1cblxuXHRnZXQgdmlld01hdHJpeCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4O1xuXHR9XG5cblxuXHRnZXQgcHJvamVjdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcHJvamVjdGlvbjtcblx0fSBcblxuXHRnZXQgcHJvamVjdGlvbk1hdHJpeCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcHJvamVjdGlvbjtcblx0fSBcblxuXG5cdGdldCBleWUoKSB7XHRyZXR1cm4gdGhpcy5fZXllO1x0fVxuXG5cdGdldCBjZW50ZXIoKSB7XHRyZXR1cm4gdGhpcy5fY2VudGVyO1x0fVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IENhbWVyYTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9jYW1lcmFzL0NhbWVyYS5qcyIsIi8vIENhbWVyYVBlcnNwZWN0aXZlLmpzXG5cbmltcG9ydCBDYW1lcmEgZnJvbSAnLi9DYW1lcmEnO1xuaW1wb3J0IFJheSBmcm9tICcuLi9tYXRoL1JheSc7XG5pbXBvcnQgeyBtYXQ0LCB2ZWMzIH0gZnJvbSAnZ2wtbWF0cml4JztcblxuY29uc3QgbUludmVyc2VWaWV3UHJvaiA9IG1hdDQuY3JlYXRlKCk7XG5jb25zdCBjYW1lcmFEaXIgPSB2ZWMzLmNyZWF0ZSgpO1xuXG5cbmNsYXNzIENhbWVyYVBlcnNwZWN0aXZlIGV4dGVuZHMgQ2FtZXJhIHtcblxuXHRzZXRQZXJzcGVjdGl2ZShtRm92LCBtQXNwZWN0UmF0aW8sIG1OZWFyLCBtRmFyKSB7XG5cdFx0XG5cdFx0dGhpcy5fZm92ICAgICAgICAgPSBtRm92O1xuXHRcdHRoaXMuX25lYXIgICAgICAgID0gbU5lYXI7XG5cdFx0dGhpcy5fZmFyICAgICAgICAgPSBtRmFyO1xuXHRcdHRoaXMuX2FzcGVjdFJhdGlvID0gbUFzcGVjdFJhdGlvO1xuXHRcdG1hdDQucGVyc3BlY3RpdmUodGhpcy5fcHJvamVjdGlvbiwgbUZvdiwgbUFzcGVjdFJhdGlvLCBtTmVhciwgbUZhcik7XG5cblx0XHQvLyB0aGlzLl9mcnVzdHVtVG9wID0gdGhpcy5fbmVhciAqIE1hdGgudGFuKHRoaXMuX2ZvdiAqIDAuNSk7XG5cdFx0Ly8gdGhpcy5fZnJ1c3R1bUJ1dHRvbSA9IC10aGlzLl9mcnVzdHVtVG9wO1xuXHRcdC8vIHRoaXMuX2ZydXN0dW1SaWdodCA9IHRoaXMuX2ZydXN0dW1Ub3AgKiB0aGlzLl9hc3BlY3RSYXRpbztcblx0XHQvLyB0aGlzLl9mcnVzdHVtTGVmdCA9IC10aGlzLl9mcnVzdHVtUmlnaHQ7XG5cdH1cblxuXG5cdHNldEFzcGVjdFJhdGlvKG1Bc3BlY3RSYXRpbykge1xuXHRcdHRoaXMuX2FzcGVjdFJhdGlvID0gbUFzcGVjdFJhdGlvO1xuXHRcdG1hdDQucGVyc3BlY3RpdmUodGhpcy5wcm9qZWN0aW9uLCB0aGlzLl9mb3YsIG1Bc3BlY3RSYXRpbywgdGhpcy5fbmVhciwgdGhpcy5fZmFyKTtcblx0fVxuXG5cblx0Z2VuZXJhdGVSYXkobVNjcmVlblBvc2l0aW9uLCBtUmF5KSB7XG5cdFx0Y29uc3QgcHJvaiA9IHRoaXMucHJvamVjdGlvbk1hdHJpeDtcblx0XHRjb25zdCB2aWV3ID0gdGhpcy52aWV3TWF0cml4O1xuXG5cdFx0bWF0NC5tdWx0aXBseShtSW52ZXJzZVZpZXdQcm9qLCBwcm9qLCB2aWV3KTtcblx0XHRtYXQ0LmludmVydChtSW52ZXJzZVZpZXdQcm9qLCBtSW52ZXJzZVZpZXdQcm9qKTtcblxuXHRcdHZlYzMudHJhbnNmb3JtTWF0NChjYW1lcmFEaXIsIG1TY3JlZW5Qb3NpdGlvbiwgbUludmVyc2VWaWV3UHJvaik7XG5cdFx0dmVjMy5zdWIoY2FtZXJhRGlyLCBjYW1lcmFEaXIsIHRoaXMucG9zaXRpb24pO1xuXHRcdHZlYzMubm9ybWFsaXplKGNhbWVyYURpciwgY2FtZXJhRGlyKTtcblxuXHRcdGlmICghbVJheSkge1xuXHRcdFx0bVJheSA9IG5ldyBSYXkodGhpcy5wb3NpdGlvbiwgY2FtZXJhRGlyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bVJheS5vcmlnaW4gPSB0aGlzLnBvc2l0aW9uO1xuXHRcdFx0bVJheS5kaXJlY3Rpb24gPSBjYW1lcmFEaXI7XG5cdFx0fVxuXG5cblx0XHRyZXR1cm4gbVJheTtcblx0fVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IENhbWVyYVBlcnNwZWN0aXZlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2NhbWVyYXMvQ2FtZXJhUGVyc3BlY3RpdmUuanMiLCIvLyBCaW5hcnlMb2FkZXIuanNcblxuY2xhc3MgQmluYXJ5TG9hZGVyIHtcblxuXHRjb25zdHJ1Y3Rvcihpc0FycmF5QnVmZmVyID0gZmFsc2UpIHtcblx0XHR0aGlzLl9yZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0XHR0aGlzLl9yZXEuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIChlKT0+dGhpcy5fb25Mb2FkZWQoZSkpO1xuXHRcdHRoaXMuX3JlcS5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIChlKT0+dGhpcy5fb25Qcm9ncmVzcyhlKSk7XG5cdFx0aWYoaXNBcnJheUJ1ZmZlcikge1xuXHRcdFx0dGhpcy5fcmVxLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cdFx0fVxuXHR9XHRcblxuXG5cdGxvYWQodXJsLCBjYWxsYmFjaykge1xuXHRcdGNvbnNvbGUubG9nKCdMb2FkaW5nIDogJywgdXJsKTtcblx0XHR0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuXG5cdFx0dGhpcy5fcmVxLm9wZW4oJ0dFVCcsIHVybCk7XG5cdFx0dGhpcy5fcmVxLnNlbmQoKTtcblx0fVxuXG5cblx0X29uTG9hZGVkKCkge1xuXHRcdHRoaXMuX2NhbGxiYWNrKHRoaXMuX3JlcS5yZXNwb25zZSk7XG5cdH1cblxuXHRfb25Qcm9ncmVzcygvKiBlKi8pIHtcblx0XHQvLyBjb25zb2xlLmxvZygnb24gUHJvZ3Jlc3M6JywgKGUubG9hZGVkL2UudG90YWwqMTAwKS50b0ZpeGVkKDIpKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCaW5hcnlMb2FkZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvbG9hZGVycy9CaW5hcnlMb2FkZXIuanMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gYmlnVHJpYW5nbGUudmVydFxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgQklHX1RSSUFOR0xFX1ZFUlRFWFxcblxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuYXR0cmlidXRlIHZlYzIgYVBvc2l0aW9uO1xcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhUG9zaXRpb24sIDAuMCwgMS4wKTtcXG4gICAgdlRleHR1cmVDb29yZCA9IGFQb3NpdGlvbiAqIC41ICsgLjU7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9zaGFkZXJzL2JpZ1RyaWFuZ2xlLnZlcnRcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vIGNvcHkuZnJhZ1xcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgQ09QWV9GUkFHTUVOVFxcblxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleHR1cmVDb29yZCk7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9zaGFkZXJzL2NvcHkuZnJhZ1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBhbGZyaWQuanNcblxuaW1wb3J0ICogYXMgR0xNIFx0XHRcdGZyb20gJ2dsLW1hdHJpeCc7XG5pbXBvcnQgR0wgXHRcdFx0XHRcdGZyb20gJy4vYWxmcmlkL0dMVG9vbCc7XG5pbXBvcnQgR0xTaGFkZXIgXHRcdFx0ZnJvbSAnLi9hbGZyaWQvR0xTaGFkZXInO1xuaW1wb3J0IEdMVGV4dHVyZU9sZCBcdFx0ZnJvbSAnLi9hbGZyaWQvR0xUZXh0dXJlJztcbmltcG9ydCBHTFRleHR1cmUgXHRcdFx0ZnJvbSAnLi9hbGZyaWQvR0xUZXh0dXJlMic7XG5pbXBvcnQgR0xDdWJlVGV4dHVyZSBcdFx0ZnJvbSAnLi9hbGZyaWQvR0xDdWJlVGV4dHVyZSc7XG5pbXBvcnQgTWVzaCBcdFx0XHRcdGZyb20gJy4vYWxmcmlkL01lc2gnO1xuaW1wb3J0IEdlb21cdFx0XHRcdFx0ZnJvbSAnLi9hbGZyaWQvR2VvbSc7XG5pbXBvcnQgQmF0Y2hcdFx0XHRcdGZyb20gJy4vYWxmcmlkL0JhdGNoJztcbmltcG9ydCBGcmFtZUJ1ZmZlclx0XHRcdGZyb20gJy4vYWxmcmlkL0ZyYW1lQnVmZmVyJztcbmltcG9ydCBDdWJlRnJhbWVCdWZmZXJcdFx0ZnJvbSAnLi9hbGZyaWQvQ3ViZUZyYW1lQnVmZmVyJztcblxuLy9cdFdFQkdMIDJcbmltcG9ydCBNdWx0aXNhbXBsZUZyYW1lQnVmZmVyICBmcm9tICcuL2FsZnJpZC9NdWx0aXNhbXBsZUZyYW1lQnVmZmVyJztcbmltcG9ydCBUcmFuc2Zvcm1GZWVkYmFja09iamVjdCBmcm9tICcuL2FsZnJpZC9UcmFuc2Zvcm1GZWVkYmFja09iamVjdCc7XG5cbi8vXHRUT09MU1xuaW1wb3J0IFNjaGVkdWxlciBcdFx0XHRmcm9tICdzY2hlZHVsaW5nJztcbmltcG9ydCBFdmVudERpc3BhdGNoZXIgXHRcdGZyb20gJy4vYWxmcmlkL3V0aWxzL0V2ZW50RGlzcGF0Y2hlcic7XG5pbXBvcnQgRWFzZU51bWJlciBcdFx0XHRmcm9tICcuL2FsZnJpZC91dGlscy9FYXNlTnVtYmVyJztcbmltcG9ydCBUd2Vlbk51bWJlciBcdFx0XHRmcm9tICcuL2FsZnJpZC91dGlscy9Ud2Vlbk51bWJlcic7XG5pbXBvcnQgT3JiaXRhbENvbnRyb2xcdFx0ZnJvbSAnLi9hbGZyaWQvdXRpbHMvT3JiaXRhbENvbnRyb2wnO1xuaW1wb3J0IFF1YXRSb3RhdGlvblx0XHRcdGZyb20gJy4vYWxmcmlkL3V0aWxzL1F1YXRSb3RhdGlvbic7XG5pbXBvcnQgVG91Y2hEZXRlY3Rvclx0XHRmcm9tICcuL2FsZnJpZC91dGlscy9Ub3VjaERldGVjdG9yJztcbmltcG9ydCBXZWJnbE51bWJlclx0XHRcdGZyb20gJy4vYWxmcmlkL3V0aWxzL1dlYmdsTnVtYmVyJztcbmltcG9ydCBXZWJnbENvbnN0XHRcdFx0ZnJvbSAnLi9hbGZyaWQvdXRpbHMvV2ViZ2xDb25zdCc7XG5cbi8vXHRDQU1FUkFTXG5pbXBvcnQgQ2FtZXJhIFx0XHRcdFx0ZnJvbSAnLi9hbGZyaWQvY2FtZXJhcy9DYW1lcmEnO1xuaW1wb3J0IENhbWVyYU9ydGhvIFx0XHRcdGZyb20gJy4vYWxmcmlkL2NhbWVyYXMvQ2FtZXJhT3J0aG8nO1xuaW1wb3J0IENhbWVyYVBlcnNwZWN0aXZlXHRmcm9tICcuL2FsZnJpZC9jYW1lcmFzL0NhbWVyYVBlcnNwZWN0aXZlJztcbmltcG9ydCBDYW1lcmFDdWJlXHRcdFx0ZnJvbSAnLi9hbGZyaWQvY2FtZXJhcy9DYW1lcmFDdWJlJztcblxuLy9cdE1BVEhcbmltcG9ydCBSYXkgXHRcdFx0XHRcdGZyb20gJy4vYWxmcmlkL21hdGgvUmF5JztcblxuLy9cdE9CSkVDVFxuaW1wb3J0IE9iamVjdDNEIFx0XHRcdGZyb20gJy4vYWxmcmlkL29iamVjdHMvT2JqZWN0M0QnO1xuXG4vL1x0TE9BREVSU1xuaW1wb3J0IEJpbmFyeUxvYWRlclx0XHRcdGZyb20gJy4vYWxmcmlkL2xvYWRlcnMvQmluYXJ5TG9hZGVyJztcbmltcG9ydCBPYmpMb2FkZXJcdFx0XHRmcm9tICcuL2FsZnJpZC9sb2FkZXJzL09iakxvYWRlcic7XG5pbXBvcnQgSERSTG9hZGVyXHRcdFx0ZnJvbSAnLi9hbGZyaWQvbG9hZGVycy9IRFJMb2FkZXInO1xuaW1wb3J0IENvbGxhZGFQYXJzZXJcdFx0ZnJvbSAnLi9hbGZyaWQvbG9hZGVycy9Db2xsYWRhUGFyc2VyJztcbmltcG9ydCBHTFRGTG9hZGVyXHRcdFx0ZnJvbSAnLi9hbGZyaWQvbG9hZGVycy9HbHRmTG9hZGVyJztcblxuLy9cdFBPU1QgRUZGRUNUXG5pbXBvcnQgRWZmZWN0Q29tcG9zZXIgXHRcdGZyb20gJy4vYWxmcmlkL3Bvc3QvRWZmZWN0Q29tcG9zZXInO1xuaW1wb3J0IFBhc3MgXHRcdFx0XHRmcm9tICcuL2FsZnJpZC9wb3N0L1Bhc3MnO1xuaW1wb3J0IFBhc3NNYWNybyBcdFx0XHRmcm9tICcuL2FsZnJpZC9wb3N0L1Bhc3NNYWNybyc7XG5pbXBvcnQgUGFzc0JsdXIgXHRcdFx0ZnJvbSAnLi9hbGZyaWQvcG9zdC9QYXNzQmx1cic7XG5pbXBvcnQgUGFzc1ZCbHVyIFx0XHRcdGZyb20gJy4vYWxmcmlkL3Bvc3QvUGFzc1ZCbHVyJztcbmltcG9ydCBQYXNzSEJsdXIgXHRcdFx0ZnJvbSAnLi9hbGZyaWQvcG9zdC9QYXNzSEJsdXInO1xuaW1wb3J0IFBhc3NGeGFhIFx0XHRcdGZyb20gJy4vYWxmcmlkL3Bvc3QvUGFzc0Z4YWEnO1xuXG5cbi8vXHRIRUxQRVJTXG5pbXBvcnQgQmF0Y2hDb3B5XHRcdFx0ZnJvbSAnLi9hbGZyaWQvaGVscGVycy9CYXRjaENvcHknO1xuaW1wb3J0IEJhdGNoQXhpc1x0XHRcdGZyb20gJy4vYWxmcmlkL2hlbHBlcnMvQmF0Y2hBeGlzJztcbmltcG9ydCBCYXRjaEJhbGxcdFx0XHRmcm9tICcuL2FsZnJpZC9oZWxwZXJzL0JhdGNoQmFsbCc7XG5pbXBvcnQgQmF0Y2hEb3RzUGxhbmVcdFx0ZnJvbSAnLi9hbGZyaWQvaGVscGVycy9CYXRjaERvdHNQbGFuZSc7XG5pbXBvcnQgQmF0Y2hMaW5lIFx0XHRcdGZyb20gJy4vYWxmcmlkL2hlbHBlcnMvQmF0Y2hMaW5lJztcbmltcG9ydCBCYXRjaFNreWJveFx0XHRcdGZyb20gJy4vYWxmcmlkL2hlbHBlcnMvQmF0Y2hTa3lib3gnO1xuaW1wb3J0IEJhdGNoU2t5XHRcdFx0XHRmcm9tICcuL2FsZnJpZC9oZWxwZXJzL0JhdGNoU2t5JztcbmltcG9ydCBCYXRjaEZYQUFcdFx0XHRmcm9tICcuL2FsZnJpZC9oZWxwZXJzL0JhdGNoRlhBQSc7XG5pbXBvcnQgU2NlbmVcdFx0XHRcdGZyb20gJy4vYWxmcmlkL2hlbHBlcnMvU2NlbmUnO1xuaW1wb3J0IFZpZXdcdFx0XHRcdFx0ZnJvbSAnLi9hbGZyaWQvaGVscGVycy9WaWV3JztcbmltcG9ydCBWaWV3M0RcdFx0XHRcdGZyb20gJy4vYWxmcmlkL2hlbHBlcnMvVmlldzNEJztcbmltcG9ydCBTaGFkZXJMaWJzXHRcdFx0ZnJvbSAnLi9hbGZyaWQvdXRpbHMvU2hhZGVyTGlicyc7XG5cblxuY29uc3QgVkVSU0lPTiA9ICcwLjIuMCc7XG5cbmNsYXNzIEFsZnJpZCB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuZ2xtICAgICAgICAgICAgICAgPSBHTE07XG5cdFx0dGhpcy5HTCAgICAgICAgICAgICAgICA9IEdMO1xuXHRcdHRoaXMuR0xUb29sICAgICAgICAgICAgPSBHTDtcblx0XHR0aGlzLkdMU2hhZGVyICAgICAgICAgID0gR0xTaGFkZXI7XG5cdFx0dGhpcy5HTFRleHR1cmUgICAgICAgICA9IEdMVGV4dHVyZTtcblx0XHR0aGlzLkdMVGV4dHVyZU9sZCAgICAgID0gR0xUZXh0dXJlT2xkO1xuXHRcdHRoaXMuR0xDdWJlVGV4dHVyZSAgICAgPSBHTEN1YmVUZXh0dXJlO1xuXHRcdHRoaXMuTWVzaCAgICAgICAgICAgICAgPSBNZXNoO1xuXHRcdHRoaXMuR2VvbSAgICAgICAgICAgICAgPSBHZW9tO1xuXHRcdHRoaXMuQmF0Y2ggICAgICAgICAgICAgPSBCYXRjaDtcblx0XHR0aGlzLkZyYW1lQnVmZmVyICAgICAgID0gRnJhbWVCdWZmZXI7XG5cdFx0dGhpcy5DdWJlRnJhbWVCdWZmZXIgICA9IEN1YmVGcmFtZUJ1ZmZlcjtcblx0XHR0aGlzLlNjaGVkdWxlciAgICAgICAgID0gU2NoZWR1bGVyO1xuXHRcdHRoaXMuRXZlbnREaXNwYXRjaGVyICAgPSBFdmVudERpc3BhdGNoZXI7XG5cdFx0dGhpcy5FYXNlTnVtYmVyICAgICAgICA9IEVhc2VOdW1iZXI7XG5cdFx0dGhpcy5Ud2Vlbk51bWJlciAgICAgICA9IFR3ZWVuTnVtYmVyO1xuXHRcdHRoaXMuQ2FtZXJhICAgICAgICAgICAgPSBDYW1lcmE7XG5cdFx0dGhpcy5DYW1lcmFPcnRobyAgICAgICA9IENhbWVyYU9ydGhvO1xuXHRcdHRoaXMuQ2FtZXJhUGVyc3BlY3RpdmUgPSBDYW1lcmFQZXJzcGVjdGl2ZTtcblx0XHR0aGlzLlJheSBcdFx0XHQgICA9IFJheTtcblx0XHR0aGlzLkNhbWVyYUN1YmUgICAgICAgID0gQ2FtZXJhQ3ViZTtcblx0XHR0aGlzLk9yYml0YWxDb250cm9sICAgID0gT3JiaXRhbENvbnRyb2w7XG5cdFx0dGhpcy5RdWF0Um90YXRpb24gICAgICA9IFF1YXRSb3RhdGlvbjtcblx0XHR0aGlzLkJpbmFyeUxvYWRlciAgICAgID0gQmluYXJ5TG9hZGVyO1xuXHRcdHRoaXMuT2JqTG9hZGVyICAgICAgICAgPSBPYmpMb2FkZXI7XG5cdFx0dGhpcy5Db2xsYWRhUGFyc2VyICAgICA9IENvbGxhZGFQYXJzZXI7XG5cdFx0dGhpcy5IRFJMb2FkZXIgICAgICAgICA9IEhEUkxvYWRlcjtcblx0XHR0aGlzLkdMVEZMb2FkZXIgICAgICAgID0gR0xURkxvYWRlcjtcblx0XHR0aGlzLkJhdGNoQ29weSAgICAgICAgID0gQmF0Y2hDb3B5O1xuXHRcdHRoaXMuQmF0Y2hBeGlzICAgICAgICAgPSBCYXRjaEF4aXM7XG5cdFx0dGhpcy5CYXRjaEJhbGwgICAgICAgICA9IEJhdGNoQmFsbDtcblx0XHR0aGlzLkJhdGNoQmFsbCAgICAgICAgID0gQmF0Y2hCYWxsO1xuXHRcdHRoaXMuQmF0Y2hMaW5lICAgICAgICAgPSBCYXRjaExpbmU7XG5cdFx0dGhpcy5CYXRjaFNreWJveCAgICAgICA9IEJhdGNoU2t5Ym94O1xuXHRcdHRoaXMuQmF0Y2hTa3kgICAgICAgICAgPSBCYXRjaFNreTtcblx0XHR0aGlzLkJhdGNoRlhBQSAgICAgICAgID0gQmF0Y2hGWEFBO1xuXHRcdHRoaXMuQmF0Y2hEb3RzUGxhbmUgICAgPSBCYXRjaERvdHNQbGFuZTtcblx0XHR0aGlzLlNjZW5lICAgICAgICAgICAgID0gU2NlbmU7XG5cdFx0dGhpcy5WaWV3ICAgICAgICAgICAgICA9IFZpZXc7XG5cdFx0dGhpcy5WaWV3M0QgICAgICAgICAgICA9IFZpZXczRDtcblx0XHR0aGlzLk9iamVjdDNEICAgICAgICAgID0gT2JqZWN0M0Q7XG5cdFx0dGhpcy5TaGFkZXJMaWJzICAgICAgICA9IFNoYWRlckxpYnM7XG5cdFx0dGhpcy5XZWJnbE51bWJlciAgICAgICA9IFdlYmdsTnVtYmVyO1xuXHRcdFxuXHRcdHRoaXMuRWZmZWN0Q29tcG9zZXIgICAgPSBFZmZlY3RDb21wb3Nlcjtcblx0XHR0aGlzLlBhc3MgICAgICAgIFx0ICAgPSBQYXNzO1xuXHRcdHRoaXMuUGFzc01hY3JvICAgICAgICAgPSBQYXNzTWFjcm87XG5cdFx0dGhpcy5QYXNzQmx1ciAgICAgICAgICA9IFBhc3NCbHVyO1xuXHRcdHRoaXMuUGFzc1ZCbHVyICAgICAgICAgPSBQYXNzVkJsdXI7XG5cdFx0dGhpcy5QYXNzSEJsdXIgICAgICAgICA9IFBhc3NIQmx1cjtcblx0XHR0aGlzLlBhc3NGeGFhICAgICAgICAgID0gUGFzc0Z4YWE7XG5cblx0XHR0aGlzLk11bHRpc2FtcGxlRnJhbWVCdWZmZXIgICA9IE11bHRpc2FtcGxlRnJhbWVCdWZmZXI7XG5cdFx0dGhpcy5UcmFuc2Zvcm1GZWVkYmFja09iamVjdCAgPSBUcmFuc2Zvcm1GZWVkYmFja09iamVjdDtcblxuXG5cdFx0Ly9cdE5PVCBTVVBFUiBTVVJFIEknVkUgRE9ORSBUSElTIElTIEEgR09PRCBXQVlcblxuXHRcdGZvcihjb25zdCBzIGluIEdMTSkge1xuXHRcdFx0aWYoR0xNW3NdKSB7XG5cdFx0XHRcdHdpbmRvd1tzXSA9IEdMTVtzXTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRsb2coKSB7XG5cdFx0aWYobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA+IC0xKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhgJWNsaWIgYWxmcmlkIDogVkVSU0lPTiAke1ZFUlNJT059YCwgJ2JhY2tncm91bmQ6ICMxOTM0NDE7IGNvbG9yOiAjRkNGRkY1Jyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUubG9nKCdsaWIgYWxmcmlkIDogVkVSU0lPTiAnLCBWRVJTSU9OKTtcblx0XHR9XG5cdFx0Y29uc29sZS5sb2coJyVjQ2xhc3NlcyA6ICcsICdjb2xvcjogIzE5MzQ0MScpO1xuXG5cdFx0Zm9yKGNvbnN0IHMgaW4gdGhpcykge1xuXHRcdFx0aWYodGhpc1tzXSkge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhgJWMgLSAke3N9YCwgJ2NvbG9yOiAjM0U2MDZGJyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmNvbnN0IGFsID0gbmV3IEFsZnJpZCgpO1xuXG5leHBvcnQgZGVmYXVsdCBhbDtcbmV4cG9ydCB7XG5cdEdMLFxuXHRHTFNoYWRlcixcblx0R0xUZXh0dXJlLFxuXHRHTFRleHR1cmVPbGQsXG5cdEdMQ3ViZVRleHR1cmUsXG5cdE1lc2gsXG5cdEdlb20sXG5cdEJhdGNoLFxuXHRGcmFtZUJ1ZmZlcixcblx0Q3ViZUZyYW1lQnVmZmVyLFxuXHRNdWx0aXNhbXBsZUZyYW1lQnVmZmVyLFxuXHRUcmFuc2Zvcm1GZWVkYmFja09iamVjdCxcblx0U2NoZWR1bGVyLFxuXHRFdmVudERpc3BhdGNoZXIsXG5cdEVhc2VOdW1iZXIsXG5cdFR3ZWVuTnVtYmVyLFxuXHRPcmJpdGFsQ29udHJvbCxcblx0V2ViZ2xOdW1iZXIsXG5cdFF1YXRSb3RhdGlvbixcblx0VG91Y2hEZXRlY3Rvcixcblx0Q2FtZXJhLFxuXHRDYW1lcmFPcnRobyxcblx0Q2FtZXJhUGVyc3BlY3RpdmUsXG5cdENhbWVyYUN1YmUsXG5cdFJheSxcblx0T2JqZWN0M0QsXG5cdEJpbmFyeUxvYWRlcixcblx0T2JqTG9hZGVyLFxuXHRIRFJMb2FkZXIsXG5cdEdMVEZMb2FkZXIsXG5cdENvbGxhZGFQYXJzZXIsXG5cdEVmZmVjdENvbXBvc2VyLFxuXHRQYXNzLFxuXHRQYXNzTWFjcm8sXG5cdFBhc3NCbHVyLFxuXHRQYXNzVkJsdXIsXG5cdFBhc3NIQmx1cixcblx0UGFzc0Z4YWEsXG5cdEJhdGNoQ29weSxcblx0QmF0Y2hBeGlzLFxuXHRCYXRjaEJhbGwsXG5cdEJhdGNoRG90c1BsYW5lLFxuXHRCYXRjaExpbmUsXG5cdEJhdGNoU2t5Ym94LFxuXHRCYXRjaFNreSxcblx0QmF0Y2hGWEFBLFxuXHRTY2VuZSxcblx0Vmlldyxcblx0VmlldzNELFxuXHRTaGFkZXJMaWJzXG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkLmpzIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxuaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uXCI7XG5cbi8qKlxuICogM3gzIE1hdHJpeFxuICogQG1vZHVsZSBtYXQzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDNcbiAqXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOSk7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDE7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29waWVzIHRoZSB1cHBlci1sZWZ0IDN4MyB2YWx1ZXMgaW50byB0aGUgZ2l2ZW4gbWF0My5cbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIDN4MyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSAgIHRoZSBzb3VyY2UgNHg0IG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbU1hdDQob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbNF07XG4gIG91dFs0XSA9IGFbNV07XG4gIG91dFs1XSA9IGFbNl07XG4gIG91dFs2XSA9IGFbOF07XG4gIG91dFs3XSA9IGFbOV07XG4gIG91dFs4XSA9IGFbMTBdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0M30gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQzfSBhIG5ldyAzeDMgbWF0cml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MyB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWF0MyB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDQpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDIgcG9zaXRpb24gKGluZGV4IDUpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDYpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDcpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDgpXG4gKiBAcmV0dXJucyB7bWF0M30gQSBuZXcgbWF0M1xuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyhtMDAsIG0wMSwgbTAyLCBtMTAsIG0xMSwgbTEyLCBtMjAsIG0yMSwgbTIyKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0wMjtcbiAgb3V0WzNdID0gbTEwO1xuICBvdXRbNF0gPSBtMTE7XG4gIG91dFs1XSA9IG0xMjtcbiAgb3V0WzZdID0gbTIwO1xuICBvdXRbN10gPSBtMjE7XG4gIG91dFs4XSA9IG0yMjtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA1KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA2KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA3KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA4KVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgbTAwLCBtMDEsIG0wMiwgbTEwLCBtMTEsIG0xMiwgbTIwLCBtMjEsIG0yMikge1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMTA7XG4gIG91dFs0XSA9IG0xMTtcbiAgb3V0WzVdID0gbTEyO1xuICBvdXRbNl0gPSBtMjA7XG4gIG91dFs3XSA9IG0yMTtcbiAgb3V0WzhdID0gbTIyO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCBhIG1hdDMgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMTtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LCBhKSB7XG4gIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgaWYgKG91dCA9PT0gYSkge1xuICAgIGxldCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMTIgPSBhWzVdO1xuICAgIG91dFsxXSA9IGFbM107XG4gICAgb3V0WzJdID0gYVs2XTtcbiAgICBvdXRbM10gPSBhMDE7XG4gICAgb3V0WzVdID0gYVs3XTtcbiAgICBvdXRbNl0gPSBhMDI7XG4gICAgb3V0WzddID0gYTEyO1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVszXTtcbiAgICBvdXRbMl0gPSBhWzZdO1xuICAgIG91dFszXSA9IGFbMV07XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzddO1xuICAgIG91dFs2XSA9IGFbMl07XG4gICAgb3V0WzddID0gYVs1XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgbGV0IGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl07XG4gIGxldCBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdO1xuICBsZXQgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XTtcblxuICBsZXQgYjAxID0gYTIyICogYTExIC0gYTEyICogYTIxO1xuICBsZXQgYjExID0gLWEyMiAqIGExMCArIGExMiAqIGEyMDtcbiAgbGV0IGIyMSA9IGEyMSAqIGExMCAtIGExMSAqIGEyMDtcblxuICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gIGxldCBkZXQgPSBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjE7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgb3V0WzBdID0gYjAxICogZGV0O1xuICBvdXRbMV0gPSAoLWEyMiAqIGEwMSArIGEwMiAqIGEyMSkgKiBkZXQ7XG4gIG91dFsyXSA9IChhMTIgKiBhMDEgLSBhMDIgKiBhMTEpICogZGV0O1xuICBvdXRbM10gPSBiMTEgKiBkZXQ7XG4gIG91dFs0XSA9IChhMjIgKiBhMDAgLSBhMDIgKiBhMjApICogZGV0O1xuICBvdXRbNV0gPSAoLWExMiAqIGEwMCArIGEwMiAqIGExMCkgKiBkZXQ7XG4gIG91dFs2XSA9IGIyMSAqIGRldDtcbiAgb3V0WzddID0gKC1hMjEgKiBhMDAgKyBhMDEgKiBhMjApICogZGV0O1xuICBvdXRbOF0gPSAoYTExICogYTAwIC0gYTAxICogYTEwKSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGpvaW50KG91dCwgYSkge1xuICBsZXQgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXTtcbiAgbGV0IGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV07XG4gIGxldCBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdO1xuXG4gIG91dFswXSA9IChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpO1xuICBvdXRbMV0gPSAoYTAyICogYTIxIC0gYTAxICogYTIyKTtcbiAgb3V0WzJdID0gKGEwMSAqIGExMiAtIGEwMiAqIGExMSk7XG4gIG91dFszXSA9IChhMTIgKiBhMjAgLSBhMTAgKiBhMjIpO1xuICBvdXRbNF0gPSAoYTAwICogYTIyIC0gYTAyICogYTIwKTtcbiAgb3V0WzVdID0gKGEwMiAqIGExMCAtIGEwMCAqIGExMik7XG4gIG91dFs2XSA9IChhMTAgKiBhMjEgLSBhMTEgKiBhMjApO1xuICBvdXRbN10gPSAoYTAxICogYTIwIC0gYTAwICogYTIxKTtcbiAgb3V0WzhdID0gKGEwMCAqIGExMSAtIGEwMSAqIGExMCk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIGxldCBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdO1xuICBsZXQgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XTtcbiAgbGV0IGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF07XG5cbiAgcmV0dXJuIGEwMCAqIChhMjIgKiBhMTEgLSBhMTIgKiBhMjEpICsgYTAxICogKC1hMjIgKiBhMTAgKyBhMTIgKiBhMjApICsgYTAyICogKGEyMSAqIGExMCAtIGExMSAqIGEyMCk7XG59XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MydzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIGxldCBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdO1xuICBsZXQgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XTtcbiAgbGV0IGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF07XG5cbiAgbGV0IGIwMCA9IGJbMF0sIGIwMSA9IGJbMV0sIGIwMiA9IGJbMl07XG4gIGxldCBiMTAgPSBiWzNdLCBiMTEgPSBiWzRdLCBiMTIgPSBiWzVdO1xuICBsZXQgYjIwID0gYls2XSwgYjIxID0gYls3XSwgYjIyID0gYls4XTtcblxuICBvdXRbMF0gPSBiMDAgKiBhMDAgKyBiMDEgKiBhMTAgKyBiMDIgKiBhMjA7XG4gIG91dFsxXSA9IGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMTtcbiAgb3V0WzJdID0gYjAwICogYTAyICsgYjAxICogYTEyICsgYjAyICogYTIyO1xuXG4gIG91dFszXSA9IGIxMCAqIGEwMCArIGIxMSAqIGExMCArIGIxMiAqIGEyMDtcbiAgb3V0WzRdID0gYjEwICogYTAxICsgYjExICogYTExICsgYjEyICogYTIxO1xuICBvdXRbNV0gPSBiMTAgKiBhMDIgKyBiMTEgKiBhMTIgKyBiMTIgKiBhMjI7XG5cbiAgb3V0WzZdID0gYjIwICogYTAwICsgYjIxICogYTEwICsgYjIyICogYTIwO1xuICBvdXRbN10gPSBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjE7XG4gIG91dFs4XSA9IGIyMCAqIGEwMiArIGIyMSAqIGExMiArIGIyMiAqIGEyMjtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGUgYSBtYXQzIGJ5IHRoZSBnaXZlbiB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICBsZXQgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXG4gICAgeCA9IHZbMF0sIHkgPSB2WzFdO1xuXG4gIG91dFswXSA9IGEwMDtcbiAgb3V0WzFdID0gYTAxO1xuICBvdXRbMl0gPSBhMDI7XG5cbiAgb3V0WzNdID0gYTEwO1xuICBvdXRbNF0gPSBhMTE7XG4gIG91dFs1XSA9IGExMjtcblxuICBvdXRbNl0gPSB4ICogYTAwICsgeSAqIGExMCArIGEyMDtcbiAgb3V0WzddID0geCAqIGEwMSArIHkgKiBhMTEgKyBhMjE7XG4gIG91dFs4XSA9IHggKiBhMDIgKyB5ICogYTEyICsgYTIyO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQzIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQpIHtcbiAgbGV0IGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdLFxuXG4gICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgYyA9IE1hdGguY29zKHJhZCk7XG5cbiAgb3V0WzBdID0gYyAqIGEwMCArIHMgKiBhMTA7XG4gIG91dFsxXSA9IGMgKiBhMDEgKyBzICogYTExO1xuICBvdXRbMl0gPSBjICogYTAyICsgcyAqIGExMjtcblxuICBvdXRbM10gPSBjICogYTEwIC0gcyAqIGEwMDtcbiAgb3V0WzRdID0gYyAqIGExMSAtIHMgKiBhMDE7XG4gIG91dFs1XSA9IGMgKiBhMTIgLSBzICogYTAyO1xuXG4gIG91dFs2XSA9IGEyMDtcbiAgb3V0WzddID0gYTIxO1xuICBvdXRbOF0gPSBhMjI7XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MyBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIGxldCB4ID0gdlswXSwgeSA9IHZbMV07XG5cbiAgb3V0WzBdID0geCAqIGFbMF07XG4gIG91dFsxXSA9IHggKiBhWzFdO1xuICBvdXRbMl0gPSB4ICogYVsyXTtcblxuICBvdXRbM10gPSB5ICogYVszXTtcbiAgb3V0WzRdID0geSAqIGFbNF07XG4gIG91dFs1XSA9IHkgKiBhWzVdO1xuXG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0My5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQzLnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21UcmFuc2xhdGlvbihvdXQsIHYpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMTtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gdlswXTtcbiAgb3V0WzddID0gdlsxXTtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0My5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIGxldCBzID0gTWF0aC5zaW4ocmFkKSwgYyA9IE1hdGguY29zKHJhZCk7XG5cbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gcztcbiAgb3V0WzJdID0gMDtcblxuICBvdXRbM10gPSAtcztcbiAgb3V0WzRdID0gYztcbiAgb3V0WzVdID0gMDtcblxuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0My5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQzLnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcblxuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB2WzFdO1xuICBvdXRbNV0gPSAwO1xuXG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgZnJvbSBhIG1hdDJkIGludG8gYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byBjb3B5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gZnJvbU1hdDJkKG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSAwO1xuXG4gIG91dFszXSA9IGFbMl07XG4gIG91dFs0XSA9IGFbM107XG4gIG91dFs1XSA9IDA7XG5cbiAgb3V0WzZdID0gYVs0XTtcbiAgb3V0WzddID0gYVs1XTtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4qIENhbGN1bGF0ZXMgYSAzeDMgbWF0cml4IGZyb20gdGhlIGdpdmVuIHF1YXRlcm5pb25cbipcbiogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuKiBAcGFyYW0ge3F1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cbipcbiogQHJldHVybnMge21hdDN9IG91dFxuKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUXVhdChvdXQsIHEpIHtcbiAgbGV0IHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdO1xuICBsZXQgeDIgPSB4ICsgeDtcbiAgbGV0IHkyID0geSArIHk7XG4gIGxldCB6MiA9IHogKyB6O1xuXG4gIGxldCB4eCA9IHggKiB4MjtcbiAgbGV0IHl4ID0geSAqIHgyO1xuICBsZXQgeXkgPSB5ICogeTI7XG4gIGxldCB6eCA9IHogKiB4MjtcbiAgbGV0IHp5ID0geiAqIHkyO1xuICBsZXQgenogPSB6ICogejI7XG4gIGxldCB3eCA9IHcgKiB4MjtcbiAgbGV0IHd5ID0gdyAqIHkyO1xuICBsZXQgd3ogPSB3ICogejI7XG5cbiAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gIG91dFszXSA9IHl4IC0gd3o7XG4gIG91dFs2XSA9IHp4ICsgd3k7XG5cbiAgb3V0WzFdID0geXggKyB3ejtcbiAgb3V0WzRdID0gMSAtIHh4IC0geno7XG4gIG91dFs3XSA9IHp5IC0gd3g7XG5cbiAgb3V0WzJdID0genggLSB3eTtcbiAgb3V0WzVdID0genkgKyB3eDtcbiAgb3V0WzhdID0gMSAtIHh4IC0geXk7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4qIENhbGN1bGF0ZXMgYSAzeDMgbm9ybWFsIG1hdHJpeCAodHJhbnNwb3NlIGludmVyc2UpIGZyb20gdGhlIDR4NCBtYXRyaXhcbipcbiogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuKiBAcGFyYW0ge21hdDR9IGEgTWF0NCB0byBkZXJpdmUgdGhlIG5vcm1hbCBtYXRyaXggZnJvbVxuKlxuKiBAcmV0dXJucyB7bWF0M30gb3V0XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbEZyb21NYXQ0KG91dCwgYSkge1xuICBsZXQgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXTtcbiAgbGV0IGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN107XG4gIGxldCBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV07XG4gIGxldCBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XTtcblxuICBsZXQgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICBsZXQgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICBsZXQgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICBsZXQgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICBsZXQgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICBsZXQgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICBsZXQgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICBsZXQgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICBsZXQgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICBsZXQgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICBsZXQgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICBsZXQgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyO1xuXG4gIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgbGV0IGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGRldCA9IDEuMCAvIGRldDtcblxuICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgb3V0WzFdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gIG91dFsyXSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuXG4gIG91dFszXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICBvdXRbNF0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgb3V0WzVdID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG5cbiAgb3V0WzZdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gIG91dFs3XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICBvdXRbOF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIDJEIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBXaWR0aCBvZiB5b3VyIGdsIGNvbnRleHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIGdsIGNvbnRleHRcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb2plY3Rpb24ob3V0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgb3V0WzBdID0gMiAvIHdpZHRoO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IC0yIC8gaGVpZ2h0O1xuICAgIG91dFs1XSA9IDA7XG4gICAgb3V0WzZdID0gLTE7XG4gICAgb3V0WzddID0gMTtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiAnbWF0MygnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICtcbiAgICAgICAgICBhWzNdICsgJywgJyArIGFbNF0gKyAnLCAnICsgYVs1XSArICcsICcgK1xuICAgICAgICAgIGFbNl0gKyAnLCAnICsgYVs3XSArICcsICcgKyBhWzhdICsgJyknO1xufVxuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybihNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikgKyBNYXRoLnBvdyhhWzRdLCAyKSArIE1hdGgucG93KGFbNV0sIDIpICsgTWF0aC5wb3coYVs2XSwgMikgKyBNYXRoLnBvdyhhWzddLCAyKSArIE1hdGgucG93KGFbOF0sIDIpKSlcbn1cblxuLyoqXG4gKiBBZGRzIHR3byBtYXQzJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gKyBiWzZdO1xuICBvdXRbN10gPSBhWzddICsgYls3XTtcbiAgb3V0WzhdID0gYVs4XSArIGJbOF07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgb3V0WzZdID0gYVs2XSAtIGJbNl07XG4gIG91dFs3XSA9IGFbN10gLSBiWzddO1xuICBvdXRbOF0gPSBhWzhdIC0gYls4XTtcbiAgcmV0dXJuIG91dDtcbn1cblxuXG5cbi8qKlxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIG1hdHJpeCdzIGVsZW1lbnRzIGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhcihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIG91dFs0XSA9IGFbNF0gKiBiO1xuICBvdXRbNV0gPSBhWzVdICogYjtcbiAgb3V0WzZdID0gYVs2XSAqIGI7XG4gIG91dFs3XSA9IGFbN10gKiBiO1xuICBvdXRbOF0gPSBhWzhdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byBtYXQzJ3MgYWZ0ZXIgbXVsdGlwbHlpbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiJ3MgZWxlbWVudHMgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXJBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICBvdXRbM10gPSBhWzNdICsgKGJbM10gKiBzY2FsZSk7XG4gIG91dFs0XSA9IGFbNF0gKyAoYls0XSAqIHNjYWxlKTtcbiAgb3V0WzVdID0gYVs1XSArIChiWzVdICogc2NhbGUpO1xuICBvdXRbNl0gPSBhWzZdICsgKGJbNl0gKiBzY2FsZSk7XG4gIG91dFs3XSA9IGFbN10gKyAoYls3XSAqIHNjYWxlKTtcbiAgb3V0WzhdID0gYVs4XSArIChiWzhdICogc2NhbGUpO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0M30gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmXG4gICAgICAgICBhWzNdID09PSBiWzNdICYmIGFbNF0gPT09IGJbNF0gJiYgYVs1XSA9PT0gYls1XSAmJlxuICAgICAgICAgYVs2XSA9PT0gYls2XSAmJiBhWzddID09PSBiWzddICYmIGFbOF0gPT09IGJbOF07XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7bWF0M30gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQzfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV0sIGE2ID0gYVs2XSwgYTcgPSBhWzddLCBhOCA9IGFbOF07XG4gIGxldCBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM10sIGI0ID0gYls0XSwgYjUgPSBiWzVdLCBiNiA9IGJbNl0sIGI3ID0gYls3XSwgYjggPSBiWzhdO1xuICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTQpLCBNYXRoLmFicyhiNCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTUgLSBiNSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE1KSwgTWF0aC5hYnMoYjUpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGE2IC0gYjYpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNiksIE1hdGguYWJzKGI2KSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhNyAtIGI3KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTcpLCBNYXRoLmFicyhiNykpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTggLSBiOCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE4KSwgTWF0aC5hYnMoYjgpKSk7XG59XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQzLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBtdWwgPSBtdWx0aXBseTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDMuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHN1YiA9IHN1YnRyYWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvbWF0My5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG5pbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb25cIjtcblxuLyoqXG4gKiAzIERpbWVuc2lvbmFsIFZlY3RvclxuICogQG1vZHVsZSB2ZWMzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMzXG4gKlxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIG91dFswXSA9IDA7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gIGxldCB4ID0gYVswXTtcbiAgbGV0IHkgPSBhWzFdO1xuICBsZXQgeiA9IGFbMl07XG4gIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5LCB6KSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMyB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgeCwgeSwgeikge1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKiBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpdmlkZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC8gYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguY2VpbChhWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGZsb29yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbG9vcihvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5mbG9vcihhWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gcm91bmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLnJvdW5kKGFbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzMgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMydzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICBvdXRbMl0gPSBhWzJdICsgKGJbMl0gKiBzY2FsZSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIGxldCB4ID0gYlswXSAtIGFbMF07XG4gIGxldCB5ID0gYlsxXSAtIGFbMV07XG4gIGxldCB6ID0gYlsyXSAtIGFbMl07XG4gIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICBsZXQgeCA9IGJbMF0gLSBhWzBdO1xuICBsZXQgeSA9IGJbMV0gLSBhWzFdO1xuICBsZXQgeiA9IGJbMl0gLSBhWzJdO1xuICByZXR1cm4geCp4ICsgeSp5ICsgeip6O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkTGVuZ3RoKGEpIHtcbiAgbGV0IHggPSBhWzBdO1xuICBsZXQgeSA9IGFbMV07XG4gIGxldCB6ID0gYVsyXTtcbiAgcmV0dXJuIHgqeCArIHkqeSArIHoqejtcbn1cblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICBvdXRbMl0gPSAxLjAgLyBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgbGV0IHggPSBhWzBdO1xuICBsZXQgeSA9IGFbMV07XG4gIGxldCB6ID0gYVsyXTtcbiAgbGV0IGxlbiA9IHgqeCArIHkqeSArIHoqejtcbiAgaWYgKGxlbiA+IDApIHtcbiAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gICAgb3V0WzJdID0gYVsyXSAqIGxlbjtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl07XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICBsZXQgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXTtcbiAgbGV0IGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl07XG5cbiAgb3V0WzBdID0gYXkgKiBieiAtIGF6ICogYnk7XG4gIG91dFsxXSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICBvdXRbMl0gPSBheCAqIGJ5IC0gYXkgKiBieDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gIGxldCBheCA9IGFbMF07XG4gIGxldCBheSA9IGFbMV07XG4gIGxldCBheiA9IGFbMl07XG4gIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSBoZXJtaXRlIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gZCB0aGUgZm91cnRoIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhlcm1pdGUob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gIGxldCBmYWN0b3JUaW1lczIgPSB0ICogdDtcbiAgbGV0IGZhY3RvcjEgPSBmYWN0b3JUaW1lczIgKiAoMiAqIHQgLSAzKSArIDE7XG4gIGxldCBmYWN0b3IyID0gZmFjdG9yVGltZXMyICogKHQgLSAyKSArIHQ7XG4gIGxldCBmYWN0b3IzID0gZmFjdG9yVGltZXMyICogKHQgLSAxKTtcbiAgbGV0IGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiAoMyAtIDIgKiB0KTtcblxuICBvdXRbMF0gPSBhWzBdICogZmFjdG9yMSArIGJbMF0gKiBmYWN0b3IyICsgY1swXSAqIGZhY3RvcjMgKyBkWzBdICogZmFjdG9yNDtcbiAgb3V0WzFdID0gYVsxXSAqIGZhY3RvcjEgKyBiWzFdICogZmFjdG9yMiArIGNbMV0gKiBmYWN0b3IzICsgZFsxXSAqIGZhY3RvcjQ7XG4gIG91dFsyXSA9IGFbMl0gKiBmYWN0b3IxICsgYlsyXSAqIGZhY3RvcjIgKyBjWzJdICogZmFjdG9yMyArIGRbMl0gKiBmYWN0b3I0O1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSBiZXppZXIgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYyB0aGUgdGhpcmQgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBkIHRoZSBmb3VydGggb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmV6aWVyKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICBsZXQgaW52ZXJzZUZhY3RvciA9IDEgLSB0O1xuICBsZXQgaW52ZXJzZUZhY3RvclRpbWVzVHdvID0gaW52ZXJzZUZhY3RvciAqIGludmVyc2VGYWN0b3I7XG4gIGxldCBmYWN0b3JUaW1lczIgPSB0ICogdDtcbiAgbGV0IGZhY3RvcjEgPSBpbnZlcnNlRmFjdG9yVGltZXNUd28gKiBpbnZlcnNlRmFjdG9yO1xuICBsZXQgZmFjdG9yMiA9IDMgKiB0ICogaW52ZXJzZUZhY3RvclRpbWVzVHdvO1xuICBsZXQgZmFjdG9yMyA9IDMgKiBmYWN0b3JUaW1lczIgKiBpbnZlcnNlRmFjdG9yO1xuICBsZXQgZmFjdG9yNCA9IGZhY3RvclRpbWVzMiAqIHQ7XG5cbiAgb3V0WzBdID0gYVswXSAqIGZhY3RvcjEgKyBiWzBdICogZmFjdG9yMiArIGNbMF0gKiBmYWN0b3IzICsgZFswXSAqIGZhY3RvcjQ7XG4gIG91dFsxXSA9IGFbMV0gKiBmYWN0b3IxICsgYlsxXSAqIGZhY3RvcjIgKyBjWzFdICogZmFjdG9yMyArIGRbMV0gKiBmYWN0b3I0O1xuICBvdXRbMl0gPSBhWzJdICogZmFjdG9yMSArIGJbMl0gKiBmYWN0b3IyICsgY1syXSAqIGZhY3RvcjMgKyBkWzJdICogZmFjdG9yNDtcblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb20ob3V0LCBzY2FsZSkge1xuICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcblxuICBsZXQgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgbGV0IHogPSAoZ2xNYXRyaXguUkFORE9NKCkgKiAyLjApIC0gMS4wO1xuICBsZXQgelNjYWxlID0gTWF0aC5zcXJ0KDEuMC16KnopICogc2NhbGU7XG5cbiAgb3V0WzBdID0gTWF0aC5jb3MocikgKiB6U2NhbGU7XG4gIG91dFsxXSA9IE1hdGguc2luKHIpICogelNjYWxlO1xuICBvdXRbMl0gPSB6ICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgbGV0IHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XG4gIGxldCB3ID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdO1xuICB3ID0gdyB8fCAxLjA7XG4gIG91dFswXSA9IChtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSkgLyB3O1xuICBvdXRbMV0gPSAobVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10pIC8gdztcbiAgb3V0WzJdID0gKG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSkgLyB3O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDMuXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQzfSBtIHRoZSAzeDMgbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICBsZXQgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXTtcbiAgb3V0WzBdID0geCAqIG1bMF0gKyB5ICogbVszXSArIHogKiBtWzZdO1xuICBvdXRbMV0gPSB4ICogbVsxXSArIHkgKiBtWzRdICsgeiAqIG1bN107XG4gIG91dFsyXSA9IHggKiBtWzJdICsgeSAqIG1bNV0gKyB6ICogbVs4XTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBxdWF0XG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtxdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVF1YXQob3V0LCBhLCBxKSB7XG4gIC8vIGJlbmNobWFya3M6IGh0dHA6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tdHJhbnNmb3JtLXZlYzMtaW1wbGVtZW50YXRpb25zXG5cbiAgbGV0IHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XG4gIGxldCBxeCA9IHFbMF0sIHF5ID0gcVsxXSwgcXogPSBxWzJdLCBxdyA9IHFbM107XG5cbiAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcbiAgbGV0IGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xuICBsZXQgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG4gIGxldCBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeDtcbiAgbGV0IGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG4gIG91dFswXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XG4gIG91dFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeC1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVYKG91dCwgYSwgYiwgYyl7XG4gIGxldCBwID0gW10sIHI9W107XG4gIC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIHBbMl0gPSBhWzJdIC0gYlsyXTtcblxuICAvL3BlcmZvcm0gcm90YXRpb25cbiAgclswXSA9IHBbMF07XG4gIHJbMV0gPSBwWzFdKk1hdGguY29zKGMpIC0gcFsyXSpNYXRoLnNpbihjKTtcbiAgclsyXSA9IHBbMV0qTWF0aC5zaW4oYykgKyBwWzJdKk1hdGguY29zKGMpO1xuXG4gIC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHktYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIGIsIGMpe1xuICBsZXQgcCA9IFtdLCByPVtdO1xuICAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBwWzJdID0gYVsyXSAtIGJbMl07XG5cbiAgLy9wZXJmb3JtIHJvdGF0aW9uXG4gIHJbMF0gPSBwWzJdKk1hdGguc2luKGMpICsgcFswXSpNYXRoLmNvcyhjKTtcbiAgclsxXSA9IHBbMV07XG4gIHJbMl0gPSBwWzJdKk1hdGguY29zKGMpIC0gcFswXSpNYXRoLnNpbihjKTtcblxuICAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gclsyXSArIGJbMl07XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB6LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCBiLCBjKXtcbiAgbGV0IHAgPSBbXSwgcj1bXTtcbiAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdO1xuXG4gIC8vcGVyZm9ybSByb3RhdGlvblxuICByWzBdID0gcFswXSpNYXRoLmNvcyhjKSAtIHBbMV0qTWF0aC5zaW4oYyk7XG4gIHJbMV0gPSBwWzBdKk1hdGguc2luKGMpICsgcFsxXSpNYXRoLmNvcyhjKTtcbiAgclsyXSA9IHBbMl07XG5cbiAgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICBvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgb3V0WzFdID0gclsxXSArIGJbMV07XG4gIG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBhbmdsZSBiZXR3ZWVuIHR3byAzRCB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gIGxldCB0ZW1wQSA9IGZyb21WYWx1ZXMoYVswXSwgYVsxXSwgYVsyXSk7XG4gIGxldCB0ZW1wQiA9IGZyb21WYWx1ZXMoYlswXSwgYlsxXSwgYlsyXSk7XG5cbiAgbm9ybWFsaXplKHRlbXBBLCB0ZW1wQSk7XG4gIG5vcm1hbGl6ZSh0ZW1wQiwgdGVtcEIpO1xuXG4gIGxldCBjb3NpbmUgPSBkb3QodGVtcEEsIHRlbXBCKTtcblxuICBpZihjb3NpbmUgPiAxLjApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBlbHNlIGlmKGNvc2luZSA8IC0xLjApIHtcbiAgICByZXR1cm4gTWF0aC5QSTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gTWF0aC5hY29zKGNvc2luZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gJ3ZlYzMoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJyknO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl07XG4gIGxldCBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdO1xuICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSk7XG59XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzdWIgPSBzdWJ0cmFjdDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IG11bCA9IG11bHRpcGx5O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGRpdiA9IGRpdmlkZTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGRpc3QgPSBkaXN0YW5jZTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzcXJEaXN0ID0gc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGxlbiA9IGxlbmd0aDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc3FyTGVuID0gc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjM3MuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMy4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzNzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZm9yRWFjaCA9IChmdW5jdGlvbigpIHtcbiAgbGV0IHZlYyA9IGNyZWF0ZSgpO1xuXG4gIHJldHVybiBmdW5jdGlvbihhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICBsZXQgaSwgbDtcbiAgICBpZighc3RyaWRlKSB7XG4gICAgICBzdHJpZGUgPSAzO1xuICAgIH1cblxuICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgaWYoY291bnQpIHtcbiAgICAgIGwgPSBNYXRoLm1pbigoY291bnQgKiBzdHJpZGUpICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICB2ZWNbMF0gPSBhW2ldOyB2ZWNbMV0gPSBhW2krMV07IHZlY1syXSA9IGFbaSsyXTtcbiAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdOyBhW2krMl0gPSB2ZWNbMl07XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH07XG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvdmVjMy5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG5pbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb25cIjtcblxuLyoqXG4gKiA0IERpbWVuc2lvbmFsIFZlY3RvclxuICogQG1vZHVsZSB2ZWM0XG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWM0XG4gKlxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IDA7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWM0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWM0IGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHksIHosIHcpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICBvdXRbM10gPSB3O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWM0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzQgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgeCwgeSwgeiwgdykge1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICBvdXRbM10gPSB3O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gIG91dFszXSA9IGFbM10gKiBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpdmlkZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC8gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAvIGJbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNlaWxcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmNlaWwoYVsyXSk7XG4gIG91dFszXSA9IE1hdGguY2VpbChhWzNdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGZsb29yXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbG9vcihvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5mbG9vcihhWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5mbG9vcihhWzNdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gIG91dFszXSA9IE1hdGgubWluKGFbM10sIGJbM10pO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5tYXgoYVszXSwgYlszXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byByb3VuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGgucm91bmQoYVsyXSk7XG4gIG91dFszXSA9IE1hdGgucm91bmQoYVszXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjNCBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQWRkcyB0d28gdmVjNCdzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICBvdXRbMl0gPSBhWzJdICsgKGJbMl0gKiBzY2FsZSk7XG4gIG91dFszXSA9IGFbM10gKyAoYlszXSAqIHNjYWxlKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgbGV0IHggPSBiWzBdIC0gYVswXTtcbiAgbGV0IHkgPSBiWzFdIC0gYVsxXTtcbiAgbGV0IHogPSBiWzJdIC0gYVsyXTtcbiAgbGV0IHcgPSBiWzNdIC0gYVszXTtcbiAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnogKyB3KncpO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gIGxldCB4ID0gYlswXSAtIGFbMF07XG4gIGxldCB5ID0gYlsxXSAtIGFbMV07XG4gIGxldCB6ID0gYlsyXSAtIGFbMl07XG4gIGxldCB3ID0gYlszXSAtIGFbM107XG4gIHJldHVybiB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gIGxldCB4ID0gYVswXTtcbiAgbGV0IHkgPSBhWzFdO1xuICBsZXQgeiA9IGFbMl07XG4gIGxldCB3ID0gYVszXTtcbiAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnogKyB3KncpO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkTGVuZ3RoKGEpIHtcbiAgbGV0IHggPSBhWzBdO1xuICBsZXQgeSA9IGFbMV07XG4gIGxldCB6ID0gYVsyXTtcbiAgbGV0IHcgPSBhWzNdO1xuICByZXR1cm4geCp4ICsgeSp5ICsgeip6ICsgdyp3O1xufVxuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuZWdhdGUob3V0LCBhKSB7XG4gIG91dFswXSA9IC1hWzBdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgb3V0WzJdID0gLWFbMl07XG4gIG91dFszXSA9IC1hWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICBvdXRbMl0gPSAxLjAgLyBhWzJdO1xuICBvdXRbM10gPSAxLjAgLyBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgbGV0IHggPSBhWzBdO1xuICBsZXQgeSA9IGFbMV07XG4gIGxldCB6ID0gYVsyXTtcbiAgbGV0IHcgPSBhWzNdO1xuICBsZXQgbGVuID0geCp4ICsgeSp5ICsgeip6ICsgdyp3O1xuICBpZiAobGVuID4gMCkge1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICBvdXRbMF0gPSB4ICogbGVuO1xuICAgIG91dFsxXSA9IHkgKiBsZW47XG4gICAgb3V0WzJdID0geiAqIGxlbjtcbiAgICBvdXRbM10gPSB3ICogbGVuO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5leHBvcnQgZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXSArIGFbM10gKiBiWzNdO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgbGV0IGF4ID0gYVswXTtcbiAgbGV0IGF5ID0gYVsxXTtcbiAgbGV0IGF6ID0gYVsyXTtcbiAgbGV0IGF3ID0gYVszXTtcbiAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgb3V0WzNdID0gYXcgKyB0ICogKGJbM10gLSBhdyk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShvdXQsIHZlY3RvclNjYWxlKSB7XG4gIHZlY3RvclNjYWxlID0gdmVjdG9yU2NhbGUgfHwgMS4wO1xuXG4gIC8vVE9ETzogVGhpcyBpcyBhIHByZXR0eSBhd2Z1bCB3YXkgb2YgZG9pbmcgdGhpcy4gRmluZCBzb21ldGhpbmcgYmV0dGVyLlxuICBvdXRbMF0gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgb3V0WzFdID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gIG91dFsyXSA9IGdsTWF0cml4LlJBTkRPTSgpO1xuICBvdXRbM10gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgbm9ybWFsaXplKG91dCwgb3V0KTtcbiAgc2NhbGUob3V0LCBvdXQsIHZlY3RvclNjYWxlKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWM0IHdpdGggYSBtYXQ0LlxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gIGxldCB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLCB3ID0gYVszXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0gKiB3O1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSAqIHc7XG4gIG91dFsyXSA9IG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSAqIHc7XG4gIG91dFszXSA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XSAqIHc7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjNCB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1RdWF0KG91dCwgYSwgcSkge1xuICBsZXQgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXTtcbiAgbGV0IHF4ID0gcVswXSwgcXkgPSBxWzFdLCBxeiA9IHFbMl0sIHF3ID0gcVszXTtcblxuICAvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY1xuICBsZXQgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XG4gIGxldCBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcbiAgbGV0IGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xuICBsZXQgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG4gIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcbiAgb3V0WzBdID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcbiAgb3V0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgb3V0WzJdID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gJ3ZlYzQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzR9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM107XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzR9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIGxldCBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM107XG4gIGxldCBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM107XG4gIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSk7XG59XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzdWIgPSBzdWJ0cmFjdDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IG11bCA9IG11bHRpcGx5O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGRpdiA9IGRpdmlkZTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuZGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGRpc3QgPSBkaXN0YW5jZTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzcXJEaXN0ID0gc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGxlbiA9IGxlbmd0aDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc3FyTGVuID0gc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjNHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjNC4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzRzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZm9yRWFjaCA9IChmdW5jdGlvbigpIHtcbiAgbGV0IHZlYyA9IGNyZWF0ZSgpO1xuXG4gIHJldHVybiBmdW5jdGlvbihhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICBsZXQgaSwgbDtcbiAgICBpZighc3RyaWRlKSB7XG4gICAgICBzdHJpZGUgPSA0O1xuICAgIH1cblxuICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgaWYoY291bnQpIHtcbiAgICAgIGwgPSBNYXRoLm1pbigoY291bnQgKiBzdHJpZGUpICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICB2ZWNbMF0gPSBhW2ldOyB2ZWNbMV0gPSBhW2krMV07IHZlY1syXSA9IGFbaSsyXTsgdmVjWzNdID0gYVtpKzNdO1xuICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICBhW2ldID0gdmVjWzBdOyBhW2krMV0gPSB2ZWNbMV07IGFbaSsyXSA9IHZlY1syXTsgYVtpKzNdID0gdmVjWzNdO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9O1xufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzQuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gV2ViZ2xDb25zdC5qc1xuXG4vLyBzdG9sZW4gdGhlcmUgaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsL2dsLWNvbnN0YW50cyB0aGFua3MgQG1hdHRkZXNsIF5eXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRBQ1RJVkVfQVRUUklCVVRFUzogMzU3MjEsXG5cdEFDVElWRV9BVFRSSUJVVEVfTUFYX0xFTkdUSDogMzU3MjIsXG5cdEFDVElWRV9URVhUVVJFOiAzNDAxNixcblx0QUNUSVZFX1VOSUZPUk1TOiAzNTcxOCxcblx0QUNUSVZFX1VOSUZPUk1fTUFYX0xFTkdUSDogMzU3MTksXG5cdEFMSUFTRURfTElORV9XSURUSF9SQU5HRTogMzM5MDIsXG5cdEFMSUFTRURfUE9JTlRfU0laRV9SQU5HRTogMzM5MDEsXG5cdEFMUEhBOiA2NDA2LFxuXHRBTFBIQV9CSVRTOiAzNDEzLFxuXHRBTFdBWVM6IDUxOSxcblx0QVJSQVlfQlVGRkVSOiAzNDk2Mixcblx0QVJSQVlfQlVGRkVSX0JJTkRJTkc6IDM0OTY0LFxuXHRBVFRBQ0hFRF9TSEFERVJTOiAzNTcxNyxcblx0QkFDSzogMTAyOSxcblx0QkxFTkQ6IDMwNDIsXG5cdEJMRU5EX0NPTE9SOiAzMjc3Myxcblx0QkxFTkRfRFNUX0FMUEhBOiAzMjk3MCxcblx0QkxFTkRfRFNUX1JHQjogMzI5NjgsXG5cdEJMRU5EX0VRVUFUSU9OOiAzMjc3Nyxcblx0QkxFTkRfRVFVQVRJT05fQUxQSEE6IDM0ODc3LFxuXHRCTEVORF9FUVVBVElPTl9SR0I6IDMyNzc3LFxuXHRCTEVORF9TUkNfQUxQSEE6IDMyOTcxLFxuXHRCTEVORF9TUkNfUkdCOiAzMjk2OSxcblx0QkxVRV9CSVRTOiAzNDEyLFxuXHRCT09MOiAzNTY3MCxcblx0Qk9PTF9WRUMyOiAzNTY3MSxcblx0Qk9PTF9WRUMzOiAzNTY3Mixcblx0Qk9PTF9WRUM0OiAzNTY3Myxcblx0QlJPV1NFUl9ERUZBVUxUX1dFQkdMOiAzNzQ0NCxcblx0QlVGRkVSX1NJWkU6IDM0NjYwLFxuXHRCVUZGRVJfVVNBR0U6IDM0NjYxLFxuXHRCWVRFOiA1MTIwLFxuXHRDQ1c6IDIzMDUsXG5cdENMQU1QX1RPX0VER0U6IDMzMDcxLFxuXHRDT0xPUl9BVFRBQ0hNRU5UMDogMzYwNjQsXG5cdENPTE9SX0JVRkZFUl9CSVQ6IDE2Mzg0LFxuXHRDT0xPUl9DTEVBUl9WQUxVRTogMzEwNixcblx0Q09MT1JfV1JJVEVNQVNLOiAzMTA3LFxuXHRDT01QSUxFX1NUQVRVUzogMzU3MTMsXG5cdENPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTOiAzNDQ2Nyxcblx0Q09OU1RBTlRfQUxQSEE6IDMyNzcxLFxuXHRDT05TVEFOVF9DT0xPUjogMzI3NjksXG5cdENPTlRFWFRfTE9TVF9XRUJHTDogMzc0NDIsXG5cdENVTExfRkFDRTogMjg4NCxcblx0Q1VMTF9GQUNFX01PREU6IDI4ODUsXG5cdENVUlJFTlRfUFJPR1JBTTogMzU3MjUsXG5cdENVUlJFTlRfVkVSVEVYX0FUVFJJQjogMzQzNDIsXG5cdENXOiAyMzA0LFxuXHRERUNSOiA3NjgzLFxuXHRERUNSX1dSQVA6IDM0MDU2LFxuXHRERUxFVEVfU1RBVFVTOiAzNTcxMixcblx0REVQVEhfQVRUQUNITUVOVDogMzYwOTYsXG5cdERFUFRIX0JJVFM6IDM0MTQsXG5cdERFUFRIX0JVRkZFUl9CSVQ6IDI1Nixcblx0REVQVEhfQ0xFQVJfVkFMVUU6IDI5MzEsXG5cdERFUFRIX0NPTVBPTkVOVDogNjQwMixcblx0UkVEOiA2NDAzLFxuXHRERVBUSF9DT01QT05FTlQxNjogMzMxODksXG5cdERFUFRIX0ZVTkM6IDI5MzIsXG5cdERFUFRIX1JBTkdFOiAyOTI4LFxuXHRERVBUSF9TVEVOQ0lMOiAzNDA0MSxcblx0REVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UOiAzMzMwNixcblx0REVQVEhfVEVTVDogMjkyOSxcblx0REVQVEhfV1JJVEVNQVNLOiAyOTMwLFxuXHRESVRIRVI6IDMwMjQsXG5cdERPTlRfQ0FSRTogNDM1Mixcblx0RFNUX0FMUEhBOiA3NzIsXG5cdERTVF9DT0xPUjogNzc0LFxuXHREWU5BTUlDX0RSQVc6IDM1MDQ4LFxuXHRFTEVNRU5UX0FSUkFZX0JVRkZFUjogMzQ5NjMsXG5cdEVMRU1FTlRfQVJSQVlfQlVGRkVSX0JJTkRJTkc6IDM0OTY1LFxuXHRFUVVBTDogNTE0LFxuXHRGQVNURVNUOiA0MzUzLFxuXHRGTE9BVDogNTEyNixcblx0RkxPQVRfTUFUMjogMzU2NzQsXG5cdEZMT0FUX01BVDM6IDM1Njc1LFxuXHRGTE9BVF9NQVQ0OiAzNTY3Nixcblx0RkxPQVRfVkVDMjogMzU2NjQsXG5cdEZMT0FUX1ZFQzM6IDM1NjY1LFxuXHRGTE9BVF9WRUM0OiAzNTY2Nixcblx0RlJBR01FTlRfU0hBREVSOiAzNTYzMixcblx0RlJBTUVCVUZGRVI6IDM2MTYwLFxuXHRGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX09CSkVDVF9OQU1FOiAzNjA0OSxcblx0RlJBTUVCVUZGRVJfQVRUQUNITUVOVF9PQkpFQ1RfVFlQRTogMzYwNDgsXG5cdEZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfVEVYVFVSRV9DVUJFX01BUF9GQUNFOiAzNjA1MSxcblx0RlJBTUVCVUZGRVJfQVRUQUNITUVOVF9URVhUVVJFX0xFVkVMOiAzNjA1MCxcblx0RlJBTUVCVUZGRVJfQklORElORzogMzYwMDYsXG5cdEZSQU1FQlVGRkVSX0NPTVBMRVRFOiAzNjA1Myxcblx0RlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UOiAzNjA1NCxcblx0RlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TOiAzNjA1Nyxcblx0RlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlQ6IDM2MDU1LFxuXHRGUkFNRUJVRkZFUl9VTlNVUFBPUlRFRDogMzYwNjEsXG5cdEZST05UOiAxMDI4LFxuXHRGUk9OVF9BTkRfQkFDSzogMTAzMixcblx0RlJPTlRfRkFDRTogMjg4Nixcblx0RlVOQ19BREQ6IDMyNzc0LFxuXHRGVU5DX1JFVkVSU0VfU1VCVFJBQ1Q6IDMyNzc5LFxuXHRGVU5DX1NVQlRSQUNUOiAzMjc3OCxcblx0R0VORVJBVEVfTUlQTUFQX0hJTlQ6IDMzMTcwLFxuXHRHRVFVQUw6IDUxOCxcblx0R1JFQVRFUjogNTE2LFxuXHRHUkVFTl9CSVRTOiAzNDExLFxuXHRISUdIX0ZMT0FUOiAzNjMzOCxcblx0SElHSF9JTlQ6IDM2MzQxLFxuXHRJTkNSOiA3NjgyLFxuXHRJTkNSX1dSQVA6IDM0MDU1LFxuXHRJTkZPX0xPR19MRU5HVEg6IDM1NzE2LFxuXHRJTlQ6IDUxMjQsXG5cdElOVF9WRUMyOiAzNTY2Nyxcblx0SU5UX1ZFQzM6IDM1NjY4LFxuXHRJTlRfVkVDNDogMzU2NjksXG5cdElOVkFMSURfRU5VTTogMTI4MCxcblx0SU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT046IDEyODYsXG5cdElOVkFMSURfT1BFUkFUSU9OOiAxMjgyLFxuXHRJTlZBTElEX1ZBTFVFOiAxMjgxLFxuXHRJTlZFUlQ6IDUzODYsXG5cdEtFRVA6IDc2ODAsXG5cdExFUVVBTDogNTE1LFxuXHRMRVNTOiA1MTMsXG5cdExJTkVBUjogOTcyOSxcblx0TElORUFSX01JUE1BUF9MSU5FQVI6IDk5ODcsXG5cdExJTkVBUl9NSVBNQVBfTkVBUkVTVDogOTk4NSxcblx0TElORVM6IDEsXG5cdExJTkVfTE9PUDogMixcblx0TElORV9TVFJJUDogMyxcblx0TElORV9XSURUSDogMjg0OSxcblx0TElOS19TVEFUVVM6IDM1NzE0LFxuXHRMT1dfRkxPQVQ6IDM2MzM2LFxuXHRMT1dfSU5UOiAzNjMzOSxcblx0TFVNSU5BTkNFOiA2NDA5LFxuXHRMVU1JTkFOQ0VfQUxQSEE6IDY0MTAsXG5cdE1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTOiAzNTY2MSxcblx0TUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRTogMzQwNzYsXG5cdE1BWF9GUkFHTUVOVF9VTklGT1JNX1ZFQ1RPUlM6IDM2MzQ5LFxuXHRNQVhfUkVOREVSQlVGRkVSX1NJWkU6IDM0MDI0LFxuXHRNQVhfVEVYVFVSRV9JTUFHRV9VTklUUzogMzQ5MzAsXG5cdE1BWF9URVhUVVJFX1NJWkU6IDMzNzksXG5cdE1BWF9WQVJZSU5HX1ZFQ1RPUlM6IDM2MzQ4LFxuXHRNQVhfVkVSVEVYX0FUVFJJQlM6IDM0OTIxLFxuXHRNQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFM6IDM1NjYwLFxuXHRNQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUzogMzYzNDcsXG5cdE1BWF9WSUVXUE9SVF9ESU1TOiAzMzg2LFxuXHRNRURJVU1fRkxPQVQ6IDM2MzM3LFxuXHRNRURJVU1fSU5UOiAzNjM0MCxcblx0TUlSUk9SRURfUkVQRUFUOiAzMzY0OCxcblx0TkVBUkVTVDogOTcyOCxcblx0TkVBUkVTVF9NSVBNQVBfTElORUFSOiA5OTg2LFxuXHRORUFSRVNUX01JUE1BUF9ORUFSRVNUOiA5OTg0LFxuXHRORVZFUjogNTEyLFxuXHROSUNFU1Q6IDQzNTQsXG5cdE5PTkU6IDAsXG5cdE5PVEVRVUFMOiA1MTcsXG5cdE5PX0VSUk9SOiAwLFxuXHROVU1fQ09NUFJFU1NFRF9URVhUVVJFX0ZPUk1BVFM6IDM0NDY2LFxuXHRPTkU6IDEsXG5cdE9ORV9NSU5VU19DT05TVEFOVF9BTFBIQTogMzI3NzIsXG5cdE9ORV9NSU5VU19DT05TVEFOVF9DT0xPUjogMzI3NzAsXG5cdE9ORV9NSU5VU19EU1RfQUxQSEE6IDc3Myxcblx0T05FX01JTlVTX0RTVF9DT0xPUjogNzc1LFxuXHRPTkVfTUlOVVNfU1JDX0FMUEhBOiA3NzEsXG5cdE9ORV9NSU5VU19TUkNfQ09MT1I6IDc2OSxcblx0T1VUX09GX01FTU9SWTogMTI4NSxcblx0UEFDS19BTElHTk1FTlQ6IDMzMzMsXG5cdFBPSU5UUzogMCxcblx0UE9MWUdPTl9PRkZTRVRfRkFDVE9SOiAzMjgyNCxcblx0UE9MWUdPTl9PRkZTRVRfRklMTDogMzI4MjMsXG5cdFBPTFlHT05fT0ZGU0VUX1VOSVRTOiAxMDc1Mixcblx0UkVEX0JJVFM6IDM0MTAsXG5cdFJFTkRFUkJVRkZFUjogMzYxNjEsXG5cdFJFTkRFUkJVRkZFUl9BTFBIQV9TSVpFOiAzNjE3OSxcblx0UkVOREVSQlVGRkVSX0JJTkRJTkc6IDM2MDA3LFxuXHRSRU5ERVJCVUZGRVJfQkxVRV9TSVpFOiAzNjE3OCxcblx0UkVOREVSQlVGRkVSX0RFUFRIX1NJWkU6IDM2MTgwLFxuXHRSRU5ERVJCVUZGRVJfR1JFRU5fU0laRTogMzYxNzcsXG5cdFJFTkRFUkJVRkZFUl9IRUlHSFQ6IDM2MTYzLFxuXHRSRU5ERVJCVUZGRVJfSU5URVJOQUxfRk9STUFUOiAzNjE2NCxcblx0UkVOREVSQlVGRkVSX1JFRF9TSVpFOiAzNjE3Nixcblx0UkVOREVSQlVGRkVSX1NURU5DSUxfU0laRTogMzYxODEsXG5cdFJFTkRFUkJVRkZFUl9XSURUSDogMzYxNjIsXG5cdFJFTkRFUkVSOiA3OTM3LFxuXHRSRVBFQVQ6IDEwNDk3LFxuXHRSRVBMQUNFOiA3NjgxLFxuXHRSR0I6IDY0MDcsXG5cdFJHQjVfQTE6IDMyODU1LFxuXHRSR0I1NjU6IDM2MTk0LFxuXHRSR0JBOiA2NDA4LFxuXHRSR0JBNDogMzI4NTQsXG5cdFNBTVBMRVJfMkQ6IDM1Njc4LFxuXHRTQU1QTEVSX0NVQkU6IDM1NjgwLFxuXHRTQU1QTEVTOiAzMjkzNyxcblx0U0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFOiAzMjkyNixcblx0U0FNUExFX0JVRkZFUlM6IDMyOTM2LFxuXHRTQU1QTEVfQ09WRVJBR0U6IDMyOTI4LFxuXHRTQU1QTEVfQ09WRVJBR0VfSU5WRVJUOiAzMjkzOSxcblx0U0FNUExFX0NPVkVSQUdFX1ZBTFVFOiAzMjkzOCxcblx0U0NJU1NPUl9CT1g6IDMwODgsXG5cdFNDSVNTT1JfVEVTVDogMzA4OSxcblx0U0hBREVSX0NPTVBJTEVSOiAzNjM0Nixcblx0U0hBREVSX1NPVVJDRV9MRU5HVEg6IDM1NzIwLFxuXHRTSEFERVJfVFlQRTogMzU2NjMsXG5cdFNIQURJTkdfTEFOR1VBR0VfVkVSU0lPTjogMzU3MjQsXG5cdFNIT1JUOiA1MTIyLFxuXHRTUkNfQUxQSEE6IDc3MCxcblx0U1JDX0FMUEhBX1NBVFVSQVRFOiA3NzYsXG5cdFNSQ19DT0xPUjogNzY4LFxuXHRTVEFUSUNfRFJBVzogMzUwNDQsXG5cdFNURU5DSUxfQVRUQUNITUVOVDogMzYxMjgsXG5cdFNURU5DSUxfQkFDS19GQUlMOiAzNDgxNyxcblx0U1RFTkNJTF9CQUNLX0ZVTkM6IDM0ODE2LFxuXHRTVEVOQ0lMX0JBQ0tfUEFTU19ERVBUSF9GQUlMOiAzNDgxOCxcblx0U1RFTkNJTF9CQUNLX1BBU1NfREVQVEhfUEFTUzogMzQ4MTksXG5cdFNURU5DSUxfQkFDS19SRUY6IDM2MDAzLFxuXHRTVEVOQ0lMX0JBQ0tfVkFMVUVfTUFTSzogMzYwMDQsXG5cdFNURU5DSUxfQkFDS19XUklURU1BU0s6IDM2MDA1LFxuXHRTVEVOQ0lMX0JJVFM6IDM0MTUsXG5cdFNURU5DSUxfQlVGRkVSX0JJVDogMTAyNCxcblx0U1RFTkNJTF9DTEVBUl9WQUxVRTogMjk2MSxcblx0U1RFTkNJTF9GQUlMOiAyOTY0LFxuXHRTVEVOQ0lMX0ZVTkM6IDI5NjIsXG5cdFNURU5DSUxfSU5ERVg6IDY0MDEsXG5cdFNURU5DSUxfSU5ERVg4OiAzNjE2OCxcblx0U1RFTkNJTF9QQVNTX0RFUFRIX0ZBSUw6IDI5NjUsXG5cdFNURU5DSUxfUEFTU19ERVBUSF9QQVNTOiAyOTY2LFxuXHRTVEVOQ0lMX1JFRjogMjk2Nyxcblx0U1RFTkNJTF9URVNUOiAyOTYwLFxuXHRTVEVOQ0lMX1ZBTFVFX01BU0s6IDI5NjMsXG5cdFNURU5DSUxfV1JJVEVNQVNLOiAyOTY4LFxuXHRTVFJFQU1fRFJBVzogMzUwNDAsXG5cdFNVQlBJWEVMX0JJVFM6IDM0MDgsXG5cdFRFWFRVUkU6IDU4OTAsXG5cdFRFWFRVUkUwOiAzMzk4NCxcblx0VEVYVFVSRTE6IDMzOTg1LFxuXHRURVhUVVJFMjogMzM5ODYsXG5cdFRFWFRVUkUzOiAzMzk4Nyxcblx0VEVYVFVSRTQ6IDMzOTg4LFxuXHRURVhUVVJFNTogMzM5ODksXG5cdFRFWFRVUkU2OiAzMzk5MCxcblx0VEVYVFVSRTc6IDMzOTkxLFxuXHRURVhUVVJFODogMzM5OTIsXG5cdFRFWFRVUkU5OiAzMzk5Myxcblx0VEVYVFVSRTEwOiAzMzk5NCxcblx0VEVYVFVSRTExOiAzMzk5NSxcblx0VEVYVFVSRTEyOiAzMzk5Nixcblx0VEVYVFVSRTEzOiAzMzk5Nyxcblx0VEVYVFVSRTE0OiAzMzk5OCxcblx0VEVYVFVSRTE1OiAzMzk5OSxcblx0VEVYVFVSRTE2OiAzNDAwMCxcblx0VEVYVFVSRTE3OiAzNDAwMSxcblx0VEVYVFVSRTE4OiAzNDAwMixcblx0VEVYVFVSRTE5OiAzNDAwMyxcblx0VEVYVFVSRTIwOiAzNDAwNCxcblx0VEVYVFVSRTIxOiAzNDAwNSxcblx0VEVYVFVSRTIyOiAzNDAwNixcblx0VEVYVFVSRTIzOiAzNDAwNyxcblx0VEVYVFVSRTI0OiAzNDAwOCxcblx0VEVYVFVSRTI1OiAzNDAwOSxcblx0VEVYVFVSRTI2OiAzNDAxMCxcblx0VEVYVFVSRTI3OiAzNDAxMSxcblx0VEVYVFVSRTI4OiAzNDAxMixcblx0VEVYVFVSRTI5OiAzNDAxMyxcblx0VEVYVFVSRTMwOiAzNDAxNCxcblx0VEVYVFVSRTMxOiAzNDAxNSxcblx0VEVYVFVSRV8yRDogMzU1Myxcblx0VEVYVFVSRV9CSU5ESU5HXzJEOiAzMjg3Myxcblx0VEVYVFVSRV9CSU5ESU5HX0NVQkVfTUFQOiAzNDA2OCxcblx0VEVYVFVSRV9DVUJFX01BUDogMzQwNjcsXG5cdFRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWDogMzQwNzAsXG5cdFRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWTogMzQwNzIsXG5cdFRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWjogMzQwNzQsXG5cdFRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWDogMzQwNjksXG5cdFRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWTogMzQwNzEsXG5cdFRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWjogMzQwNzMsXG5cdFRFWFRVUkVfTUFHX0ZJTFRFUjogMTAyNDAsXG5cdFRFWFRVUkVfTUlOX0ZJTFRFUjogMTAyNDEsXG5cdFRFWFRVUkVfV1JBUF9TOiAxMDI0Mixcblx0VEVYVFVSRV9XUkFQX1Q6IDEwMjQzLFxuXHRUUklBTkdMRVM6IDQsXG5cdFRSSUFOR0xFX0ZBTjogNixcblx0VFJJQU5HTEVfU1RSSVA6IDUsXG5cdFVOUEFDS19BTElHTk1FTlQ6IDMzMTcsXG5cdFVOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0w6IDM3NDQzLFxuXHRVTlBBQ0tfRkxJUF9ZX1dFQkdMOiAzNzQ0MCxcblx0VU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMOiAzNzQ0MSxcblx0VU5TSUdORURfQllURTogNTEyMSxcblx0VU5TSUdORURfSU5UOiA1MTI1LFxuXHRVTlNJR05FRF9TSE9SVDogNTEyMyxcblx0VU5TSUdORURfU0hPUlRfNF80XzRfNDogMzI4MTksXG5cdFVOU0lHTkVEX1NIT1JUXzVfNV81XzE6IDMyODIwLFxuXHRVTlNJR05FRF9TSE9SVF81XzZfNTogMzM2MzUsXG5cdFZBTElEQVRFX1NUQVRVUzogMzU3MTUsXG5cdFZFTkRPUjogNzkzNixcblx0VkVSU0lPTjogNzkzOCxcblx0VkVSVEVYX0FUVFJJQl9BUlJBWV9CVUZGRVJfQklORElORzogMzQ5NzUsXG5cdFZFUlRFWF9BVFRSSUJfQVJSQVlfRU5BQkxFRDogMzQzMzgsXG5cdFZFUlRFWF9BVFRSSUJfQVJSQVlfTk9STUFMSVpFRDogMzQ5MjIsXG5cdFZFUlRFWF9BVFRSSUJfQVJSQVlfUE9JTlRFUjogMzQzNzMsXG5cdFZFUlRFWF9BVFRSSUJfQVJSQVlfU0laRTogMzQzMzksXG5cdFZFUlRFWF9BVFRSSUJfQVJSQVlfU1RSSURFOiAzNDM0MCxcblx0VkVSVEVYX0FUVFJJQl9BUlJBWV9UWVBFOiAzNDM0MSxcblx0VkVSVEVYX1NIQURFUjogMzU2MzMsXG5cdFZJRVdQT1JUOiAyOTc4LFxuXHRaRVJPOiAwLFxuXHRSODogMzMzMjEsXG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL1dlYmdsQ29uc3QuanMiLCIvLyBnZXRBdHRyaWJMb2MuanNcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGdsLCBzaGFkZXJQcm9ncmFtLCBuYW1lKSB7XG5cdGlmKHNoYWRlclByb2dyYW0uY2FjaGVBdHRyaWJMb2MgPT09IHVuZGVmaW5lZCkge1x0c2hhZGVyUHJvZ3JhbS5jYWNoZUF0dHJpYkxvYyA9IHt9O1x0fVxuXHRpZihzaGFkZXJQcm9ncmFtLmNhY2hlQXR0cmliTG9jW25hbWVdID09PSB1bmRlZmluZWQpIHtcblx0XHRzaGFkZXJQcm9ncmFtLmNhY2hlQXR0cmliTG9jW25hbWVdID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSwgbmFtZSk7XG5cdH1cblxuXHRyZXR1cm4gc2hhZGVyUHJvZ3JhbS5jYWNoZUF0dHJpYkxvY1tuYW1lXTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvZ2V0QXR0cmliTG9jLmpzIiwiLy8gR0xUZXh0dXJlLmpzXG5cbmltcG9ydCBHTCBmcm9tICcuL0dMVG9vbCc7XG5pbXBvcnQgV2ViZ2xOdW1iZXIgZnJvbSAnLi91dGlscy9XZWJnbE51bWJlcic7XG5cbmZ1bmN0aW9uIGlzUG93ZXJPZlR3byh4KSB7XHRcblx0cmV0dXJuICh4ICE9PSAwKSAmJiAoISh4ICYgKHggLSAxKSkpO1xufTtcblxuZnVuY3Rpb24gaXNTb3VyY2VQb3dlck9mVHdvKG9iaikge1x0XG5cdGNvbnN0IHcgPSBvYmoud2lkdGggfHwgb2JqLnZpZGVvV2lkdGg7XG5cdGNvbnN0IGggPSBvYmouaGVpZ2h0IHx8IG9iai52aWRlb0hlaWdodDtcblxuXHRpZighdyB8fCAhaCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRyZXR1cm4gaXNQb3dlck9mVHdvKHcpICYmIGlzUG93ZXJPZlR3byhoKTtcbn07XG5cbmxldCBnbDtcblxuY2xhc3MgR0xUZXh0dXJlIHtcblxuXHRjb25zdHJ1Y3RvcihtU291cmNlLCBpc1RleHR1cmUgPSBmYWxzZSwgbVBhcmFtZXRlcnMgPSB7fSkge1xuXHRcdGdsID0gR0wuZ2w7XG5cblx0XHRpZihpc1RleHR1cmUpIHtcblx0XHRcdHRoaXMuX3RleHR1cmUgPSBtU291cmNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9tU291cmNlICA9IG1Tb3VyY2U7XG5cdFx0XHR0aGlzLl90ZXh0dXJlICA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblx0XHRcdHRoaXMuX2lzVmlkZW8gID0gKG1Tb3VyY2UudGFnTmFtZSA9PT0gJ1ZJREVPJyk7XG5cdFx0XHR0aGlzLl9wcmVtdWx0aXBseUFscGhhID0gdHJ1ZTtcblx0XHRcdHRoaXMuX21hZ0ZpbHRlciA9IG1QYXJhbWV0ZXJzLm1hZ0ZpbHRlciB8fCBnbC5MSU5FQVI7XG5cdFx0XHR0aGlzLl9taW5GaWx0ZXIgPSBtUGFyYW1ldGVycy5taW5GaWx0ZXIgfHwgZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSO1xuXHRcdFx0XG5cdFx0XHR0aGlzLl93cmFwUyAgICAgPSBtUGFyYW1ldGVycy53cmFwUyB8fCBnbC5NSVJST1JFRF9SRVBFQVQ7XG5cdFx0XHR0aGlzLl93cmFwVCAgICAgPSBtUGFyYW1ldGVycy53cmFwVCB8fCBnbC5NSVJST1JFRF9SRVBFQVQ7XG5cdFx0XHRjb25zdCB3aWR0aCAgICA9IG1Tb3VyY2Uud2lkdGggfHwgbVNvdXJjZS52aWRlb1dpZHRoO1xuXG5cdFx0XHRpZih3aWR0aCkge1xuXHRcdFx0XHRpZighaXNTb3VyY2VQb3dlck9mVHdvKG1Tb3VyY2UpKSB7XG5cdFx0XHRcdFx0dGhpcy5fd3JhcFMgPSB0aGlzLl93cmFwVCA9IGdsLkNMQU1QX1RPX0VER0U7XG5cdFx0XHRcdFx0aWYodGhpcy5fbWluRmlsdGVyID09PSBnbC5ORUFSRVNUX01JUE1BUF9MSU5FQVIpIHtcblx0XHRcdFx0XHRcdHRoaXMuX21pbkZpbHRlciA9IGdsLkxJTkVBUjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gXHRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3dyYXBTID0gdGhpcy5fd3JhcFQgPSBnbC5DTEFNUF9UT19FREdFO1xuXHRcdFx0XHRpZih0aGlzLl9taW5GaWx0ZXIgPT09IGdsLk5FQVJFU1RfTUlQTUFQX0xJTkVBUikge1xuXHRcdFx0XHRcdHRoaXMuX21pbkZpbHRlciA9IGdsLkxJTkVBUjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKTtcblx0XHRcdGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xuXG5cdFx0XHRpZihtU291cmNlLmV4cG9zdXJlKSB7XG5cdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgbVNvdXJjZS5zaGFwZVswXSwgbVNvdXJjZS5zaGFwZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG1Tb3VyY2UuZGF0YSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG1Tb3VyY2UpO1x0XG5cdFx0XHRcdC8vIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGhpcy5fbWFnRmlsdGVyKTtcblx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLl9taW5GaWx0ZXIpO1xuXHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgdGhpcy5fd3JhcFMpO1xuXHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgdGhpcy5fd3JhcFQpO1xuXG5cdFx0XHQvLyBjb25zb2xlLmxvZygnVGV4dHVyZSBNaW4gOicsIFdlYmdsTnVtYmVyW3RoaXMuX21pbkZpbHRlcl0pO1xuXHRcdFx0Ly8gY29uc29sZS5sb2coJ1RleHR1cmUgTWFnIDonLCBXZWJnbE51bWJlclt0aGlzLl9tYWdGaWx0ZXJdKTtcblxuXHRcdFx0Y29uc3QgZXh0ID0gR0wuZ2V0RXh0ZW5zaW9uKCdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnKTtcblx0XHRcdGlmKGV4dCkge1xuXHRcdFx0XHRjb25zdCBtYXggPSBnbC5nZXRQYXJhbWV0ZXIoZXh0Lk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCk7XG5cdFx0XHRcdGdsLnRleFBhcmFtZXRlcmYoZ2wuVEVYVFVSRV8yRCwgZXh0LlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULCBtYXgpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZih0aGlzLl9jYW5HZW5lcmF0ZU1pcG1hcCgpKSB7XG5cdFx0XHRcdGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpO1xuXHRcdFx0fVxuXG5cdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblx0XHR9XG5cdH1cblxuXHRnZW5lcmF0ZU1pcG1hcCgpIHtcblx0XHRpZiAoIXRoaXMuX2NhbkdlbmVyYXRlTWlwbWFwKCkpIHsgcmV0dXJuOyB9XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZSk7XG5cdFx0Z2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cdH1cblxuXG5cdC8vXHRNSVBNQVAgRklMVEVSXG5cblx0c2V0IG1pbkZpbHRlcihtVmFsdWUpIHtcblx0XHRpZihtVmFsdWUgIT09IGdsLkxJTkVBUlxuXHRcdFx0JiYgbVZhbHVlICE9PSBnbC5ORUFSRVNUIFxuXHRcdFx0JiYgbVZhbHVlICE9PSBnbC5ORUFSRVNUX01JUE1BUF9MSU5FQVJcblx0XHRcdCYmIG1WYWx1ZSAhPT0gZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSXG5cdFx0XHQmJiBtVmFsdWUgIT09IGdsLkxJTkVBUl9NSVBNQVBfTElORUFSXG5cdFx0XHQmJiBtVmFsdWUgIT09IGdsLk5FQVJFU1RfTUlQTUFQX05FQVJFU1Rcblx0XHQpIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR0aGlzLl9taW5GaWx0ZXIgPSBtVmFsdWU7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZSk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRoaXMuX21pbkZpbHRlcik7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cdH1cblxuXHRnZXQgbWluRmlsdGVyKCkge1xuXHRcdHJldHVybiB0aGlzLl9taW5GaWx0ZXI7XG5cdH1cblxuXHRzZXQgbWFnRmlsdGVyKG1WYWx1ZSkge1xuXHRcdGlmKG1WYWx1ZSAhPT0gZ2wuTElORUFSICYmIG1WYWx1ZSAhPT0gZ2wuTkVBUkVTVCkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHRoaXMuX21hZ0ZpbHRlciA9IG1WYWx1ZTtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGhpcy5fbWFnRmlsdGVyKTtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblx0fVxuXG5cdGdldCBtYWdGaWx0ZXIoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hZ0ZpbHRlcjtcblx0fVxuXG5cblx0Ly9cdFdSQVBcblxuXHRzZXQgd3JhcFMobVZhbHVlKSB7XG5cdFx0aWYobVZhbHVlICE9PSBnbC5DTEFNUF9UT19FREdFICYmIG1WYWx1ZSAhPT0gZ2wuUkVQRUFUICYmIG1WYWx1ZSAhPT0gZ2wuTUlSUk9SRURfUkVQRUFUKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dGhpcy5fd3JhcFMgPSBtVmFsdWU7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZSk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgdGhpcy5fd3JhcFMpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuXHR9XG5cblx0Z2V0IHdyYXBTKCkge1xuXHRcdHJldHVybiB0aGlzLl93cmFwUztcblx0fVxuXG5cdHNldCB3cmFwVChtVmFsdWUpIHtcblx0XHRpZihtVmFsdWUgIT09IGdsLkNMQU1QX1RPX0VER0UgJiYgbVZhbHVlICE9PSBnbC5SRVBFQVQgJiYgbVZhbHVlICE9PSBnbC5NSVJST1JFRF9SRVBFQVQpIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR0aGlzLl93cmFwVCA9IG1WYWx1ZTtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLl93cmFwVCk7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cdH1cblxuXHRnZXQgd3JhcFQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3dyYXBUO1xuXHR9XG5cblxuXHQvL1x0UFJFTVVMVElQTFkgQUxQSEFcblxuXHRzZXQgcHJlbXVsdGlwbHlBbHBoYShtVmFsdWUpIHtcblx0XHR0aGlzLl9wcmVtdWx0aXBseUFscGhhID0gbVZhbHVlO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmUpO1xuXHRcdGNvbnNvbGUubG9nKCdwcmVtdWx0aXBseUFscGhhOicsIG1WYWx1ZSk7XG5cdFx0Z2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0aGlzLl9wcmVtdWx0aXBseUFscGhhKTtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblxuXHR9XG5cblx0Z2V0IHByZW11bHRpcGx5QWxwaGEoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3ByZW11bHRpcGx5QWxwaGE7XG5cdH1cblxuXHQvL1x0VVBEQVRFIFRFWFRVUkVcblxuXHR1cGRhdGVUZXh0dXJlKG1Tb3VyY2UpIHtcblx0XHRpZihtU291cmNlKSB7IHRoaXMuX21Tb3VyY2UgPSBtU291cmNlOyB9XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZSk7XG5cdFx0Z2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XG5cdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLl9tU291cmNlKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGhpcy5fbWFnRmlsdGVyKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5fbWluRmlsdGVyKTtcblx0XHRpZih0aGlzLl9jYW5HZW5lcmF0ZU1pcG1hcCgpKSB7XG5cdFx0XHRnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcblx0XHR9XG5cblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblx0fVxuXG5cblx0YmluZChpbmRleCkge1xuXHRcdGlmKGluZGV4ID09PSB1bmRlZmluZWQpIHsgaW5kZXggPSAwOyB9XG5cdFx0aWYoIUdMLnNoYWRlcikgeyByZXR1cm47IH1cblxuXHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyBpbmRleCk7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZSk7XG5cdFx0dGhpcy5fYmluZEluZGV4ID0gaW5kZXg7XG5cdH1cblxuXHRfY2FuR2VuZXJhdGVNaXBtYXAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21pbkZpbHRlciA9PT0gZ2wuTElORUFSX01JUE1BUF9ORUFSRVNUIFxuXHRcdFx0XHR8fCB0aGlzLl9taW5GaWx0ZXIgPT09IGdsLk5FQVJFU1RfTUlQTUFQX0xJTkVBUiBcblx0XHRcdFx0fHwgdGhpcy5fbWluRmlsdGVyID09PSBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUiBcblx0XHRcdFx0fHwgdGhpcy5fbWluRmlsdGVyID09PSBnbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNUO1xuXHR9XG5cblx0Ly9cdEdFVFRFUlxuXG5cdGdldCB0ZXh0dXJlKCkge1x0cmV0dXJuIHRoaXMuX3RleHR1cmU7XHR9XG59XG5cblxubGV0IF93aGl0ZVRleHR1cmUsIF9ncmV5VGV4dHVyZSwgX2JsYWNrVGV4dHVyZTtcblxuR0xUZXh0dXJlLndoaXRlVGV4dHVyZSA9IGZ1bmN0aW9uIHdoaXRlVGV4dHVyZSgpIHtcblx0aWYoX3doaXRlVGV4dHVyZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Y29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cdFx0Y2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDQ7XG5cdFx0Y29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdFx0Y3R4LmZpbGxTdHlsZSA9ICcjZmZmJztcblx0XHRjdHguZmlsbFJlY3QoMCwgMCwgNCwgNCk7XG5cdFx0X3doaXRlVGV4dHVyZSA9IG5ldyBHTFRleHR1cmUoY2FudmFzKTtcblx0fVxuXHRcblx0cmV0dXJuIF93aGl0ZVRleHR1cmU7XG59O1xuXG5HTFRleHR1cmUuZ3JleVRleHR1cmUgPSBmdW5jdGlvbiBncmV5VGV4dHVyZSgpIHtcblx0aWYoX2dyZXlUZXh0dXJlID09PSB1bmRlZmluZWQpIHtcblx0XHRjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0XHRjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gNDtcblx0XHRjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRjdHguZmlsbFN0eWxlID0gJ3JnYigxMjcsIDEyNywgMTI3KSc7XG5cdFx0Y3R4LmZpbGxSZWN0KDAsIDAsIDQsIDQpO1xuXHRcdF9ncmV5VGV4dHVyZSA9IG5ldyBHTFRleHR1cmUoY2FudmFzKTtcblx0fVxuXHRyZXR1cm4gX2dyZXlUZXh0dXJlO1xufTtcblxuR0xUZXh0dXJlLmJsYWNrVGV4dHVyZSA9IGZ1bmN0aW9uIGJsYWNrVGV4dHVyZSgpIHtcblx0aWYoX2JsYWNrVGV4dHVyZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Y29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cdFx0Y2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDQ7XG5cdFx0Y29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdFx0Y3R4LmZpbGxTdHlsZSA9ICdyZ2IoMTI3LCAxMjcsIDEyNyknO1xuXHRcdGN0eC5maWxsUmVjdCgwLCAwLCA0LCA0KTtcblx0XHRfYmxhY2tUZXh0dXJlID0gbmV3IEdMVGV4dHVyZShjYW52YXMpO1xuXHR9XG5cdHJldHVybiBfYmxhY2tUZXh0dXJlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgR0xUZXh0dXJlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL0dMVGV4dHVyZS5qcyIsIi8vIEdMVGV4dHVyZTIuanNcblxuaW1wb3J0IGdldFRleHR1cmVQYXJhbWV0ZXJzIGZyb20gJy4vdXRpbHMvZ2V0VGV4dHVyZVBhcmFtZXRlcnMnO1xuaW1wb3J0IFdlYmdsTnVtYmVyIGZyb20gJy4vdXRpbHMvV2ViZ2xOdW1iZXInO1xuaW1wb3J0IEdMIGZyb20gJy4vR0xUb29sJztcbmltcG9ydCBTY2hlZHVsZXIgZnJvbSAnc2NoZWR1bGluZyc7XG5cbmxldCBnbDtcblxuY2xhc3MgR0xUZXh0dXJlIHtcblxuXHRjb25zdHJ1Y3RvcihtU291cmNlLCBtUGFyYW0gPSB7fSwgbVdpZHRoID0gMCwgbUhlaWdodCA9IDApIHtcblx0XHRnbCA9IEdMLmdsO1xuXG5cdFx0dGhpcy5fc291cmNlID0gbVNvdXJjZTtcblx0XHR0aGlzLl9nZXREaW1lbnNpb24obVNvdXJjZSwgbVdpZHRoLCBtSGVpZ2h0KTtcblx0XHR0aGlzLl9zb3VyY2VUeXBlID0gbVBhcmFtLnR5cGUgfHwgZ2V0U291cmNlVHlwZShtU291cmNlKTtcblx0XHR0aGlzLl9jaGVja1NvdXJjZSgpO1xuXHRcdHRoaXMuX3RleGVsVHlwZSA9IHRoaXMuX2dldFRleGVsVHlwZSgpO1xuXHRcdHRoaXMuX2lzVGV4dHVyZVJlYWR5ID0gdHJ1ZTtcblxuXHRcdHRoaXMuX3BhcmFtcyA9IGdldFRleHR1cmVQYXJhbWV0ZXJzKG1QYXJhbSwgbVNvdXJjZSwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XG5cdFx0dGhpcy5fY2hlY2tNaXBtYXAoKTtcblx0XHR0aGlzLl9jaGVja1dyYXBwaW5nKCk7XG5cblx0XHQvL1x0c2V0dXAgdGV4dHVyZVxuXHRcdHRoaXMuX3RleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG5cblx0XHRpZih0aGlzLl9zb3VyY2VUeXBlID09PSAndmlkZW8nKSB7XG5cdFx0XHR0aGlzLl9pc1RleHR1cmVSZWFkeSA9IGZhbHNlO1xuXHRcdFx0U2NoZWR1bGVyLmFkZEVGKCgpPT50aGlzLl9sb29wKCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl91cGxvYWRUZXh0dXJlKCk7XHRcblx0XHR9XG5cdFx0XG5cdH1cblxuXHRfbG9vcCgpIHtcblx0XHRpZih0aGlzLl9zb3VyY2UucmVhZHlTdGF0ZSA9PSA0KSB7XG5cdFx0XHR0aGlzLl9pc1RleHR1cmVSZWFkeSA9IHRydWU7XG5cdFx0XHR0aGlzLl91cGxvYWRUZXh0dXJlKCk7XG5cdFx0fVxuXHR9XG5cblxuXHRfdXBsb2FkVGV4dHVyZSgpIHtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKTtcblx0XHRnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0cnVlKTtcblxuXHRcdGlmKHRoaXMuX2lzU291cmNlSHRtbEVsZW1lbnQoKSkge1xuXHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCB0aGlzLl9wYXJhbXMuaW50ZXJuYWxGb3JtYXQsIHRoaXMuX3BhcmFtcy5mb3JtYXQsIHRoaXMuX3RleGVsVHlwZSwgdGhpcy5fc291cmNlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCB0aGlzLl9wYXJhbXMuaW50ZXJuYWxGb3JtYXQsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQsIDAsIHRoaXMuX3BhcmFtcy5mb3JtYXQsIHRoaXMuX3RleGVsVHlwZSwgdGhpcy5fc291cmNlKTtcdFxuXHRcdH1cblx0XHRcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGhpcy5fcGFyYW1zLm1hZ0ZpbHRlcik7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRoaXMuX3BhcmFtcy5taW5GaWx0ZXIpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMuX3BhcmFtcy53cmFwUyk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgdGhpcy5fcGFyYW1zLndyYXBUKTtcblx0XHRnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRoaXMuX3BhcmFtcy5wcmVtdWx0aXBseUFscGhhKTtcblxuXHRcdGlmKHRoaXMuX3BhcmFtcy5hbmlzb3Ryb3B5ID4gMCkge1xuXHRcdFx0Y29uc3QgZXh0ID0gR0wuZ2V0RXh0ZW5zaW9uKCdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnKTtcblx0XHRcdGlmKGV4dCkge1xuXHRcdFx0XHRjb25zdCBtYXggPSBnbC5nZXRQYXJhbWV0ZXIoZXh0Lk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCk7XG5cdFx0XHRcdGNvbnN0IGxldmVsID0gTWF0aC5taW4obWF4LCB0aGlzLl9wYXJhbXMuYW5pc290cm9weSk7XG5cdFx0XHRcdGdsLnRleFBhcmFtZXRlcmYoZ2wuVEVYVFVSRV8yRCwgZXh0LlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULCBsZXZlbCk7XG5cdFx0XHR9XHRcblx0XHR9XG5cdFx0XG5cblx0XHRpZih0aGlzLl9nZW5lcmF0ZU1pcG1hcCkge1x0Z2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XHR9XG5cblx0XHQvL1x0dW5iaW5kIHRleHR1cmVcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblx0fVxuXG5cblx0YmluZChpbmRleCkge1xuXHRcdGlmKGluZGV4ID09PSB1bmRlZmluZWQpIHsgaW5kZXggPSAwOyB9XG5cdFx0aWYoIUdMLnNoYWRlcikgeyByZXR1cm47IH1cblxuXHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyBpbmRleCk7XG5cdFx0aWYodGhpcy5faXNUZXh0dXJlUmVhZHkpIHtcblx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmUpO1x0XG5cdFx0fSBlbHNlIHtcblx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIEdMVGV4dHVyZS5ibGFja1RleHR1cmUoKS50ZXh0dXJlKTtcblx0XHR9XG5cdFx0XG5cdFx0dGhpcy5fYmluZEluZGV4ID0gaW5kZXg7XG5cdH1cblxuXG5cdHVwZGF0ZVRleHR1cmUobVNvdXJjZSkge1xuXHRcdHRoaXMuX3NvdXJjZSA9IG1Tb3VyY2U7XG5cdFx0dGhpcy5fY2hlY2tTb3VyY2UoKTtcblx0XHR0aGlzLl91cGxvYWRUZXh0dXJlKCk7XG5cdH1cblxuXG5cdGdlbmVyYXRlTWlwbWFwKCkge1xuXHRcdGlmICghdGhpcy5fZ2VuZXJhdGVNaXBtYXApIHsgcmV0dXJuOyB9XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZSk7XG5cdFx0Z2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cdH1cblxuXHRzaG93UGFyYW1ldGVycygpIHtcblx0XHRjb25zb2xlLmxvZygnU291cmNlIHR5cGUgOiAnLCBXZWJnbE51bWJlclt0aGlzLl9zb3VyY2VUeXBlXSB8fCB0aGlzLl9zb3VyY2VUeXBlKTtcblx0XHRjb25zb2xlLmxvZygnVGV4ZWwgdHlwZTonLCBXZWJnbE51bWJlclt0aGlzLnRleGVsVHlwZV0pO1xuXHRcdGNvbnNvbGUubG9nKCdEaW1lbnNpb24gOicsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuXHRcdGZvcihjb25zdCBzIGluIHRoaXMuX3BhcmFtcykge1xuXHRcdFx0Y29uc29sZS5sb2cocywgV2ViZ2xOdW1iZXJbdGhpcy5fcGFyYW1zW3NdXSB8fCB0aGlzLl9wYXJhbXNbc10pO1xuXHRcdH1cblxuXHRcdGNvbnNvbGUubG9nKCdNaXBtYXBwaW5nIDonLCB0aGlzLl9nZW5lcmF0ZU1pcG1hcCk7XG5cdH1cblxuXHRfZ2V0RGltZW5zaW9uKG1Tb3VyY2UsIG1XaWR0aCwgbUhlaWdodCkge1xuXHRcdGlmKG1Tb3VyY2UpIHtcblx0XHRcdC8vXHRmb3IgaHRtbCBpbWFnZSAvIHZpZGVvIGVsZW1lbnRcblx0XHRcdHRoaXMuX3dpZHRoID0gbVNvdXJjZS53aWR0aCB8fCBtU291cmNlLnZpZGVvV2lkdGg7XG5cdFx0XHR0aGlzLl9oZWlnaHQgPSBtU291cmNlLmhlaWdodCB8fCBtU291cmNlLnZpZGVvV2lkdGg7XG5cblx0XHRcdC8vXHRmb3IgbWFudWFsIHdpZHRoIC8gaGVpZ2h0IHNldHRpbmdzXG5cdFx0XHR0aGlzLl93aWR0aCA9IHRoaXMuX3dpZHRoIHx8IG1XaWR0aDtcblx0XHRcdHRoaXMuX2hlaWdodCA9IHRoaXMuX2hlaWdodCB8fCBtSGVpZ2h0O1xuXG5cdFx0XHQvL1x0YXV0byBkZXRlY3QgKCBkYXRhIGFycmF5KSA/IG5vdCBzdXJlIGlzIGdvb2QgaWRlYSA/IFxuXHRcdFx0Ly9cdHRvZG8gOiBjaGVjayBIRFIgXG5cdFx0XHRpZighdGhpcy5fd2lkdGggfHwgIXRoaXMuX2hlaWdodCkge1xuXHRcdFx0XHR0aGlzLl93aWR0aCA9IHRoaXMuX2hlaWdodCA9IE1hdGguc3FydChtU291cmNlLmxlbmd0aCAvIDQpO1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZygnQXV0byBkZXRlY3QsIGRhdGEgZGltZW5zaW9uIDogJywgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XHRcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl93aWR0aCA9IG1XaWR0aDtcblx0XHRcdHRoaXMuX2hlaWdodCA9IG1IZWlnaHQ7XG5cdFx0fVxuXHR9XG5cblx0X2NoZWNrU291cmNlKCkge1xuXHRcdGlmKCF0aGlzLl9zb3VyY2UpIHtcdHJldHVybjsgfVxuXG5cdFx0aWYodGhpcy5fc291cmNlVHlwZSA9PT0gR0wuVU5TSUdORURfQllURSkge1xuXHRcdFx0aWYgKCEodGhpcy5fc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ0NvbnZlcnRpbmcgdG8gVWludDhBcnJheScpO1xuXHRcdFx0XHR0aGlzLl9zb3VyY2UgPSBuZXcgVWludDhBcnJheSh0aGlzLl9zb3VyY2UpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZih0aGlzLl9zb3VyY2VUeXBlID09PSBHTC5GTE9BVCkge1xuXHRcdFx0aWYgKCEodGhpcy5fc291cmNlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSkge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZygnQ29udmVydGluZyB0byBGbG9hdDMyQXJyYXknKTtcblx0XHRcdFx0dGhpcy5fc291cmNlID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLl9zb3VyY2UpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHR9XG5cblx0X2dldFRleGVsVHlwZSgpIHtcblx0XHRpZih0aGlzLl9pc1NvdXJjZUh0bWxFbGVtZW50KCkpIHtcblx0XHRcdHJldHVybiBHTC5VTlNJR05FRF9CWVRFO1x0XG5cdFx0fVxuXG5cdFx0Ly9cdGJhZCBjb2RlIGhlcmUsIGlmIHRoZSB0eXBlIGlzIG5vdCBvbiB0aGUgd2ViZ2xOdW1iZXIgbGlzdCwgaXQgZG9lc24ndCB3b3JrXG5cdFx0cmV0dXJuIEdMW1dlYmdsTnVtYmVyW3RoaXMuX3NvdXJjZVR5cGVdXSB8fCB0aGlzLl9zb3VyY2VUeXBlO1xuXHR9XG5cblx0X2NoZWNrTWlwbWFwKCkge1xuXHRcdHRoaXMuX2dlbmVyYXRlTWlwbWFwID0gdGhpcy5fcGFyYW1zLm1pcG1hcDtcblxuXHRcdGlmKCEoaXNQb3dlck9mVHdvKHRoaXMuX3dpZHRoKSAmJiBpc1Bvd2VyT2ZUd28odGhpcy5faGVpZ2h0KSkpIHtcblx0XHRcdHRoaXMuX2dlbmVyYXRlTWlwbWFwID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Y29uc3QgbWluRmlsdGVyID0gV2ViZ2xOdW1iZXJbdGhpcy5fcGFyYW1zLm1pbkZpbHRlcl07XG5cdFx0aWYobWluRmlsdGVyLmluZGV4T2YoJ01JUE1BUCcpID09IC0xKSB7XG5cdFx0XHR0aGlzLl9nZW5lcmF0ZU1pcG1hcCA9IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdF9jaGVja1dyYXBwaW5nKCkge1xuXHRcdGlmKCF0aGlzLl9nZW5lcmF0ZU1pcG1hcCkge1xuXHRcdFx0dGhpcy5fcGFyYW1zLndyYXBTID0gR0wuQ0xBTVBfVE9fRURHRTtcblx0XHRcdHRoaXMuX3BhcmFtcy53cmFwVCA9IEdMLkNMQU1QX1RPX0VER0U7XG5cdFx0fVxuXHR9XG5cblx0X2lzU291cmNlSHRtbEVsZW1lbnQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NvdXJjZVR5cGUgPT09ICdpbWFnZScgfHwgdGhpcy5fc291cmNlVHlwZSA9PT0gJ3ZpZGVvJyB8fCB0aGlzLl9zb3VyY2VUeXBlID09PSAnY2FudmFzJztcblx0fVxuXG5cblx0Z2V0IG1pbkZpbHRlcigpIHtcdHJldHVybiB0aGlzLl9wYXJhbXMubWluRmlsdGVyO1x0fVxuXG5cdHNldCBtaW5GaWx0ZXIobVZhbHVlKSB7XG5cdFx0dGhpcy5fcGFyYW1zLm1pbkZpbHRlciA9IG1WYWx1ZTtcblx0XHR0aGlzLl9jaGVja01pcG1hcCgpO1xuXG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZSk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRoaXMuX3BhcmFtcy5taW5GaWx0ZXIpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuXG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcCgpO1xuXHR9XG5cblx0Z2V0IG1hZ0ZpbHRlcigpIHtcdHJldHVybiB0aGlzLl9wYXJhbXMubWluRmlsdGVyO1x0fVxuXG5cdHNldCBtYWdGaWx0ZXIobVZhbHVlKSB7XG5cdFx0dGhpcy5fcGFyYW1zLm1hZ0ZpbHRlciA9IG1WYWx1ZTtcblxuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmUpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0aGlzLl9wYXJhbXMubWFnRmlsdGVyKTtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblx0fVxuXG5cblx0Z2V0IHdyYXBTKCkge1x0cmV0dXJuIHRoaXMuX3BhcmFtcy53cmFwUztcdH1cblxuXHRzZXQgd3JhcFMobVZhbHVlKSB7XG5cdFx0dGhpcy5fcGFyYW1zLndyYXBTID0gbVZhbHVlO1xuXHRcdHRoaXMuX2NoZWNrV3JhcHBpbmcoKTtcblxuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmUpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMuX3BhcmFtcy53cmFwUyk7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cdH1cblxuXG5cdGdldCB3cmFwVCgpIHtcdHJldHVybiB0aGlzLl9wYXJhbXMud3JhcFQ7XHR9XG5cblx0c2V0IHdyYXBUKG1WYWx1ZSkge1xuXHRcdHRoaXMuX3BhcmFtcy53cmFwVCA9IG1WYWx1ZTtcblx0XHR0aGlzLl9jaGVja1dyYXBwaW5nKCk7XG5cblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLl9wYXJhbXMud3JhcFQpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuXHR9XG5cblx0Z2V0IHRleGVsVHlwZSgpIHtcdHJldHVybiB0aGlzLl90ZXhlbFR5cGU7XHR9XG5cblx0Z2V0IHdpZHRoKCkge1x0cmV0dXJuIHRoaXMuX3dpZHRoO1x0fVxuXG5cdGdldCBoZWlnaHQoKSB7XHRyZXR1cm4gdGhpcy5faGVpZ2h0O1x0fVxuXG5cdGdldCB0ZXh0dXJlKCkge1x0cmV0dXJuIHRoaXMuX3RleHR1cmU7XHR9XG5cblx0Z2V0IGlzVGV4dHVyZVJlYWR5KCkge1x0cmV0dXJuIHRoaXMuX2lzVGV4dHVyZVJlYWR5O1x0fVxuXG59XG5cblxuZnVuY3Rpb24gaXNQb3dlck9mVHdvKHgpIHtcdFxuXHRyZXR1cm4gKHggIT09IDApICYmICghKHggJiAoeCAtIDEpKSk7XG59O1xuXG5mdW5jdGlvbiBnZXRTb3VyY2VUeXBlKG1Tb3VyY2UpIHtcblx0Ly9cdHBvc3NpYmxlIHNvdXJjZSB0eXBlIDogSW1hZ2UgLyBWaWRlbyAvIFVuaXQ4QXJyYXkgLyBGbG9hdDMyQXJyYXlcblx0Ly9cdHRoaXMgbGlzdCBtdXN0IGJlIGZsZXhpYmxlXG5cblx0bGV0IHR5cGUgPSBHTC5VTlNJR05FRF9CWVRFO1xuXG5cdGlmKG1Tb3VyY2UgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdHR5cGUgPSBHTC5VTlNJR05FRF9CWVRFO1xuXHR9IGVsc2UgaWYobVNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcblx0XHR0eXBlID0gR0wuVU5TSUdORURfQllURTtcblx0fSBlbHNlIGlmKG1Tb3VyY2UgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcblx0XHR0eXBlID0gR0wuRkxPQVQ7XG5cdH0gZWxzZSBpZihtU291cmNlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuXHRcdHR5cGUgPSAnaW1hZ2UnO1xuXHR9IGVsc2UgaWYobVNvdXJjZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XG5cdFx0dHlwZSA9ICdjYW52YXMnO1xuXHR9IGVsc2UgaWYobVNvdXJjZSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcblx0XHR0eXBlID0gJ3ZpZGVvJztcblx0fVxuXHRyZXR1cm4gdHlwZTtcbn1cblxubGV0IF93aGl0ZVRleHR1cmUsIF9ncmV5VGV4dHVyZSwgX2JsYWNrVGV4dHVyZTtcblxuR0xUZXh0dXJlLndoaXRlVGV4dHVyZSA9IGZ1bmN0aW9uIHdoaXRlVGV4dHVyZSgpIHtcblx0aWYoX3doaXRlVGV4dHVyZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Y29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cdFx0Y2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDI7XG5cdFx0Y29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdFx0Y3R4LmZpbGxTdHlsZSA9ICcjZmZmJztcblx0XHRjdHguZmlsbFJlY3QoMCwgMCwgMiwgMik7XG5cdFx0X3doaXRlVGV4dHVyZSA9IG5ldyBHTFRleHR1cmUoY2FudmFzKTtcblx0fVxuXHRcblx0cmV0dXJuIF93aGl0ZVRleHR1cmU7XG59O1xuXG5HTFRleHR1cmUuZ3JleVRleHR1cmUgPSBmdW5jdGlvbiBncmV5VGV4dHVyZSgpIHtcblx0aWYoX2dyZXlUZXh0dXJlID09PSB1bmRlZmluZWQpIHtcblx0XHRjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0XHRjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMjtcblx0XHRjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRjdHguZmlsbFN0eWxlID0gJ3JnYigxMjcsIDEyNywgMTI3KSc7XG5cdFx0Y3R4LmZpbGxSZWN0KDAsIDAsIDIsIDIpO1xuXHRcdF9ncmV5VGV4dHVyZSA9IG5ldyBHTFRleHR1cmUoY2FudmFzKTtcblx0fVxuXHRyZXR1cm4gX2dyZXlUZXh0dXJlO1xufTtcblxuR0xUZXh0dXJlLmJsYWNrVGV4dHVyZSA9IGZ1bmN0aW9uIGJsYWNrVGV4dHVyZSgpIHtcblx0aWYoX2JsYWNrVGV4dHVyZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Y29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cdFx0Y2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDI7XG5cdFx0Y29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdFx0Y3R4LmZpbGxTdHlsZSA9ICdyZ2IoMCwgMCwgMCknO1xuXHRcdGN0eC5maWxsUmVjdCgwLCAwLCAyLCAyKTtcblx0XHRfYmxhY2tUZXh0dXJlID0gbmV3IEdMVGV4dHVyZShjYW52YXMpO1xuXHR9XG5cdHJldHVybiBfYmxhY2tUZXh0dXJlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgR0xUZXh0dXJlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL0dMVGV4dHVyZTIuanMiLCIvLyBHTEN1YmVUZXh0dXJlLmpzXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEdMIGZyb20gJy4vR0xUb29sJztcbmltcG9ydCBwYXJzZSBmcm9tICdwYXJzZS1kZHMnO1xubGV0IGdsO1xuY29uc3QgRERTRF9NSVBNQVBDT1VOVCA9IDB4MjAwMDA7XG5jb25zdCBPRkZfTUlQTUFQQ09VTlQgPSA3O1xuY29uc3QgaGVhZGVyTGVuZ3RoSW50ID0gMzE7XG5cbmNsYXNzIEdMQ3ViZVRleHR1cmUge1xuXHRjb25zdHJ1Y3RvcihtU291cmNlLCBtUGFyYW1ldGVycyA9IHt9LCBpc0N1YmVUZXh0dXJlID0gZmFsc2UpIHtcblx0XHRnbCA9IEdMLmdsO1xuXG5cdFx0aWYoaXNDdWJlVGV4dHVyZSkge1xuXHRcdFx0dGhpcy50ZXh0dXJlID0gbVNvdXJjZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRsZXQgaGFzTWlwbWFwcyA9IG1Tb3VyY2UubGVuZ3RoID4gNjtcblx0XHRpZihtU291cmNlWzBdLm1pcG1hcENvdW50KSB7XG5cdFx0XHRoYXNNaXBtYXBzID0gbVNvdXJjZVswXS5taXBtYXBDb3VudCA+IDE7XG5cdFx0fVxuXG5cdFx0dGhpcy50ZXh0dXJlICAgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG5cdFx0dGhpcy5tYWdGaWx0ZXIgPSBtUGFyYW1ldGVycy5tYWdGaWx0ZXIgfHwgZ2wuTElORUFSO1xuXHRcdHRoaXMubWluRmlsdGVyID0gbVBhcmFtZXRlcnMubWluRmlsdGVyIHx8IGdsLkxJTkVBUl9NSVBNQVBfTElORUFSO1xuXHRcdHRoaXMud3JhcFMgICAgID0gbVBhcmFtZXRlcnMud3JhcFMgfHwgZ2wuQ0xBTVBfVE9fRURHRTtcblx0XHR0aGlzLndyYXBUICAgICA9IG1QYXJhbWV0ZXJzLndyYXBUIHx8IGdsLkNMQU1QX1RPX0VER0U7XG5cblx0XHRpZighaGFzTWlwbWFwcyAmJiB0aGlzLm1pbkZpbHRlciA9PSBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUikge1xuXHRcdFx0dGhpcy5taW5GaWx0ZXIgPSBnbC5MSU5FQVI7XG5cdFx0fVxuXG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGhpcy50ZXh0dXJlKTtcblx0XHRjb25zdCB0YXJnZXRzID0gW1xuXHRcdFx0Z2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YLCBnbC5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1gsIFxuXHRcdFx0Z2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9ZLCBnbC5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1ksIFxuXHRcdFx0Z2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aLCBnbC5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1ogXG5cdFx0XTtcblxuXHRcdFxuXHRcdGxldCBudW1MZXZlbHMgPSAxO1xuXHRcdGxldCBpbmRleCA9IDA7XG5cdFx0bnVtTGV2ZWxzID0gbVNvdXJjZS5sZW5ndGggLyA2O1xuXHRcdHRoaXMubnVtTGV2ZWxzID0gbnVtTGV2ZWxzO1xuXG5cdFx0aWYgKGhhc01pcG1hcHMpIHtcblx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgNjsgaisrKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbnVtTGV2ZWxzOyBpKyspIHtcblx0XHRcdFx0XHRnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRcdGluZGV4ID0gaiAqIG51bUxldmVscyArIGk7XG5cdFx0XHRcdFx0aWYobVNvdXJjZVtpbmRleF0uc2hhcGUpIHtcblx0XHRcdFx0XHRcdGdsLnRleEltYWdlMkQodGFyZ2V0c1tqXSwgaSwgZ2wuUkdCQSwgbVNvdXJjZVtpbmRleF0uc2hhcGVbMF0sIG1Tb3VyY2VbaW5kZXhdLnNoYXBlWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgbVNvdXJjZVtpbmRleF0uZGF0YSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGdsLnRleEltYWdlMkQodGFyZ2V0c1tqXSwgaSwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbVNvdXJjZVtpbmRleF0pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMud3JhcFMpO1xuXHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMud3JhcFQpO1xuXHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0aGlzLm1hZ0ZpbHRlcik7XG5cdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRoaXMubWluRmlsdGVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCA2OyBqKyspIHtcblx0XHRcdFx0aW5kZXggPSBqICogbnVtTGV2ZWxzO1xuXHRcdFx0XHRnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG5cdFx0XHRcdGlmKG1Tb3VyY2VbaW5kZXhdLnNoYXBlKSB7XG5cdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRCh0YXJnZXRzW2pdLCAwLCBnbC5SR0JBLCBtU291cmNlW2luZGV4XS5zaGFwZVswXSwgbVNvdXJjZVtpbmRleF0uc2hhcGVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBtU291cmNlW2luZGV4XS5kYXRhKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRnbC50ZXhJbWFnZTJEKHRhcmdldHNbal0sIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG1Tb3VyY2VbaW5kZXhdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLndyYXBTKTtcblx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX1dSQVBfVCwgdGhpcy53cmFwVCk7XG5cdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0aGlzLm1hZ0ZpbHRlcik7XG5cdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLm1pbkZpbHRlcik7XG5cdFx0XHR9XG5cblx0XHRcdGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfQ1VCRV9NQVApO1xuXHRcdH1cblxuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwpO1xuXHR9XG5cblx0XG5cblx0Ly9cdFBVQkxJQyBNRVRIT0RcblxuXHRiaW5kKGluZGV4ID0gMCkge1xuXHRcdGlmKCFHTC5zaGFkZXIpIHsgcmV0dXJuOyB9XG5cblx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgaW5kZXgpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIHRoaXMudGV4dHVyZSk7XG5cdFx0Z2wudW5pZm9ybTFpKEdMLnNoYWRlci51bmlmb3JtVGV4dHVyZXNbaW5kZXhdLCBpbmRleCk7XG5cdFx0dGhpcy5fYmluZEluZGV4ID0gaW5kZXg7XG5cdH1cblxuXHR1bmJpbmQoKSB7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgbnVsbCk7XHRcblx0fVxufVxuXG5cbkdMQ3ViZVRleHR1cmUucGFyc2VERFMgPSBmdW5jdGlvbiBwYXJzZUREUyhtQXJyYXlCdWZmZXIpIHtcblxuXHRmdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcblx0XHRpZiAobWluID4gbWF4KSB7XG5cdFx0XHRyZXR1cm4gY2xhbXAodmFsdWUsIG1heCwgbWluKTtcblx0XHR9XG5cblx0XHRpZiAodmFsdWUgPCBtaW4pIHJldHVybiBtaW47XG5cdFx0ZWxzZSBpZiAodmFsdWUgPiBtYXgpIHJldHVybiBtYXg7XG5cdFx0ZWxzZSByZXR1cm4gdmFsdWU7XG5cdH1cblxuXHQvL1x0Q0hFQ0tJTkcgTUlQIE1BUCBMRVZFTFNcblx0Y29uc3QgZGRzSW5mb3MgPSBwYXJzZShtQXJyYXlCdWZmZXIpO1xuXHRjb25zdCB7IGZsYWdzIH0gPSBkZHNJbmZvcztcblx0Y29uc3QgaGVhZGVyID0gbmV3IEludDMyQXJyYXkobUFycmF5QnVmZmVyLCAwLCBoZWFkZXJMZW5ndGhJbnQpO1xuXHRsZXQgbWlwbWFwQ291bnQgPSAxO1xuXHRpZiAoZmxhZ3MgJiBERFNEX01JUE1BUENPVU5UKSB7XG5cdFx0bWlwbWFwQ291bnQgPSBNYXRoLm1heCgxLCBoZWFkZXJbT0ZGX01JUE1BUENPVU5UXSk7XG5cdH1cblx0Y29uc3Qgc291cmNlcyA9IGRkc0luZm9zLmltYWdlcy5tYXAoKGltZykgPT4ge1xuXHRcdGNvbnN0IGZhY2VEYXRhID0gbmV3IEZsb2F0MzJBcnJheShtQXJyYXlCdWZmZXIuc2xpY2UoaW1nLm9mZnNldCwgaW1nLm9mZnNldCArIGltZy5sZW5ndGgpKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZGF0YTogZmFjZURhdGEsXG5cdFx0XHRzaGFwZTogaW1nLnNoYXBlLFxuXHRcdFx0bWlwbWFwQ291bnQsXG5cdFx0fTtcblx0fSk7XG5cblx0cmV0dXJuIG5ldyBHTEN1YmVUZXh0dXJlKHNvdXJjZXMpO1xufTtcblxuXG5leHBvcnQgZGVmYXVsdCBHTEN1YmVUZXh0dXJlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL0dMQ3ViZVRleHR1cmUuanMiLCIvLyBFdmVudERpc3BhdGNoZXIuanNcblxubGV0IHN1cHBvcnRzQ3VzdG9tRXZlbnRzID0gdHJ1ZTtcbnRyeSB7XG5cdGxldCBuZXdUZXN0Q3VzdG9tRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcblx0bmV3VGVzdEN1c3RvbUV2ZW50ID0gbnVsbDtcbn0gY2F0Y2goZSkge1xuXHRzdXBwb3J0c0N1c3RvbUV2ZW50cyA9IGZhbHNlO1xufVxuXG5jbGFzcyBFdmVudERpc3BhdGNoZXIge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuX2V2ZW50TGlzdGVuZXJzID0ge307XG5cdH1cblxuXG5cdGFkZEV2ZW50TGlzdGVuZXIoYUV2ZW50VHlwZSwgYUZ1bmN0aW9uKSB7XG5cblx0XHRpZih0aGlzLl9ldmVudExpc3RlbmVycyA9PT0gbnVsbCB8fCB0aGlzLl9ldmVudExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLl9ldmVudExpc3RlbmVycyA9IHt9O1xuXHRcdH1cblxuXHRcdGlmKCF0aGlzLl9ldmVudExpc3RlbmVyc1thRXZlbnRUeXBlXSkge1xuXHRcdFx0dGhpcy5fZXZlbnRMaXN0ZW5lcnNbYUV2ZW50VHlwZV0gPSBbXTtcblx0XHR9XG5cdFx0dGhpcy5fZXZlbnRMaXN0ZW5lcnNbYUV2ZW50VHlwZV0ucHVzaChhRnVuY3Rpb24pO1xuXHRcdFxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRvbihhRXZlbnRUeXBlLCBhRnVuY3Rpb24pIHtcdHJldHVybiB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoYUV2ZW50VHlwZSwgYUZ1bmN0aW9uKTtcdH1cblxuXHRyZW1vdmVFdmVudExpc3RlbmVyKGFFdmVudFR5cGUsIGFGdW5jdGlvbikge1xuXHRcdGlmKHRoaXMuX2V2ZW50TGlzdGVuZXJzID09PSBudWxsIHx8IHRoaXMuX2V2ZW50TGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuX2V2ZW50TGlzdGVuZXJzID0ge307XG5cdFx0fVxuXHRcdGNvbnN0IGN1cnJlbnRBcnJheSA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzW2FFdmVudFR5cGVdO1xuXHRcdFxuXHRcdGlmICh0eXBlb2YoY3VycmVudEFycmF5KSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRcblx0XHRsZXQgY3VycmVudEFycmF5TGVuZ3RoID0gY3VycmVudEFycmF5Lmxlbmd0aDtcblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgY3VycmVudEFycmF5TGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmKGN1cnJlbnRBcnJheVtpXSA9PT0gYUZ1bmN0aW9uKSB7XG5cdFx0XHRcdGN1cnJlbnRBcnJheS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdGktLTtcblx0XHRcdFx0Y3VycmVudEFycmF5TGVuZ3RoLS07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0b2ZmKGFFdmVudFR5cGUsIGFGdW5jdGlvbikge1x0cmV0dXJuIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihhRXZlbnRUeXBlLCBhRnVuY3Rpb24pO1x0fVxuXG5cdGRpc3BhdGNoRXZlbnQoYUV2ZW50KSB7XG5cdFx0aWYodGhpcy5fZXZlbnRMaXN0ZW5lcnMgPT09IG51bGwgfHwgdGhpcy5fZXZlbnRMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSB7fTtcblx0XHR9XG5cdFx0Y29uc3QgZXZlbnRUeXBlID0gYUV2ZW50LnR5cGU7XG5cdFx0XG5cdFx0dHJ5IHtcblx0XHRcdGlmKGFFdmVudC50YXJnZXQgPT09IG51bGwpIHtcblx0XHRcdFx0YUV2ZW50LnRhcmdldCA9IHRoaXM7XG5cdFx0XHR9XG5cdFx0XHRhRXZlbnQuY3VycmVudFRhcmdldCA9IHRoaXM7XG5cdFx0fSBjYXRjaCh0aGVFcnJvcikge1xuXHRcdFx0Y29uc3QgbmV3RXZlbnQgPSB7IHR5cGU6IGV2ZW50VHlwZSwgZGV0YWlsOiBhRXZlbnQuZGV0YWlsLCBkaXNwYXRjaGVyOiB0aGlzIH07XG5cdFx0XHRyZXR1cm4gdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcblx0XHR9XG5cdFx0XG5cdFx0Y29uc3QgY3VycmVudEV2ZW50TGlzdGVuZXJzID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnNbZXZlbnRUeXBlXTtcblx0XHRpZihjdXJyZW50RXZlbnRMaXN0ZW5lcnMgIT09IG51bGwgJiYgY3VycmVudEV2ZW50TGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGNvbnN0IGN1cnJlbnRBcnJheSA9IHRoaXMuX2NvcHlBcnJheShjdXJyZW50RXZlbnRMaXN0ZW5lcnMpO1xuXHRcdFx0Y29uc3QgY3VycmVudEFycmF5TGVuZ3RoID0gY3VycmVudEFycmF5Lmxlbmd0aDtcblx0XHRcdGZvcihsZXQgaSA9IDA7IGkgPCBjdXJyZW50QXJyYXlMZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb25zdCBjdXJyZW50RnVuY3Rpb24gPSBjdXJyZW50QXJyYXlbaV07XG5cdFx0XHRcdGN1cnJlbnRGdW5jdGlvbi5jYWxsKHRoaXMsIGFFdmVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0ZGlzcGF0Y2hDdXN0b21FdmVudChhRXZlbnRUeXBlLCBhRGV0YWlsKSB7XG5cdFx0bGV0IG5ld0V2ZW50O1xuXHRcdGlmIChzdXBwb3J0c0N1c3RvbUV2ZW50cykge1xuXHRcdFx0bmV3RXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcblx0XHRcdG5ld0V2ZW50LmRpc3BhdGNoZXIgPSB0aGlzO1xuXHRcdFx0bmV3RXZlbnQuaW5pdEN1c3RvbUV2ZW50KGFFdmVudFR5cGUsIGZhbHNlLCBmYWxzZSwgYURldGFpbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5ld0V2ZW50ID0geyB0eXBlOiBhRXZlbnRUeXBlLCBkZXRhaWw6IGFEZXRhaWwsIGRpc3BhdGNoZXI6IHRoaXMgfTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG5cdH1cblxuXHR0cmlnZ2VyKGFFdmVudFR5cGUsIGFEZXRhaWwpIHtcdHJldHVybiB0aGlzLmRpc3BhdGNoQ3VzdG9tRXZlbnQoYUV2ZW50VHlwZSwgYURldGFpbCk7XHR9XG5cblx0X2Rlc3Ryb3koKSB7XG5cdFx0aWYodGhpcy5fZXZlbnRMaXN0ZW5lcnMgIT09IG51bGwpIHtcblx0XHRcdGZvcihjb25zdCBvYmplY3ROYW1lIGluIHRoaXMuX2V2ZW50TGlzdGVuZXJzKSB7XG5cdFx0XHRcdGlmKHRoaXMuX2V2ZW50TGlzdGVuZXJzLmhhc093blByb3BlcnR5KG9iamVjdE5hbWUpKSB7XG5cdFx0XHRcdFx0Y29uc3QgY3VycmVudEFycmF5ID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnNbb2JqZWN0TmFtZV07XG5cdFx0XHRcdFx0Y29uc3QgY3VycmVudEFycmF5TGVuZ3RoID0gY3VycmVudEFycmF5Lmxlbmd0aDtcblx0XHRcdFx0XHRmb3IobGV0IGkgPSAwOyBpIDwgY3VycmVudEFycmF5TGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGN1cnJlbnRBcnJheVtpXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudExpc3RlbmVyc1tvYmplY3ROYW1lXTtcdFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9ldmVudExpc3RlbmVycyA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0X2NvcHlBcnJheShhQXJyYXkpIHtcblx0XHRjb25zdCBjdXJyZW50QXJyYXkgPSBuZXcgQXJyYXkoYUFycmF5Lmxlbmd0aCk7XG5cdFx0Y29uc3QgY3VycmVudEFycmF5TGVuZ3RoID0gY3VycmVudEFycmF5Lmxlbmd0aDtcblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgY3VycmVudEFycmF5TGVuZ3RoOyBpKyspIHtcblx0XHRcdGN1cnJlbnRBcnJheVtpXSA9IGFBcnJheVtpXTtcblx0XHR9XG5cdFx0cmV0dXJuIGN1cnJlbnRBcnJheTtcblx0fVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IEV2ZW50RGlzcGF0Y2hlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9FdmVudERpc3BhdGNoZXIuanMiLCIvLyBPcmJpdGFsQ29udHJvbC5qc1xuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgRWFzZU51bWJlciBmcm9tICcuL0Vhc2VOdW1iZXInO1xuaW1wb3J0IFNjaGVkdWxlciBmcm9tICAnc2NoZWR1bGluZyc7XG5pbXBvcnQgeyB2ZWMzIH0gZnJvbSAnZ2wtbWF0cml4JztcblxuY29uc3QgZ2V0TW91c2UgPSBmdW5jdGlvbiAobUV2ZW50LCBtVGFyZ2V0KSB7XG5cblx0Y29uc3QgbyA9IG1UYXJnZXQgfHwge307XG5cdGlmKG1FdmVudC50b3VjaGVzKSB7XG5cdFx0by54ID0gbUV2ZW50LnRvdWNoZXNbMF0ucGFnZVg7XG5cdFx0by55ID0gbUV2ZW50LnRvdWNoZXNbMF0ucGFnZVk7XG5cdH0gZWxzZSB7XG5cdFx0by54ID0gbUV2ZW50LmNsaWVudFg7XG5cdFx0by55ID0gbUV2ZW50LmNsaWVudFk7XG5cdH1cblxuXHRyZXR1cm4gbztcbn07XG5cbmNsYXNzIE9yYml0YWxDb250cm9sIHtcblxuXHRjb25zdHJ1Y3RvcihtVGFyZ2V0LCBtTGlzdGVuZXJUYXJnZXQgPSB3aW5kb3csIG1SYWRpdXMgPSA1MDApIHtcblx0XHR0aGlzLl90YXJnZXQgICAgICAgICA9IG1UYXJnZXQ7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQgPSBtTGlzdGVuZXJUYXJnZXQ7XG5cdFx0dGhpcy5fbW91c2UgICAgICAgICAgPSB7fTtcblx0XHR0aGlzLl9wcmVNb3VzZSAgICAgICA9IHt9O1xuXHRcdHRoaXMuY2VudGVyICAgICAgICAgID0gdmVjMy5jcmVhdGUoKTtcblx0XHR0aGlzLl91cCAgICAgICAgICAgICA9IHZlYzMuZnJvbVZhbHVlcygwLCAxLCAwKTtcblx0XHR0aGlzLnJhZGl1cyAgICAgICAgICA9IG5ldyBFYXNlTnVtYmVyKG1SYWRpdXMpO1xuXHRcdHRoaXMucG9zaXRpb24gICAgICAgID0gdmVjMy5mcm9tVmFsdWVzKDAsIDAsIHRoaXMucmFkaXVzLnZhbHVlKTtcblx0XHR0aGlzLnBvc2l0aW9uT2Zmc2V0ICA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0dGhpcy5fcnggICAgICAgICAgICAgPSBuZXcgRWFzZU51bWJlcigwKTtcblx0XHR0aGlzLl9yeC5saW1pdCgtTWF0aC5QSSAvIDIsIE1hdGguUEkgLyAyKTtcblx0XHR0aGlzLl9yeSAgICAgICAgICAgICA9IG5ldyBFYXNlTnVtYmVyKDApO1xuXHRcdHRoaXMuX3ByZVJYICAgICAgICAgID0gMDtcblx0XHR0aGlzLl9wcmVSWSAgICAgICAgICA9IDA7XG5cdFx0XG5cdFx0dGhpcy5faXNMb2NrWm9vbSAgICAgPSBmYWxzZTtcblx0XHR0aGlzLl9pc0xvY2tSb3RhdGlvbiA9IGZhbHNlO1xuXHRcdHRoaXMuX2lzSW52ZXJ0ICAgICAgID0gZmFsc2U7XG5cdFx0dGhpcy5zZW5zaXRpdml0eVx0ID0gMS4wO1xuXG5cblx0XHR0aGlzLl93aGVlbEJpbmQgPSAoZSkgPT4gdGhpcy5fb25XaGVlbChlKTtcblx0XHR0aGlzLl9kb3duQmluZCA9IChlKSA9PiB0aGlzLl9vbkRvd24oZSk7XG5cdFx0dGhpcy5fbW92ZUJpbmQgPSAoZSkgPT4gdGhpcy5fb25Nb3ZlKGUpO1xuXHRcdHRoaXMuX3VwQmluZCA9ICgpID0+IHRoaXMuX29uVXAoKTtcblx0XG5cdFx0dGhpcy5jb25uZWN0KCk7XHRcdFxuXHRcdFNjaGVkdWxlci5hZGRFRigoKSA9PiB0aGlzLl9sb29wKCkpO1xuXHR9XG5cblx0Y29ubmVjdCgpIHtcblx0XHR0aGlzLmRpc2Nvbm5lY3QoKTtcblxuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCB0aGlzLl93aGVlbEJpbmQpO1xuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcy5fd2hlZWxCaW5kKTtcblxuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX2Rvd25CaW5kKTtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fZG93bkJpbmQpO1xuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX21vdmVCaW5kKTtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9tb3ZlQmluZCk7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fdXBCaW5kKTtcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX3VwQmluZCk7XG5cdH1cblxuXHRkaXNjb25uZWN0KCkge1xuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCB0aGlzLl93aGVlbEJpbmQpO1xuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcy5fd2hlZWxCaW5kKTtcblxuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX2Rvd25CaW5kKTtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fZG93bkJpbmQpO1xuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX21vdmVCaW5kKTtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9tb3ZlQmluZCk7XG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fdXBCaW5kKTtcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX3VwQmluZCk7XG5cdH1cblxuXG5cdC8vXHRQVUJMSUMgTUVUSE9EU1xuXG5cdGxvY2sobVZhbHVlID0gdHJ1ZSkge1xuXHRcdHRoaXMuX2lzTG9ja1pvb20gPSBtVmFsdWU7XG5cdFx0dGhpcy5faXNMb2NrUm90YXRpb24gPSBtVmFsdWU7XG5cdFx0dGhpcy5faXNNb3VzZURvd24gPSBmYWxzZTtcblx0fVxuXG5cdGxvY2tab29tKG1WYWx1ZSA9IHRydWUpIHtcblx0XHR0aGlzLl9pc0xvY2tab29tID0gbVZhbHVlO1xuXHR9XG5cblxuXHRsb2NrUm90YXRpb24obVZhbHVlID0gdHJ1ZSkge1xuXHRcdHRoaXMuX2lzTG9ja1JvdGF0aW9uID0gbVZhbHVlO1xuXHR9XG5cblxuXHRpbnZlcnNlQ29udHJvbChpc0ludmVydCA9IHRydWUpIHtcblx0XHR0aGlzLl9pc0ludmVydCA9IGlzSW52ZXJ0O1xuXHR9XG5cblxuXHQvL1x0RVZFTlQgSEFORExFUkVTXG5cdF9vbkRvd24obUV2ZW50KSB7XG5cdFx0aWYodGhpcy5faXNMb2NrUm90YXRpb24pIHsgcmV0dXJuOyB9XG5cdFx0dGhpcy5faXNNb3VzZURvd24gPSB0cnVlO1xuXHRcdGdldE1vdXNlKG1FdmVudCwgdGhpcy5fbW91c2UpO1xuXHRcdGdldE1vdXNlKG1FdmVudCwgdGhpcy5fcHJlTW91c2UpO1xuXHRcdHRoaXMuX3ByZVJYID0gdGhpcy5fcngudGFyZ2V0VmFsdWU7XG5cdFx0dGhpcy5fcHJlUlkgPSB0aGlzLl9yeS50YXJnZXRWYWx1ZTtcblx0fVxuXG5cblx0X29uTW92ZShtRXZlbnQpIHtcblx0XHRpZih0aGlzLl9pc0xvY2tSb3RhdGlvbikgeyByZXR1cm47IH1cblx0XHRnZXRNb3VzZShtRXZlbnQsIHRoaXMuX21vdXNlKTtcblx0XHRpZihtRXZlbnQudG91Y2hlcykgeyBtRXZlbnQucHJldmVudERlZmF1bHQoKTsgfVxuXG5cdFx0aWYodGhpcy5faXNNb3VzZURvd24pIHtcblx0XHRcdGxldCBkaWZmWCA9IC0odGhpcy5fbW91c2UueCAtIHRoaXMuX3ByZU1vdXNlLngpO1xuXHRcdFx0aWYodGhpcy5faXNJbnZlcnQpIHsgZGlmZlggKj0gLTE7IH1cblx0XHRcdHRoaXMuX3J5LnZhbHVlID0gdGhpcy5fcHJlUlkgLSBkaWZmWCAqIDAuMDEgKiB0aGlzLnNlbnNpdGl2aXR5O1xuXG5cdFx0XHRsZXQgZGlmZlkgPSAtKHRoaXMuX21vdXNlLnkgLSB0aGlzLl9wcmVNb3VzZS55KTtcblx0XHRcdGlmKHRoaXMuX2lzSW52ZXJ0KSB7IGRpZmZZICo9IC0xOyB9XG5cdFx0XHR0aGlzLl9yeC52YWx1ZSA9IHRoaXMuX3ByZVJYIC0gZGlmZlkgKiAwLjAxICogdGhpcy5zZW5zaXRpdml0eTtcblx0XHR9XG5cdH1cblxuXG5cdF9vblVwKCkge1xuXHRcdGlmKHRoaXMuX2lzTG9ja1JvdGF0aW9uKSB7IHJldHVybjsgfVxuXHRcdHRoaXMuX2lzTW91c2VEb3duID0gZmFsc2U7XG5cdH1cblxuXG5cdF9vbldoZWVsKG1FdmVudCkge1xuXHRcdGlmKHRoaXMuX2lzTG9ja1pvb20pIHtcdHJldHVybjtcdH1cblx0XHRjb25zdCB3ID0gbUV2ZW50LndoZWVsRGVsdGE7XG5cdFx0Y29uc3QgZCA9IG1FdmVudC5kZXRhaWw7XG5cdFx0bGV0IHZhbHVlID0gMDtcblx0XHRpZiAoZCkge1xuXHRcdFx0aWYgKHcpIHtcblx0XHRcdFx0dmFsdWUgPSB3IC8gZCAvIDQwICogZCA+IDAgPyAxIDogLTE7IC8vIE9wZXJhXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWx1ZSA9IC1kIC8gMzsgICAgICAgICAgICAgIC8vIEZpcmVmb3g7ICAgICAgICAgVE9ETzogZG8gbm90IC8zIGZvciBPUyBYXG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhbHVlID0gdyAvIDEyMDsgXG5cdFx0fVxuXG5cdFx0dGhpcy5yYWRpdXMuYWRkKC12YWx1ZSAqIDIpO1xuXHR9XG5cblxuXHQvL1x0UFJJVkFURSBNRVRIT0RTXG5cblx0X2xvb3AoKSB7XG5cblx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuXG5cdFx0aWYodGhpcy5fdGFyZ2V0KSB7XG5cdFx0XHR0aGlzLl91cGRhdGVDYW1lcmEoKTtcblx0XHR9XG5cdH1cblxuXG5cdF91cGRhdGVQb3NpdGlvbigpIHtcblx0XHR0aGlzLnBvc2l0aW9uWzFdID0gTWF0aC5zaW4odGhpcy5fcngudmFsdWUpICogdGhpcy5yYWRpdXMudmFsdWU7XG5cdFx0Y29uc3QgdHIgPSBNYXRoLmNvcyh0aGlzLl9yeC52YWx1ZSkgKiB0aGlzLnJhZGl1cy52YWx1ZTtcblx0XHR0aGlzLnBvc2l0aW9uWzBdID0gTWF0aC5jb3ModGhpcy5fcnkudmFsdWUgKyBNYXRoLlBJICogMC41KSAqIHRyO1xuXHRcdHRoaXMucG9zaXRpb25bMl0gPSBNYXRoLnNpbih0aGlzLl9yeS52YWx1ZSArIE1hdGguUEkgKiAwLjUpICogdHI7XG5cdFx0dmVjMy5hZGQodGhpcy5wb3NpdGlvbiwgdGhpcy5wb3NpdGlvbiwgdGhpcy5wb3NpdGlvbk9mZnNldCk7XG5cdH1cblxuXG5cdF91cGRhdGVDYW1lcmEoKSB7XG5cdFx0dGhpcy5fdGFyZ2V0Lmxvb2tBdCh0aGlzLnBvc2l0aW9uLCB0aGlzLmNlbnRlciwgdGhpcy5fdXApO1xuXHR9XG5cblxuXHQvL1x0R0VUVEVSIC8gU0VUVEVSXG5cblxuXHRnZXQgcngoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3J4O1xuXHR9XG5cblxuXHRnZXQgcnkoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3J5O1xuXHR9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgT3JiaXRhbENvbnRyb2w7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvT3JiaXRhbENvbnRyb2wuanMiLCIvLyBDYW1lcmFPcnRoby5qc1xuXG5pbXBvcnQgQ2FtZXJhIGZyb20gJy4vQ2FtZXJhJztcbmltcG9ydCB7IHZlYzMgfSBmcm9tICdnbC1tYXRyaXgnO1xuXG5jbGFzcyBDYW1lcmFPcnRobyBleHRlbmRzIENhbWVyYSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cblx0XHRjb25zdCBleWUgICAgPSB2ZWMzLmNsb25lKFswLCAwLCAxNV0pO1xuXHRcdGNvbnN0IGNlbnRlciA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0Y29uc3QgdXAgICAgID0gdmVjMy5jbG9uZShbMCwgLTEsIDBdKTtcblx0XHR0aGlzLmxvb2tBdChleWUsIGNlbnRlciwgdXApO1xuXHRcdHRoaXMub3J0aG8oMSwgLTEsIDEsIC0xKTtcblx0fVxuXG5cblx0c2V0Qm91bmRhcnkobGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyPTAuMSwgZmFyPTEwMCkge1xuXHRcdHRoaXMub3J0aG8obGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIpO1xuXHR9XG5cblxuXHRvcnRobyhsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXI9MC4xLCBmYXI9MTAwKSB7XG5cdFx0dGhpcy5sZWZ0ICAgPSBsZWZ0O1xuXHRcdHRoaXMucmlnaHQgID0gcmlnaHQ7XG5cdFx0dGhpcy50b3AgICAgPSB0b3A7XG5cdFx0dGhpcy5ib3R0b20gPSBib3R0b207XG5cdFx0bWF0NC5vcnRobyh0aGlzLl9wcm9qZWN0aW9uLCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhcik7XG5cdH1cblxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IENhbWVyYU9ydGhvO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2NhbWVyYXMvQ2FtZXJhT3J0aG8uanMiLCIvLyBPYmplY3QzRC5qc1xuXG5pbXBvcnQgeyB2ZWMzLCBtYXQ0LCBxdWF0IH0gZnJvbSAnZ2wtbWF0cml4JztcblxuY2xhc3MgT2JqZWN0M0Qge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXG5cdFx0dGhpcy5feCA9IDA7XG5cdFx0dGhpcy5feSA9IDA7XG5cdFx0dGhpcy5feiA9IDA7XG5cblx0XHR0aGlzLl9zeCA9IDE7XG5cdFx0dGhpcy5fc3kgPSAxO1xuXHRcdHRoaXMuX3N6ID0gMTtcblxuXHRcdHRoaXMuX3J4ID0gMDtcblx0XHR0aGlzLl9yeSA9IDA7XG5cdFx0dGhpcy5fcnogPSAwO1xuXG5cdFx0dGhpcy5fcG9zaXRpb24gPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdHRoaXMuX3NjYWxlID0gdmVjMy5mcm9tVmFsdWVzKDEsIDEsIDEpO1xuXHRcdHRoaXMuX3JvdGF0aW9uID0gdmVjMy5jcmVhdGUoKTtcblxuXHRcdHRoaXMuX21hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cdFx0dGhpcy5fbWF0cml4Um90YXRpb24gPSBtYXQ0LmNyZWF0ZSgpO1xuXHRcdHRoaXMuX21hdHJpeFNjYWxlID0gbWF0NC5jcmVhdGUoKTtcblx0XHR0aGlzLl9tYXRyaXhUcmFuc2xhdGlvbiA9IG1hdDQuY3JlYXRlKCk7XG5cdFx0dGhpcy5fbWF0cml4UXVhdGVybmlvbiA9IG1hdDQuY3JlYXRlKCk7XG5cdFx0dGhpcy5fcXVhdCA9IHF1YXQuY3JlYXRlKCk7XG5cdH1cblxuXHRfdXBkYXRlKCkge1xuXHRcdHZlYzMuc2V0KHRoaXMuX3NjYWxlLCB0aGlzLl9zeCwgdGhpcy5fc3ksIHRoaXMuX3N6KTtcblx0XHR2ZWMzLnNldCh0aGlzLl9yb3RhdGlvbiwgdGhpcy5fcngsIHRoaXMuX3J5LCB0aGlzLl9yeik7XG5cdFx0dmVjMy5zZXQodGhpcy5fcG9zaXRpb24sIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3opO1xuXG5cdFx0bWF0NC5pZGVudGl0eSh0aGlzLl9tYXRyaXhUcmFuc2xhdGlvbiwgdGhpcy5fbWF0cml4VHJhbnNsYXRpb24pO1xuXHRcdG1hdDQuaWRlbnRpdHkodGhpcy5fbWF0cml4U2NhbGUsIHRoaXMuX21hdHJpeFNjYWxlKTtcblx0XHRtYXQ0LmlkZW50aXR5KHRoaXMuX21hdHJpeFJvdGF0aW9uLCB0aGlzLl9tYXRyaXhSb3RhdGlvbik7XG5cblx0XHRtYXQ0LnJvdGF0ZVgodGhpcy5fbWF0cml4Um90YXRpb24sIHRoaXMuX21hdHJpeFJvdGF0aW9uLCB0aGlzLl9yeCk7XG5cdFx0bWF0NC5yb3RhdGVZKHRoaXMuX21hdHJpeFJvdGF0aW9uLCB0aGlzLl9tYXRyaXhSb3RhdGlvbiwgdGhpcy5fcnkpO1xuXHRcdG1hdDQucm90YXRlWih0aGlzLl9tYXRyaXhSb3RhdGlvbiwgdGhpcy5fbWF0cml4Um90YXRpb24sIHRoaXMuX3J6KTtcblxuXG5cdFx0bWF0NC5mcm9tUXVhdCh0aGlzLl9tYXRyaXhRdWF0ZXJuaW9uLCB0aGlzLl9xdWF0KTtcblx0XHRtYXQ0Lm11bCh0aGlzLl9tYXRyaXhSb3RhdGlvbiwgdGhpcy5fbWF0cml4UXVhdGVybmlvbiwgdGhpcy5fbWF0cml4Um90YXRpb24pO1xuXG5cdFx0bWF0NC5zY2FsZSh0aGlzLl9tYXRyaXhTY2FsZSwgdGhpcy5fbWF0cml4U2NhbGUsIHRoaXMuX3NjYWxlKTtcblx0XHRtYXQ0LnRyYW5zbGF0ZSh0aGlzLl9tYXRyaXhUcmFuc2xhdGlvbiwgdGhpcy5fbWF0cml4VHJhbnNsYXRpb24sIHRoaXMuX3Bvc2l0aW9uKTtcblxuXHRcdG1hdDQubXVsKHRoaXMuX21hdHJpeCwgdGhpcy5fbWF0cml4VHJhbnNsYXRpb24sIHRoaXMuX21hdHJpeFJvdGF0aW9uKTtcblx0XHRtYXQ0Lm11bCh0aGlzLl9tYXRyaXgsIHRoaXMuX21hdHJpeCwgdGhpcy5fbWF0cml4U2NhbGUpO1xuXG5cdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHR9XG5cblxuXHRzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKG1RdWF0KSB7XG5cdFx0cXVhdC5jb3B5KHRoaXMuX3F1YXQsIG1RdWF0KTtcblx0XHR0aGlzLl9uZWVkVXBkYXRlID0gdHJ1ZTtcblx0fVxuXG5cblx0Z2V0IG1hdHJpeCgpIHtcblx0XHRpZih0aGlzLl9uZWVkVXBkYXRlKSB7XHR0aGlzLl91cGRhdGUoKTtcdH1cblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4O1xuXHR9XG5cblx0Z2V0IHgoKSB7XHRyZXR1cm4gdGhpcy5feDtcdH1cblx0c2V0IHgobVZhbHVlKSB7XG5cdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5feCA9IG1WYWx1ZTtcblx0fVxuXG5cdGdldCB5KCkge1x0cmV0dXJuIHRoaXMuX3k7XHR9XG5cdHNldCB5KG1WYWx1ZSkge1xuXHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMuX3kgPSBtVmFsdWU7XG5cdH1cblxuXHRnZXQgeigpIHtcdHJldHVybiB0aGlzLl96O1x0fVxuXHRzZXQgeihtVmFsdWUpIHtcblx0XHR0aGlzLl9uZWVkVXBkYXRlID0gdHJ1ZTtcblx0XHR0aGlzLl96ID0gbVZhbHVlO1xuXHR9XG5cblx0XG5cdGdldCBzY2FsZVgoKSB7XHRyZXR1cm4gdGhpcy5fc3g7XHR9XG5cdHNldCBzY2FsZVgobVZhbHVlKSB7XG5cdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5fc3ggPSBtVmFsdWU7XG5cdH1cblxuXHRnZXQgc2NhbGVZKCkge1x0cmV0dXJuIHRoaXMuX3N5O1x0fVxuXHRzZXQgc2NhbGVZKG1WYWx1ZSkge1xuXHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMuX3N5ID0gbVZhbHVlO1xuXHR9XG5cblx0Z2V0IHNjYWxlWigpIHtcdHJldHVybiB0aGlzLl9zejtcdH1cblx0c2V0IHNjYWxlWihtVmFsdWUpIHtcblx0XHR0aGlzLl9uZWVkVXBkYXRlID0gdHJ1ZTtcblx0XHR0aGlzLl9zeiA9IG1WYWx1ZTtcblx0fVxuXG5cblx0Z2V0IHJvdGF0aW9uWCgpIHtcdHJldHVybiB0aGlzLl9yeDtcdH1cblx0c2V0IHJvdGF0aW9uWChtVmFsdWUpIHtcblx0XHR0aGlzLl9uZWVkVXBkYXRlID0gdHJ1ZTtcblx0XHR0aGlzLl9yeCA9IG1WYWx1ZTtcblx0fVxuXG5cdGdldCByb3RhdGlvblkoKSB7XHRyZXR1cm4gdGhpcy5fcnk7XHR9XG5cdHNldCByb3RhdGlvblkobVZhbHVlKSB7XG5cdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5fcnkgPSBtVmFsdWU7XG5cdH1cblxuXHRnZXQgcm90YXRpb25aKCkge1x0cmV0dXJuIHRoaXMuX3J6O1x0fVxuXHRzZXQgcm90YXRpb25aKG1WYWx1ZSkge1xuXHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMuX3J6ID0gbVZhbHVlO1xuXHR9XG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBPYmplY3QzRDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9vYmplY3RzL09iamVjdDNELmpzIiwiLy8gU2hhZGVyTGJzLmpzXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHNpbXBsZUNvbG9yRnJhZyBmcm9tICcuLi9zaGFkZXJzL3NpbXBsZUNvbG9yLmZyYWcnO1xuaW1wb3J0IGJpZ1RyaWFuZ2xlVmVydCBmcm9tICcuLi9zaGFkZXJzL2JpZ1RyaWFuZ2xlLnZlcnQnO1xuaW1wb3J0IGdlbmVyYWxWZXJ0IGZyb20gJy4uL3NoYWRlcnMvZ2VuZXJhbC52ZXJ0JztcbmltcG9ydCBjb3B5RnJhZyBmcm9tICcuLi9zaGFkZXJzL2NvcHkuZnJhZyc7XG5pbXBvcnQgYmFzaWNWZXJ0IGZyb20gJy4uL3NoYWRlcnMvYmFzaWMudmVydCc7XG5pbXBvcnQgc2t5Ym94VmVydCBmcm9tICcuLi9zaGFkZXJzL3NreWJveC52ZXJ0JztcbmltcG9ydCBza3lib3hGcmFnIGZyb20gJy4uL3NoYWRlcnMvc2t5Ym94LmZyYWcnO1xuXG5jb25zdCBTaGFkZXJMaWJzID0ge1xuXHRzaW1wbGVDb2xvckZyYWcsXG5cdGJpZ1RyaWFuZ2xlVmVydCxcblx0Z2VuZXJhbFZlcnQsXG5cdGNvcHlGcmFnLFxuXHRiYXNpY1ZlcnQsXG5cdHNreWJveFZlcnQsXG5cdHNreWJveEZyYWcsXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFNoYWRlckxpYnM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvU2hhZGVyTGlicy5qcyIsIm1vZHVsZS5leHBvcnRzID0gXCIvLyBnZW5lcmFsV2l0aE5vcm1hbC52ZXJ0XFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBHRU5FUkFMX1ZFUlRFWFxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbmF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcbmF0dHJpYnV0ZSB2ZWMzIGFOb3JtYWw7XFxuXFxudW5pZm9ybSBtYXQ0IHVNb2RlbE1hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xcbnVuaWZvcm0gbWF0MyB1Tm9ybWFsTWF0cml4O1xcblxcbnVuaWZvcm0gdmVjMyBwb3NpdGlvbjtcXG51bmlmb3JtIHZlYzMgc2NhbGU7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG5cXHR2ZWMzIHBvcyAgICAgID0gYVZlcnRleFBvc2l0aW9uICogc2NhbGU7XFxuXFx0cG9zICAgICAgICAgICArPSBwb3NpdGlvbjtcXG5cXHRnbF9Qb3NpdGlvbiAgID0gdVByb2plY3Rpb25NYXRyaXggKiB1Vmlld01hdHJpeCAqIHVNb2RlbE1hdHJpeCAqIHZlYzQocG9zLCAxLjApO1xcblxcdFxcblxcdHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcblxcdHZOb3JtYWwgICAgICAgPSBub3JtYWxpemUodU5vcm1hbE1hdHJpeCAqIGFOb3JtYWwpO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9nZW5lcmFsLnZlcnRcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vIGJhc2ljLnZlcnRcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIFNLWUJPWF9WRVJURVhcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMyBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5hdHRyaWJ1dGUgdmVjMyBhTm9ybWFsO1xcblxcbnVuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVWaWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzMgdlZlcnRleDtcXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcdG1hdDQgbWF0VmlldyA9IHVWaWV3TWF0cml4O1xcblxcdG1hdFZpZXdbM11bMF0gPSAwLjA7XFxuXFx0bWF0Vmlld1szXVsxXSA9IDAuMDtcXG5cXHRtYXRWaWV3WzNdWzJdID0gMC4wO1xcblxcdFxcblxcdGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb25NYXRyaXggKiBtYXRWaWV3ICogdU1vZGVsTWF0cml4ICogdmVjNChhVmVydGV4UG9zaXRpb24sIDEuMCk7XFxuXFx0dlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxuXFx0XFxuXFx0dlZlcnRleCA9IGFWZXJ0ZXhQb3NpdGlvbjtcXG5cXHR2Tm9ybWFsID0gYU5vcm1hbDtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3NoYWRlcnMvc2t5Ym94LnZlcnRcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vIGJhc2ljLmZyYWdcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIFNLWUJPWF9GUkFHTUVOVFxcblxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxudW5pZm9ybSBzYW1wbGVyQ3ViZSB0ZXh0dXJlO1xcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjMyB2VmVydGV4O1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKHRleHR1cmUsIHZWZXJ0ZXgpO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9za3lib3guZnJhZ1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBQYXNzTWFjcm8uanNcblxuY2xhc3MgUGFzc01hY3JvIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5fcGFzc2VzID0gW107XG5cdH1cblxuXHRhZGRQYXNzKHBhc3MpIHtcblx0XHR0aGlzLl9wYXNzZXMucHVzaChwYXNzKTtcblx0fVxuXG5cdGdldCBwYXNzZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Bhc3Nlcztcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBQYXNzTWFjcm87XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvcG9zdC9QYXNzTWFjcm8uanMiLCIvLyBQYXNzVkJsdXIuanNcblxuaW1wb3J0IFBhc3NCbHVyQmFzZSBmcm9tICcuL1Bhc3NCbHVyQmFzZSc7XG5cbmNsYXNzIFBhc3NWQmx1ciBleHRlbmRzIFBhc3NCbHVyQmFzZSB7XG5cdGNvbnN0cnVjdG9yKG1RdWFsaXR5ID0gOSwgbVdpZHRoLCBtSGVpZ2h0LCBtUGFyYW1zKSB7XG5cdFx0c3VwZXIobVF1YWxpdHksIFswLCAxXSwgbVdpZHRoLCBtSGVpZ2h0LCBtUGFyYW1zKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBQYXNzVkJsdXI7XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3Bvc3QvUGFzc1ZCbHVyLmpzIiwiLy8gUGFzc0JsdXJCYXNlLmpzXG5cbmltcG9ydCBHTCBmcm9tICcuLi9HTFRvb2wnO1xuaW1wb3J0IFBhc3MgZnJvbSAnLi9QYXNzJztcblxuY29uc3QgZnNCbHVyNSA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvYmx1cjUuZnJhZycpO1xuY29uc3QgZnNCbHVyOSA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvYmx1cjkuZnJhZycpO1xuY29uc3QgZnNCbHVyMTMgPSByZXF1aXJlKCcuLi9zaGFkZXJzL2JsdXIxMy5mcmFnJyk7XG5cbmNsYXNzIFBhc3NCbHVyQmFzZSBleHRlbmRzIFBhc3Mge1xuXHRjb25zdHJ1Y3RvcihtUXVhbGl0eSA9IDksIG1EaXJlY3Rpb24sIG1XaWR0aCwgbUhlaWdodCwgbVBhcmFtcyA9IHt9KSB7XG5cdFx0bGV0IGZzO1xuXHRcdHN3aXRjaChtUXVhbGl0eSkge1xuXHRcdGNhc2UgNTpcblx0XHRkZWZhdWx0OlxuXHRcdFx0ZnMgPSBmc0JsdXI1O1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSA5IDogXG5cdFx0XHRmcyA9IGZzQmx1cjk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDEzIDogXG5cdFx0XHRmcyA9IGZzQmx1cjEzO1xuXHRcdFx0YnJlYWs7XG5cblx0XHR9XG5cdFx0c3VwZXIoZnMsIG1XaWR0aCwgbUhlaWdodCwgbVBhcmFtcyk7XG5cdFx0dGhpcy51bmlmb3JtKCd1RGlyZWN0aW9uJywgbURpcmVjdGlvbik7XG5cdFx0dGhpcy51bmlmb3JtKCd1UmVzb2x1dGlvbicsIFtHTC53aWR0aCwgR0wuaGVpZ2h0XSk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFzc0JsdXJCYXNlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvcG9zdC9QYXNzQmx1ckJhc2UuanMiLCIvLyBQYXNzSEJsdXIuanNcblxuaW1wb3J0IFBhc3NCbHVyQmFzZSBmcm9tICcuL1Bhc3NCbHVyQmFzZSc7XG5cbmNsYXNzIFBhc3NIQmx1ciBleHRlbmRzIFBhc3NCbHVyQmFzZSB7XG5cdGNvbnN0cnVjdG9yKG1RdWFsaXR5ID0gOSwgbVdpZHRoLCBtSGVpZ2h0LCBtUGFyYW1zKSB7XG5cdFx0c3VwZXIobVF1YWxpdHksIFsxLCAwXSwgbVdpZHRoLCBtSGVpZ2h0LCBtUGFyYW1zKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBQYXNzSEJsdXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9wb3N0L1Bhc3NIQmx1ci5qcyIsIm1vZHVsZS5leHBvcnRzID0gXCIvLyBmeGFhLmZyYWdcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIEZYQUFcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlO1xcbnVuaWZvcm0gdmVjMiB1UmVzb2x1dGlvbjtcXG5cXG5cXG5mbG9hdCBGWEFBX1NVQlBJWF9TSElGVCA9IDEuMC80LjA7XFxuI2RlZmluZSBGWEFBX1JFRFVDRV9NSU4gICAoMS4wLyAxMjguMClcXG4jZGVmaW5lIEZYQUFfUkVEVUNFX01VTCAgICgxLjAgLyA4LjApXFxuI2RlZmluZSBGWEFBX1NQQU5fTUFYICAgICA4LjBcXG5cXG5cXG52ZWM0IGFwcGx5RlhBQShzYW1wbGVyMkQgdGV4KSB7XFxuICAgIHZlYzQgY29sb3I7XFxuICAgIHZlYzIgZnJhZ0Nvb3JkID0gZ2xfRnJhZ0Nvb3JkLnh5O1xcbiAgICB2ZWMzIHJnYk5XID0gdGV4dHVyZTJEKHRleCwgKGZyYWdDb29yZCArIHZlYzIoLTEuMCwgLTEuMCkpICogdVJlc29sdXRpb24pLnh5ejtcXG4gICAgdmVjMyByZ2JORSA9IHRleHR1cmUyRCh0ZXgsIChmcmFnQ29vcmQgKyB2ZWMyKDEuMCwgLTEuMCkpICogdVJlc29sdXRpb24pLnh5ejtcXG4gICAgdmVjMyByZ2JTVyA9IHRleHR1cmUyRCh0ZXgsIChmcmFnQ29vcmQgKyB2ZWMyKC0xLjAsIDEuMCkpICogdVJlc29sdXRpb24pLnh5ejtcXG4gICAgdmVjMyByZ2JTRSA9IHRleHR1cmUyRCh0ZXgsIChmcmFnQ29vcmQgKyB2ZWMyKDEuMCwgMS4wKSkgKiB1UmVzb2x1dGlvbikueHl6O1xcbiAgICB2ZWMzIHJnYk0gID0gdGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICAqIHVSZXNvbHV0aW9uKS54eXo7XFxuICAgIHZlYzMgbHVtYSA9IHZlYzMoMC4yOTksIDAuNTg3LCAwLjExNCk7XFxuICAgIGZsb2F0IGx1bWFOVyA9IGRvdChyZ2JOVywgbHVtYSk7XFxuICAgIGZsb2F0IGx1bWFORSA9IGRvdChyZ2JORSwgbHVtYSk7XFxuICAgIGZsb2F0IGx1bWFTVyA9IGRvdChyZ2JTVywgbHVtYSk7XFxuICAgIGZsb2F0IGx1bWFTRSA9IGRvdChyZ2JTRSwgbHVtYSk7XFxuICAgIGZsb2F0IGx1bWFNICA9IGRvdChyZ2JNLCAgbHVtYSk7XFxuICAgIGZsb2F0IGx1bWFNaW4gPSBtaW4obHVtYU0sIG1pbihtaW4obHVtYU5XLCBsdW1hTkUpLCBtaW4obHVtYVNXLCBsdW1hU0UpKSk7XFxuICAgIGZsb2F0IGx1bWFNYXggPSBtYXgobHVtYU0sIG1heChtYXgobHVtYU5XLCBsdW1hTkUpLCBtYXgobHVtYVNXLCBsdW1hU0UpKSk7XFxuXFxuICAgIHZlYzIgZGlyO1xcbiAgICBkaXIueCA9IC0oKGx1bWFOVyArIGx1bWFORSkgLSAobHVtYVNXICsgbHVtYVNFKSk7XFxuICAgIGRpci55ID0gICgobHVtYU5XICsgbHVtYVNXKSAtIChsdW1hTkUgKyBsdW1hU0UpKTtcXG5cXG4gICAgZmxvYXQgZGlyUmVkdWNlID0gbWF4KChsdW1hTlcgKyBsdW1hTkUgKyBsdW1hU1cgKyBsdW1hU0UpICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgwLjI1ICogRlhBQV9SRURVQ0VfTVVMKSwgRlhBQV9SRURVQ0VfTUlOKTtcXG5cXG4gICAgZmxvYXQgcmNwRGlyTWluID0gMS4wIC8gKG1pbihhYnMoZGlyLngpLCBhYnMoZGlyLnkpKSArIGRpclJlZHVjZSk7XFxuICAgIGRpciA9IG1pbih2ZWMyKEZYQUFfU1BBTl9NQVgsIEZYQUFfU1BBTl9NQVgpLFxcbiAgICAgICAgICAgICAgbWF4KHZlYzIoLUZYQUFfU1BBTl9NQVgsIC1GWEFBX1NQQU5fTUFYKSxcXG4gICAgICAgICAgICAgIGRpciAqIHJjcERpck1pbikpICogdVJlc29sdXRpb247XFxuXFxuICAgIHZlYzMgcmdiQSA9IDAuNSAqIChcXG4gICAgICAgIHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIHVSZXNvbHV0aW9uICsgZGlyICogKDEuMCAvIDMuMCAtIDAuNSkpLnh5eiArXFxuICAgICAgICB0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgKiB1UmVzb2x1dGlvbiArIGRpciAqICgyLjAgLyAzLjAgLSAwLjUpKS54eXopO1xcbiAgICB2ZWMzIHJnYkIgPSByZ2JBICogMC41ICsgMC4yNSAqIChcXG4gICAgICAgIHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIHVSZXNvbHV0aW9uICsgZGlyICogLTAuNSkueHl6ICtcXG4gICAgICAgIHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIHVSZXNvbHV0aW9uICsgZGlyICogMC41KS54eXopO1xcblxcbiAgICBmbG9hdCBsdW1hQiA9IGRvdChyZ2JCLCBsdW1hKTtcXG4gICAgaWYgKChsdW1hQiA8IGx1bWFNaW4pIHx8IChsdW1hQiA+IGx1bWFNYXgpKVxcbiAgICAgICAgY29sb3IgPSB2ZWM0KHJnYkEsIDEuMCk7XFxuICAgIGVsc2VcXG4gICAgICAgIGNvbG9yID0gdmVjNChyZ2JCLCAxLjApO1xcbiAgICByZXR1cm4gY29sb3I7XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuIFxcdHZlYzQgY29sb3IgPSBhcHBseUZYQUEodGV4dHVyZSk7XFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9meGFhLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodW5kZWZpbmVkKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcImh0bWwsIGJvZHkge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIHBvc2l0aW9uOiBzdGF0aWM7XFxuICAvKiBQZXJtYWxpbmsgLSB1c2UgdG8gZWRpdCBhbmQgc2hhcmUgdGhpcyBncmFkaWVudDogaHR0cDovL2NvbG9yemlsbGEuY29tL2dyYWRpZW50LWVkaXRvci8jNmQ2ZDZkKzAsMDAwMDAwKzEwMCAqL1xcbiAgYmFja2dyb3VuZDogIzMzMzMzMztcXG4gIC8qIE9sZCBicm93c2VycyAqL1xcbiAgYmFja2dyb3VuZDogLW1vei1yYWRpYWwtZ3JhZGllbnQoY2VudGVyLCBlbGxpcHNlIGNvdmVyLCAjMzMzMzMzIDAlLCAjMDAwMDAwIDEwMCUpO1xcbiAgLyogRkYzLjYtMTUgKi9cXG4gIGJhY2tncm91bmQ6IC13ZWJraXQtcmFkaWFsLWdyYWRpZW50KGNlbnRlciwgZWxsaXBzZSBjb3ZlciwgIzMzMzMzMyAwJSwgIzAwMDAwMCAxMDAlKTtcXG4gIC8qIENocm9tZTEwLTI1LFNhZmFyaTUuMS02ICovXFxuICBiYWNrZ3JvdW5kOiByYWRpYWwtZ3JhZGllbnQoZWxsaXBzZSBhdCBjZW50ZXIsICMzMzMzMzMgMCUsICMwMDAwMDAgMTAwJSk7XFxuICAvKiBXM0MsIElFMTArLCBGRjE2KywgQ2hyb21lMjYrLCBPcGVyYTEyKywgU2FmYXJpNysgKi8gfVxcblxcbmh0bWwge1xcbiAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiBub25lO1xcbiAgLW1vei10ZXh0LXNpemUtYWRqdXN0OiBub25lO1xcbiAgdGV4dC1zaXplLWFkanVzdDogbm9uZTsgfVxcblxcbmgxLCBoMiwgaDMsIGg0LCB0ZXh0LCBwIHtcXG4gIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xcbiAgLW1vei1vc3gtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcXG4gIGZvbnQtZmFtaWx5OiAnT3BlbiBTYW5zJywgc2Fucy1zZXJpZjsgfVxcblxcbi5NYWluLUNhbnZhcyB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHRvcDogMHB4O1xcbiAgbGVmdDogMHB4O1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICBvcGFjaXR5OiAxO1xcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSAuNXMgZWFzZS1vdXQgLjI1czsgfVxcbiAgLmlzTG9hZGluZyAuTWFpbi1DYW52YXMge1xcbiAgICBvcGFjaXR5OiAwOyB9XFxuXFxuLk1lc3NhZ2Uge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDogOTk5O1xcbiAgd2lkdGg6IDEwMCU7XFxuICB0b3A6IGNhbGMoNTAlIC0gNTBweCk7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBsZXR0ZXItc3BhY2luZzogMTFweDtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIG9wYWNpdHk6IDA7XFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IC41cyBlYXNlLW91dCwgbGV0dGVyLXNwYWNpbmcgLjVzIGVhc2Utb3V0OyB9XFxuICAuaXNMb2FkaW5nIC5NZXNzYWdlIHtcXG4gICAgbGV0dGVyLXNwYWNpbmc6IDEwcHg7XFxuICAgIG9wYWNpdHk6IDE7IH1cXG5cXG4uTG9hZGluZy1CYXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDogOTk4O1xcbiAgd2lkdGg6IDAlO1xcbiAgaGVpZ2h0OiAxcHg7XFxuICB0b3A6IDUwJTtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KTtcXG4gIG9wYWNpdHk6IDA7XFxuICB0cmFuc2l0aW9uOiB3aWR0aCAuNXMgZWFzZS1vdXQsIG9wYWNpdHkgLjVzIGVhc2Utb3V0OyB9XFxuICAuaXNMb2FkaW5nIC5Mb2FkaW5nLUJhciB7XFxuICAgIG9wYWNpdHk6IDE7IH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyP3VybD1mYWxzZSEuL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vc3JjL3Njc3MvZ2xvYmFsLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbmltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vblwiXG5cbi8qKlxuICogMngyIE1hdHJpeFxuICogQG1vZHVsZSBtYXQyXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDJcbiAqXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQyfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCBhIG1hdDIgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWF0MiB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0IEEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMobTAwLCBtMDEsIG0xMCwgbTExKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0xMDtcbiAgb3V0WzNdID0gbTExO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDIgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCBtMDAsIG0wMSwgbTEwLCBtMTEpIHtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0xMDtcbiAgb3V0WzNdID0gbTExO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zcG9zZShvdXQsIGEpIHtcbiAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZVxuICAvLyBzb21lIHZhbHVlc1xuICBpZiAob3V0ID09PSBhKSB7XG4gICAgbGV0IGExID0gYVsxXTtcbiAgICBvdXRbMV0gPSBhWzJdO1xuICAgIG91dFsyXSA9IGExO1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsyXTtcbiAgICBvdXRbMl0gPSBhWzFdO1xuICAgIG91dFszXSA9IGFbM107XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEludmVydHMgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICBsZXQgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdO1xuXG4gIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgbGV0IGRldCA9IGEwICogYTMgLSBhMiAqIGExO1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gIG91dFswXSA9ICBhMyAqIGRldDtcbiAgb3V0WzFdID0gLWExICogZGV0O1xuICBvdXRbMl0gPSAtYTIgKiBkZXQ7XG4gIG91dFszXSA9ICBhMCAqIGRldDtcblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gIC8vIENhY2hpbmcgdGhpcyB2YWx1ZSBpcyBuZXNzZWNhcnkgaWYgb3V0ID09IGFcbiAgbGV0IGEwID0gYVswXTtcbiAgb3V0WzBdID0gIGFbM107XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgb3V0WzNdID0gIGEwO1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIHJldHVybiBhWzBdICogYVszXSAtIGFbMl0gKiBhWzFdO1xufVxuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDInc1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBsZXQgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdO1xuICBsZXQgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdO1xuICBvdXRbMF0gPSBhMCAqIGIwICsgYTIgKiBiMTtcbiAgb3V0WzFdID0gYTEgKiBiMCArIGEzICogYjE7XG4gIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzO1xuICBvdXRbM10gPSBhMSAqIGIyICsgYTMgKiBiMztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MiBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkKSB7XG4gIGxldCBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM107XG4gIGxldCBzID0gTWF0aC5zaW4ocmFkKTtcbiAgbGV0IGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBhMCAqICBjICsgYTIgKiBzO1xuICBvdXRbMV0gPSBhMSAqICBjICsgYTMgKiBzO1xuICBvdXRbMl0gPSBhMCAqIC1zICsgYTIgKiBjO1xuICBvdXRbM10gPSBhMSAqIC1zICsgYTMgKiBjO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MiBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIGxldCBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM107XG4gIGxldCB2MCA9IHZbMF0sIHYxID0gdlsxXTtcbiAgb3V0WzBdID0gYTAgKiB2MDtcbiAgb3V0WzFdID0gYTEgKiB2MDtcbiAgb3V0WzJdID0gYTIgKiB2MTtcbiAgb3V0WzNdID0gYTMgKiB2MTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDIuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0Mi5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCBtYXQyIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIGxldCBzID0gTWF0aC5zaW4ocmFkKTtcbiAgbGV0IGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBjO1xuICBvdXRbMV0gPSBzO1xuICBvdXRbMl0gPSAtcztcbiAgb3V0WzNdID0gYztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDIuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0Mi5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IG1hdDIgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IHZbMV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiAnbWF0MignICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcpJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpKSlcbn1cblxuLyoqXG4gKiBSZXR1cm5zIEwsIEQgYW5kIFUgbWF0cmljZXMgKExvd2VyIHRyaWFuZ3VsYXIsIERpYWdvbmFsIGFuZCBVcHBlciB0cmlhbmd1bGFyKSBieSBmYWN0b3JpemluZyB0aGUgaW5wdXQgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IEwgdGhlIGxvd2VyIHRyaWFuZ3VsYXIgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IEQgdGhlIGRpYWdvbmFsIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBVIHRoZSB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBpbnB1dCBtYXRyaXggdG8gZmFjdG9yaXplXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIExEVShMLCBELCBVLCBhKSB7XG4gIExbMl0gPSBhWzJdL2FbMF07XG4gIFVbMF0gPSBhWzBdO1xuICBVWzFdID0gYVsxXTtcbiAgVVszXSA9IGFbM10gLSBMWzJdICogVVsxXTtcbiAgcmV0dXJuIFtMLCBELCBVXTtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byBtYXQyJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFN1YnRyYWN0cyBtYXRyaXggYiBmcm9tIG1hdHJpeCBhXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0Mn0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM107XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQyfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXTtcbiAgbGV0IGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTtcbiAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpKTtcbn1cblxuLyoqXG4gKiBNdWx0aXBseSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhci5cbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byBtYXQyJ3MgYWZ0ZXIgbXVsdGlwbHlpbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiJ3MgZWxlbWVudHMgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXJBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICBvdXRbM10gPSBhWzNdICsgKGJbM10gKiBzY2FsZSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBtdWwgPSBtdWx0aXBseTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDIuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHN1YiA9IHN1YnRyYWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvbWF0Mi5qc1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG5pbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb25cIjtcblxuLyoqXG4gKiAyeDMgTWF0cml4XG4gKiBAbW9kdWxlIG1hdDJkXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBIG1hdDJkIGNvbnRhaW5zIHNpeCBlbGVtZW50cyBkZWZpbmVkIGFzOlxuICogPHByZT5cbiAqIFthLCBjLCB0eCxcbiAqICBiLCBkLCB0eV1cbiAqIDwvcHJlPlxuICogVGhpcyBpcyBhIHNob3J0IGZvcm0gZm9yIHRoZSAzeDMgbWF0cml4OlxuICogPHByZT5cbiAqIFthLCBjLCB0eCxcbiAqICBiLCBkLCB0eSxcbiAqICAwLCAwLCAxXVxuICogPC9wcmU+XG4gKiBUaGUgbGFzdCByb3cgaXMgaWdub3JlZCBzbyB0aGUgYXJyYXkgaXMgc2hvcnRlciBhbmQgb3BlcmF0aW9ucyBhcmUgZmFzdGVyLlxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyZFxuICpcbiAqIEByZXR1cm5zIHttYXQyZH0gYSBuZXcgMngzIG1hdHJpeFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNik7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQyZCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0MmR9IGEgbmV3IDJ4MyBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDYpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyZCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXQgYSBtYXQyZCB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1hdDJkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIENvbXBvbmVudCBBIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgQ29tcG9uZW50IEIgKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gYyBDb21wb25lbnQgQyAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBkIENvbXBvbmVudCBEIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IHR4IENvbXBvbmVudCBUWCAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eSBDb21wb25lbnQgVFkgKGluZGV4IDUpXG4gKiBAcmV0dXJucyB7bWF0MmR9IEEgbmV3IG1hdDJkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNik7XG4gIG91dFswXSA9IGE7XG4gIG91dFsxXSA9IGI7XG4gIG91dFsyXSA9IGM7XG4gIG91dFszXSA9IGQ7XG4gIG91dFs0XSA9IHR4O1xuICBvdXRbNV0gPSB0eTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQyZCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge051bWJlcn0gYSBDb21wb25lbnQgQSAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIENvbXBvbmVudCBCIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IGMgQ29tcG9uZW50IEMgKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gZCBDb21wb25lbnQgRCAoaW5kZXggMylcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eCBDb21wb25lbnQgVFggKGluZGV4IDQpXG4gKiBAcGFyYW0ge051bWJlcn0gdHkgQ29tcG9uZW50IFRZIChpbmRleCA1KVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuICBvdXRbMF0gPSBhO1xuICBvdXRbMV0gPSBiO1xuICBvdXRbMl0gPSBjO1xuICBvdXRbM10gPSBkO1xuICBvdXRbNF0gPSB0eDtcbiAgb3V0WzVdID0gdHk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICBsZXQgYWEgPSBhWzBdLCBhYiA9IGFbMV0sIGFjID0gYVsyXSwgYWQgPSBhWzNdO1xuICBsZXQgYXR4ID0gYVs0XSwgYXR5ID0gYVs1XTtcblxuICBsZXQgZGV0ID0gYWEgKiBhZCAtIGFiICogYWM7XG4gIGlmKCFkZXQpe1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGRldCA9IDEuMCAvIGRldDtcblxuICBvdXRbMF0gPSBhZCAqIGRldDtcbiAgb3V0WzFdID0gLWFiICogZGV0O1xuICBvdXRbMl0gPSAtYWMgKiBkZXQ7XG4gIG91dFszXSA9IGFhICogZGV0O1xuICBvdXRbNF0gPSAoYWMgKiBhdHkgLSBhZCAqIGF0eCkgKiBkZXQ7XG4gIG91dFs1XSA9IChhYiAqIGF0eCAtIGFhICogYXR5KSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzFdICogYVsyXTtcbn1cblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyZCdzXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBsZXQgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XTtcbiAgbGV0IGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXSwgYjQgPSBiWzRdLCBiNSA9IGJbNV07XG4gIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxO1xuICBvdXRbMV0gPSBhMSAqIGIwICsgYTMgKiBiMTtcbiAgb3V0WzJdID0gYTAgKiBiMiArIGEyICogYjM7XG4gIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzO1xuICBvdXRbNF0gPSBhMCAqIGI0ICsgYTIgKiBiNSArIGE0O1xuICBvdXRbNV0gPSBhMSAqIGI0ICsgYTMgKiBiNSArIGE1O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQyZCBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkKSB7XG4gIGxldCBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdO1xuICBsZXQgcyA9IE1hdGguc2luKHJhZCk7XG4gIGxldCBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYTAgKiAgYyArIGEyICogcztcbiAgb3V0WzFdID0gYTEgKiAgYyArIGEzICogcztcbiAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogYztcbiAgb3V0WzNdID0gYTEgKiAtcyArIGEzICogYztcbiAgb3V0WzRdID0gYTQ7XG4gIG91dFs1XSA9IGE1O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MmQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICBsZXQgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XTtcbiAgbGV0IHYwID0gdlswXSwgdjEgPSB2WzFdO1xuICBvdXRbMF0gPSBhMCAqIHYwO1xuICBvdXRbMV0gPSBhMSAqIHYwO1xuICBvdXRbMl0gPSBhMiAqIHYxO1xuICBvdXRbM10gPSBhMyAqIHYxO1xuICBvdXRbNF0gPSBhNDtcbiAgb3V0WzVdID0gYTU7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNsYXRlcyB0aGUgbWF0MmQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byB0cmFuc2xhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gIGxldCBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdO1xuICBsZXQgdjAgPSB2WzBdLCB2MSA9IHZbMV07XG4gIG91dFswXSA9IGEwO1xuICBvdXRbMV0gPSBhMTtcbiAgb3V0WzJdID0gYTI7XG4gIG91dFszXSA9IGEzO1xuICBvdXRbNF0gPSBhMCAqIHYwICsgYTIgKiB2MSArIGE0O1xuICBvdXRbNV0gPSBhMSAqIHYwICsgYTMgKiB2MSArIGE1O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0MmQucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IG1hdDJkIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHJhZCkge1xuICBsZXQgcyA9IE1hdGguc2luKHJhZCksIGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBjO1xuICBvdXRbMV0gPSBzO1xuICBvdXRbMl0gPSAtcztcbiAgb3V0WzNdID0gYztcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDJkLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDJkLnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IG1hdDJkIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzJ9IHYgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gdlsxXTtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQyZC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQyZC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHJhbnNsYXRpb24ob3V0LCB2KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIG91dFs0XSA9IHZbMF07XG4gIG91dFs1XSA9IHZbMV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuICdtYXQyZCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICtcbiAgICAgICAgICBhWzNdICsgJywgJyArIGFbNF0gKyAnLCAnICsgYVs1XSArICcpJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybihNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikgKyBNYXRoLnBvdyhhWzRdLCAyKSArIE1hdGgucG93KGFbNV0sIDIpICsgMSkpXG59XG5cbi8qKlxuICogQWRkcyB0d28gbWF0MmQnc1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0MmR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICBvdXRbNF0gPSBhWzRdIC0gYls0XTtcbiAgb3V0WzVdID0gYVs1XSAtIGJbNV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhcihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIG91dFs0XSA9IGFbNF0gKiBiO1xuICBvdXRbNV0gPSBhWzVdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byBtYXQyZCdzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhckFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICBvdXRbMl0gPSBhWzJdICsgKGJbMl0gKiBzY2FsZSk7XG4gIG91dFszXSA9IGFbM10gKyAoYlszXSAqIHNjYWxlKTtcbiAgb3V0WzRdID0gYVs0XSArIChiWzRdICogc2NhbGUpO1xuICBvdXRbNV0gPSBhWzVdICsgKGJbNV0gKiBzY2FsZSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0MmR9IGIgVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdICYmIGFbNF0gPT09IGJbNF0gJiYgYVs1XSA9PT0gYls1XTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQyZH0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIGxldCBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdO1xuICBsZXQgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdLCBiNCA9IGJbNF0sIGI1ID0gYls1XTtcbiAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTQgLSBiNCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE0KSwgTWF0aC5hYnMoYjQpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGE1IC0gYjUpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSkpO1xufVxuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0MmQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IG11bCA9IG11bHRpcGx5O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0MmQuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHN1YiA9IHN1YnRyYWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvbWF0MmQuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxuaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uXCI7XG5cbi8qKlxuICogNHg0IE1hdHJpeFxuICogQG1vZHVsZSBtYXQ0XG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDRcbiAqXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0NCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIG91dFs5XSA9IGFbOV07XG4gIG91dFsxMF0gPSBhWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdO1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIG91dFs5XSA9IGFbOV07XG4gIG91dFsxMF0gPSBhWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdO1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1hdDQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMyBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA1KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA2KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMyBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAzIHBvc2l0aW9uIChpbmRleCA3KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA4KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA5KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjMgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMwIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDAgcG9zaXRpb24gKGluZGV4IDEyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMSBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxMylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzIgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTQpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMzIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDMgcG9zaXRpb24gKGluZGV4IDE1KVxuICogQHJldHVybnMge21hdDR9IEEgbmV3IG1hdDRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMobTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMDI7XG4gIG91dFszXSA9IG0wMztcbiAgb3V0WzRdID0gbTEwO1xuICBvdXRbNV0gPSBtMTE7XG4gIG91dFs2XSA9IG0xMjtcbiAgb3V0WzddID0gbTEzO1xuICBvdXRbOF0gPSBtMjA7XG4gIG91dFs5XSA9IG0yMTtcbiAgb3V0WzEwXSA9IG0yMjtcbiAgb3V0WzExXSA9IG0yMztcbiAgb3V0WzEyXSA9IG0zMDtcbiAgb3V0WzEzXSA9IG0zMTtcbiAgb3V0WzE0XSA9IG0zMjtcbiAgb3V0WzE1XSA9IG0zMztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQ0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMyBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA1KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA2KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMyBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAzIHBvc2l0aW9uIChpbmRleCA3KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA4KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA5KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjMgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMwIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDAgcG9zaXRpb24gKGluZGV4IDEyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMSBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxMylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzIgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTQpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMzIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDMgcG9zaXRpb24gKGluZGV4IDE1KVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgbTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKSB7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMDI7XG4gIG91dFszXSA9IG0wMztcbiAgb3V0WzRdID0gbTEwO1xuICBvdXRbNV0gPSBtMTE7XG4gIG91dFs2XSA9IG0xMjtcbiAgb3V0WzddID0gbTEzO1xuICBvdXRbOF0gPSBtMjA7XG4gIG91dFs5XSA9IG0yMTtcbiAgb3V0WzEwXSA9IG0yMjtcbiAgb3V0WzExXSA9IG0yMztcbiAgb3V0WzEyXSA9IG0zMDtcbiAgb3V0WzEzXSA9IG0zMTtcbiAgb3V0WzE0XSA9IG0zMjtcbiAgb3V0WzE1XSA9IG0zMztcbiAgcmV0dXJuIG91dDtcbn1cblxuXG4vKipcbiAqIFNldCBhIG1hdDQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LCBhKSB7XG4gIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgaWYgKG91dCA9PT0gYSkge1xuICAgIGxldCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdO1xuICAgIGxldCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddO1xuICAgIGxldCBhMjMgPSBhWzExXTtcblxuICAgIG91dFsxXSA9IGFbNF07XG4gICAgb3V0WzJdID0gYVs4XTtcbiAgICBvdXRbM10gPSBhWzEyXTtcbiAgICBvdXRbNF0gPSBhMDE7XG4gICAgb3V0WzZdID0gYVs5XTtcbiAgICBvdXRbN10gPSBhWzEzXTtcbiAgICBvdXRbOF0gPSBhMDI7XG4gICAgb3V0WzldID0gYTEyO1xuICAgIG91dFsxMV0gPSBhWzE0XTtcbiAgICBvdXRbMTJdID0gYTAzO1xuICAgIG91dFsxM10gPSBhMTM7XG4gICAgb3V0WzE0XSA9IGEyMztcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbNF07XG4gICAgb3V0WzJdID0gYVs4XTtcbiAgICBvdXRbM10gPSBhWzEyXTtcbiAgICBvdXRbNF0gPSBhWzFdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs5XTtcbiAgICBvdXRbN10gPSBhWzEzXTtcbiAgICBvdXRbOF0gPSBhWzJdO1xuICAgIG91dFs5XSA9IGFbNl07XG4gICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgIG91dFsxMV0gPSBhWzE0XTtcbiAgICBvdXRbMTJdID0gYVszXTtcbiAgICBvdXRbMTNdID0gYVs3XTtcbiAgICBvdXRbMTRdID0gYVsxMV07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgbGV0IGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM107XG4gIGxldCBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddO1xuICBsZXQgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdO1xuICBsZXQgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgbGV0IGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcbiAgbGV0IGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMDtcbiAgbGV0IGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMDtcbiAgbGV0IGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcbiAgbGV0IGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMTtcbiAgbGV0IGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMjtcbiAgbGV0IGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDtcbiAgbGV0IGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMDtcbiAgbGV0IGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMDtcbiAgbGV0IGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTtcbiAgbGV0IGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMTtcbiAgbGV0IGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjtcblxuICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gIGxldCBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFsxXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICBvdXRbMl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgb3V0WzNdID0gKGEyMiAqIGIwNCAtIGEyMSAqIGIwNSAtIGEyMyAqIGIwMykgKiBkZXQ7XG4gIG91dFs0XSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICBvdXRbNV0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgb3V0WzZdID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XG4gIG91dFs3XSA9IChhMjAgKiBiMDUgLSBhMjIgKiBiMDIgKyBhMjMgKiBiMDEpICogZGV0O1xuICBvdXRbOF0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcbiAgb3V0WzldID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gIG91dFsxMF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcbiAgb3V0WzExXSA9IChhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDApICogZGV0O1xuICBvdXRbMTJdID0gKGExMSAqIGIwNyAtIGExMCAqIGIwOSAtIGExMiAqIGIwNikgKiBkZXQ7XG4gIG91dFsxM10gPSAoYTAwICogYjA5IC0gYTAxICogYjA3ICsgYTAyICogYjA2KSAqIGRldDtcbiAgb3V0WzE0XSA9IChhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDApICogZGV0O1xuICBvdXRbMTVdID0gKGEyMCAqIGIwMyAtIGEyMSAqIGIwMSArIGEyMiAqIGIwMCkgKiBkZXQ7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGpvaW50KG91dCwgYSkge1xuICBsZXQgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXTtcbiAgbGV0IGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN107XG4gIGxldCBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV07XG4gIGxldCBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XTtcblxuICBvdXRbMF0gID0gIChhMTEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikpO1xuICBvdXRbMV0gID0gLShhMDEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikpO1xuICBvdXRbMl0gID0gIChhMDEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICBvdXRbM10gID0gLShhMDEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICBvdXRbNF0gID0gLShhMTAgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikpO1xuICBvdXRbNV0gID0gIChhMDAgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikpO1xuICBvdXRbNl0gID0gLShhMDAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICBvdXRbN10gID0gIChhMDAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICBvdXRbOF0gID0gIChhMTAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSkpO1xuICBvdXRbOV0gID0gLShhMDAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkpO1xuICBvdXRbMTBdID0gIChhMDAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSkpO1xuICBvdXRbMTFdID0gLShhMDAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSkpO1xuICBvdXRbMTJdID0gLShhMTAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkpO1xuICBvdXRbMTNdID0gIChhMDAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSkpO1xuICBvdXRbMTRdID0gLShhMDAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSkpO1xuICBvdXRbMTVdID0gIChhMDAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSkpO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICBsZXQgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXTtcbiAgbGV0IGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN107XG4gIGxldCBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV07XG4gIGxldCBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XTtcblxuICBsZXQgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICBsZXQgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICBsZXQgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICBsZXQgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICBsZXQgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICBsZXQgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICBsZXQgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICBsZXQgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICBsZXQgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICBsZXQgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICBsZXQgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICBsZXQgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyO1xuXG4gIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgcmV0dXJuIGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcbn1cblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQ0c1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBsZXQgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXTtcbiAgbGV0IGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN107XG4gIGxldCBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV07XG4gIGxldCBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XTtcblxuICAvLyBDYWNoZSBvbmx5IHRoZSBjdXJyZW50IGxpbmUgb2YgdGhlIHNlY29uZCBtYXRyaXhcbiAgbGV0IGIwICA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM107XG4gIG91dFswXSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgb3V0WzFdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICBvdXRbMl0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gIG91dFszXSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICBiMCA9IGJbNF07IGIxID0gYls1XTsgYjIgPSBiWzZdOyBiMyA9IGJbN107XG4gIG91dFs0XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgb3V0WzVdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICBvdXRbNl0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gIG91dFs3XSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICBiMCA9IGJbOF07IGIxID0gYls5XTsgYjIgPSBiWzEwXTsgYjMgPSBiWzExXTtcbiAgb3V0WzhdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICBvdXRbOV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gIG91dFsxMF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gIG91dFsxMV0gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgYjAgPSBiWzEyXTsgYjEgPSBiWzEzXTsgYjIgPSBiWzE0XTsgYjMgPSBiWzE1XTtcbiAgb3V0WzEyXSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgb3V0WzEzXSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgb3V0WzE0XSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgb3V0WzE1XSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGUgYSBtYXQ0IGJ5IHRoZSBnaXZlbiB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICBsZXQgeCA9IHZbMF0sIHkgPSB2WzFdLCB6ID0gdlsyXTtcbiAgbGV0IGEwMCwgYTAxLCBhMDIsIGEwMztcbiAgbGV0IGExMCwgYTExLCBhMTIsIGExMztcbiAgbGV0IGEyMCwgYTIxLCBhMjIsIGEyMztcblxuICBpZiAoYSA9PT0gb3V0KSB7XG4gICAgb3V0WzEyXSA9IGFbMF0gKiB4ICsgYVs0XSAqIHkgKyBhWzhdICogeiArIGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeiArIGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzNdICogeCArIGFbN10gKiB5ICsgYVsxMV0gKiB6ICsgYVsxNV07XG4gIH0gZWxzZSB7XG4gICAgYTAwID0gYVswXTsgYTAxID0gYVsxXTsgYTAyID0gYVsyXTsgYTAzID0gYVszXTtcbiAgICBhMTAgPSBhWzRdOyBhMTEgPSBhWzVdOyBhMTIgPSBhWzZdOyBhMTMgPSBhWzddO1xuICAgIGEyMCA9IGFbOF07IGEyMSA9IGFbOV07IGEyMiA9IGFbMTBdOyBhMjMgPSBhWzExXTtcblxuICAgIG91dFswXSA9IGEwMDsgb3V0WzFdID0gYTAxOyBvdXRbMl0gPSBhMDI7IG91dFszXSA9IGEwMztcbiAgICBvdXRbNF0gPSBhMTA7IG91dFs1XSA9IGExMTsgb3V0WzZdID0gYTEyOyBvdXRbN10gPSBhMTM7XG4gICAgb3V0WzhdID0gYTIwOyBvdXRbOV0gPSBhMjE7IG91dFsxMF0gPSBhMjI7IG91dFsxMV0gPSBhMjM7XG5cbiAgICBvdXRbMTJdID0gYTAwICogeCArIGExMCAqIHkgKyBhMjAgKiB6ICsgYVsxMl07XG4gICAgb3V0WzEzXSA9IGEwMSAqIHggKyBhMTEgKiB5ICsgYTIxICogeiArIGFbMTNdO1xuICAgIG91dFsxNF0gPSBhMDIgKiB4ICsgYTEyICogeSArIGEyMiAqIHogKyBhWzE0XTtcbiAgICBvdXRbMTVdID0gYTAzICogeCArIGExMyAqIHkgKyBhMjMgKiB6ICsgYVsxNV07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0NCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMyBub3QgdXNpbmcgdmVjdG9yaXphdGlvblxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHt2ZWMzfSB2IHRoZSB2ZWMzIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgbGV0IHggPSB2WzBdLCB5ID0gdlsxXSwgeiA9IHZbMl07XG5cbiAgb3V0WzBdID0gYVswXSAqIHg7XG4gIG91dFsxXSA9IGFbMV0gKiB4O1xuICBvdXRbMl0gPSBhWzJdICogeDtcbiAgb3V0WzNdID0gYVszXSAqIHg7XG4gIG91dFs0XSA9IGFbNF0gKiB5O1xuICBvdXRbNV0gPSBhWzVdICogeTtcbiAgb3V0WzZdID0gYVs2XSAqIHk7XG4gIG91dFs3XSA9IGFbN10gKiB5O1xuICBvdXRbOF0gPSBhWzhdICogejtcbiAgb3V0WzldID0gYVs5XSAqIHo7XG4gIG91dFsxMF0gPSBhWzEwXSAqIHo7XG4gIG91dFsxMV0gPSBhWzExXSAqIHo7XG4gIG91dFsxMl0gPSBhWzEyXTtcbiAgb3V0WzEzXSA9IGFbMTNdO1xuICBvdXRbMTRdID0gYVsxNF07XG4gIG91dFsxNV0gPSBhWzE1XTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0NCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBnaXZlbiBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQsIGF4aXMpIHtcbiAgbGV0IHggPSBheGlzWzBdLCB5ID0gYXhpc1sxXSwgeiA9IGF4aXNbMl07XG4gIGxldCBsZW4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbiAgbGV0IHMsIGMsIHQ7XG4gIGxldCBhMDAsIGEwMSwgYTAyLCBhMDM7XG4gIGxldCBhMTAsIGExMSwgYTEyLCBhMTM7XG4gIGxldCBhMjAsIGEyMSwgYTIyLCBhMjM7XG4gIGxldCBiMDAsIGIwMSwgYjAyO1xuICBsZXQgYjEwLCBiMTEsIGIxMjtcbiAgbGV0IGIyMCwgYjIxLCBiMjI7XG5cbiAgaWYgKE1hdGguYWJzKGxlbikgPCBnbE1hdHJpeC5FUFNJTE9OKSB7IHJldHVybiBudWxsOyB9XG5cbiAgbGVuID0gMSAvIGxlbjtcbiAgeCAqPSBsZW47XG4gIHkgKj0gbGVuO1xuICB6ICo9IGxlbjtcblxuICBzID0gTWF0aC5zaW4ocmFkKTtcbiAgYyA9IE1hdGguY29zKHJhZCk7XG4gIHQgPSAxIC0gYztcblxuICBhMDAgPSBhWzBdOyBhMDEgPSBhWzFdOyBhMDIgPSBhWzJdOyBhMDMgPSBhWzNdO1xuICBhMTAgPSBhWzRdOyBhMTEgPSBhWzVdOyBhMTIgPSBhWzZdOyBhMTMgPSBhWzddO1xuICBhMjAgPSBhWzhdOyBhMjEgPSBhWzldOyBhMjIgPSBhWzEwXTsgYTIzID0gYVsxMV07XG5cbiAgLy8gQ29uc3RydWN0IHRoZSBlbGVtZW50cyBvZiB0aGUgcm90YXRpb24gbWF0cml4XG4gIGIwMCA9IHggKiB4ICogdCArIGM7IGIwMSA9IHkgKiB4ICogdCArIHogKiBzOyBiMDIgPSB6ICogeCAqIHQgLSB5ICogcztcbiAgYjEwID0geCAqIHkgKiB0IC0geiAqIHM7IGIxMSA9IHkgKiB5ICogdCArIGM7IGIxMiA9IHogKiB5ICogdCArIHggKiBzO1xuICBiMjAgPSB4ICogeiAqIHQgKyB5ICogczsgYjIxID0geSAqIHogKiB0IC0geCAqIHM7IGIyMiA9IHogKiB6ICogdCArIGM7XG5cbiAgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgb3V0WzBdID0gYTAwICogYjAwICsgYTEwICogYjAxICsgYTIwICogYjAyO1xuICBvdXRbMV0gPSBhMDEgKiBiMDAgKyBhMTEgKiBiMDEgKyBhMjEgKiBiMDI7XG4gIG91dFsyXSA9IGEwMiAqIGIwMCArIGExMiAqIGIwMSArIGEyMiAqIGIwMjtcbiAgb3V0WzNdID0gYTAzICogYjAwICsgYTEzICogYjAxICsgYTIzICogYjAyO1xuICBvdXRbNF0gPSBhMDAgKiBiMTAgKyBhMTAgKiBiMTEgKyBhMjAgKiBiMTI7XG4gIG91dFs1XSA9IGEwMSAqIGIxMCArIGExMSAqIGIxMSArIGEyMSAqIGIxMjtcbiAgb3V0WzZdID0gYTAyICogYjEwICsgYTEyICogYjExICsgYTIyICogYjEyO1xuICBvdXRbN10gPSBhMDMgKiBiMTAgKyBhMTMgKiBiMTEgKyBhMjMgKiBiMTI7XG4gIG91dFs4XSA9IGEwMCAqIGIyMCArIGExMCAqIGIyMSArIGEyMCAqIGIyMjtcbiAgb3V0WzldID0gYTAxICogYjIwICsgYTExICogYjIxICsgYTIxICogYjIyO1xuICBvdXRbMTBdID0gYTAyICogYjIwICsgYTEyICogYjIxICsgYTIyICogYjIyO1xuICBvdXRbMTFdID0gYTAzICogYjIwICsgYTEzICogYjIxICsgYTIzICogYjIyO1xuXG4gIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVYKG91dCwgYSwgcmFkKSB7XG4gIGxldCBzID0gTWF0aC5zaW4ocmFkKTtcbiAgbGV0IGMgPSBNYXRoLmNvcyhyYWQpO1xuICBsZXQgYTEwID0gYVs0XTtcbiAgbGV0IGExMSA9IGFbNV07XG4gIGxldCBhMTIgPSBhWzZdO1xuICBsZXQgYTEzID0gYVs3XTtcbiAgbGV0IGEyMCA9IGFbOF07XG4gIGxldCBhMjEgPSBhWzldO1xuICBsZXQgYTIyID0gYVsxMF07XG4gIGxldCBhMjMgPSBhWzExXTtcblxuICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICBvdXRbMF0gID0gYVswXTtcbiAgICBvdXRbMV0gID0gYVsxXTtcbiAgICBvdXRbMl0gID0gYVsyXTtcbiAgICBvdXRbM10gID0gYVszXTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH1cblxuICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gIG91dFs0XSA9IGExMCAqIGMgKyBhMjAgKiBzO1xuICBvdXRbNV0gPSBhMTEgKiBjICsgYTIxICogcztcbiAgb3V0WzZdID0gYTEyICogYyArIGEyMiAqIHM7XG4gIG91dFs3XSA9IGExMyAqIGMgKyBhMjMgKiBzO1xuICBvdXRbOF0gPSBhMjAgKiBjIC0gYTEwICogcztcbiAgb3V0WzldID0gYTIxICogYyAtIGExMSAqIHM7XG4gIG91dFsxMF0gPSBhMjIgKiBjIC0gYTEyICogcztcbiAgb3V0WzExXSA9IGEyMyAqIGMgLSBhMTMgKiBzO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCByYWQpIHtcbiAgbGV0IHMgPSBNYXRoLnNpbihyYWQpO1xuICBsZXQgYyA9IE1hdGguY29zKHJhZCk7XG4gIGxldCBhMDAgPSBhWzBdO1xuICBsZXQgYTAxID0gYVsxXTtcbiAgbGV0IGEwMiA9IGFbMl07XG4gIGxldCBhMDMgPSBhWzNdO1xuICBsZXQgYTIwID0gYVs4XTtcbiAgbGV0IGEyMSA9IGFbOV07XG4gIGxldCBhMjIgPSBhWzEwXTtcbiAgbGV0IGEyMyA9IGFbMTFdO1xuXG4gIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgIG91dFs0XSAgPSBhWzRdO1xuICAgIG91dFs1XSAgPSBhWzVdO1xuICAgIG91dFs2XSAgPSBhWzZdO1xuICAgIG91dFs3XSAgPSBhWzddO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgb3V0WzBdID0gYTAwICogYyAtIGEyMCAqIHM7XG4gIG91dFsxXSA9IGEwMSAqIGMgLSBhMjEgKiBzO1xuICBvdXRbMl0gPSBhMDIgKiBjIC0gYTIyICogcztcbiAgb3V0WzNdID0gYTAzICogYyAtIGEyMyAqIHM7XG4gIG91dFs4XSA9IGEwMCAqIHMgKyBhMjAgKiBjO1xuICBvdXRbOV0gPSBhMDEgKiBzICsgYTIxICogYztcbiAgb3V0WzEwXSA9IGEwMiAqIHMgKyBhMjIgKiBjO1xuICBvdXRbMTFdID0gYTAzICogcyArIGEyMyAqIGM7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIHJhZCkge1xuICBsZXQgcyA9IE1hdGguc2luKHJhZCk7XG4gIGxldCBjID0gTWF0aC5jb3MocmFkKTtcbiAgbGV0IGEwMCA9IGFbMF07XG4gIGxldCBhMDEgPSBhWzFdO1xuICBsZXQgYTAyID0gYVsyXTtcbiAgbGV0IGEwMyA9IGFbM107XG4gIGxldCBhMTAgPSBhWzRdO1xuICBsZXQgYTExID0gYVs1XTtcbiAgbGV0IGExMiA9IGFbNl07XG4gIGxldCBhMTMgPSBhWzddO1xuXG4gIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICBvdXRbOF0gID0gYVs4XTtcbiAgICBvdXRbOV0gID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgb3V0WzBdID0gYTAwICogYyArIGExMCAqIHM7XG4gIG91dFsxXSA9IGEwMSAqIGMgKyBhMTEgKiBzO1xuICBvdXRbMl0gPSBhMDIgKiBjICsgYTEyICogcztcbiAgb3V0WzNdID0gYTAzICogYyArIGExMyAqIHM7XG4gIG91dFs0XSA9IGExMCAqIGMgLSBhMDAgKiBzO1xuICBvdXRbNV0gPSBhMTEgKiBjIC0gYTAxICogcztcbiAgb3V0WzZdID0gYTEyICogYyAtIGEwMiAqIHM7XG4gIG91dFs3XSA9IGExMyAqIGMgLSBhMDMgKiBzO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHJhbnNsYXRpb24ob3V0LCB2KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDE7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAxO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF07XG4gIG91dFsxM10gPSB2WzFdO1xuICBvdXRbMTRdID0gdlsyXTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzN9IHYgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21TY2FsaW5nKG91dCwgdikge1xuICBvdXRbMF0gPSB2WzBdO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSB2WzFdO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gdlsyXTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlIGFyb3VuZCBhIGdpdmVuIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQucm90YXRlKGRlc3QsIGRlc3QsIHJhZCwgYXhpcyk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCByYWQsIGF4aXMpIHtcbiAgbGV0IHggPSBheGlzWzBdLCB5ID0gYXhpc1sxXSwgeiA9IGF4aXNbMl07XG4gIGxldCBsZW4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbiAgbGV0IHMsIGMsIHQ7XG5cbiAgaWYgKE1hdGguYWJzKGxlbikgPCBnbE1hdHJpeC5FUFNJTE9OKSB7IHJldHVybiBudWxsOyB9XG5cbiAgbGVuID0gMSAvIGxlbjtcbiAgeCAqPSBsZW47XG4gIHkgKj0gbGVuO1xuICB6ICo9IGxlbjtcblxuICBzID0gTWF0aC5zaW4ocmFkKTtcbiAgYyA9IE1hdGguY29zKHJhZCk7XG4gIHQgPSAxIC0gYztcblxuICAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICBvdXRbMF0gPSB4ICogeCAqIHQgKyBjO1xuICBvdXRbMV0gPSB5ICogeCAqIHQgKyB6ICogcztcbiAgb3V0WzJdID0geiAqIHggKiB0IC0geSAqIHM7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHggKiB5ICogdCAtIHogKiBzO1xuICBvdXRbNV0gPSB5ICogeSAqIHQgKyBjO1xuICBvdXRbNl0gPSB6ICogeSAqIHQgKyB4ICogcztcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0geCAqIHogKiB0ICsgeSAqIHM7XG4gIG91dFs5XSA9IHkgKiB6ICogdCAtIHggKiBzO1xuICBvdXRbMTBdID0geiAqIHogKiB0ICsgYztcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQucm90YXRlWChkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tWFJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIGxldCBzID0gTWF0aC5zaW4ocmFkKTtcbiAgbGV0IGMgPSBNYXRoLmNvcyhyYWQpO1xuXG4gIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgb3V0WzBdICA9IDE7XG4gIG91dFsxXSAgPSAwO1xuICBvdXRbMl0gID0gMDtcbiAgb3V0WzNdICA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IGM7XG4gIG91dFs2XSA9IHM7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IC1zO1xuICBvdXRbMTBdID0gYztcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQucm90YXRlWShkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tWVJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIGxldCBzID0gTWF0aC5zaW4ocmFkKTtcbiAgbGV0IGMgPSBNYXRoLmNvcyhyYWQpO1xuXG4gIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgb3V0WzBdICA9IGM7XG4gIG91dFsxXSAgPSAwO1xuICBvdXRbMl0gID0gLXM7XG4gIG91dFszXSAgPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSBzO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gYztcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQucm90YXRlWihkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tWlJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIGxldCBzID0gTWF0aC5zaW4ocmFkKTtcbiAgbGV0IGMgPSBNYXRoLmNvcyhyYWQpO1xuXG4gIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgb3V0WzBdICA9IGM7XG4gIG91dFsxXSAgPSBzO1xuICBvdXRbMl0gID0gMDtcbiAgb3V0WzNdICA9IDA7XG4gIG91dFs0XSA9IC1zO1xuICBvdXRbNV0gPSBjO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24gYW5kIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcbiAqICAgICBsZXQgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb25UcmFuc2xhdGlvbihvdXQsIHEsIHYpIHtcbiAgLy8gUXVhdGVybmlvbiBtYXRoXG4gIGxldCB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXTtcbiAgbGV0IHgyID0geCArIHg7XG4gIGxldCB5MiA9IHkgKyB5O1xuICBsZXQgejIgPSB6ICsgejtcblxuICBsZXQgeHggPSB4ICogeDI7XG4gIGxldCB4eSA9IHggKiB5MjtcbiAgbGV0IHh6ID0geCAqIHoyO1xuICBsZXQgeXkgPSB5ICogeTI7XG4gIGxldCB5eiA9IHkgKiB6MjtcbiAgbGV0IHp6ID0geiAqIHoyO1xuICBsZXQgd3ggPSB3ICogeDI7XG4gIGxldCB3eSA9IHcgKiB5MjtcbiAgbGV0IHd6ID0gdyAqIHoyO1xuXG4gIG91dFswXSA9IDEgLSAoeXkgKyB6eik7XG4gIG91dFsxXSA9IHh5ICsgd3o7XG4gIG91dFsyXSA9IHh6IC0gd3k7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHh5IC0gd3o7XG4gIG91dFs1XSA9IDEgLSAoeHggKyB6eik7XG4gIG91dFs2XSA9IHl6ICsgd3g7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHh6ICsgd3k7XG4gIG91dFs5XSA9IHl6IC0gd3g7XG4gIG91dFsxMF0gPSAxIC0gKHh4ICsgeXkpO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF07XG4gIG91dFsxM10gPSB2WzFdO1xuICBvdXRbMTRdID0gdlsyXTtcbiAgb3V0WzE1XSA9IDE7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0cmFuc2xhdGlvbiB2ZWN0b3IgY29tcG9uZW50IG9mIGEgdHJhbnNmb3JtYXRpb25cbiAqICBtYXRyaXguIElmIGEgbWF0cml4IGlzIGJ1aWx0IHdpdGggZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24sXG4gKiAgdGhlIHJldHVybmVkIHZlY3RvciB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSB0cmFuc2xhdGlvbiB2ZWN0b3JcbiAqICBvcmlnaW5hbGx5IHN1cHBsaWVkLlxuICogQHBhcmFtICB7dmVjM30gb3V0IFZlY3RvciB0byByZWNlaXZlIHRyYW5zbGF0aW9uIGNvbXBvbmVudFxuICogQHBhcmFtICB7bWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcbiAqIEByZXR1cm4ge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24ob3V0LCBtYXQpIHtcbiAgb3V0WzBdID0gbWF0WzEyXTtcbiAgb3V0WzFdID0gbWF0WzEzXTtcbiAgb3V0WzJdID0gbWF0WzE0XTtcblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNjYWxpbmcgZmFjdG9yIGNvbXBvbmVudCBvZiBhIHRyYW5zZm9ybWF0aW9uXG4gKiAgbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVcbiAqICB3aXRoIGEgbm9ybWFsaXplZCBRdWF0ZXJuaW9uIHBhcmFtdGVyLCB0aGUgcmV0dXJuZWQgdmVjdG9yIHdpbGwgYmVcbiAqICB0aGUgc2FtZSBhcyB0aGUgc2NhbGluZyB2ZWN0b3JcbiAqICBvcmlnaW5hbGx5IHN1cHBsaWVkLlxuICogQHBhcmFtICB7dmVjM30gb3V0IFZlY3RvciB0byByZWNlaXZlIHNjYWxpbmcgZmFjdG9yIGNvbXBvbmVudFxuICogQHBhcmFtICB7bWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcbiAqIEByZXR1cm4ge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NhbGluZyhvdXQsIG1hdCkge1xuICBsZXQgbTExID0gbWF0WzBdO1xuICBsZXQgbTEyID0gbWF0WzFdO1xuICBsZXQgbTEzID0gbWF0WzJdO1xuICBsZXQgbTIxID0gbWF0WzRdO1xuICBsZXQgbTIyID0gbWF0WzVdO1xuICBsZXQgbTIzID0gbWF0WzZdO1xuICBsZXQgbTMxID0gbWF0WzhdO1xuICBsZXQgbTMyID0gbWF0WzldO1xuICBsZXQgbTMzID0gbWF0WzEwXTtcblxuICBvdXRbMF0gPSBNYXRoLnNxcnQobTExICogbTExICsgbTEyICogbTEyICsgbTEzICogbTEzKTtcbiAgb3V0WzFdID0gTWF0aC5zcXJ0KG0yMSAqIG0yMSArIG0yMiAqIG0yMiArIG0yMyAqIG0yMyk7XG4gIG91dFsyXSA9IE1hdGguc3FydChtMzEgKiBtMzEgKyBtMzIgKiBtMzIgKyBtMzMgKiBtMzMpO1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHF1YXRlcm5pb24gcmVwcmVzZW50aW5nIHRoZSByb3RhdGlvbmFsIGNvbXBvbmVudFxuICogIG9mIGEgdHJhbnNmb3JtYXRpb24gbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoXG4gKiAgZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24sIHRoZSByZXR1cm5lZCBxdWF0ZXJuaW9uIHdpbGwgYmUgdGhlXG4gKiAgc2FtZSBhcyB0aGUgcXVhdGVybmlvbiBvcmlnaW5hbGx5IHN1cHBsaWVkLlxuICogQHBhcmFtIHtxdWF0fSBvdXQgUXVhdGVybmlvbiB0byByZWNlaXZlIHRoZSByb3RhdGlvbiBjb21wb25lbnRcbiAqIEBwYXJhbSB7bWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcbiAqIEByZXR1cm4ge3F1YXR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um90YXRpb24ob3V0LCBtYXQpIHtcbiAgLy8gQWxnb3JpdGhtIHRha2VuIGZyb20gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvUXVhdGVybmlvbi9pbmRleC5odG1cbiAgbGV0IHRyYWNlID0gbWF0WzBdICsgbWF0WzVdICsgbWF0WzEwXTtcbiAgbGV0IFMgPSAwO1xuXG4gIGlmICh0cmFjZSA+IDApIHtcbiAgICBTID0gTWF0aC5zcXJ0KHRyYWNlICsgMS4wKSAqIDI7XG4gICAgb3V0WzNdID0gMC4yNSAqIFM7XG4gICAgb3V0WzBdID0gKG1hdFs2XSAtIG1hdFs5XSkgLyBTO1xuICAgIG91dFsxXSA9IChtYXRbOF0gLSBtYXRbMl0pIC8gUztcbiAgICBvdXRbMl0gPSAobWF0WzFdIC0gbWF0WzRdKSAvIFM7XG4gIH0gZWxzZSBpZiAoKG1hdFswXSA+IG1hdFs1XSkmKG1hdFswXSA+IG1hdFsxMF0pKSB7XG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBtYXRbMF0gLSBtYXRbNV0gLSBtYXRbMTBdKSAqIDI7XG4gICAgb3V0WzNdID0gKG1hdFs2XSAtIG1hdFs5XSkgLyBTO1xuICAgIG91dFswXSA9IDAuMjUgKiBTO1xuICAgIG91dFsxXSA9IChtYXRbMV0gKyBtYXRbNF0pIC8gUztcbiAgICBvdXRbMl0gPSAobWF0WzhdICsgbWF0WzJdKSAvIFM7XG4gIH0gZWxzZSBpZiAobWF0WzVdID4gbWF0WzEwXSkge1xuICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgbWF0WzVdIC0gbWF0WzBdIC0gbWF0WzEwXSkgKiAyO1xuICAgIG91dFszXSA9IChtYXRbOF0gLSBtYXRbMl0pIC8gUztcbiAgICBvdXRbMF0gPSAobWF0WzFdICsgbWF0WzRdKSAvIFM7XG4gICAgb3V0WzFdID0gMC4yNSAqIFM7XG4gICAgb3V0WzJdID0gKG1hdFs2XSArIG1hdFs5XSkgLyBTO1xuICB9IGVsc2Uge1xuICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgbWF0WzEwXSAtIG1hdFswXSAtIG1hdFs1XSkgKiAyO1xuICAgIG91dFszXSA9IChtYXRbMV0gLSBtYXRbNF0pIC8gUztcbiAgICBvdXRbMF0gPSAobWF0WzhdICsgbWF0WzJdKSAvIFM7XG4gICAgb3V0WzFdID0gKG1hdFs2XSArIG1hdFs5XSkgLyBTO1xuICAgIG91dFsyXSA9IDAuMjUgKiBTO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uLCB2ZWN0b3IgdHJhbnNsYXRpb24gYW5kIHZlY3RvciBzY2FsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcbiAqICAgICBsZXQgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBzY2FsZSlcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gcyBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZShvdXQsIHEsIHYsIHMpIHtcbiAgLy8gUXVhdGVybmlvbiBtYXRoXG4gIGxldCB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXTtcbiAgbGV0IHgyID0geCArIHg7XG4gIGxldCB5MiA9IHkgKyB5O1xuICBsZXQgejIgPSB6ICsgejtcblxuICBsZXQgeHggPSB4ICogeDI7XG4gIGxldCB4eSA9IHggKiB5MjtcbiAgbGV0IHh6ID0geCAqIHoyO1xuICBsZXQgeXkgPSB5ICogeTI7XG4gIGxldCB5eiA9IHkgKiB6MjtcbiAgbGV0IHp6ID0geiAqIHoyO1xuICBsZXQgd3ggPSB3ICogeDI7XG4gIGxldCB3eSA9IHcgKiB5MjtcbiAgbGV0IHd6ID0gdyAqIHoyO1xuICBsZXQgc3ggPSBzWzBdO1xuICBsZXQgc3kgPSBzWzFdO1xuICBsZXQgc3ogPSBzWzJdO1xuXG4gIG91dFswXSA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xuICBvdXRbMV0gPSAoeHkgKyB3eikgKiBzeDtcbiAgb3V0WzJdID0gKHh6IC0gd3kpICogc3g7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9ICh4eSAtIHd6KSAqIHN5O1xuICBvdXRbNV0gPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgb3V0WzZdID0gKHl6ICsgd3gpICogc3k7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9ICh4eiArIHd5KSAqIHN6O1xuICBvdXRbOV0gPSAoeXogLSB3eCkgKiBzejtcbiAgb3V0WzEwXSA9ICgxIC0gKHh4ICsgeXkpKSAqIHN6O1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF07XG4gIG91dFsxM10gPSB2WzFdO1xuICBvdXRbMTRdID0gdlsyXTtcbiAgb3V0WzE1XSA9IDE7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uLCB2ZWN0b3IgdHJhbnNsYXRpb24gYW5kIHZlY3RvciBzY2FsZSwgcm90YXRpbmcgYW5kIHNjYWxpbmcgYXJvdW5kIHRoZSBnaXZlbiBvcmlnaW5cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgb3JpZ2luKTtcbiAqICAgICBsZXQgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBzY2FsZSlcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBuZWdhdGl2ZU9yaWdpbik7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IHMgU2NhbGluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gbyBUaGUgb3JpZ2luIHZlY3RvciBhcm91bmQgd2hpY2ggdG8gc2NhbGUgYW5kIHJvdGF0ZVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbihvdXQsIHEsIHYsIHMsIG8pIHtcbiAgLy8gUXVhdGVybmlvbiBtYXRoXG4gIGxldCB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXTtcbiAgbGV0IHgyID0geCArIHg7XG4gIGxldCB5MiA9IHkgKyB5O1xuICBsZXQgejIgPSB6ICsgejtcblxuICBsZXQgeHggPSB4ICogeDI7XG4gIGxldCB4eSA9IHggKiB5MjtcbiAgbGV0IHh6ID0geCAqIHoyO1xuICBsZXQgeXkgPSB5ICogeTI7XG4gIGxldCB5eiA9IHkgKiB6MjtcbiAgbGV0IHp6ID0geiAqIHoyO1xuICBsZXQgd3ggPSB3ICogeDI7XG4gIGxldCB3eSA9IHcgKiB5MjtcbiAgbGV0IHd6ID0gdyAqIHoyO1xuXG4gIGxldCBzeCA9IHNbMF07XG4gIGxldCBzeSA9IHNbMV07XG4gIGxldCBzeiA9IHNbMl07XG5cbiAgbGV0IG94ID0gb1swXTtcbiAgbGV0IG95ID0gb1sxXTtcbiAgbGV0IG96ID0gb1syXTtcblxuICBvdXRbMF0gPSAoMSAtICh5eSArIHp6KSkgKiBzeDtcbiAgb3V0WzFdID0gKHh5ICsgd3opICogc3g7XG4gIG91dFsyXSA9ICh4eiAtIHd5KSAqIHN4O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAoeHkgLSB3eikgKiBzeTtcbiAgb3V0WzVdID0gKDEgLSAoeHggKyB6eikpICogc3k7XG4gIG91dFs2XSA9ICh5eiArIHd4KSAqIHN5O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAoeHogKyB3eSkgKiBzejtcbiAgb3V0WzldID0gKHl6IC0gd3gpICogc3o7XG4gIG91dFsxMF0gPSAoMSAtICh4eCArIHl5KSkgKiBzejtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdICsgb3ggLSAob3V0WzBdICogb3ggKyBvdXRbNF0gKiBveSArIG91dFs4XSAqIG96KTtcbiAgb3V0WzEzXSA9IHZbMV0gKyBveSAtIChvdXRbMV0gKiBveCArIG91dFs1XSAqIG95ICsgb3V0WzldICogb3opO1xuICBvdXRbMTRdID0gdlsyXSArIG96IC0gKG91dFsyXSAqIG94ICsgb3V0WzZdICogb3kgKyBvdXRbMTBdICogb3opO1xuICBvdXRbMTVdID0gMTtcblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgYSA0eDQgbWF0cml4IGZyb20gdGhlIGdpdmVuIHF1YXRlcm5pb25cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cbiAqXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUXVhdChvdXQsIHEpIHtcbiAgbGV0IHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdO1xuICBsZXQgeDIgPSB4ICsgeDtcbiAgbGV0IHkyID0geSArIHk7XG4gIGxldCB6MiA9IHogKyB6O1xuXG4gIGxldCB4eCA9IHggKiB4MjtcbiAgbGV0IHl4ID0geSAqIHgyO1xuICBsZXQgeXkgPSB5ICogeTI7XG4gIGxldCB6eCA9IHogKiB4MjtcbiAgbGV0IHp5ID0geiAqIHkyO1xuICBsZXQgenogPSB6ICogejI7XG4gIGxldCB3eCA9IHcgKiB4MjtcbiAgbGV0IHd5ID0gdyAqIHkyO1xuICBsZXQgd3ogPSB3ICogejI7XG5cbiAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gIG91dFsxXSA9IHl4ICsgd3o7XG4gIG91dFsyXSA9IHp4IC0gd3k7XG4gIG91dFszXSA9IDA7XG5cbiAgb3V0WzRdID0geXggLSB3ejtcbiAgb3V0WzVdID0gMSAtIHh4IC0geno7XG4gIG91dFs2XSA9IHp5ICsgd3g7XG4gIG91dFs3XSA9IDA7XG5cbiAgb3V0WzhdID0genggKyB3eTtcbiAgb3V0WzldID0genkgLSB3eDtcbiAgb3V0WzEwXSA9IDEgLSB4eCAtIHl5O1xuICBvdXRbMTFdID0gMDtcblxuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGZydXN0dW0gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJ1c3R1bShvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gIGxldCBybCA9IDEgLyAocmlnaHQgLSBsZWZ0KTtcbiAgbGV0IHRiID0gMSAvICh0b3AgLSBib3R0b20pO1xuICBsZXQgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMF0gPSAobmVhciAqIDIpICogcmw7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IChuZWFyICogMikgKiB0YjtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gKHJpZ2h0ICsgbGVmdCkgKiBybDtcbiAgb3V0WzldID0gKHRvcCArIGJvdHRvbSkgKiB0YjtcbiAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICBvdXRbMTFdID0gLTE7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IChmYXIgKiBuZWFyICogMikgKiBuZjtcbiAgb3V0WzE1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGZvdnkgVmVydGljYWwgZmllbGQgb2YgdmlldyBpbiByYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0IEFzcGVjdCByYXRpby4gdHlwaWNhbGx5IHZpZXdwb3J0IHdpZHRoL2hlaWdodFxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBlcnNwZWN0aXZlKG91dCwgZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcbiAgbGV0IGYgPSAxLjAgLyBNYXRoLnRhbihmb3Z5IC8gMik7XG4gIGxldCBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gIG91dFswXSA9IGYgLyBhc3BlY3Q7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IGY7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgb3V0WzExXSA9IC0xO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAoMiAqIGZhciAqIG5lYXIpICogbmY7XG4gIG91dFsxNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGZpZWxkIG9mIHZpZXcuXG4gKiBUaGlzIGlzIHByaW1hcmlseSB1c2VmdWwgZm9yIGdlbmVyYXRpbmcgcHJvamVjdGlvbiBtYXRyaWNlcyB0byBiZSB1c2VkXG4gKiB3aXRoIHRoZSBzdGlsbCBleHBlcmllbWVudGFsIFdlYlZSIEFQSS5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge09iamVjdH0gZm92IE9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgdmFsdWVzOiB1cERlZ3JlZXMsIGRvd25EZWdyZWVzLCBsZWZ0RGVncmVlcywgcmlnaHREZWdyZWVzXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXcob3V0LCBmb3YsIG5lYXIsIGZhcikge1xuICBsZXQgdXBUYW4gPSBNYXRoLnRhbihmb3YudXBEZWdyZWVzICogTWF0aC5QSS8xODAuMCk7XG4gIGxldCBkb3duVGFuID0gTWF0aC50YW4oZm92LmRvd25EZWdyZWVzICogTWF0aC5QSS8xODAuMCk7XG4gIGxldCBsZWZ0VGFuID0gTWF0aC50YW4oZm92LmxlZnREZWdyZWVzICogTWF0aC5QSS8xODAuMCk7XG4gIGxldCByaWdodFRhbiA9IE1hdGgudGFuKGZvdi5yaWdodERlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKTtcbiAgbGV0IHhTY2FsZSA9IDIuMCAvIChsZWZ0VGFuICsgcmlnaHRUYW4pO1xuICBsZXQgeVNjYWxlID0gMi4wIC8gKHVwVGFuICsgZG93blRhbik7XG5cbiAgb3V0WzBdID0geFNjYWxlO1xuICBvdXRbMV0gPSAwLjA7XG4gIG91dFsyXSA9IDAuMDtcbiAgb3V0WzNdID0gMC4wO1xuICBvdXRbNF0gPSAwLjA7XG4gIG91dFs1XSA9IHlTY2FsZTtcbiAgb3V0WzZdID0gMC4wO1xuICBvdXRbN10gPSAwLjA7XG4gIG91dFs4XSA9IC0oKGxlZnRUYW4gLSByaWdodFRhbikgKiB4U2NhbGUgKiAwLjUpO1xuICBvdXRbOV0gPSAoKHVwVGFuIC0gZG93blRhbikgKiB5U2NhbGUgKiAwLjUpO1xuICBvdXRbMTBdID0gZmFyIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMTFdID0gLTEuMDtcbiAgb3V0WzEyXSA9IDAuMDtcbiAgb3V0WzEzXSA9IDAuMDtcbiAgb3V0WzE0XSA9IChmYXIgKiBuZWFyKSAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzE1XSA9IDAuMDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBvcnRob2dvbmFsIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gb3J0aG8ob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICBsZXQgbHIgPSAxIC8gKGxlZnQgLSByaWdodCk7XG4gIGxldCBidCA9IDEgLyAoYm90dG9tIC0gdG9wKTtcbiAgbGV0IG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzBdID0gLTIgKiBscjtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gLTIgKiBidDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDIgKiBuZjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAobGVmdCArIHJpZ2h0KSAqIGxyO1xuICBvdXRbMTNdID0gKHRvcCArIGJvdHRvbSkgKiBidDtcbiAgb3V0WzE0XSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBsb29rLWF0IG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBleWUgcG9zaXRpb24sIGZvY2FsIHBvaW50LCBhbmQgdXAgYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7dmVjM30gZXllIFBvc2l0aW9uIG9mIHRoZSB2aWV3ZXJcbiAqIEBwYXJhbSB7dmVjM30gY2VudGVyIFBvaW50IHRoZSB2aWV3ZXIgaXMgbG9va2luZyBhdFxuICogQHBhcmFtIHt2ZWMzfSB1cCB2ZWMzIHBvaW50aW5nIHVwXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb29rQXQob3V0LCBleWUsIGNlbnRlciwgdXApIHtcbiAgbGV0IHgwLCB4MSwgeDIsIHkwLCB5MSwgeTIsIHowLCB6MSwgejIsIGxlbjtcbiAgbGV0IGV5ZXggPSBleWVbMF07XG4gIGxldCBleWV5ID0gZXllWzFdO1xuICBsZXQgZXlleiA9IGV5ZVsyXTtcbiAgbGV0IHVweCA9IHVwWzBdO1xuICBsZXQgdXB5ID0gdXBbMV07XG4gIGxldCB1cHogPSB1cFsyXTtcbiAgbGV0IGNlbnRlcnggPSBjZW50ZXJbMF07XG4gIGxldCBjZW50ZXJ5ID0gY2VudGVyWzFdO1xuICBsZXQgY2VudGVyeiA9IGNlbnRlclsyXTtcblxuICBpZiAoTWF0aC5hYnMoZXlleCAtIGNlbnRlcngpIDwgZ2xNYXRyaXguRVBTSUxPTiAmJlxuICAgICAgTWF0aC5hYnMoZXlleSAtIGNlbnRlcnkpIDwgZ2xNYXRyaXguRVBTSUxPTiAmJlxuICAgICAgTWF0aC5hYnMoZXlleiAtIGNlbnRlcnopIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIHJldHVybiBtYXQ0LmlkZW50aXR5KG91dCk7XG4gIH1cblxuICB6MCA9IGV5ZXggLSBjZW50ZXJ4O1xuICB6MSA9IGV5ZXkgLSBjZW50ZXJ5O1xuICB6MiA9IGV5ZXogLSBjZW50ZXJ6O1xuXG4gIGxlbiA9IDEgLyBNYXRoLnNxcnQoejAgKiB6MCArIHoxICogejEgKyB6MiAqIHoyKTtcbiAgejAgKj0gbGVuO1xuICB6MSAqPSBsZW47XG4gIHoyICo9IGxlbjtcblxuICB4MCA9IHVweSAqIHoyIC0gdXB6ICogejE7XG4gIHgxID0gdXB6ICogejAgLSB1cHggKiB6MjtcbiAgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICBsZW4gPSBNYXRoLnNxcnQoeDAgKiB4MCArIHgxICogeDEgKyB4MiAqIHgyKTtcbiAgaWYgKCFsZW4pIHtcbiAgICB4MCA9IDA7XG4gICAgeDEgPSAwO1xuICAgIHgyID0gMDtcbiAgfSBlbHNlIHtcbiAgICBsZW4gPSAxIC8gbGVuO1xuICAgIHgwICo9IGxlbjtcbiAgICB4MSAqPSBsZW47XG4gICAgeDIgKj0gbGVuO1xuICB9XG5cbiAgeTAgPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgeTEgPSB6MiAqIHgwIC0gejAgKiB4MjtcbiAgeTIgPSB6MCAqIHgxIC0gejEgKiB4MDtcblxuICBsZW4gPSBNYXRoLnNxcnQoeTAgKiB5MCArIHkxICogeTEgKyB5MiAqIHkyKTtcbiAgaWYgKCFsZW4pIHtcbiAgICB5MCA9IDA7XG4gICAgeTEgPSAwO1xuICAgIHkyID0gMDtcbiAgfSBlbHNlIHtcbiAgICBsZW4gPSAxIC8gbGVuO1xuICAgIHkwICo9IGxlbjtcbiAgICB5MSAqPSBsZW47XG4gICAgeTIgKj0gbGVuO1xuICB9XG5cbiAgb3V0WzBdID0geDA7XG4gIG91dFsxXSA9IHkwO1xuICBvdXRbMl0gPSB6MDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0geDE7XG4gIG91dFs1XSA9IHkxO1xuICBvdXRbNl0gPSB6MTtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0geDI7XG4gIG91dFs5XSA9IHkyO1xuICBvdXRbMTBdID0gejI7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gLSh4MCAqIGV5ZXggKyB4MSAqIGV5ZXkgKyB4MiAqIGV5ZXopO1xuICBvdXRbMTNdID0gLSh5MCAqIGV5ZXggKyB5MSAqIGV5ZXkgKyB5MiAqIGV5ZXopO1xuICBvdXRbMTRdID0gLSh6MCAqIGV5ZXggKyB6MSAqIGV5ZXkgKyB6MiAqIGV5ZXopO1xuICBvdXRbMTVdID0gMTtcblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIG1hdHJpeCB0aGF0IG1ha2VzIHNvbWV0aGluZyBsb29rIGF0IHNvbWV0aGluZyBlbHNlLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7dmVjM30gZXllIFBvc2l0aW9uIG9mIHRoZSB2aWV3ZXJcbiAqIEBwYXJhbSB7dmVjM30gY2VudGVyIFBvaW50IHRoZSB2aWV3ZXIgaXMgbG9va2luZyBhdFxuICogQHBhcmFtIHt2ZWMzfSB1cCB2ZWMzIHBvaW50aW5nIHVwXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0YXJnZXRUbyhvdXQsIGV5ZSwgdGFyZ2V0LCB1cCkge1xuICBsZXQgZXlleCA9IGV5ZVswXSxcbiAgICAgIGV5ZXkgPSBleWVbMV0sXG4gICAgICBleWV6ID0gZXllWzJdLFxuICAgICAgdXB4ID0gdXBbMF0sXG4gICAgICB1cHkgPSB1cFsxXSxcbiAgICAgIHVweiA9IHVwWzJdO1xuXG4gIGxldCB6MCA9IGV5ZXggLSB0YXJnZXRbMF0sXG4gICAgICB6MSA9IGV5ZXkgLSB0YXJnZXRbMV0sXG4gICAgICB6MiA9IGV5ZXogLSB0YXJnZXRbMl07XG5cbiAgbGV0IGxlbiA9IHowKnowICsgejEqejEgKyB6Mip6MjtcbiAgaWYgKGxlbiA+IDApIHtcbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgejAgKj0gbGVuO1xuICAgIHoxICo9IGxlbjtcbiAgICB6MiAqPSBsZW47XG4gIH1cblxuICBsZXQgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxLFxuICAgICAgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyLFxuICAgICAgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuXG4gIG91dFswXSA9IHgwO1xuICBvdXRbMV0gPSB4MTtcbiAgb3V0WzJdID0geDI7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHoxICogeDIgLSB6MiAqIHgxO1xuICBvdXRbNV0gPSB6MiAqIHgwIC0gejAgKiB4MjtcbiAgb3V0WzZdID0gejAgKiB4MSAtIHoxICogeDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHowO1xuICBvdXRbOV0gPSB6MTtcbiAgb3V0WzEwXSA9IHoyO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IGV5ZXg7XG4gIG91dFsxM10gPSBleWV5O1xuICBvdXRbMTRdID0gZXllejtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gJ21hdDQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnLCAnICtcbiAgICAgICAgICBhWzRdICsgJywgJyArIGFbNV0gKyAnLCAnICsgYVs2XSArICcsICcgKyBhWzddICsgJywgJyArXG4gICAgICAgICAgYVs4XSArICcsICcgKyBhWzldICsgJywgJyArIGFbMTBdICsgJywgJyArIGFbMTFdICsgJywgJyArXG4gICAgICAgICAgYVsxMl0gKyAnLCAnICsgYVsxM10gKyAnLCAnICsgYVsxNF0gKyAnLCAnICsgYVsxNV0gKyAnKSc7XG59XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9iKGEpIHtcbiAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyBNYXRoLnBvdyhhWzZdLCAyKSArIE1hdGgucG93KGFbN10sIDIpICsgTWF0aC5wb3coYVs4XSwgMikgKyBNYXRoLnBvdyhhWzldLCAyKSArIE1hdGgucG93KGFbMTBdLCAyKSArIE1hdGgucG93KGFbMTFdLCAyKSArIE1hdGgucG93KGFbMTJdLCAyKSArIE1hdGgucG93KGFbMTNdLCAyKSArIE1hdGgucG93KGFbMTRdLCAyKSArIE1hdGgucG93KGFbMTVdLCAyKSApKVxufVxuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDQnc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl07XG4gIG91dFs3XSA9IGFbN10gKyBiWzddO1xuICBvdXRbOF0gPSBhWzhdICsgYls4XTtcbiAgb3V0WzldID0gYVs5XSArIGJbOV07XG4gIG91dFsxMF0gPSBhWzEwXSArIGJbMTBdO1xuICBvdXRbMTFdID0gYVsxMV0gKyBiWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdICsgYlsxMl07XG4gIG91dFsxM10gPSBhWzEzXSArIGJbMTNdO1xuICBvdXRbMTRdID0gYVsxNF0gKyBiWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdICsgYlsxNV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgb3V0WzZdID0gYVs2XSAtIGJbNl07XG4gIG91dFs3XSA9IGFbN10gLSBiWzddO1xuICBvdXRbOF0gPSBhWzhdIC0gYls4XTtcbiAgb3V0WzldID0gYVs5XSAtIGJbOV07XG4gIG91dFsxMF0gPSBhWzEwXSAtIGJbMTBdO1xuICBvdXRbMTFdID0gYVsxMV0gLSBiWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdIC0gYlsxMl07XG4gIG91dFsxM10gPSBhWzEzXSAtIGJbMTNdO1xuICBvdXRbMTRdID0gYVsxNF0gLSBiWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdIC0gYlsxNV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIG1hdHJpeCdzIGVsZW1lbnRzIGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhcihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIG91dFs0XSA9IGFbNF0gKiBiO1xuICBvdXRbNV0gPSBhWzVdICogYjtcbiAgb3V0WzZdID0gYVs2XSAqIGI7XG4gIG91dFs3XSA9IGFbN10gKiBiO1xuICBvdXRbOF0gPSBhWzhdICogYjtcbiAgb3V0WzldID0gYVs5XSAqIGI7XG4gIG91dFsxMF0gPSBhWzEwXSAqIGI7XG4gIG91dFsxMV0gPSBhWzExXSAqIGI7XG4gIG91dFsxMl0gPSBhWzEyXSAqIGI7XG4gIG91dFsxM10gPSBhWzEzXSAqIGI7XG4gIG91dFsxNF0gPSBhWzE0XSAqIGI7XG4gIG91dFsxNV0gPSBhWzE1XSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQWRkcyB0d28gbWF0NCdzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgb3V0WzNdID0gYVszXSArIChiWzNdICogc2NhbGUpO1xuICBvdXRbNF0gPSBhWzRdICsgKGJbNF0gKiBzY2FsZSk7XG4gIG91dFs1XSA9IGFbNV0gKyAoYls1XSAqIHNjYWxlKTtcbiAgb3V0WzZdID0gYVs2XSArIChiWzZdICogc2NhbGUpO1xuICBvdXRbN10gPSBhWzddICsgKGJbN10gKiBzY2FsZSk7XG4gIG91dFs4XSA9IGFbOF0gKyAoYls4XSAqIHNjYWxlKTtcbiAgb3V0WzldID0gYVs5XSArIChiWzldICogc2NhbGUpO1xuICBvdXRbMTBdID0gYVsxMF0gKyAoYlsxMF0gKiBzY2FsZSk7XG4gIG91dFsxMV0gPSBhWzExXSArIChiWzExXSAqIHNjYWxlKTtcbiAgb3V0WzEyXSA9IGFbMTJdICsgKGJbMTJdICogc2NhbGUpO1xuICBvdXRbMTNdID0gYVsxM10gKyAoYlsxM10gKiBzY2FsZSk7XG4gIG91dFsxNF0gPSBhWzE0XSArIChiWzE0XSAqIHNjYWxlKTtcbiAgb3V0WzE1XSA9IGFbMTVdICsgKGJbMTVdICogc2NhbGUpO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0NH0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM10gJiZcbiAgICAgICAgIGFbNF0gPT09IGJbNF0gJiYgYVs1XSA9PT0gYls1XSAmJiBhWzZdID09PSBiWzZdICYmIGFbN10gPT09IGJbN10gJiZcbiAgICAgICAgIGFbOF0gPT09IGJbOF0gJiYgYVs5XSA9PT0gYls5XSAmJiBhWzEwXSA9PT0gYlsxMF0gJiYgYVsxMV0gPT09IGJbMTFdICYmXG4gICAgICAgICBhWzEyXSA9PT0gYlsxMl0gJiYgYVsxM10gPT09IGJbMTNdICYmIGFbMTRdID09PSBiWzE0XSAmJiBhWzE1XSA9PT0gYlsxNV07XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQ0fSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgbGV0IGEwICA9IGFbMF0sICBhMSAgPSBhWzFdLCAgYTIgID0gYVsyXSwgIGEzICA9IGFbM107XG4gIGxldCBhNCAgPSBhWzRdLCAgYTUgID0gYVs1XSwgIGE2ICA9IGFbNl0sICBhNyAgPSBhWzddO1xuICBsZXQgYTggID0gYVs4XSwgIGE5ICA9IGFbOV0sICBhMTAgPSBhWzEwXSwgYTExID0gYVsxMV07XG4gIGxldCBhMTIgPSBhWzEyXSwgYTEzID0gYVsxM10sIGExNCA9IGFbMTRdLCBhMTUgPSBhWzE1XTtcblxuICBsZXQgYjAgID0gYlswXSwgIGIxICA9IGJbMV0sICBiMiAgPSBiWzJdLCAgYjMgID0gYlszXTtcbiAgbGV0IGI0ICA9IGJbNF0sICBiNSAgPSBiWzVdLCAgYjYgID0gYls2XSwgIGI3ICA9IGJbN107XG4gIGxldCBiOCAgPSBiWzhdLCAgYjkgID0gYls5XSwgIGIxMCA9IGJbMTBdLCBiMTEgPSBiWzExXTtcbiAgbGV0IGIxMiA9IGJbMTJdLCBiMTMgPSBiWzEzXSwgYjE0ID0gYlsxNF0sIGIxNSA9IGJbMTVdO1xuXG4gIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTYgLSBiNikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE2KSwgTWF0aC5hYnMoYjYpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGE3IC0gYjcpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNyksIE1hdGguYWJzKGI3KSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhOCAtIGI4KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTgpLCBNYXRoLmFicyhiOCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTkgLSBiOSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE5KSwgTWF0aC5hYnMoYjkpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGExMCAtIGIxMCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMCksIE1hdGguYWJzKGIxMCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTExIC0gYjExKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTExKSwgTWF0aC5hYnMoYjExKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMTIgLSBiMTIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTIpLCBNYXRoLmFicyhiMTIpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGExMyAtIGIxMykgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMyksIE1hdGguYWJzKGIxMykpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTE0IC0gYjE0KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTE0KSwgTWF0aC5hYnMoYjE0KSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMTUgLSBiMTUpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTUpLCBNYXRoLmFicyhiMTUpKSk7XG59XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQ0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBtdWwgPSBtdWx0aXBseTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHN1YiA9IHN1YnRyYWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvbWF0NC5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG5pbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb25cIlxuaW1wb3J0ICogYXMgbWF0MyBmcm9tIFwiLi9tYXQzXCJcbmltcG9ydCAqIGFzIHZlYzMgZnJvbSBcIi4vdmVjM1wiXG5pbXBvcnQgKiBhcyB2ZWM0IGZyb20gXCIuL3ZlYzRcIlxuXG4vKipcbiAqIFF1YXRlcm5pb25cbiAqIEBtb2R1bGUgcXVhdFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBxdWF0XG4gKlxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSAwO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCBhIHF1YXQgdG8gdGhlIGlkZW50aXR5IHF1YXRlcm5pb25cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAwO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldHMgYSBxdWF0IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFuZCByb3RhdGlvbiBheGlzLFxuICogdGhlbiByZXR1cm5zIGl0LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIGFyb3VuZCB3aGljaCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRBeGlzQW5nbGUob3V0LCBheGlzLCByYWQpIHtcbiAgcmFkID0gcmFkICogMC41O1xuICBsZXQgcyA9IE1hdGguc2luKHJhZCk7XG4gIG91dFswXSA9IHMgKiBheGlzWzBdO1xuICBvdXRbMV0gPSBzICogYXhpc1sxXTtcbiAgb3V0WzJdID0gcyAqIGF4aXNbMl07XG4gIG91dFszXSA9IE1hdGguY29zKHJhZCk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgcm90YXRpb24gYXhpcyBhbmQgYW5nbGUgZm9yIGEgZ2l2ZW5cbiAqICBxdWF0ZXJuaW9uLiBJZiBhIHF1YXRlcm5pb24gaXMgY3JlYXRlZCB3aXRoXG4gKiAgc2V0QXhpc0FuZ2xlLCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgc2FtZVxuICogIHZhbHVlcyBhcyBwcm92aWRpZWQgaW4gdGhlIG9yaWdpbmFsIHBhcmFtZXRlciBsaXN0XG4gKiAgT1IgZnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdmFsdWVzLlxuICogRXhhbXBsZTogVGhlIHF1YXRlcm5pb24gZm9ybWVkIGJ5IGF4aXMgWzAsIDAsIDFdIGFuZFxuICogIGFuZ2xlIC05MCBpcyB0aGUgc2FtZSBhcyB0aGUgcXVhdGVybmlvbiBmb3JtZWQgYnlcbiAqICBbMCwgMCwgMV0gYW5kIDI3MC4gVGhpcyBtZXRob2QgZmF2b3JzIHRoZSBsYXR0ZXIuXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXRfYXhpcyAgVmVjdG9yIHJlY2VpdmluZyB0aGUgYXhpcyBvZiByb3RhdGlvblxuICogQHBhcmFtICB7cXVhdH0gcSAgICAgUXVhdGVybmlvbiB0byBiZSBkZWNvbXBvc2VkXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICBBbmdsZSwgaW4gcmFkaWFucywgb2YgdGhlIHJvdGF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBeGlzQW5nbGUob3V0X2F4aXMsIHEpIHtcbiAgbGV0IHJhZCA9IE1hdGguYWNvcyhxWzNdKSAqIDIuMDtcbiAgbGV0IHMgPSBNYXRoLnNpbihyYWQgLyAyLjApO1xuICBpZiAocyAhPSAwLjApIHtcbiAgICBvdXRfYXhpc1swXSA9IHFbMF0gLyBzO1xuICAgIG91dF9heGlzWzFdID0gcVsxXSAvIHM7XG4gICAgb3V0X2F4aXNbMl0gPSBxWzJdIC8gcztcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBzIGlzIHplcm8sIHJldHVybiBhbnkgYXhpcyAobm8gcm90YXRpb24gLSBheGlzIGRvZXMgbm90IG1hdHRlcilcbiAgICBvdXRfYXhpc1swXSA9IDE7XG4gICAgb3V0X2F4aXNbMV0gPSAwO1xuICAgIG91dF9heGlzWzJdID0gMDtcbiAgfVxuICByZXR1cm4gcmFkO1xufVxuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgbGV0IGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXTtcbiAgbGV0IGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl0sIGJ3ID0gYlszXTtcblxuICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5O1xuICBvdXRbMV0gPSBheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6O1xuICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4O1xuICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWCBheGlzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVgob3V0LCBhLCByYWQpIHtcbiAgcmFkICo9IDAuNTtcblxuICBsZXQgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdO1xuICBsZXQgYnggPSBNYXRoLnNpbihyYWQpLCBidyA9IE1hdGguY29zKHJhZCk7XG5cbiAgb3V0WzBdID0gYXggKiBidyArIGF3ICogYng7XG4gIG91dFsxXSA9IGF5ICogYncgKyBheiAqIGJ4O1xuICBvdXRbMl0gPSBheiAqIGJ3IC0gYXkgKiBieDtcbiAgb3V0WzNdID0gYXcgKiBidyAtIGF4ICogYng7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBZIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIHJhZCkge1xuICByYWQgKj0gMC41O1xuXG4gIGxldCBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM107XG4gIGxldCBieSA9IE1hdGguc2luKHJhZCksIGJ3ID0gTWF0aC5jb3MocmFkKTtcblxuICBvdXRbMF0gPSBheCAqIGJ3IC0gYXogKiBieTtcbiAgb3V0WzFdID0gYXkgKiBidyArIGF3ICogYnk7XG4gIG91dFsyXSA9IGF6ICogYncgKyBheCAqIGJ5O1xuICBvdXRbM10gPSBhdyAqIGJ3IC0gYXkgKiBieTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFogYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgcmFkKSB7XG4gIHJhZCAqPSAwLjU7XG5cbiAgbGV0IGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXTtcbiAgbGV0IGJ6ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gIG91dFswXSA9IGF4ICogYncgKyBheSAqIGJ6O1xuICBvdXRbMV0gPSBheSAqIGJ3IC0gYXggKiBiejtcbiAgb3V0WzJdID0gYXogKiBidyArIGF3ICogYno7XG4gIG91dFszXSA9IGF3ICogYncgLSBheiAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIFcgY29tcG9uZW50IG9mIGEgcXVhdCBmcm9tIHRoZSBYLCBZLCBhbmQgWiBjb21wb25lbnRzLlxuICogQXNzdW1lcyB0aGF0IHF1YXRlcm5pb24gaXMgMSB1bml0IGluIGxlbmd0aC5cbiAqIEFueSBleGlzdGluZyBXIGNvbXBvbmVudCB3aWxsIGJlIGlnbm9yZWQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgVyBjb21wb25lbnQgb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVcob3V0LCBhKSB7XG4gIGxldCB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdO1xuXG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIG91dFszXSA9IE1hdGguc3FydChNYXRoLmFicygxLjAgLSB4ICogeCAtIHkgKiB5IC0geiAqIHopKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNsZXJwKG91dCwgYSwgYiwgdCkge1xuICAvLyBiZW5jaG1hcmtzOlxuICAvLyAgICBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXNsZXJwLWltcGxlbWVudGF0aW9uc1xuICBsZXQgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdO1xuICBsZXQgYnggPSBiWzBdLCBieSA9IGJbMV0sIGJ6ID0gYlsyXSwgYncgPSBiWzNdO1xuXG4gIGxldCBvbWVnYSwgY29zb20sIHNpbm9tLCBzY2FsZTAsIHNjYWxlMTtcblxuICAvLyBjYWxjIGNvc2luZVxuICBjb3NvbSA9IGF4ICogYnggKyBheSAqIGJ5ICsgYXogKiBieiArIGF3ICogYnc7XG4gIC8vIGFkanVzdCBzaWducyAoaWYgbmVjZXNzYXJ5KVxuICBpZiAoIGNvc29tIDwgMC4wICkge1xuICAgIGNvc29tID0gLWNvc29tO1xuICAgIGJ4ID0gLSBieDtcbiAgICBieSA9IC0gYnk7XG4gICAgYnogPSAtIGJ6O1xuICAgIGJ3ID0gLSBidztcbiAgfVxuICAvLyBjYWxjdWxhdGUgY29lZmZpY2llbnRzXG4gIGlmICggKDEuMCAtIGNvc29tKSA+IDAuMDAwMDAxICkge1xuICAgIC8vIHN0YW5kYXJkIGNhc2UgKHNsZXJwKVxuICAgIG9tZWdhICA9IE1hdGguYWNvcyhjb3NvbSk7XG4gICAgc2lub20gID0gTWF0aC5zaW4ob21lZ2EpO1xuICAgIHNjYWxlMCA9IE1hdGguc2luKCgxLjAgLSB0KSAqIG9tZWdhKSAvIHNpbm9tO1xuICAgIHNjYWxlMSA9IE1hdGguc2luKHQgKiBvbWVnYSkgLyBzaW5vbTtcbiAgfSBlbHNlIHtcbiAgICAvLyBcImZyb21cIiBhbmQgXCJ0b1wiIHF1YXRlcm5pb25zIGFyZSB2ZXJ5IGNsb3NlXG4gICAgLy8gIC4uLiBzbyB3ZSBjYW4gZG8gYSBsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgIHNjYWxlMCA9IDEuMCAtIHQ7XG4gICAgc2NhbGUxID0gdDtcbiAgfVxuICAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWVzXG4gIG91dFswXSA9IHNjYWxlMCAqIGF4ICsgc2NhbGUxICogYng7XG4gIG91dFsxXSA9IHNjYWxlMCAqIGF5ICsgc2NhbGUxICogYnk7XG4gIG91dFsyXSA9IHNjYWxlMCAqIGF6ICsgc2NhbGUxICogYno7XG4gIG91dFszXSA9IHNjYWxlMCAqIGF3ICsgc2NhbGUxICogYnc7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBpbnZlcnNlIG9mIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIGludmVyc2Ugb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXTtcbiAgbGV0IGRvdCA9IGEwKmEwICsgYTEqYTEgKyBhMiphMiArIGEzKmEzO1xuICBsZXQgaW52RG90ID0gZG90ID8gMS4wL2RvdCA6IDA7XG5cbiAgLy8gVE9ETzogV291bGQgYmUgZmFzdGVyIHRvIHJldHVybiBbMCwwLDAsMF0gaW1tZWRpYXRlbHkgaWYgZG90ID09IDBcblxuICBvdXRbMF0gPSAtYTAqaW52RG90O1xuICBvdXRbMV0gPSAtYTEqaW52RG90O1xuICBvdXRbMl0gPSAtYTIqaW52RG90O1xuICBvdXRbM10gPSBhMyppbnZEb3Q7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgY29uanVnYXRlIG9mIGEgcXVhdFxuICogSWYgdGhlIHF1YXRlcm5pb24gaXMgbm9ybWFsaXplZCwgdGhpcyBmdW5jdGlvbiBpcyBmYXN0ZXIgdGhhbiBxdWF0LmludmVyc2UgYW5kIHByb2R1Y2VzIHRoZSBzYW1lIHJlc3VsdC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBjb25qdWdhdGUgb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmp1Z2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgcXVhdGVybmlvbiBmcm9tIHRoZSBnaXZlbiAzeDMgcm90YXRpb24gbWF0cml4LlxuICpcbiAqIE5PVEU6IFRoZSByZXN1bHRhbnQgcXVhdGVybmlvbiBpcyBub3Qgbm9ybWFsaXplZCwgc28geW91IHNob3VsZCBiZSBzdXJlXG4gKiB0byByZW5vcm1hbGl6ZSB0aGUgcXVhdGVybmlvbiB5b3Vyc2VsZiB3aGVyZSBuZWNlc3NhcnkuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge21hdDN9IG0gcm90YXRpb24gbWF0cml4XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21NYXQzKG91dCwgbSkge1xuICAvLyBBbGdvcml0aG0gaW4gS2VuIFNob2VtYWtlJ3MgYXJ0aWNsZSBpbiAxOTg3IFNJR0dSQVBIIGNvdXJzZSBub3Rlc1xuICAvLyBhcnRpY2xlIFwiUXVhdGVybmlvbiBDYWxjdWx1cyBhbmQgRmFzdCBBbmltYXRpb25cIi5cbiAgbGV0IGZUcmFjZSA9IG1bMF0gKyBtWzRdICsgbVs4XTtcbiAgbGV0IGZSb290O1xuXG4gIGlmICggZlRyYWNlID4gMC4wICkge1xuICAgIC8vIHx3fCA+IDEvMiwgbWF5IGFzIHdlbGwgY2hvb3NlIHcgPiAxLzJcbiAgICBmUm9vdCA9IE1hdGguc3FydChmVHJhY2UgKyAxLjApOyAgLy8gMndcbiAgICBvdXRbM10gPSAwLjUgKiBmUm9vdDtcbiAgICBmUm9vdCA9IDAuNS9mUm9vdDsgIC8vIDEvKDR3KVxuICAgIG91dFswXSA9IChtWzVdLW1bN10pKmZSb290O1xuICAgIG91dFsxXSA9IChtWzZdLW1bMl0pKmZSb290O1xuICAgIG91dFsyXSA9IChtWzFdLW1bM10pKmZSb290O1xuICB9IGVsc2Uge1xuICAgIC8vIHx3fCA8PSAxLzJcbiAgICBsZXQgaSA9IDA7XG4gICAgaWYgKCBtWzRdID4gbVswXSApXG4gICAgICBpID0gMTtcbiAgICBpZiAoIG1bOF0gPiBtW2kqMytpXSApXG4gICAgICBpID0gMjtcbiAgICBsZXQgaiA9IChpKzEpJTM7XG4gICAgbGV0IGsgPSAoaSsyKSUzO1xuXG4gICAgZlJvb3QgPSBNYXRoLnNxcnQobVtpKjMraV0tbVtqKjMral0tbVtrKjMra10gKyAxLjApO1xuICAgIG91dFtpXSA9IDAuNSAqIGZSb290O1xuICAgIGZSb290ID0gMC41IC8gZlJvb3Q7XG4gICAgb3V0WzNdID0gKG1baiozK2tdIC0gbVtrKjMral0pICogZlJvb3Q7XG4gICAgb3V0W2pdID0gKG1baiozK2ldICsgbVtpKjMral0pICogZlJvb3Q7XG4gICAgb3V0W2tdID0gKG1bayozK2ldICsgbVtpKjMra10pICogZlJvb3Q7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBxdWF0ZXJuaW9uIGZyb20gdGhlIGdpdmVuIGV1bGVyIGFuZ2xlIHgsIHksIHouXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3h9IEFuZ2xlIHRvIHJvdGF0ZSBhcm91bmQgWCBheGlzIGluIGRlZ3JlZXMuXG4gKiBAcGFyYW0ge3l9IEFuZ2xlIHRvIHJvdGF0ZSBhcm91bmQgWSBheGlzIGluIGRlZ3JlZXMuXG4gKiBAcGFyYW0ge3p9IEFuZ2xlIHRvIHJvdGF0ZSBhcm91bmQgWiBheGlzIGluIGRlZ3JlZXMuXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21FdWxlcihvdXQsIHgsIHksIHopIHtcbiAgICBsZXQgaGFsZlRvUmFkID0gMC41ICogTWF0aC5QSSAvIDE4MC4wO1xuICAgIHggKj0gaGFsZlRvUmFkO1xuICAgIHkgKj0gaGFsZlRvUmFkO1xuICAgIHogKj0gaGFsZlRvUmFkO1xuXG4gICAgbGV0IHN4ID0gTWF0aC5zaW4oeCk7XG4gICAgbGV0IGN4ID0gTWF0aC5jb3MoeCk7XG4gICAgbGV0IHN5ID0gTWF0aC5zaW4oeSk7XG4gICAgbGV0IGN5ID0gTWF0aC5jb3MoeSk7XG4gICAgbGV0IHN6ID0gTWF0aC5zaW4oeik7XG4gICAgbGV0IGN6ID0gTWF0aC5jb3Moeik7XG5cbiAgICBvdXRbMF0gPSBzeCAqIGN5ICogY3ogLSBjeCAqIHN5ICogc3o7XG4gICAgb3V0WzFdID0gY3ggKiBzeSAqIGN6ICsgc3ggKiBjeSAqIHN6O1xuICAgIG91dFsyXSA9IGN4ICogY3kgKiBzeiAtIHN4ICogc3kgKiBjejtcbiAgICBvdXRbM10gPSBjeCAqIGN5ICogY3ogKyBzeCAqIHN5ICogc3o7XG5cbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBxdWF0ZW5pb25cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiAncXVhdCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcpJztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXRlcm5pb24gdG8gY2xvbmVcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGNsb25lID0gdmVjNC5jbG9uZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGZyb21WYWx1ZXMgPSB2ZWM0LmZyb21WYWx1ZXM7XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHF1YXQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBzb3VyY2UgcXVhdGVybmlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBjb3B5ID0gdmVjNC5jb3B5O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHF1YXQgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc2V0ID0gdmVjNC5zZXQ7XG5cbi8qKlxuICogQWRkcyB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgYWRkID0gdmVjNC5hZGQ7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBtdWwgPSBtdWx0aXBseTtcblxuLyoqXG4gKiBTY2FsZXMgYSBxdWF0IGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc2NhbGUgPSB2ZWM0LnNjYWxlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZG90ID0gdmVjNC5kb3Q7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBsZXJwID0gdmVjNC5sZXJwO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbmV4cG9ydCBjb25zdCBsZW5ndGggPSB2ZWM0Lmxlbmd0aDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBsZW4gPSBsZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc3F1YXJlZExlbmd0aCA9IHZlYzQuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc3FyTGVuID0gc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdGVybmlvbiB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplID0gdmVjNC5ub3JtYWxpemU7XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcXVhdGVybmlvbnMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSBUaGUgZmlyc3QgcXVhdGVybmlvbi5cbiAqIEBwYXJhbSB7cXVhdH0gYiBUaGUgc2Vjb25kIHF1YXRlcm5pb24uXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGV4YWN0RXF1YWxzID0gdmVjNC5leGFjdEVxdWFscztcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBxdWF0ZXJuaW9ucyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3F1YXR9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGVxdWFscyA9IHZlYzQuZXF1YWxzO1xuXG4vKipcbiAqIFNldHMgYSBxdWF0ZXJuaW9uIHRvIHJlcHJlc2VudCB0aGUgc2hvcnRlc3Qgcm90YXRpb24gZnJvbSBvbmVcbiAqIHZlY3RvciB0byBhbm90aGVyLlxuICpcbiAqIEJvdGggdmVjdG9ycyBhcmUgYXNzdW1lZCB0byBiZSB1bml0IGxlbmd0aC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb24uXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGluaXRpYWwgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIGRlc3RpbmF0aW9uIHZlY3RvclxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5leHBvcnQgY29uc3Qgcm90YXRpb25UbyA9IChmdW5jdGlvbigpIHtcbiAgbGV0IHRtcHZlYzMgPSB2ZWMzLmNyZWF0ZSgpO1xuICBsZXQgeFVuaXRWZWMzID0gdmVjMy5mcm9tVmFsdWVzKDEsMCwwKTtcbiAgbGV0IHlVbml0VmVjMyA9IHZlYzMuZnJvbVZhbHVlcygwLDEsMCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIGxldCBkb3QgPSB2ZWMzLmRvdChhLCBiKTtcbiAgICBpZiAoZG90IDwgLTAuOTk5OTk5KSB7XG4gICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIHhVbml0VmVjMywgYSk7XG4gICAgICBpZiAodmVjMy5sZW4odG1wdmVjMykgPCAwLjAwMDAwMSlcbiAgICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCB5VW5pdFZlYzMsIGEpO1xuICAgICAgdmVjMy5ub3JtYWxpemUodG1wdmVjMywgdG1wdmVjMyk7XG4gICAgICBzZXRBeGlzQW5nbGUob3V0LCB0bXB2ZWMzLCBNYXRoLlBJKTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfSBlbHNlIGlmIChkb3QgPiAwLjk5OTk5OSkge1xuICAgICAgb3V0WzBdID0gMDtcbiAgICAgIG91dFsxXSA9IDA7XG4gICAgICBvdXRbMl0gPSAwO1xuICAgICAgb3V0WzNdID0gMTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgYSwgYik7XG4gICAgICBvdXRbMF0gPSB0bXB2ZWMzWzBdO1xuICAgICAgb3V0WzFdID0gdG1wdmVjM1sxXTtcbiAgICAgIG91dFsyXSA9IHRtcHZlYzNbMl07XG4gICAgICBvdXRbM10gPSAxICsgZG90O1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZShvdXQsIG91dCk7XG4gICAgfVxuICB9O1xufSkoKTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGMgdGhlIHRoaXJkIG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gZCB0aGUgZm91cnRoIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbmV4cG9ydCBjb25zdCBzcWxlcnAgPSAoZnVuY3Rpb24gKCkge1xuICBsZXQgdGVtcDEgPSBjcmVhdGUoKTtcbiAgbGV0IHRlbXAyID0gY3JlYXRlKCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgICBzbGVycCh0ZW1wMSwgYSwgZCwgdCk7XG4gICAgc2xlcnAodGVtcDIsIGIsIGMsIHQpO1xuICAgIHNsZXJwKG91dCwgdGVtcDEsIHRlbXAyLCAyICogdCAqICgxIC0gdCkpO1xuXG4gICAgcmV0dXJuIG91dDtcbiAgfTtcbn0oKSk7XG5cbi8qKlxuICogU2V0cyB0aGUgc3BlY2lmaWVkIHF1YXRlcm5pb24gd2l0aCB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW5cbiAqIGF4ZXMuIEVhY2ggYXhpcyBpcyBhIHZlYzMgYW5kIGlzIGV4cGVjdGVkIHRvIGJlIHVuaXQgbGVuZ3RoIGFuZFxuICogcGVycGVuZGljdWxhciB0byBhbGwgb3RoZXIgc3BlY2lmaWVkIGF4ZXMuXG4gKlxuICogQHBhcmFtIHt2ZWMzfSB2aWV3ICB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgdmlld2luZyBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7dmVjM30gcmlnaHQgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGxvY2FsIFwicmlnaHRcIiBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7dmVjM30gdXAgICAgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGxvY2FsIFwidXBcIiBkaXJlY3Rpb25cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGNvbnN0IHNldEF4ZXMgPSAoZnVuY3Rpb24oKSB7XG4gIGxldCBtYXRyID0gbWF0My5jcmVhdGUoKTtcblxuICByZXR1cm4gZnVuY3Rpb24ob3V0LCB2aWV3LCByaWdodCwgdXApIHtcbiAgICBtYXRyWzBdID0gcmlnaHRbMF07XG4gICAgbWF0clszXSA9IHJpZ2h0WzFdO1xuICAgIG1hdHJbNl0gPSByaWdodFsyXTtcblxuICAgIG1hdHJbMV0gPSB1cFswXTtcbiAgICBtYXRyWzRdID0gdXBbMV07XG4gICAgbWF0cls3XSA9IHVwWzJdO1xuXG4gICAgbWF0clsyXSA9IC12aWV3WzBdO1xuICAgIG1hdHJbNV0gPSAtdmlld1sxXTtcbiAgICBtYXRyWzhdID0gLXZpZXdbMl07XG5cbiAgICByZXR1cm4gbm9ybWFsaXplKG91dCwgZnJvbU1hdDMob3V0LCBtYXRyKSk7XG4gIH07XG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvcXVhdC5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG5pbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb25cIjtcblxuLyoqXG4gKiAyIERpbWVuc2lvbmFsIFZlY3RvclxuICogQG1vZHVsZSB2ZWMyXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMyXG4gKlxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG4gIG91dFswXSA9IDA7XG4gIG91dFsxXSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5KSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCB4LCB5KSB7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpdmlkZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gcm91bmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kIChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMiBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkpO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgcmV0dXJuIHgqeCArIHkqeTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICB5ID0gYVsxXTtcbiAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkpO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZExlbmd0aCAoYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV07XG4gIHJldHVybiB4KnggKyB5Knk7XG59O1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuZWdhdGUob3V0LCBhKSB7XG4gIG91dFswXSA9IC1hWzBdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgIHkgPSBhWzFdO1xuICB2YXIgbGVuID0geCp4ICsgeSp5O1xuICBpZiAobGVuID4gMCkge1xuICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICogTm90ZSB0aGF0IHRoZSBjcm9zcyBwcm9kdWN0IG11c3QgYnkgZGVmaW5pdGlvbiBwcm9kdWNlIGEgM0QgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3Jvc3Mob3V0LCBhLCBiKSB7XG4gIHZhciB6ID0gYVswXSAqIGJbMV0gLSBhWzFdICogYlswXTtcbiAgb3V0WzBdID0gb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gejtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICB2YXIgYXggPSBhWzBdLFxuICAgIGF5ID0gYVsxXTtcbiAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG4gIHZhciByID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJO1xuICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHNjYWxlO1xuICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQyfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MihvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5O1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5O1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0MmR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQyZChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeSArIG1bNV07XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDNcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQzfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MyhvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bM10gKiB5ICsgbVs2XTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzRdICogeSArIG1bN107XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDRcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzAnXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gIGxldCB4ID0gYVswXTtcbiAgbGV0IHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVsxMl07XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzEzXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gJ3ZlYzIoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcpJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGV4YWN0bHkgaGF2ZSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMyfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICBsZXQgYTAgPSBhWzBdLCBhMSA9IGFbMV07XG4gIGxldCBiMCA9IGJbMF0sIGIxID0gYlsxXTtcbiAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSk7XG59XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgbGVuID0gbGVuZ3RoO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc3ViID0gc3VidHJhY3Q7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBtdWwgPSBtdWx0aXBseTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBkaXYgPSBkaXZpZGU7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBkaXN0ID0gZGlzdGFuY2U7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc3FyTGVuID0gc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjMnMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMi4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzJzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZm9yRWFjaCA9IChmdW5jdGlvbigpIHtcbiAgbGV0IHZlYyA9IGNyZWF0ZSgpO1xuXG4gIHJldHVybiBmdW5jdGlvbihhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICBsZXQgaSwgbDtcbiAgICBpZighc3RyaWRlKSB7XG4gICAgICBzdHJpZGUgPSAyO1xuICAgIH1cblxuICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgaWYoY291bnQpIHtcbiAgICAgIGwgPSBNYXRoLm1pbigoY291bnQgKiBzdHJpZGUpICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICB2ZWNbMF0gPSBhW2ldOyB2ZWNbMV0gPSBhW2krMV07XG4gICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgIGFbaV0gPSB2ZWNbMF07IGFbaSsxXSA9IHZlY1sxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfTtcbn0pKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC92ZWMyLmpzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIFZlcnRleEFycmF5T2JqZWN0LmpzXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEFuZEFwcGx5RXh0ZW5zaW9uKGdsLCBuYW1lKSB7XG5cdGNvbnN0IGV4dCA9IGdsLmdldEV4dGVuc2lvbihuYW1lKTtcblx0aWYgKCFleHQpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0Y29uc3Qgc3VmZml4ID0gbmFtZS5zcGxpdCgnXycpWzBdO1xuXHRjb25zdCBzdWZmaXhSRSA9IG5ldyBSZWdFeHAoYCR7c3VmZml4fSRgKTtcblxuXHRmb3IgKGNvbnN0IGtleSBpbiBleHQpIHtcblx0XHRjb25zdCB2YWwgPSBleHRba2V5XTtcblx0XHRpZiAodHlwZW9mKHZhbCkgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNvbnN0IHVuc3VmZml4ZWRLZXkgPSBrZXkucmVwbGFjZShzdWZmaXhSRSwgJycpO1xuXHRcdFx0aWYgKGtleS5zdWJzdHJpbmcpIHtcblx0XHRcdFx0Z2xbdW5zdWZmaXhlZEtleV0gPSBleHRba2V5XS5iaW5kKGV4dCk7XHRcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ1JlcGxhY2luZyA6Jywga2V5LCAnPT4nLCB1bnN1ZmZpeGVkS2V5KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9nZXRBbmRBcHBseUV4dGVuc2lvbi5qcyIsIi8vIGV4cG9zZUF0dHJpYnV0ZXMuanNcblxuaW1wb3J0IEdMIGZyb20gJy4uL0dMVG9vbCc7XG5pbXBvcnQgV2ViZ2xDb25zdCBmcm9tICcuL1dlYmdsQ29uc3QnO1xuXG5jb25zdCBleHBvc2VBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xuXHQvLyBHTC5WRVJURVhfU0hBREVSICAgICAgICAgPSBHTC5nbC5WRVJURVhfU0hBREVSO1xuXHQvLyBHTC5GUkFHTUVOVF9TSEFERVIgICAgICAgPSBHTC5nbC5GUkFHTUVOVF9TSEFERVI7XG5cdC8vIEdMLkNPTVBJTEVfU1RBVFVTICAgICAgICA9IEdMLmdsLkNPTVBJTEVfU1RBVFVTO1xuXHQvLyBHTC5ERVBUSF9URVNUICAgICAgICAgICAgPSBHTC5nbC5ERVBUSF9URVNUO1xuXHQvLyBHTC5DVUxMX0ZBQ0UgICAgICAgICAgICAgPSBHTC5nbC5DVUxMX0ZBQ0U7XG5cdC8vIEdMLkJMRU5EICAgICAgICAgICAgICAgICA9IEdMLmdsLkJMRU5EO1xuXHQvLyBHTC5QT0lOVFMgICAgICAgICAgICAgICAgPSBHTC5nbC5QT0lOVFM7XG5cdC8vIEdMLkxJTkVTICAgICAgICAgICAgICAgICA9IEdMLmdsLkxJTkVTO1xuXHQvLyBHTC5UUklBTkdMRVMgICAgICAgICAgICAgPSBHTC5nbC5UUklBTkdMRVM7XG5cdFxuXHQvLyBHTC5MSU5FQVIgICAgICAgICAgICAgICAgXHQ9IEdMLmdsLkxJTkVBUjtcblx0Ly8gR0wuTkVBUkVTVCAgICAgICAgICAgICAgIFx0PSBHTC5nbC5ORUFSRVNUO1xuXHQvLyBHTC5MSU5FQVJfTUlQTUFQX05FQVJFU1QgXHQ9IEdMLmdsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVDtcblx0Ly8gR0wuTkVBUkVTVF9NSVBNQVBfTElORUFSIFx0PSBHTC5nbC5ORUFSRVNUX01JUE1BUF9MSU5FQVI7XG5cdC8vIEdMLkxJTkVBUl9NSVBNQVBfTElORUFSIFx0PSBHTC5nbC5MSU5FQVJfTUlQTUFQX0xJTkVBUjtcblx0Ly8gR0wuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCBcdD0gR0wuZ2wuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVDtcblx0Ly8gR0wuTUlSUk9SRURfUkVQRUFUICAgICAgIFx0PSBHTC5nbC5NSVJST1JFRF9SRVBFQVQ7XG5cdC8vIEdMLkNMQU1QX1RPX0VER0UgICAgICAgICBcdD0gR0wuZ2wuQ0xBTVBfVE9fRURHRTtcblx0Ly8gR0wuU0NJU1NPUl9URVNUXHRcdCAgIFx0IFx0PSBHTC5nbC5TQ0lTU09SX1RFU1Q7XG5cdC8vIEdMLlVOU0lHTkVEX0JZVEVcdFx0IFx0PSBHTC5nbC5VTlNJR05FRF9CWVRFO1xuXHRmb3IgKGNvbnN0IHMgaW4gV2ViZ2xDb25zdCkge1xuXHRcdGlmKCFHTFtzXSkge1xuXHRcdFx0R0xbc10gPSBXZWJnbENvbnN0W3NdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLmxvZygnYWxyZWFkeSBleGlzdCA6ICcsIHMpO1xuXHRcdH1cblx0XHRcblx0fVxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBleHBvc2VBdHRyaWJ1dGVzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL2V4cG9zZUF0dHJpYnV0ZXMuanMiLCIvLyBnZXRGbG9hdC5qc1xuXG5pbXBvcnQgR0wgZnJvbSAnLi4vR0xUb29sJztcblxubGV0IGhhc0NoZWNrZWQgPSBmYWxzZTtcbmxldCBfZmxvYXQ7XG5cblxuZnVuY3Rpb24gY2hlY2tGbG9hdCgpIHtcblx0aWYoR0wud2ViZ2wyKSB7XG5cdFx0cmV0dXJuIEdMLmdsLkZMT0FUO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnN0IGV4dEZsb2F0ID0gR0wuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdCcpO1xuXHRcdGlmKGV4dEZsb2F0KSB7XG5cdFx0XHRyZXR1cm4gR0wuZ2wuRkxPQVQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUud2FybignVVNJTkcgRkxPQVQgQlVUIE9FU190ZXh0dXJlX2Zsb2F0IE5PVCBTVVBQT1JURUQnKTtcblx0XHRcdHJldHVybiBHTC5nbC5VTlNJR05FRF9CWVRFO1xuXHRcdH1cblx0fVxuXG5cdGhhc0NoZWNrZWQgPSB0cnVlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuXHRpZighaGFzQ2hlY2tlZCkge1xuXHRcdF9mbG9hdCA9IGNoZWNrRmxvYXQoKTtcblx0fVxuXG5cblx0cmV0dXJuIF9mbG9hdDtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9nZXRGbG9hdC5qcyIsIi8vIGdldEhhbGZGbG9hdC5qc1xuXG5pbXBvcnQgR0wgZnJvbSAnLi4vR0xUb29sJztcblxubGV0IGhhc0NoZWNrZWQgPSBmYWxzZTtcbmxldCBoYWxmRmxvYXQ7XG5cbmZ1bmN0aW9uIGNoZWNrSGFsZkZsb2F0KCkge1xuXHRpZihHTC53ZWJnbDIpIHtcblx0XHRyZXR1cm4gR0wuZ2wuSEFMRl9GTE9BVDtcblx0fSBlbHNlIHtcblx0XHRjb25zdCBleHRIYWxmRmxvYXQgPSBHTC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnKTtcblx0XHRpZihleHRIYWxmRmxvYXQpIHtcblx0XHRcdHJldHVybiBleHRIYWxmRmxvYXQuSEFMRl9GTE9BVF9PRVM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUud2FybignVVNJTkcgSEFMRiBGTE9BVCBCVVQgT0VTX3RleHR1cmVfaGFsZl9mbG9hdCBOT1QgU1VQUE9SVEVEJyk7XG5cdFx0XHRyZXR1cm4gR0wuZ2wuVU5TSUdORURfQllURTtcblx0XHR9XG5cdH1cblxuXHRoYXNDaGVja2VkID0gdHJ1ZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcblx0aWYoIWhhc0NoZWNrZWQpIHtcblx0XHRoYWxmRmxvYXQgPSBjaGVja0hhbGZGbG9hdCgpO1xuXHR9XG5cblx0cmV0dXJuIGhhbGZGbG9hdDtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9nZXRIYWxmRmxvYXQuanMiLCIvLyBFeHRlbnNpb25zTGlzdC5qc1xuXG5leHBvcnQgZGVmYXVsdCBbXG5cdCdFWFRfc2hhZGVyX3RleHR1cmVfbG9kJywgXG5cdCdFWFRfc1JHQicsIFxuXHQnRVhUX2ZyYWdfZGVwdGgnLCBcblx0J09FU190ZXh0dXJlX2Zsb2F0JywgXG5cdCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0JywgXG5cdCdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInLCBcblx0J09FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyJywgXG5cdCdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnLCBcblx0J1dFQkdMX2RlcHRoX3RleHR1cmUnLCBcblx0J0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycsIFxuXHQnT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnLCBcblx0J0FOR0xFX2luc3RhbmNlZF9hcnJheXMnLCBcblx0J1dFQkdMX2RyYXdfYnVmZmVycydcbl07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvRXh0ZW5zaW9uc0xpc3QuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHN0cmluZ3MpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmdzID09PSAnc3RyaW5nJykgc3RyaW5ncyA9IFtzdHJpbmdzXVxuICB2YXIgZXhwcnMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKVxuICB2YXIgcGFydHMgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ3MubGVuZ3RoLTE7IGkrKykge1xuICAgIHBhcnRzLnB1c2goc3RyaW5nc1tpXSwgZXhwcnNbaV0gfHwgJycpXG4gIH1cbiAgcGFydHMucHVzaChzdHJpbmdzW2ldKVxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsc2xpZnkvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gYmFzaWMuZnJhZ1xcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgQkFTSUNfRlJBR01FTlRcXG5cXG5wcmVjaXNpb24gbG93cCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnVuaWZvcm0gZmxvYXQgdGltZTtcXG4vLyB1bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodlRleHR1cmVDb29yZCwgc2luKHRpbWUpICogLjUgKyAuNSwgMS4wKTtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3NoYWRlcnMvYmFzaWMuZnJhZ1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBnZXRUZXh0dXJlUGFyYW1ldGVycy5qc1xuXG5pbXBvcnQgR0wgZnJvbSAnLi4vR0xUb29sJztcblxuZnVuY3Rpb24gaXNQb3dlck9mVHdvKHgpIHtcdFxuXHRyZXR1cm4gKHggIT09IDApICYmICghKHggJiAoeCAtIDEpKSk7XG59O1xuXG5jb25zdCBnZXRUZXh0dXJlUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChtUGFyYW1zLCBtU291cmNlLCBtV2lkdGgsIG1IZWlnaHQpIHtcblx0aWYoIW1QYXJhbXMubWluRmlsdGVyKSB7XG5cdFx0bGV0IG1pbkZpbHRlciA9IEdMLkxJTkVBUjtcblx0XHRpZihtV2lkdGggJiYgbVdpZHRoKSB7XG5cdFx0XHRpZihpc1Bvd2VyT2ZUd28obVdpZHRoKSAmJiBpc1Bvd2VyT2ZUd28obUhlaWdodCkpIHtcblx0XHRcdFx0bWluRmlsdGVyID0gR0wuTkVBUkVTVF9NSVBNQVBfTElORUFSO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG1QYXJhbXMubWluRmlsdGVyID0gbWluRmlsdGVyO1xuXHR9IFxuXG5cblx0bVBhcmFtcy5taXBtYXAgPSBtUGFyYW1zLm1pcG1hcCB8fCB0cnVlO1xuXHRtUGFyYW1zLm1hZ0ZpbHRlciA9IG1QYXJhbXMubWFnRmlsdGVyIHx8IEdMLkxJTkVBUjtcblx0bVBhcmFtcy53cmFwUyA9IG1QYXJhbXMud3JhcFMgfHwgR0wuQ0xBTVBfVE9fRURHRTtcblx0bVBhcmFtcy53cmFwVCA9IG1QYXJhbXMud3JhcFQgfHwgR0wuQ0xBTVBfVE9fRURHRTtcblx0bVBhcmFtcy5pbnRlcm5hbEZvcm1hdCA9IG1QYXJhbXMuaW50ZXJuYWxGb3JtYXQgfHwgR0wuUkdCQTtcblx0bVBhcmFtcy5mb3JtYXQgPSBtUGFyYW1zLmZvcm1hdCB8fCBHTC5SR0JBO1xuXHRtUGFyYW1zLnByZW11bHRpcGx5QWxwaGEgPSBtUGFyYW1zLnByZW11bHRpcGx5QWxwaGEgfHwgZmFsc2U7XG5cdG1QYXJhbXMubGV2ZWwgPSBtUGFyYW1zLmxldmVsIHx8IDA7XG5cdG1QYXJhbXMuYW5pc290cm9weSA9IG1QYXJhbXMuYW5pc290cm9weSB8fCAwO1xuXHRyZXR1cm4gbVBhcmFtcztcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgZ2V0VGV4dHVyZVBhcmFtZXRlcnM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvZ2V0VGV4dHVyZVBhcmFtZXRlcnMuanMiLCIvLyBBbGwgdmFsdWVzIGFuZCBzdHJ1Y3R1cmVzIHJlZmVyZW5jZWQgZnJvbTpcbi8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9iYjk0Mzk5MS5hc3B4L1xuLy9cbi8vIERYMTAgQ3ViZW1hcCBzdXBwb3J0IGJhc2VkIG9uXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGFyaW9tYW5lc2t1L2NtZnQvaXNzdWVzLzcjaXNzdWVjb21tZW50LTY5NTE2ODQ0XG4vLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvZGVza3RvcC9iYjk0Mzk4Myh2PXZzLjg1KS5hc3B4XG4vLyBodHRwczovL2dpdGh1Yi5jb20vcGxheWNhbnZhcy9lbmdpbmUvYmxvYi9tYXN0ZXIvc3JjL3Jlc291cmNlcy9yZXNvdXJjZXNfdGV4dHVyZS5qc1xuXG52YXIgRERTX01BR0lDID0gMHgyMDUzNDQ0NFxudmFyIEREU0RfTUlQTUFQQ09VTlQgPSAweDIwMDAwXG52YXIgRERQRl9GT1VSQ0MgPSAweDRcblxudmFyIEZPVVJDQ19EWFQxID0gZm91ckNDVG9JbnQzMignRFhUMScpXG52YXIgRk9VUkNDX0RYVDMgPSBmb3VyQ0NUb0ludDMyKCdEWFQzJylcbnZhciBGT1VSQ0NfRFhUNSA9IGZvdXJDQ1RvSW50MzIoJ0RYVDUnKVxudmFyIEZPVVJDQ19EWDEwID0gZm91ckNDVG9JbnQzMignRFgxMCcpXG52YXIgRk9VUkNDX0ZQMzJGID0gMTE2IC8vIERYR0lfRk9STUFUX1IzMkczMkIzMkEzMl9GTE9BVFxuXG52YXIgRERTQ0FQUzJfQ1VCRU1BUCA9IDB4MjAwXG52YXIgRDNEMTBfUkVTT1VSQ0VfRElNRU5TSU9OX1RFWFRVUkUyRCA9IDNcbnZhciBEWEdJX0ZPUk1BVF9SMzJHMzJCMzJBMzJfRkxPQVQgPSAyXG5cbi8vIFRoZSBoZWFkZXIgbGVuZ3RoIGluIDMyIGJpdCBpbnRzXG52YXIgaGVhZGVyTGVuZ3RoSW50ID0gMzFcblxuLy8gT2Zmc2V0cyBpbnRvIHRoZSBoZWFkZXIgYXJyYXlcbnZhciBvZmZfbWFnaWMgPSAwXG52YXIgb2ZmX3NpemUgPSAxXG52YXIgb2ZmX2ZsYWdzID0gMlxudmFyIG9mZl9oZWlnaHQgPSAzXG52YXIgb2ZmX3dpZHRoID0gNFxudmFyIG9mZl9taXBtYXBDb3VudCA9IDdcbnZhciBvZmZfcGZGbGFncyA9IDIwXG52YXIgb2ZmX3BmRm91ckNDID0gMjFcbnZhciBvZmZfY2FwczIgPSAyOFxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlSGVhZGVyc1xuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMgKGFycmF5QnVmZmVyKSB7XG4gIHZhciBoZWFkZXIgPSBuZXcgSW50MzJBcnJheShhcnJheUJ1ZmZlciwgMCwgaGVhZGVyTGVuZ3RoSW50KVxuXG4gIGlmIChoZWFkZXJbb2ZmX21hZ2ljXSAhPT0gRERTX01BR0lDKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1hZ2ljIG51bWJlciBpbiBERFMgaGVhZGVyJylcbiAgfVxuXG4gIGlmICghaGVhZGVyW29mZl9wZkZsYWdzXSAmIEREUEZfRk9VUkNDKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBmb3JtYXQsIG11c3QgY29udGFpbiBhIEZvdXJDQyBjb2RlJylcbiAgfVxuXG4gIHZhciBibG9ja0J5dGVzXG4gIHZhciBmb3JtYXRcbiAgdmFyIGZvdXJDQyA9IGhlYWRlcltvZmZfcGZGb3VyQ0NdXG4gIHN3aXRjaCAoZm91ckNDKSB7XG4gICAgY2FzZSBGT1VSQ0NfRFhUMTpcbiAgICAgIGJsb2NrQnl0ZXMgPSA4XG4gICAgICBmb3JtYXQgPSAnZHh0MSdcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBGT1VSQ0NfRFhUMzpcbiAgICAgIGJsb2NrQnl0ZXMgPSAxNlxuICAgICAgZm9ybWF0ID0gJ2R4dDMnXG4gICAgICBicmVha1xuICAgIGNhc2UgRk9VUkNDX0RYVDU6XG4gICAgICBibG9ja0J5dGVzID0gMTZcbiAgICAgIGZvcm1hdCA9ICdkeHQ1J1xuICAgICAgYnJlYWtcbiAgICBjYXNlIEZPVVJDQ19GUDMyRjpcbiAgICAgIGZvcm1hdCA9ICdyZ2JhMzJmJ1xuICAgICAgYnJlYWtcbiAgICBjYXNlIEZPVVJDQ19EWDEwOlxuICAgICAgdmFyIGR4MTBIZWFkZXIgPSBuZXcgVWludDMyQXJyYXkoYXJyYXlCdWZmZXIuc2xpY2UoMTI4LCAxMjggKyAyMCkpXG4gICAgICBmb3JtYXQgPSBkeDEwSGVhZGVyWzBdXG4gICAgICB2YXIgcmVzb3VyY2VEaW1lbnNpb24gPSBkeDEwSGVhZGVyWzFdXG4gICAgICB2YXIgbWlzY0ZsYWcgPSBkeDEwSGVhZGVyWzJdXG4gICAgICB2YXIgYXJyYXlTaXplID0gZHgxMEhlYWRlclszXVxuICAgICAgdmFyIG1pc2NGbGFnczIgPSBkeDEwSGVhZGVyWzRdXG5cbiAgICAgIGlmIChyZXNvdXJjZURpbWVuc2lvbiA9PT0gRDNEMTBfUkVTT1VSQ0VfRElNRU5TSU9OX1RFWFRVUkUyRCAmJiBmb3JtYXQgPT09IERYR0lfRk9STUFUX1IzMkczMkIzMkEzMl9GTE9BVCkge1xuICAgICAgICBmb3JtYXQgPSAncmdiYTMyZidcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgRFgxMCB0ZXh0dXJlIGZvcm1hdCAnICsgZm9ybWF0KVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBGb3VyQ0MgY29kZTogJyArIGludDMyVG9Gb3VyQ0MoZm91ckNDKSlcbiAgfVxuXG4gIHZhciBmbGFncyA9IGhlYWRlcltvZmZfZmxhZ3NdXG4gIHZhciBtaXBtYXBDb3VudCA9IDFcblxuICBpZiAoZmxhZ3MgJiBERFNEX01JUE1BUENPVU5UKSB7XG4gICAgbWlwbWFwQ291bnQgPSBNYXRoLm1heCgxLCBoZWFkZXJbb2ZmX21pcG1hcENvdW50XSlcbiAgfVxuXG4gIHZhciBjdWJlbWFwID0gZmFsc2VcbiAgdmFyIGNhcHMyID0gaGVhZGVyW29mZl9jYXBzMl1cbiAgaWYgKGNhcHMyICYgRERTQ0FQUzJfQ1VCRU1BUCkge1xuICAgIGN1YmVtYXAgPSB0cnVlXG4gIH1cblxuICB2YXIgd2lkdGggPSBoZWFkZXJbb2ZmX3dpZHRoXVxuICB2YXIgaGVpZ2h0ID0gaGVhZGVyW29mZl9oZWlnaHRdXG4gIHZhciBkYXRhT2Zmc2V0ID0gaGVhZGVyW29mZl9zaXplXSArIDRcbiAgdmFyIHRleFdpZHRoID0gd2lkdGhcbiAgdmFyIHRleEhlaWdodCA9IGhlaWdodFxuICB2YXIgaW1hZ2VzID0gW11cbiAgdmFyIGRhdGFMZW5ndGhcblxuICBpZiAoZm91ckNDID09PSBGT1VSQ0NfRFgxMCkge1xuICAgIGRhdGFPZmZzZXQgKz0gMjBcbiAgfVxuXG4gIGlmIChjdWJlbWFwKSB7XG4gICAgZm9yICh2YXIgZiA9IDA7IGYgPCA2OyBmKyspIHtcbiAgICAgIGlmIChmb3JtYXQgIT09ICdyZ2JhMzJmJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgUkdCQTMyZiBjdWJlbWFwcyBhcmUgc3VwcG9ydGVkJylcbiAgICAgIH1cbiAgICAgIHZhciBicHAgPSA0ICogMzIgLyA4XG5cbiAgICAgIHdpZHRoID0gdGV4V2lkdGhcbiAgICAgIGhlaWdodCA9IHRleEhlaWdodFxuXG4gICAgICAvLyBjdWJlbWFwIHNob3VsZCBoYXZlIGFsbCBtaXBtYXAgbGV2ZWxzIGRlZmluZWRcbiAgICAgIC8vIE1hdGgubG9nMih3aWR0aCkgKyAxXG4gICAgICB2YXIgcmVxdWlyZWRNaXBMZXZlbHMgPSBNYXRoLmxvZyh3aWR0aCkgLyBNYXRoLmxvZygyKSArIDFcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXF1aXJlZE1pcExldmVsczsgaSsrKSB7XG4gICAgICAgIGRhdGFMZW5ndGggPSB3aWR0aCAqIGhlaWdodCAqIGJwcFxuICAgICAgICBpbWFnZXMucHVzaCh7XG4gICAgICAgICAgb2Zmc2V0OiBkYXRhT2Zmc2V0LFxuICAgICAgICAgIGxlbmd0aDogZGF0YUxlbmd0aCxcbiAgICAgICAgICBzaGFwZTogWyB3aWR0aCwgaGVpZ2h0IF1cbiAgICAgICAgfSlcbiAgICAgICAgLy8gUmV1c2UgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyBsZXZlbCBpZiB3ZSBhcmUgYmV5b25kIG1pcG1hcENvdW50XG4gICAgICAgIC8vIFRoaXMgaXMgaGFjayBmb3IgQ01GVCBub3QgcHVibGlzaGluZyBmdWxsIG1pcG1hcCBjaGFpbiBodHRwczovL2dpdGh1Yi5jb20vZGFyaW9tYW5lc2t1L2NtZnQvaXNzdWVzLzEwXG4gICAgICAgIGlmIChpIDwgbWlwbWFwQ291bnQpIHtcbiAgICAgICAgICBkYXRhT2Zmc2V0ICs9IGRhdGFMZW5ndGhcbiAgICAgICAgfVxuICAgICAgICB3aWR0aCA9IE1hdGguZmxvb3Iod2lkdGggLyAyKVxuICAgICAgICBoZWlnaHQgPSBNYXRoLmZsb29yKGhlaWdodCAvIDIpXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWlwbWFwQ291bnQ7IGkrKykge1xuICAgICAgZGF0YUxlbmd0aCA9IE1hdGgubWF4KDQsIHdpZHRoKSAvIDQgKiBNYXRoLm1heCg0LCBoZWlnaHQpIC8gNCAqIGJsb2NrQnl0ZXNcblxuICAgICAgaW1hZ2VzLnB1c2goe1xuICAgICAgICBvZmZzZXQ6IGRhdGFPZmZzZXQsXG4gICAgICAgIGxlbmd0aDogZGF0YUxlbmd0aCxcbiAgICAgICAgc2hhcGU6IFsgd2lkdGgsIGhlaWdodCBdXG4gICAgICB9KVxuICAgICAgZGF0YU9mZnNldCArPSBkYXRhTGVuZ3RoXG4gICAgICB3aWR0aCA9IE1hdGguZmxvb3Iod2lkdGggLyAyKVxuICAgICAgaGVpZ2h0ID0gTWF0aC5mbG9vcihoZWlnaHQgLyAyKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc2hhcGU6IFsgdGV4V2lkdGgsIHRleEhlaWdodCBdLFxuICAgIGltYWdlczogaW1hZ2VzLFxuICAgIGZvcm1hdDogZm9ybWF0LFxuICAgIGZsYWdzOiBmbGFncyxcbiAgICBjdWJlbWFwOiBjdWJlbWFwXG4gIH1cbn1cblxuZnVuY3Rpb24gZm91ckNDVG9JbnQzMiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLmNoYXJDb2RlQXQoMCkgK1xuICAgICh2YWx1ZS5jaGFyQ29kZUF0KDEpIDw8IDgpICtcbiAgICAodmFsdWUuY2hhckNvZGVBdCgyKSA8PCAxNikgK1xuICAgICh2YWx1ZS5jaGFyQ29kZUF0KDMpIDw8IDI0KVxufVxuXG5mdW5jdGlvbiBpbnQzMlRvRm91ckNDICh2YWx1ZSkge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICB2YWx1ZSAmIDB4ZmYsXG4gICAgKHZhbHVlID4+IDgpICYgMHhmZixcbiAgICAodmFsdWUgPj4gMTYpICYgMHhmZixcbiAgICAodmFsdWUgPj4gMjQpICYgMHhmZlxuICApXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wYXJzZS1kZHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gQ3ViZUZyYW1lQnVmZmVyLmpzXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEdMIGZyb20gJy4vR0xUb29sJztcbmltcG9ydCBHTEN1YmVUZXh0dXJlIGZyb20gJy4vR0xDdWJlVGV4dHVyZSc7XG5cbmxldCBnbDtcblxuXG5jbGFzcyBDdWJlRnJhbWVCdWZmZXIge1xuXG5cdGNvbnN0cnVjdG9yKHNpemUsIG1QYXJhbWV0ZXJzID0ge30pIHtcblx0XHRnbCA9IEdMLmdsO1xuXHRcdHRoaXMuX3NpemUgPSBzaXplO1xuXHRcdHRoaXMubWFnRmlsdGVyID0gbVBhcmFtZXRlcnMubWFnRmlsdGVyIHx8IGdsLkxJTkVBUjtcblx0XHR0aGlzLm1pbkZpbHRlciA9IG1QYXJhbWV0ZXJzLm1pbkZpbHRlciB8fCBnbC5MSU5FQVI7XG5cdFx0dGhpcy53cmFwUyAgICAgPSBtUGFyYW1ldGVycy53cmFwUyB8fCBnbC5DTEFNUF9UT19FREdFO1xuXHRcdHRoaXMud3JhcFQgICAgID0gbVBhcmFtZXRlcnMud3JhcFQgfHwgZ2wuQ0xBTVBfVE9fRURHRTtcblxuXHRcdHRoaXMuX2luaXQoKTtcblx0fVxuXG5cblx0X2luaXQoKSB7XG5cdFx0dGhpcy50ZXh0dXJlICAgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG5cdFx0dGhpcy5nbFRleHR1cmUgPSBuZXcgR0xDdWJlVGV4dHVyZSh0aGlzLnRleHR1cmUsIHt9LCB0cnVlKTtcblxuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIHRoaXMudGV4dHVyZSk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01BR19GSUxURVIsIHRoaXMubWFnRmlsdGVyKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5taW5GaWx0ZXIpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMud3JhcFMpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMud3JhcFQpO1xuXG5cdFx0Y29uc3QgdGFyZ2V0cyA9IFtcblx0XHRcdGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCwgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YLCBcblx0XHRcdGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWSwgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZLCBcblx0XHRcdGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWiwgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9aIFxuXHRcdF07XG5cblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Z2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuXHRcdFx0Z2wudGV4SW1hZ2UyRCh0YXJnZXRzW2ldLCAwLCBnbC5SR0JBLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG51bGwpO1xuXHRcdH1cblxuXG5cdFx0dGhpcy5fZnJhbWVCdWZmZXJzID0gW107XG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGZyYW1lQnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblx0XHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIpO1xuXHRcdFx0Z2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCB0YXJnZXRzW2ldLCB0aGlzLnRleHR1cmUsIDApO1xuXG5cdFx0XHRjb25zdCBzdGF0dXMgPSBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKTtcblx0XHRcdGlmIChzdGF0dXMgIT09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGAnZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cygpIHJldHVybmVkICcke3N0YXR1c31gKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fZnJhbWVCdWZmZXJzLnB1c2goZnJhbWVCdWZmZXIpO1xuXHRcdH1cblxuXHRcdC8vIGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfQ1VCRV9NQVApO1xuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cdFx0Z2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIG51bGwpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwpO1xuXHR9XG5cblxuXHRiaW5kKG1UYXJnZXRJbmRleCkge1xuXG5cdFx0Ly8gaWYoTWF0aC5yYW5kb20oKSA+IC45OSkgY29uc29sZS5sb2coJ2JpbmQgOicsIG1UYXJnZXRJbmRleCwgdGhpcy5fZnJhbWVCdWZmZXJzW21UYXJnZXRJbmRleF0pO1xuXHRcdEdMLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2ZyYW1lQnVmZmVyc1ttVGFyZ2V0SW5kZXhdKTtcblx0fVxuXG5cdHVuYmluZCgpIHtcblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXHRcdEdMLnZpZXdwb3J0KDAsIDAsIEdMLndpZHRoLCBHTC5oZWlnaHQpO1xuXHR9XG5cblx0Ly9cdFRFWFRVUkVTXG5cblx0Z2V0VGV4dHVyZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5nbFRleHR1cmU7XG5cdH1cblxuXHQvL1x0R0VUVEVSUyBBTkQgU0VUVEVSU1xuXG5cdGdldCB3aWR0aCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZTtcblx0fVxuXG5cdGdldCBoZWlnaHQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NpemU7XG5cdH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBDdWJlRnJhbWVCdWZmZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvQ3ViZUZyYW1lQnVmZmVyLmpzIiwiLy8gTXVsdGlzYW1wbGVGcmFtZUJ1ZmZlci5qc1xuXG5pbXBvcnQgR0wgZnJvbSAnLi9HTFRvb2wnO1xuaW1wb3J0IEdMVGV4dHVyZSBmcm9tICcuL0dMVGV4dHVyZSc7XG5cbmxldCBnbDtcblxuZnVuY3Rpb24gaXNQb3dlck9mVHdvKHgpIHtcdFxuXHRyZXR1cm4gKHggIT09IDApICYmICghKHggJiAoeCAtIDEpKSk7XG59O1xuXG5jbGFzcyBNdWx0aXNhbXBsZUZyYW1lQnVmZmVyIHtcblx0Y29uc3RydWN0b3IobVdpZHRoLCBtSGVpZ2h0LCBtUGFyYW1ldGVycyA9IHt9KSB7XG5cdFx0Z2wgPSBHTC5nbDtcblxuXHRcdHRoaXMud2lkdGggICAgICAgICAgICA9IG1XaWR0aDtcblx0XHR0aGlzLmhlaWdodCAgICAgICAgICAgPSBtSGVpZ2h0O1xuXG5cdFx0dGhpcy5tYWdGaWx0ZXIgID0gbVBhcmFtZXRlcnMubWFnRmlsdGVyIFx0fHwgZ2wuTElORUFSO1xuXHRcdHRoaXMubWluRmlsdGVyICA9IG1QYXJhbWV0ZXJzLm1pbkZpbHRlciBcdHx8IGdsLkxJTkVBUjtcblx0XHR0aGlzLndyYXBTICAgICAgPSBtUGFyYW1ldGVycy53cmFwUyBcdFx0fHwgZ2wuQ0xBTVBfVE9fRURHRTtcblx0XHR0aGlzLndyYXBUICAgICAgPSBtUGFyYW1ldGVycy53cmFwVCBcdFx0fHwgZ2wuQ0xBTVBfVE9fRURHRTtcblx0XHR0aGlzLnVzZURlcHRoICAgPSBtUGFyYW1ldGVycy51c2VEZXB0aCBcdFx0fHwgdHJ1ZTtcblx0XHR0aGlzLnVzZVN0ZW5jaWwgPSBtUGFyYW1ldGVycy51c2VTdGVuY2lsIFx0fHwgZmFsc2U7XG5cdFx0dGhpcy50ZXhlbFR5cGUgXHQ9IG1QYXJhbWV0ZXJzLnR5cGU7XG5cdFx0dGhpcy5fbnVtU2FtcGxlID0gbVBhcmFtZXRlcnMubnVtU2FtcGxlIFx0fHwgODtcblxuXHRcdGlmKCFpc1Bvd2VyT2ZUd28odGhpcy53aWR0aCkgfHwgIWlzUG93ZXJPZlR3byh0aGlzLmhlaWdodCkpIHtcblx0XHRcdHRoaXMud3JhcFMgPSB0aGlzLndyYXBUID0gZ2wuQ0xBTVBfVE9fRURHRTtcblxuXHRcdFx0aWYodGhpcy5taW5GaWx0ZXIgPT09IGdsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVCkge1xuXHRcdFx0XHR0aGlzLm1pbkZpbHRlciA9IGdsLkxJTkVBUjtcblx0XHRcdH1cblx0XHR9IFxuXG5cdFx0dGhpcy5faW5pdCgpO1xuXHR9XG5cblx0X2luaXQoKSB7XG5cdFx0bGV0IHRleGVsVHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0aWYgKHRoaXMudGV4ZWxUeXBlKSB7XG5cdFx0XHR0ZXhlbFR5cGUgPSB0aGlzLnRleGVsVHlwZTtcblx0XHR9XG5cblx0XHR0aGlzLnRleGVsVHlwZSA9IHRleGVsVHlwZTtcblxuXHRcdHRoaXMuZnJhbWVCdWZmZXIgICAgICAgID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcdFxuXHRcdHRoaXMuZnJhbWVCdWZmZXJDb2xvciAgID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcdFxuXHRcdHRoaXMucmVuZGVyQnVmZmVyQ29sb3IgID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cdFx0dGhpcy5yZW5kZXJCdWZmZXJEZXB0aCAgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcblx0XHR0aGlzLmdsVGV4dHVyZSBcdFx0XHQ9IHRoaXMuX2NyZWF0ZVRleHR1cmUoKTtcblx0XHR0aGlzLmdsRGVwdGhUZXh0dXJlIFx0PSB0aGlzLl9jcmVhdGVUZXh0dXJlKGdsLkRFUFRIX0NPTVBPTkVOVDE2LCBnbC5VTlNJR05FRF9TSE9SVCwgZ2wuREVQVEhfQ09NUE9ORU5ULCB0cnVlKTtcblxuXHRcdGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCB0aGlzLnJlbmRlckJ1ZmZlckNvbG9yKTtcblx0XHRnbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoZ2wuUkVOREVSQlVGRkVSLCB0aGlzLl9udW1TYW1wbGUsIGdsLlJHQkE4LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cblx0XHRnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5yZW5kZXJCdWZmZXJEZXB0aCk7XG5cdFx0Z2wucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5fbnVtU2FtcGxlLCBnbC5ERVBUSF9DT01QT05FTlQxNiwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lQnVmZmVyKTtcblx0XHRnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5yZW5kZXJCdWZmZXJDb2xvcik7XG5cdFx0Z2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5yZW5kZXJCdWZmZXJEZXB0aCk7XG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblxuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZUJ1ZmZlckNvbG9yKTtcblx0XHRnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRoaXMuZ2xUZXh0dXJlLnRleHR1cmUsIDApO1xuXHRcdC8vIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9BVFRBQ0hNRU5ULCBnbC5URVhUVVJFXzJELCB0aGlzLmdsRGVwdGhUZXh0dXJlLnRleHR1cmUsIDApO1xuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cblx0XHQvLyBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVCdWZmZXJEZXB0aCk7XG5cdFx0Ly8gZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlRFWFRVUkVfMkQsIHRoaXMuZ2xEZXB0aFRleHR1cmUudGV4dHVyZSwgMCk7XG5cdFx0Ly8gZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblx0fVxuXG5cdF9jcmVhdGVUZXh0dXJlKG1JbnRlcm5hbGZvcm1hdCwgbVRleGVsVHlwZSwgbUZvcm1hdCwgZm9yY2VOZWFyZXN0ID0gZmFsc2UpIHtcblx0XHRpZihtSW50ZXJuYWxmb3JtYXQgPT09IHVuZGVmaW5lZCkge1x0bUludGVybmFsZm9ybWF0ID0gZ2wuUkdCQTtcdH1cblx0XHRpZihtVGV4ZWxUeXBlID09PSB1bmRlZmluZWQpIHtcdG1UZXhlbFR5cGUgPSB0aGlzLnRleGVsVHlwZTtcdH1cblx0XHRpZighbUZvcm1hdCkge1x0bUZvcm1hdCA9IG1JbnRlcm5hbGZvcm1hdDsgfVxuXG5cdFx0Y29uc3QgdCA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblx0XHRjb25zdCBnbHQgPSBuZXcgR0xUZXh0dXJlKHQsIHRydWUpO1xuXHRcdGNvbnN0IG1hZ0ZpbHRlciA9IGZvcmNlTmVhcmVzdCA/IEdMLk5FQVJFU1QgOiB0aGlzLm1hZ0ZpbHRlcjtcblx0XHRjb25zdCBtaW5GaWx0ZXIgPSBmb3JjZU5lYXJlc3QgPyBHTC5ORUFSRVNUIDogdGhpcy5taW5GaWx0ZXI7XG5cblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0KTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgbWFnRmlsdGVyKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgbWluRmlsdGVyKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLndyYXBTKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLndyYXBUKTtcblx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIG1JbnRlcm5hbGZvcm1hdCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIDAsIG1Gb3JtYXQsIG1UZXhlbFR5cGUsIG51bGwpO1x0XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cblx0XHRyZXR1cm4gZ2x0O1xuXHR9XG5cblxuXHRiaW5kKG1BdXRvU2V0Vmlld3BvcnQ9dHJ1ZSkge1xuXHRcdGlmKG1BdXRvU2V0Vmlld3BvcnQpIHtcblx0XHRcdEdMLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcdFxuXHRcdH1cblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVCdWZmZXIpO1xuXHR9XG5cblxuXHR1bmJpbmQobUF1dG9TZXRWaWV3cG9ydD10cnVlKSB7XG5cdFx0aWYobUF1dG9TZXRWaWV3cG9ydCkge1xuXHRcdFx0R0wudmlld3BvcnQoMCwgMCwgR0wud2lkdGgsIEdMLmhlaWdodCk7XHRcblx0XHR9XG5cblx0XHRjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXM7XG5cblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLlJFQURfRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVCdWZmZXIpO1xuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5EUkFXX0ZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lQnVmZmVyQ29sb3IpO1xuXHRcdGdsLmNsZWFyQnVmZmVyZnYoZ2wuQ09MT1IsIDAsIFswLjAsIDAuMCwgMC4wLCAwLjBdKTtcblx0XHRnbC5ibGl0RnJhbWVidWZmZXIoXG5cdFx0XHQwLCAwLCB3aWR0aCwgaGVpZ2h0LFxuXHRcdFx0MCwgMCwgd2lkdGgsIGhlaWdodCxcblx0XHRcdGdsLkNPTE9SX0JVRkZFUl9CSVQsIEdMLk5FQVJFU1Rcblx0XHQpO1xuXHRcdC8vIGdsLmJsaXRGcmFtZWJ1ZmZlcihcblx0XHQvLyBcdDAsIDAsIHdpZHRoLCBoZWlnaHQsXG5cdFx0Ly8gXHQwLCAwLCB3aWR0aCwgaGVpZ2h0LFxuXHRcdC8vIFx0Z2wuQ09MT1JfQlVGRkVSX0JJVHxnbC5ERVBUSF9TVEVOQ0lMLCBHTC5ORUFSRVNUXG5cdFx0Ly8gKTtcblxuXHRcdC8vIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5SRUFEX0ZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lQnVmZmVyKTtcblx0XHQvLyBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRFJBV19GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZUJ1ZmZlckRlcHRoKTtcblx0XHQvLyBnbC5jbGVhckJ1ZmZlcmZpKGdsLkRFUFRIX1NURU5DSUwsIDAsIDEuMCwgMCk7XG5cdFx0Ly8gZ2wuYmxpdEZyYW1lYnVmZmVyKFxuXHRcdC8vIFx0MCwgMCwgd2lkdGgsIGhlaWdodCxcblx0XHQvLyBcdDAsIDAsIHdpZHRoLCBoZWlnaHQsXG5cdFx0Ly8gXHRnbC5ERVBUSF9CVUZGRVJfQklULCBnbC5ORUFSRVNUXG5cdFx0Ly8gKTtcblxuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cdH1cblxuXG5cdGdldFRleHR1cmUobUluZGV4ID0gMCkge1xuXHRcdHJldHVybiB0aGlzLmdsVGV4dHVyZTtcblx0fVxuXG5cblx0Z2V0RGVwdGhUZXh0dXJlKCkge1xuXHRcdHJldHVybiB0aGlzLmdsRGVwdGhUZXh0dXJlO1xuXHR9XG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBNdWx0aXNhbXBsZUZyYW1lQnVmZmVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL011bHRpc2FtcGxlRnJhbWVCdWZmZXIuanMiLCIvLyBUcmFuc2Zvcm1GZWVkYmFja09iamVjdC5qc1xuXG5pbXBvcnQgR0wgZnJvbSAnLi9HTFRvb2wnO1xuaW1wb3J0IEdMU2hhZGVyIGZyb20gJy4vR0xTaGFkZXInO1xuaW1wb3J0IE1lc2ggZnJvbSAnLi9NZXNoJztcblxubGV0IGdsO1xuXG5jbGFzcyBUcmFuc2Zvcm1GZWVkYmFja09iamVjdCB7XG5cblxuXHRjb25zdHJ1Y3RvcihzdHJWZXJ0ZXhTaGFkZXIsIHN0ckZyYWdtZW50U2hhZGVyKSB7XG5cdFx0Z2wgPSBHTC5nbDtcblx0XHR0aGlzLl92cyA9IHN0clZlcnRleFNoYWRlcjtcblx0XHR0aGlzLl9mcyA9IHN0ckZyYWdtZW50U2hhZGVyO1xuXHRcdFxuXHRcdHRoaXMuX2luaXQoKTtcblx0fVxuXG5cblx0X2luaXQoKSB7XG5cdFx0dGhpcy5fbWVzaEN1cnJlbnQgPSBuZXcgTWVzaCgpO1xuXHRcdHRoaXMuX21lc2hUYXJnZXQgPSBuZXcgTWVzaCgpO1xuXHRcdHRoaXMuX251bVBvaW50cyA9IC0xO1xuXG5cdFx0dGhpcy5fdmFyeWluZ3MgPSBbXTtcblx0XHR0aGlzLnRyYW5zZm9ybUZlZWRiYWNrID0gZ2wuY3JlYXRlVHJhbnNmb3JtRmVlZGJhY2soKTtcblx0fVxuXG5cblx0YnVmZmVyRGF0YShtRGF0YSwgbU5hbWUsIG1WYXJ5aW5nTmFtZSkge1xuXHRcdGNvbnN0IGlzVHJhbnNmb3JtRmVlZGJhY2sgPSAhIW1WYXJ5aW5nTmFtZTtcblx0XHRjb25zb2xlLmxvZygnaXMgVHJhbnNmb3JtIGZlZWRiYWNrID8nLCBtTmFtZSwgaXNUcmFuc2Zvcm1GZWVkYmFjayk7XG5cdFx0dGhpcy5fbWVzaEN1cnJlbnQuYnVmZmVyRGF0YShtRGF0YSwgbU5hbWUsIG51bGwsIGdsLlNUUkVBTV9DT1BZLCBmYWxzZSk7XG5cdFx0dGhpcy5fbWVzaFRhcmdldC5idWZmZXJEYXRhKG1EYXRhLCBtTmFtZSwgbnVsbCwgZ2wuU1RSRUFNX0NPUFksIGZhbHNlKTtcblxuXHRcdGlmKGlzVHJhbnNmb3JtRmVlZGJhY2spIHtcblx0XHRcdHRoaXMuX3ZhcnlpbmdzLnB1c2gobVZhcnlpbmdOYW1lKTtcblxuXHRcdFx0aWYodGhpcy5fbnVtUG9pbnRzIDwgMCkge1xuXHRcdFx0XHR0aGlzLl9udW1Qb2ludHMgPSBtRGF0YS5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0YnVmZmVySW5kZXgobUFycmF5SW5kaWNlcykge1xuXHRcdHRoaXMuX21lc2hDdXJyZW50LmJ1ZmZlckluZGV4KG1BcnJheUluZGljZXMpO1xuXHRcdHRoaXMuX21lc2hUYXJnZXQuYnVmZmVySW5kZXgobUFycmF5SW5kaWNlcyk7XG5cdH1cblxuXG5cdHVuaWZvcm0obU5hbWUsIG1UeXBlLCBtVmFsdWUpIHtcblx0XHRpZih0aGlzLnNoYWRlcikge1xuXHRcdFx0dGhpcy5zaGFkZXIudW5pZm9ybShtTmFtZSwgbVR5cGUsIG1WYWx1ZSk7XHRcblx0XHR9XG5cdFx0XG5cdH1cblxuXHRnZW5lcmF0ZSgpIHtcblx0XHR0aGlzLnNoYWRlciA9IG5ldyBHTFNoYWRlcih0aGlzLl92cywgdGhpcy5fZnMsIHRoaXMuX3ZhcnlpbmdzKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRpZighdGhpcy5zaGFkZXIpIHtcdHRoaXMuZ2VuZXJhdGUoKTtcdH1cblxuXHRcdHRoaXMuc2hhZGVyLmJpbmQoKTtcblx0XHRHTC5kcmF3VHJhbnNmb3JtRmVlZGJhY2sodGhpcyk7XG5cblx0XHR0aGlzLl9zd2FwKCk7XG5cdH1cblxuXHRfc3dhcCgpIHtcblx0XHRjb25zdCB0bXAgICAgICAgICAgPSB0aGlzLl9tZXNoQ3VycmVudDtcblx0XHR0aGlzLl9tZXNoQ3VycmVudCA9IHRoaXMuX21lc2hUYXJnZXQ7XG5cdFx0dGhpcy5fbWVzaFRhcmdldCAgPSB0bXA7XG5cdH1cblxuXHRnZXQgbnVtUG9pbnRzKCkge1x0cmV0dXJuIHRoaXMuX251bVBvaW50cztcdH1cblx0Z2V0IG1lc2hDdXJyZW50KCkge1x0cmV0dXJuIHRoaXMuX21lc2hDdXJyZW50O1x0fVxuXHRnZXQgbWVzaFRhcmdldCgpIHtcdHJldHVybiB0aGlzLl9tZXNoVGFyZ2V0O1x0fVxuXHRnZXQgbWVzaFNvdXJjZSgpIHtcdHJldHVybiB0aGlzLl9tZXNoQ3VycmVudDtcdH1cblx0Z2V0IG1lc2hEZXN0aW5hdGlvbigpIHtcdHJldHVybiB0aGlzLl9tZXNoVGFyZ2V0O1x0fVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IFRyYW5zZm9ybUZlZWRiYWNrT2JqZWN0O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL1RyYW5zZm9ybUZlZWRiYWNrT2JqZWN0LmpzIiwiLy8gVHdlZW5OdW1iZXIuanNcblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgU2NoZWR1bGVyIGZyb20gJ3NjaGVkdWxpbmcnO1xuXG5jb25zdCBFYXNpbmcgPSB7XG5cdExpbmVhcjoge1xuXHRcdE5vbmUoaykge1xuXHRcdFx0cmV0dXJuIGs7XG5cdFx0fVxuXHR9LFxuXHRRdWFkcmF0aWM6IHtcblx0XHRJbihrKSB7XG5cdFx0XHRyZXR1cm4gayAqIGs7XG5cdFx0fSxcblx0XHRPdXQoaykge1xuXHRcdFx0cmV0dXJuIGsgKiAoMiAtIGspO1xuXHRcdH0sXG5cdFx0SW5PdXQoaykge1xuXHRcdFx0aWYgKChrICo9IDIpIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gMC41ICogayAqIGs7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gLSAwLjUgKiAoLS1rICogKGsgLSAyKSAtIDEpO1xuXHRcdH1cblx0fSxcblx0Q3ViaWM6IHtcblx0XHRJbihrKSB7XG5cdFx0XHRyZXR1cm4gayAqIGsgKiBrO1xuXHRcdH0sXG5cdFx0T3V0KGspIHtcblx0XHRcdHJldHVybiAtLWsgKiBrICogayArIDE7XG5cdFx0fSxcblx0XHRJbk91dChrKSB7XG5cdFx0XHRpZiAoKGsgKj0gMikgPCAxKSB7XG5cdFx0XHRcdHJldHVybiAwLjUgKiBrICogayAqIGs7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKyAyKTtcblx0XHR9XG5cdH0sXG5cdFF1YXJ0aWM6IHtcblx0XHRJbihrKSB7XG5cdFx0XHRyZXR1cm4gayAqIGsgKiBrICogaztcblx0XHR9LFxuXHRcdE91dChrKSB7XG5cdFx0XHRyZXR1cm4gMSAtICgtLWsgKiBrICogayAqIGspO1xuXHRcdH0sXG5cdFx0SW5PdXQoaykge1xuXHRcdFx0aWYgKChrICo9IDIpIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gMC41ICogayAqIGsgKiBrICogaztcblx0XHRcdH1cblx0XHRcdHJldHVybiAtIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICogayAtIDIpO1xuXHRcdH1cblx0fSxcblx0UXVpbnRpYzoge1xuXHRcdEluKGspIHtcblx0XHRcdHJldHVybiBrICogayAqIGsgKiBrICogaztcblx0XHR9LFxuXHRcdE91dChrKSB7XG5cdFx0XHRyZXR1cm4gLS1rICogayAqIGsgKiBrICogayArIDE7XG5cdFx0fSxcblx0XHRJbk91dChrKSB7XG5cdFx0XHRpZiAoKGsgKj0gMikgPCAxKSB7XG5cdFx0XHRcdHJldHVybiAwLjUgKiBrICogayAqIGsgKiBrICogaztcblx0XHRcdH1cblx0XHRcdHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgKiBrICsgMik7XG5cdFx0fVxuXHR9LFxuXHRTaW51c29pZGFsOiB7XG5cdFx0SW4oaykge1xuXHRcdFx0cmV0dXJuIDEgLSBNYXRoLmNvcyhrICogTWF0aC5QSSAvIDIpO1xuXHRcdH0sXG5cdFx0T3V0KGspIHtcblx0XHRcdHJldHVybiBNYXRoLnNpbihrICogTWF0aC5QSSAvIDIpO1xuXHRcdH0sXG5cdFx0SW5PdXQoaykge1xuXHRcdFx0cmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGspKTtcblx0XHR9XG5cdH0sXG5cdEV4cG9uZW50aWFsOiB7XG5cdFx0SW4oaykge1xuXHRcdFx0cmV0dXJuIGsgPT09IDAgPyAwIDogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xuXHRcdH0sXG5cdFx0T3V0KGspIHtcblx0XHRcdHJldHVybiBrID09PSAxID8gMSA6IDEgLSBNYXRoLnBvdygyLCAtIDEwICogayk7XG5cdFx0fSxcblx0XHRJbk91dChrKSB7XG5cdFx0XHRpZiAoayA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH1cblx0XHRcdGlmIChrID09PSAxKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXHRcdFx0aWYgKChrICo9IDIpIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gMC41ICogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIDAuNSAqICgtIE1hdGgucG93KDIsIC0gMTAgKiAoayAtIDEpKSArIDIpO1xuXHRcdH1cblx0fSxcblx0Q2lyY3VsYXI6IHtcblx0XHRJbihrKSB7XG5cdFx0XHRyZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gayAqIGspO1xuXHRcdH0sXG5cdFx0T3V0KGspIHtcblx0XHRcdHJldHVybiBNYXRoLnNxcnQoMSAtICgtLWsgKiBrKSk7XG5cdFx0fSxcblx0XHRJbk91dChrKSB7XG5cdFx0XHRpZiAoKGsgKj0gMikgPCAxKSB7XG5cdFx0XHRcdHJldHVybiAtIDAuNSAqIChNYXRoLnNxcnQoMSAtIGsgKiBrKSAtIDEpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtIChrIC09IDIpICogaykgKyAxKTtcblx0XHR9XG5cdH0sXG5cdEVsYXN0aWM6IHtcblx0XHRJbihrKSB7XG5cdFx0XHRsZXQgcztcblx0XHRcdGxldCBhID0gMC4xO1xuXHRcdFx0Y29uc3QgcCA9IDAuNDtcblx0XHRcdGlmIChrID09PSAwKSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGsgPT09IDEpIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWEgfHwgYSA8IDEpIHtcblx0XHRcdFx0YSA9IDE7XG5cdFx0XHRcdHMgPSBwIC8gNDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHMgPSBwICogTWF0aC5hc2luKDEgLyBhKSAvICgyICogTWF0aC5QSSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gLSAoYSAqIE1hdGgucG93KDIsIDEwICogKGsgLT0gMSkpICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG5cdFx0fSxcblx0XHRPdXQoaykge1xuXHRcdFx0bGV0IHM7XG5cdFx0XHRsZXQgYSA9IDAuMTtcblx0XHRcdGNvbnN0IHAgPSAwLjQ7XG5cdFx0XHRpZiAoayA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH1cblx0XHRcdGlmIChrID09PSAxKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFhIHx8IGEgPCAxKSB7XG5cdFx0XHRcdGEgPSAxO1xuXHRcdFx0XHRzID0gcCAvIDQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIChhICogTWF0aC5wb3coMiwgLSAxMCAqIGspICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSArIDEpO1xuXHRcdH0sXG5cdFx0SW5PdXQoaykge1xuXHRcdFx0bGV0IHM7XG5cdFx0XHRsZXQgYSA9IDAuMTtcblx0XHRcdGNvbnN0IHAgPSAwLjQ7XG5cdFx0XHRpZiAoayA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH1cblx0XHRcdGlmIChrID09PSAxKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFhIHx8IGEgPCAxKSB7XG5cdFx0XHRcdGEgPSAxO1xuXHRcdFx0XHRzID0gcCAvIDQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKChrICo9IDIpIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gLSAwLjUgKiAoYSAqIE1hdGgucG93KDIsIDEwICogKGsgLT0gMSkpICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqIChrIC09IDEpKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKiAwLjUgKyAxO1xuXHRcdH1cblx0fSxcblx0QmFjazoge1xuXHRcdEluKGspIHtcblx0XHRcdGNvbnN0IHMgPSAxLjcwMTU4O1xuXHRcdFx0cmV0dXJuIGsgKiBrICogKChzICsgMSkgKiBrIC0gcyk7XG5cdFx0fSxcblx0XHRPdXQoaykge1xuXHRcdFx0Y29uc3QgcyA9IDEuNzAxNTg7XG5cdFx0XHRyZXR1cm4gLS1rICogayAqICgocyArIDEpICogayArIHMpICsgMTtcblx0XHR9LFxuXHRcdEluT3V0KGspIHtcblx0XHRcdGNvbnN0IHMgPSAxLjcwMTU4ICogMS41MjU7XG5cdFx0XHRpZiAoKGsgKj0gMikgPCAxKSB7XG5cdFx0XHRcdHJldHVybiAwLjUgKiAoayAqIGsgKiAoKHMgKyAxKSAqIGsgLSBzKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gMC41ICogKChrIC09IDIpICogayAqICgocyArIDEpICogayArIHMpICsgMik7XG5cdFx0fVxuXHR9LFxuXHRCb3VuY2U6IHtcblx0XHRpbihrKSB7XG5cdFx0XHRyZXR1cm4gMSAtIEVhc2luZy5Cb3VuY2Uub3V0KDEgLSBrKTtcblx0XHR9LFxuXHRcdG91dChrKSB7XG5cdFx0XHRpZiAoayA8ICgxIC8gMi43NSkpIHtcblx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIGsgKiBrO1xuXHRcdFx0fSBlbHNlIGlmIChrIDwgKDIgLyAyLjc1KSkge1xuXHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKGsgLT0gKDEuNSAvIDIuNzUpKSAqIGsgKyAwLjc1O1xuXHRcdFx0fSBlbHNlIGlmIChrIDwgKDIuNSAvIDIuNzUpKSB7XG5cdFx0XHRcdHJldHVybiA3LjU2MjUgKiAoayAtPSAoMi4yNSAvIDIuNzUpKSAqIGsgKyAwLjkzNzU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKGsgLT0gKDIuNjI1IC8gMi43NSkpICogayArIDAuOTg0Mzc1O1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0aW5PdXQoaykge1xuXHRcdFx0aWYgKGsgPCAwLjUpIHtcblx0XHRcdFx0cmV0dXJuIEVhc2luZy5Cb3VuY2UuaW4oayAqIDIpICogMC41O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIEVhc2luZy5Cb3VuY2Uub3V0KGsgKiAyIC0gMSkgKiAwLjUgKyAwLjU7XG5cdFx0fVxuXHR9XG59O1xuXG5mdW5jdGlvbiBnZXRGdW5jKG1FYXNpbmcpIHtcblx0c3dpdGNoIChtRWFzaW5nKSB7XG5cdGRlZmF1bHQ6XG5cdGNhc2UgJ2xpbmVhcicgOlxuXHRcdHJldHVybiBFYXNpbmcuTGluZWFyLk5vbmU7XG5cdGNhc2UgJ2V4cEluJyA6XG5cdFx0cmV0dXJuIEVhc2luZy5FeHBvbmVudGlhbC5Jbjtcblx0Y2FzZSAnZXhwT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5FeHBvbmVudGlhbC5PdXQ7XG5cdGNhc2UgJ2V4cEluT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5FeHBvbmVudGlhbC5Jbk91dDtcblxuXHRjYXNlICdjdWJpY0luJyA6XG5cdFx0cmV0dXJuIEVhc2luZy5DdWJpYy5Jbjtcblx0Y2FzZSAnY3ViaWNPdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLkN1YmljLk91dDtcblx0Y2FzZSAnY3ViaWNJbk91dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuQ3ViaWMuSW5PdXQ7XG5cblx0Y2FzZSAncXVhcnRpY0luJyA6XG5cdFx0cmV0dXJuIEVhc2luZy5RdWFydGljLkluO1xuXHRjYXNlICdxdWFydGljT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5RdWFydGljLk91dDtcblx0Y2FzZSAncXVhcnRpY0luT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5RdWFydGljLkluT3V0O1xuXG5cdGNhc2UgJ3F1aW50aWNJbicgOlxuXHRcdHJldHVybiBFYXNpbmcuUXVpbnRpYy5Jbjtcblx0Y2FzZSAncXVpbnRpY091dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuUXVpbnRpYy5PdXQ7XG5cdGNhc2UgJ3F1aW50aWNJbk91dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuUXVpbnRpYy5Jbk91dDtcblxuXHRjYXNlICdzaW51c29pZGFsSW4nIDpcblx0XHRyZXR1cm4gRWFzaW5nLlNpbnVzb2lkYWwuSW47XG5cdGNhc2UgJ3NpbnVzb2lkYWxPdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLlNpbnVzb2lkYWwuT3V0O1xuXHRjYXNlICdzaW51c29pZGFsSW5PdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLlNpbnVzb2lkYWwuSW5PdXQ7XG5cblx0Y2FzZSAnY2lyY3VsYXJJbicgOlxuXHRcdHJldHVybiBFYXNpbmcuQ2lyY3VsYXIuSW47XG5cdGNhc2UgJ2NpcmN1bGFyT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5DaXJjdWxhci5PdXQ7XG5cdGNhc2UgJ2NpcmN1bGFySW5PdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLkNpcmN1bGFyLkluT3V0O1xuXG5cdGNhc2UgJ2VsYXN0aWNJbicgOlxuXHRcdHJldHVybiBFYXNpbmcuRWxhc3RpYy5Jbjtcblx0Y2FzZSAnZWxhc3RpY091dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuRWxhc3RpYy5PdXQ7XG5cdGNhc2UgJ2VsYXN0aWNJbk91dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuRWxhc3RpYy5Jbk91dDtcblxuXHRjYXNlICdiYWNrSW4nIDpcblx0XHRyZXR1cm4gRWFzaW5nLkJhY2suSW47XG5cdGNhc2UgJ2JhY2tPdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLkJhY2suT3V0O1xuXHRjYXNlICdiYWNrSW5PdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLkJhY2suSW5PdXQ7XG5cblx0Y2FzZSAnYm91bmNlSW4nIDpcblx0XHRyZXR1cm4gRWFzaW5nLkJvdW5jZS5pbjtcblx0Y2FzZSAnYm91bmNlT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5Cb3VuY2Uub3V0O1xuXHRjYXNlICdib3VuY2VJbk91dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuQm91bmNlLmluT3V0O1xuXHR9XG59XG5cbmNsYXNzIFR3ZWVuTnVtYmVyIHtcblx0Y29uc3RydWN0b3IobVZhbHVlLCBtRWFzaW5nID0gJ2V4cE91dCcsIG1TcGVlZCA9IDAuMDEpIHtcblx0XHR0aGlzLl92YWx1ZSA9IG1WYWx1ZTtcblx0XHR0aGlzLl9zdGFydFZhbHVlID0gbVZhbHVlO1xuXHRcdHRoaXMuX3RhcmdldFZhbHVlID0gbVZhbHVlO1xuXHRcdHRoaXMuX2NvdW50ZXIgPSAxO1xuXHRcdHRoaXMuc3BlZWQgPSBtU3BlZWQ7XG5cdFx0dGhpcy5lYXNpbmcgPSBtRWFzaW5nO1xuXHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXG5cdFx0dGhpcy5fZWZJbmRleCAgICAgPSBTY2hlZHVsZXIuYWRkRUYoKCk9PiB0aGlzLl91cGRhdGUoKSk7XG5cdH1cblxuXG5cdF91cGRhdGUoKSB7XG5cdFx0bGV0IG5ld0NvdW50ZXIgPSB0aGlzLl9jb3VudGVyICsgdGhpcy5zcGVlZDtcblx0XHRpZihuZXdDb3VudGVyID4gMSkgeyBuZXdDb3VudGVyID0gMTsgfVxuXHRcdGlmKHRoaXMuX2NvdW50ZXIgPT09IG5ld0NvdW50ZXIpIHtcblx0XHRcdHRoaXMuX25lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9jb3VudGVyID0gbmV3Q291bnRlcjtcblx0XHR0aGlzLl9uZWVkVXBkYXRlID0gdHJ1ZTtcblx0fVxuXG5cblx0bGltaXQobU1pbiwgbU1heCkge1xuXHRcdGlmKG1NaW4gPiBtTWF4KSB7XG5cdFx0XHR0aGlzLmxpbWl0KG1NYXgsIG1NaW4pO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX21pbiA9IG1NaW47XG5cdFx0dGhpcy5fbWF4ID0gbU1heDtcblxuXHRcdHRoaXMuX2NoZWNrTGltaXQoKTtcblx0fVxuXG5cdHNldFRvKG1WYWx1ZSkge1xuXHRcdHRoaXMuX3ZhbHVlID0gbVZhbHVlO1xuXHRcdHRoaXMuX3RhcmdldFZhbHVlID0gbVZhbHVlO1xuXHRcdHRoaXMuX2NvdW50ZXIgPSAxO1xuXHR9XG5cblxuXHRfY2hlY2tMaW1pdCgpIHtcblx0XHRpZih0aGlzLl9taW4gIT09IHVuZGVmaW5lZCAmJiB0aGlzLl90YXJnZXRWYWx1ZSA8IHRoaXMuX21pbikge1xuXHRcdFx0dGhpcy5fdGFyZ2V0VmFsdWUgPSB0aGlzLl9taW47XG5cdFx0fSBcblxuXHRcdGlmKHRoaXMuX21heCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX3RhcmdldFZhbHVlID4gdGhpcy5fbWF4KSB7XG5cdFx0XHR0aGlzLl90YXJnZXRWYWx1ZSA9IHRoaXMuX21heDtcblx0XHR9IFxuXHR9XG5cblxuXHRkZXN0cm95KCkge1xuXHRcdFNjaGVkdWxlci5yZW1vdmVFRih0aGlzLl9lZkluZGV4KTtcblx0fVxuXG5cdC8vXHRHRVRURVJTIC8gU0VUVEVSU1xuXG5cdHNldCB2YWx1ZShtVmFsdWUpIHtcblx0XHR0aGlzLl9zdGFydFZhbHVlID0gdGhpcy5fdmFsdWU7XG5cdFx0dGhpcy5fdGFyZ2V0VmFsdWUgPSBtVmFsdWU7XG5cdFx0dGhpcy5fY2hlY2tMaW1pdCgpO1xuXHRcdHRoaXMuX2NvdW50ZXIgPSAwO1xuXHR9XG5cblx0Z2V0IHZhbHVlKCkge1xuXHRcdGlmKHRoaXMuX25lZWRVcGRhdGUpIHtcblx0XHRcdGNvbnN0IGYgPSBnZXRGdW5jKHRoaXMuZWFzaW5nKTtcblx0XHRcdGNvbnN0IHAgPSBmKHRoaXMuX2NvdW50ZXIpO1xuXHRcdFx0dGhpcy5fdmFsdWUgPSB0aGlzLl9zdGFydFZhbHVlICsgcCAqICh0aGlzLl90YXJnZXRWYWx1ZSAtIHRoaXMuX3N0YXJ0VmFsdWUpO1xuXHRcdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fdmFsdWU7XG5cdH1cblxuXHRnZXQgdGFyZ2V0VmFsdWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RhcmdldFZhbHVlO1xuXHR9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgVHdlZW5OdW1iZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvVHdlZW5OdW1iZXIuanMiLCIvLyBRdWF0Um90YXRpb24uanNcblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgZ2xtIGZyb20gJ2dsLW1hdHJpeCc7XG5pbXBvcnQgRWFzZU51bWJlciBmcm9tICcuL0Vhc2VOdW1iZXInO1xuaW1wb3J0IFNjaGVkdWxlciBmcm9tICdzY2hlZHVsaW5nJztcblxuY29uc3QgZ2V0TW91c2UgPSBmdW5jdGlvbiAobUV2ZW50LCBtVGFyZ2V0KSB7XG5cblx0Y29uc3QgbyA9IG1UYXJnZXQgfHwge307XG5cdGlmKG1FdmVudC50b3VjaGVzKSB7XG5cdFx0by54ID0gbUV2ZW50LnRvdWNoZXNbMF0ucGFnZVg7XG5cdFx0by55ID0gbUV2ZW50LnRvdWNoZXNbMF0ucGFnZVk7XG5cdH0gZWxzZSB7XG5cdFx0by54ID0gbUV2ZW50LmNsaWVudFg7XG5cdFx0by55ID0gbUV2ZW50LmNsaWVudFk7XG5cdH1cblxuXHRyZXR1cm4gbztcbn07XG5cbmNsYXNzIFF1YXRSb3RhdGlvbiB7XG5cdGNvbnN0cnVjdG9yKG1UYXJnZXQsIG1MaXN0ZW5lclRhcmdldCA9IHdpbmRvdywgbUVhc2luZyA9IDAuMSkge1xuXG5cdFx0dGhpcy5fdGFyZ2V0ICAgICAgICAgPSBtVGFyZ2V0O1xuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0ID0gbUxpc3RlbmVyVGFyZ2V0O1xuXHRcdFxuXHRcdHRoaXMubWF0cml4ICAgICAgICAgID0gZ2xtLm1hdDQuY3JlYXRlKCk7XG5cdFx0dGhpcy5tICAgICAgICAgICAgICAgPSBnbG0ubWF0NC5jcmVhdGUoKTtcblx0XHR0aGlzLl92WmF4aXMgICAgICAgICA9IGdsbS52ZWMzLmNsb25lKFswLCAwLCAwXSk7XG5cdFx0dGhpcy5fekF4aXMgICAgICAgICAgPSBnbG0udmVjMy5jbG9uZShbMCwgMCwgMV0pO1xuXHRcdHRoaXMucHJlTW91c2UgICAgICAgID0geyB4OjAsIHk6MCB9O1xuXHRcdHRoaXMubW91c2UgICAgICAgICAgID0geyB4OjAsIHk6MCB9O1xuXHRcdHRoaXMuX2lzTW91c2VEb3duICAgID0gZmFsc2U7XG5cdFx0dGhpcy5fcm90YXRpb24gICAgICAgPSBnbG0ucXVhdC5jcmVhdGUoKTtcblx0XHR0aGlzLnRlbXBSb3RhdGlvbiAgICA9IGdsbS5xdWF0LmNyZWF0ZSgpO1xuXHRcdHRoaXMuX3JvdGF0ZVpNYXJnaW4gID0gMDtcblx0XHR0aGlzLl9vZmZzZXQgICAgICAgICA9IDAuMDA0O1xuXHRcdHRoaXMuX3NsZXJwICAgICAgICAgID0gLTE7XG5cdFx0dGhpcy5faXNMb2NrZWQgICAgICAgPSBmYWxzZTtcblx0XHRcblx0XHR0aGlzLl9kaWZmWCAgICAgICAgICA9IG5ldyBFYXNlTnVtYmVyKDAsIG1FYXNpbmcpO1xuXHRcdHRoaXMuX2RpZmZZICAgICAgICAgID0gbmV3IEVhc2VOdW1iZXIoMCwgbUVhc2luZyk7XG5cblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAoZSkgPT4gdGhpcy5fb25Eb3duKGUpKTtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgKGUpID0+IHRoaXMuX29uRG93bihlKSk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgKGUpID0+IHRoaXMuX29uTW92ZShlKSk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgKGUpID0+IHRoaXMuX29uTW92ZShlKSk7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgKCkgPT4gdGhpcy5fb25VcCgpKTtcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsICgpID0+IHRoaXMuX29uVXAoKSk7XG5cblx0XHRTY2hlZHVsZXIuYWRkRUYoKCkgPT4gdGhpcy5fbG9vcCgpKTtcblx0fVxuXG5cdC8vIFx0UFVCTElDIE1FVEhPRFNcblxuXHRpbnZlcnNlQ29udHJvbChpc0ludmVydCA9IHRydWUpIHtcblx0XHR0aGlzLl9pc0ludmVydCA9IGlzSW52ZXJ0O1xuXHR9XG5cblx0bG9jayhtVmFsdWUgPSB0cnVlKSB7XG5cdFx0dGhpcy5faXNMb2NrZWQgPSBtVmFsdWU7XG5cdH1cdFxuXG5cdHNldENhbWVyYVBvcyhtUXVhdCwgc3BlZWQgPSAwLjEpIHtcblx0XHR0aGlzLmVhc2luZyA9IHNwZWVkO1xuXHRcdGlmKHRoaXMuX3NsZXJwID4gMCkgeyByZXR1cm47IH1cblx0XHRcblx0XHRjb25zdCB0ZW1wUm90YXRpb24gID0gZ2xtLnF1YXQuY2xvbmUodGhpcy5fcm90YXRpb24pO1xuXHRcdHRoaXMuX3VwZGF0ZVJvdGF0aW9uKHRlbXBSb3RhdGlvbik7XG5cdFx0dGhpcy5fcm90YXRpb24gICAgPSBnbG0ucXVhdC5jbG9uZSh0ZW1wUm90YXRpb24pO1xuXHRcdHRoaXMuX2N1cnJEaWZmWCAgID0gdGhpcy5kaWZmWCA9IDA7XG5cdFx0dGhpcy5fY3VyckRpZmZZICAgPSB0aGlzLmRpZmZZID0gMDtcblx0XHRcblx0XHR0aGlzLl9pc01vdXNlRG93biA9IGZhbHNlO1xuXHRcdHRoaXMuX2lzUm90YXRlWiAgID0gMDtcblx0XHRcblx0XHR0aGlzLl90YXJnZXRRdWF0ICA9IGdsbS5xdWF0LmNsb25lKG1RdWF0KTtcblx0XHR0aGlzLl9zbGVycCAgICAgICA9IDE7XG5cdH1cblxuXHRyZXNldFF1YXQoKSB7XG5cdFx0dGhpcy5fcm90YXRpb24gICAgPSBnbG0ucXVhdC5jbG9uZShbMCwgMCwgMSwgMF0pO1xuXHRcdHRoaXMudGVtcFJvdGF0aW9uID0gZ2xtLnF1YXQuY2xvbmUoWzAsIDAsIDAsIDBdKTtcblx0XHR0aGlzLl90YXJnZXRRdWF0ICA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLl9zbGVycCAgICAgICA9IC0xO1xuXHR9XG5cblx0Ly9cdEVWRU5UIEhBTkRMRVJcblxuXHRfb25Eb3duKG1FdmVudCkge1xuXHRcdGlmKHRoaXMuX2lzTG9ja2VkKSB7IHJldHVybjsgfVxuXG5cdFx0Y29uc3QgbW91c2UgPSBnZXRNb3VzZShtRXZlbnQpO1xuXHRcdGNvbnN0IHRlbXBSb3RhdGlvbiA9IGdsbS5xdWF0LmNsb25lKHRoaXMuX3JvdGF0aW9uKTtcblx0XHR0aGlzLl91cGRhdGVSb3RhdGlvbih0ZW1wUm90YXRpb24pO1xuXHRcdHRoaXMuX3JvdGF0aW9uID0gdGVtcFJvdGF0aW9uO1xuXG5cdFx0dGhpcy5faXNNb3VzZURvd24gPSB0cnVlO1xuXHRcdHRoaXMuX2lzUm90YXRlWiA9IDA7XG5cdFx0dGhpcy5wcmVNb3VzZSA9IHsgeDptb3VzZS54LCB5Om1vdXNlLnkgfTtcblxuXHRcdGlmKG1vdXNlLnkgPCB0aGlzLl9yb3RhdGVaTWFyZ2luIHx8IG1vdXNlLnkgPiAod2luZG93LmlubmVySGVpZ2h0IC0gdGhpcy5fcm90YXRlWk1hcmdpbikpIHtcdFxuXHRcdFx0dGhpcy5faXNSb3RhdGVaID0gMTtcdFxuXHRcdH0gZWxzZSBpZihtb3VzZS54IDwgdGhpcy5fcm90YXRlWk1hcmdpbiB8fCBtb3VzZS54ID4gKHdpbmRvdy5pbm5lcldpZHRoIC0gdGhpcy5fcm90YXRlWk1hcmdpbikpIHtcdFxuXHRcdFx0dGhpcy5faXNSb3RhdGVaID0gMjtcdFxuXHRcdH1cblxuXHRcdHRoaXMuX2RpZmZYLnNldFRvKDApO1xuXHRcdHRoaXMuX2RpZmZZLnNldFRvKDApO1xuXHR9XG5cblxuXHRfb25Nb3ZlKG1FdmVudCkge1xuXHRcdGlmKHRoaXMuX2lzTG9ja2VkKSB7IHJldHVybjsgfVxuXHRcdGdldE1vdXNlKG1FdmVudCwgdGhpcy5tb3VzZSk7XG5cdH1cblxuXG5cdF9vblVwKCkge1xuXHRcdGlmKHRoaXMuX2lzTG9ja2VkKSB7IHJldHVybjsgfVxuXHRcdHRoaXMuX2lzTW91c2VEb3duID0gZmFsc2U7XG5cdH1cblxuXG5cdC8vXHRQUklWQVRFIE1FVEhPRFNcblxuXHRfdXBkYXRlUm90YXRpb24obVRlbXBSb3RhdGlvbikge1xuXHRcdGlmKHRoaXMuX2lzTW91c2VEb3duICYmICF0aGlzLl9pc0xvY2tlZCkge1xuXHRcdFx0dGhpcy5fZGlmZlgudmFsdWUgPSAtKHRoaXMubW91c2UueCAtIHRoaXMucHJlTW91c2UueCk7XG5cdFx0XHR0aGlzLl9kaWZmWS52YWx1ZSA9ICAodGhpcy5tb3VzZS55IC0gdGhpcy5wcmVNb3VzZS55KTtcblxuXHRcdFx0aWYodGhpcy5faXNJbnZlcnQpIHtcblx0XHRcdFx0dGhpcy5fZGlmZlgudmFsdWUgPSAtdGhpcy5fZGlmZlgudGFyZ2V0VmFsdWU7XG5cdFx0XHRcdHRoaXMuX2RpZmZZLnZhbHVlID0gLXRoaXMuX2RpZmZZLnRhcmdldFZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRsZXQgYW5nbGUsIF9xdWF0O1xuXG5cdFx0aWYodGhpcy5faXNSb3RhdGVaID4gMCkge1xuXHRcdFx0aWYodGhpcy5faXNSb3RhdGVaID09PSAxKSB7XG5cdFx0XHRcdGFuZ2xlID0gLXRoaXMuX2RpZmZYLnZhbHVlICogdGhpcy5fb2Zmc2V0OyBcblx0XHRcdFx0YW5nbGUgKj0gKHRoaXMucHJlTW91c2UueSA8IHRoaXMuX3JvdGF0ZVpNYXJnaW4pID8gLTEgOiAxO1xuXHRcdFx0XHRfcXVhdCA9IGdsbS5xdWF0LmNsb25lKFswLCAwLCBNYXRoLnNpbihhbmdsZSksIE1hdGguY29zKGFuZ2xlKV0pO1xuXHRcdFx0XHRnbG0ucXVhdC5tdWx0aXBseShfcXVhdCwgbVRlbXBSb3RhdGlvbiwgX3F1YXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YW5nbGUgPSAtdGhpcy5fZGlmZlkudmFsdWUgKiB0aGlzLl9vZmZzZXQ7IFxuXHRcdFx0XHRhbmdsZSAqPSAodGhpcy5wcmVNb3VzZS54IDwgdGhpcy5fcm90YXRlWk1hcmdpbikgPyAxIDogLTE7XG5cdFx0XHRcdF9xdWF0ID0gZ2xtLnF1YXQuY2xvbmUoWzAsIDAsIE1hdGguc2luKGFuZ2xlKSwgTWF0aC5jb3MoYW5nbGUpXSk7XG5cdFx0XHRcdGdsbS5xdWF0Lm11bHRpcGx5KF9xdWF0LCBtVGVtcFJvdGF0aW9uLCBfcXVhdCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IHYgPSBnbG0udmVjMy5jbG9uZShbdGhpcy5fZGlmZlgudmFsdWUsIHRoaXMuX2RpZmZZLnZhbHVlLCAwXSk7XG5cdFx0XHRjb25zdCBheGlzID0gZ2xtLnZlYzMuY3JlYXRlKCk7XG5cdFx0XHRnbG0udmVjMy5jcm9zcyhheGlzLCB2LCB0aGlzLl96QXhpcyk7XG5cdFx0XHRnbG0udmVjMy5ub3JtYWxpemUoYXhpcywgYXhpcyk7XG5cdFx0XHRhbmdsZSA9IGdsbS52ZWMzLmxlbmd0aCh2KSAqIHRoaXMuX29mZnNldDtcblx0XHRcdF9xdWF0ID0gZ2xtLnF1YXQuY2xvbmUoW01hdGguc2luKGFuZ2xlKSAqIGF4aXNbMF0sIE1hdGguc2luKGFuZ2xlKSAqIGF4aXNbMV0sIE1hdGguc2luKGFuZ2xlKSAqIGF4aXNbMl0sIE1hdGguY29zKGFuZ2xlKV0pO1xuXHRcdFx0Z2xtLnF1YXQubXVsdGlwbHkobVRlbXBSb3RhdGlvbiwgX3F1YXQsIG1UZW1wUm90YXRpb24pO1xuXHRcdH1cblx0fVxuXG5cdF9sb29wKCkge1xuXHRcdGdsbS5tYXQ0LmlkZW50aXR5KHRoaXMubSk7XG5cblx0XHRpZih0aGlzLl90YXJnZXRRdWF0ID09PSB1bmRlZmluZWQpIHsgXG5cdFx0XHRnbG0ucXVhdC5zZXQodGhpcy50ZW1wUm90YXRpb24sIHRoaXMuX3JvdGF0aW9uWzBdLCB0aGlzLl9yb3RhdGlvblsxXSwgdGhpcy5fcm90YXRpb25bMl0sIHRoaXMuX3JvdGF0aW9uWzNdKTtcblx0XHRcdHRoaXMuX3VwZGF0ZVJvdGF0aW9uKHRoaXMudGVtcFJvdGF0aW9uKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fc2xlcnAgKz0gKDAgLSB0aGlzLl9zbGVycCkgKiAwLjE7XG5cblx0XHRcdGlmKHRoaXMuX3NsZXJwIDwgMC4wMDA1KSB7XG5cdFx0XHRcdGdsbS5xdWF0LmNvcHkodGhpcy5fcm90YXRpb24sIHRoaXMuX3RhcmdldFF1YXQpO1xuXHRcdFx0XHRnbG0ucXVhdC5jb3B5KHRoaXMudGVtcFJvdGF0aW9uLCB0aGlzLl90YXJnZXRRdWF0KTtcblx0XHRcdFx0dGhpcy5fdGFyZ2V0UXVhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0dGhpcy5fZGlmZlguc2V0VG8oMCk7XG5cdFx0XHRcdHRoaXMuX2RpZmZZLnNldFRvKDApO1xuXHRcdFx0XHR0aGlzLl9zbGVycCA9IC0xO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Z2xtLnF1YXQuc2V0KHRoaXMudGVtcFJvdGF0aW9uLCAwLCAwLCAwLCAwKTtcblx0XHRcdFx0Z2xtLnF1YXQuc2xlcnAodGhpcy50ZW1wUm90YXRpb24sIHRoaXMuX3RhcmdldFF1YXQsIHRoaXMuX3JvdGF0aW9uLCB0aGlzLl9zbGVycCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Z2xtLnZlYzMudHJhbnNmb3JtUXVhdCh0aGlzLl92WmF4aXMsIHRoaXMuX3ZaYXhpcywgdGhpcy50ZW1wUm90YXRpb24pO1xuXG5cdFx0Z2xtLm1hdDQuZnJvbVF1YXQodGhpcy5tYXRyaXgsIHRoaXMudGVtcFJvdGF0aW9uKTtcblx0fVxuXG5cblx0Ly9cdEdFVFRFUiBBTkQgU0VUVEVSXG5cblx0c2V0IGVhc2luZyhtVmFsdWUpIHtcblx0XHR0aGlzLl9kaWZmWC5lYXNpbmcgPSBtVmFsdWU7XG5cdFx0dGhpcy5fZGlmZlkuZWFzaW5nID0gbVZhbHVlO1xuXHR9XG5cblx0Z2V0IGVhc2luZygpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGlmZlguZWFzaW5nO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFF1YXRSb3RhdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9RdWF0Um90YXRpb24uanMiLCIvLyBUb3VjaERldGVjdG9yLmpzXG5pbXBvcnQgR0wgZnJvbSAnLi4vR0xUb29sJztcbmltcG9ydCBFdmVudERpc3BhdGNoZXIgZnJvbSAnLi9FdmVudERpc3BhdGNoZXInO1xuaW1wb3J0IFJheSBmcm9tICcuLi9tYXRoL1JheSc7XG5pbXBvcnQgZ2V0TW91c2UgZnJvbSAnLi9nZXRNb3VzZSc7XG5cbmZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcblx0Y29uc3QgZHggPSBhLnggLSBiLng7XG5cdGNvbnN0IGR5ID0gYS55IC0gYi55O1xuXHRyZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbn1cblxuY2xhc3MgVG91Y2hEZXRlY3RvciBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cdGNvbnN0cnVjdG9yKG1NZXNoLCBtQ2FtZXJhLCBtU2tpcE1vdmVDaGVjaz1mYWxzZSwgbUxpc3RlbmVyVGFyZ2V0PXdpbmRvdykge1xuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLl9tZXNoID0gbU1lc2g7XG5cdFx0dGhpcy5fbWVzaC5nZW5lcmF0ZUZhY2VzKCk7XG5cdFx0dGhpcy5fY2FtZXJhID0gbUNhbWVyYTtcblx0XHR0aGlzLmZhY2VWZXJ0aWNlcyA9IG1NZXNoLmZhY2VzLm1hcCgoZmFjZSk9PihmYWNlLnZlcnRpY2VzKSk7XG5cdFx0dGhpcy5jbGlja1RvbGVyYW5jZSA9IDg7XG5cblx0XHR0aGlzLl9yYXkgPSBuZXcgUmF5KFswLCAwLCAwXSwgWzAsIDAsIC0xXSk7XG5cdFx0dGhpcy5faGl0ID0gdmVjMy5mcm9tVmFsdWVzKC05OTksIC05OTksIC05OTkpO1xuXHRcdHRoaXMuX2xhc3RQb3M7XG5cdFx0dGhpcy5fZmlyc3RQb3M7XG5cdFx0dGhpcy5tdHhNb2RlbCA9IG1hdDQuY3JlYXRlKCk7XG5cblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldCA9IG1MaXN0ZW5lclRhcmdldDtcblx0XHR0aGlzLl9za2lwcGluZ01vdmUgPSBtU2tpcE1vdmVDaGVjaztcblxuXHRcdHRoaXMuX29uTW92ZUJpbmQgPSAoZSkgPT4gdGhpcy5fb25Nb3ZlKGUpO1xuXHRcdHRoaXMuX29uRG93bkJpbmQgPSAoZSkgPT4gdGhpcy5fb25Eb3duKGUpO1xuXHRcdHRoaXMuX29uVXBCaW5kID0gKCkgPT4gdGhpcy5fb25VcCgpO1xuXG5cdFx0dGhpcy5jb25uZWN0KCk7XG5cdH1cblxuXHRjb25uZWN0KCkge1xuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uRG93bkJpbmQpO1xuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW92ZUJpbmQpO1x0XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uVXBCaW5kKTtcblx0fVxuXG5cdGRpc2Nvbm5lY3QoKSB7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Eb3duQmluZCk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3ZlQmluZCk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uVXBCaW5kKTtcblx0fVxuXG5cblx0X2NoZWNrSGl0KG1UeXBlPSdvbkhpdCcpIHtcblx0XHRjb25zdCBjYW1lcmEgPSB0aGlzLl9jYW1lcmE7XG5cdFx0aWYoIWNhbWVyYSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXG5cdFx0Y29uc3QgbXggPSAodGhpcy5fbGFzdFBvcy54IC8gR0wud2lkdGgpICogMi4wIC0gMS4wO1xuXHRcdGNvbnN0IG15ID0gLSAodGhpcy5fbGFzdFBvcy55IC8gR0wuaGVpZ2h0KSAqIDIuMCArIDEuMDtcblxuXHRcdGNhbWVyYS5nZW5lcmF0ZVJheShbbXgsIG15LCAwXSwgdGhpcy5fcmF5KTtcblxuXHRcdGxldCBoaXQ7XG5cdFx0Y29uc3QgdjAgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdGNvbnN0IHYxID0gdmVjMy5jcmVhdGUoKTtcblx0XHRjb25zdCB2MiA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0bGV0IGRpc3QgPSAwO1xuXG5cdFx0Y29uc3QgZ2V0VmVjdG9yID0gKHYsIHRhcmdldCkgPT4ge1xuXHRcdFx0dmVjMy50cmFuc2Zvcm1NYXQ0KHRhcmdldCwgdiwgdGhpcy5tdHhNb2RlbCk7XG5cdFx0fTtcblxuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmZhY2VWZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgdmVydGljZXMgPSB0aGlzLmZhY2VWZXJ0aWNlc1tpXTtcblx0XHRcdGdldFZlY3Rvcih2ZXJ0aWNlc1swXSwgdjApOyBcblx0XHRcdGdldFZlY3Rvcih2ZXJ0aWNlc1sxXSwgdjEpOyBcblx0XHRcdGdldFZlY3Rvcih2ZXJ0aWNlc1syXSwgdjIpOyBcblx0XHRcdGNvbnN0IHQgPSB0aGlzLl9yYXkuaW50ZXJzZWN0VHJpYW5nbGUodjAsIHYxLCB2Mik7XG5cblx0XHRcdGlmKHQpIHtcblx0XHRcdFx0aWYoaGl0KSB7XG5cdFx0XHRcdFx0Y29uc3QgZGlzdFRvQ2FtID0gdmVjMy5kaXN0KHQsIGNhbWVyYS5wb3NpdGlvbik7XG5cdFx0XHRcdFx0aWYoZGlzdFRvQ2FtIDwgZGlzdCkge1xuXHRcdFx0XHRcdFx0aGl0ID0gdmVjMy5jbG9uZSh0KTtcblx0XHRcdFx0XHRcdGRpc3QgPSBkaXN0VG9DYW07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGhpdCA9IHZlYzMuY2xvbmUodCk7XG5cdFx0XHRcdFx0ZGlzdCA9IHZlYzMuZGlzdChoaXQsIGNhbWVyYS5wb3NpdGlvbik7XG5cdFx0XHRcdH1cdFxuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0aWYoaGl0KSB7XG5cdFx0XHR0aGlzLl9oaXQgPSB2ZWMzLmNsb25lKGhpdCk7XG5cdFx0XHR0aGlzLmRpc3BhdGNoQ3VzdG9tRXZlbnQobVR5cGUsIHsgaGl0IH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmRpc3BhdGNoQ3VzdG9tRXZlbnQoJ29uVXAnKTtcblx0XHR9XG5cdH1cblxuXG5cdF9vbkRvd24oZSkge1xuXHRcdHRoaXMuX2ZpcnN0UG9zID0gZ2V0TW91c2UoZSk7XG5cdFx0dGhpcy5fbGFzdFBvcyA9IGdldE1vdXNlKGUpO1xuXHRcdHRoaXMuX2NoZWNrSGl0KCdvbkRvd24nKTtcblx0fVxuXG5cdF9vbk1vdmUoZSkge1xuXHRcdHRoaXMuX2xhc3RQb3MgPSBnZXRNb3VzZShlKTtcblx0XHRpZighdGhpcy5fc2tpcHBpbmdNb3ZlKSB7XG5cdFx0XHR0aGlzLl9jaGVja0hpdCgpO1xuXHRcdH1cblx0fVxuXG5cdF9vblVwKCkge1xuXHRcdGNvbnN0IGRpc3QgPSBkaXN0YW5jZSh0aGlzLl9maXJzdFBvcywgdGhpcy5fbGFzdFBvcyk7XG5cdFx0aWYoZGlzdCA8IHRoaXMuY2xpY2tUb2xlcmFuY2UpIHtcblx0XHRcdHRoaXMuX2NoZWNrSGl0KCk7XHRcblx0XHR9XG5cdFx0XG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBUb3VjaERldGVjdG9yO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL1RvdWNoRGV0ZWN0b3IuanMiLCIvLyBnZXRNb3VzZS5qc1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoZSkge1xuXHRsZXQgeCwgeTtcblxuXHRpZihlLnRvdWNoZXMpIHtcblx0XHR4ID0gZS50b3VjaGVzWzBdLnBhZ2VYO1xuXHRcdHkgPSBlLnRvdWNoZXNbMF0ucGFnZVk7XG5cdH0gZWxzZSB7XG5cdFx0eCA9IGUuY2xpZW50WDtcblx0XHR5ID0gZS5jbGllbnRZO1xuXHR9XG5cblxuXHRyZXR1cm4ge1xuXHRcdHgsIHlcblx0fTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9nZXRNb3VzZS5qcyIsIi8vIENhbWVyYUN1YmUuanNcblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQ2FtZXJhUGVyc3BlY3RpdmUgZnJvbSAnLi9DYW1lcmFQZXJzcGVjdGl2ZSc7XG5pbXBvcnQgeyB2ZWMzIH0gZnJvbSAnZ2wtbWF0cml4JztcblxuY29uc3QgQ0FNRVJBX1NFVFRJTkdTID0gW1xuXHRbdmVjMy5mcm9tVmFsdWVzKDAsIDAsIDApLCB2ZWMzLmZyb21WYWx1ZXMoMSwgMCwgMCksIHZlYzMuZnJvbVZhbHVlcygwLCAtMSwgMCldLFx0XHRcblx0W3ZlYzMuZnJvbVZhbHVlcygwLCAwLCAwKSwgdmVjMy5mcm9tVmFsdWVzKC0xLCAwLCAwKSwgdmVjMy5mcm9tVmFsdWVzKDAsIC0xLCAwKV0sXG5cdFt2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgMCksIHZlYzMuZnJvbVZhbHVlcygwLCAgMSwgMCksIHZlYzMuZnJvbVZhbHVlcygwLCAwLCAgMSldLFxuXHRbdmVjMy5mcm9tVmFsdWVzKDAsIDAsIDApLCB2ZWMzLmZyb21WYWx1ZXMoMCwgLTEsIDApLCB2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgLTEpXSxcblx0W3ZlYzMuZnJvbVZhbHVlcygwLCAwLCAwKSwgdmVjMy5mcm9tVmFsdWVzKDAsIDAsICAxKSwgdmVjMy5mcm9tVmFsdWVzKDAsIC0xLCAwKV0sXG5cdFt2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgMCksIHZlYzMuZnJvbVZhbHVlcygwLCAwLCAtMSksIHZlYzMuZnJvbVZhbHVlcygwLCAtMSwgMCldXG5dO1xuXG5jbGFzcyBDYW1lcmFDdWJlIGV4dGVuZHMgQ2FtZXJhUGVyc3BlY3RpdmUge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnNldFBlcnNwZWN0aXZlKE1hdGguUEkgLyAyLCAxLCAwLjEsIDEwMDApO1xuXHR9XG5cblxuXHRmYWNlKG1JbmRleCkge1xuXHRcdGNvbnN0IG8gPSBDQU1FUkFfU0VUVElOR1NbbUluZGV4XTtcblx0XHR0aGlzLmxvb2tBdChvWzBdLCBvWzFdLCBvWzJdKTtcblx0fVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IENhbWVyYUN1YmU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvY2FtZXJhcy9DYW1lcmFDdWJlLmpzIiwiLy8gT2JqTG9hZGVyLmpzXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEJpbmFyeUxvYWRlciBmcm9tICcuL0JpbmFyeUxvYWRlcic7XG5pbXBvcnQgTWVzaCBmcm9tICcuLi9NZXNoJztcblxuY2xhc3MgT2JqTG9hZGVyIGV4dGVuZHMgQmluYXJ5TG9hZGVyIHtcblxuXHRsb2FkKHVybCwgY2FsbGJhY2ssIGRyYXdUeXBlID0gNCkge1xuXHRcdHRoaXMuX2RyYXdUeXBlID0gZHJhd1R5cGU7XG5cdFx0c3VwZXIubG9hZCh1cmwsIGNhbGxiYWNrKTtcblx0fVxuXG5cdF9vbkxvYWRlZCgpIHtcblx0XHR0aGlzLnBhcnNlT2JqKHRoaXMuX3JlcS5yZXNwb25zZSk7XG5cdH1cblxuXHRwYXJzZU9iaihvYmpTdHIpIHtcblx0XHRjb25zdCBsaW5lcyA9IG9ialN0ci5zcGxpdCgnXFxuJyk7XG5cblx0XHRjb25zdCBwb3NpdGlvbnMgICAgPSBbXTtcblx0XHRjb25zdCBjb29yZHMgICAgICAgPSBbXTtcblx0XHRjb25zdCBmaW5hbE5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCB2ZXJ0aWNlcyAgICAgPSBbXTtcblx0XHRjb25zdCBub3JtYWxzICAgICAgPSBbXTtcblx0XHRjb25zdCB1dnMgICAgICAgICAgPSBbXTtcblx0XHRjb25zdCBpbmRpY2VzICAgICAgPSBbXTtcblx0XHRsZXQgY291bnQgICAgICAgID0gMDtcblx0XHRsZXQgcmVzdWx0O1xuXG5cdFx0Ly8gdiBmbG9hdCBmbG9hdCBmbG9hdFxuXHRcdGNvbnN0IHZlcnRleFBhdHRlcm4gPSAvdiggK1tcXGR8XFwufFxcK3xcXC18ZXxFXSspKCArW1xcZHxcXC58XFwrfFxcLXxlfEVdKykoICtbXFxkfFxcLnxcXCt8XFwtfGV8RV0rKS87XG5cblx0XHQvLyB2biBmbG9hdCBmbG9hdCBmbG9hdFxuXHRcdGNvbnN0IG5vcm1hbFBhdHRlcm4gPSAvdm4oICtbXFxkfFxcLnxcXCt8XFwtfGV8RV0rKSggK1tcXGR8XFwufFxcK3xcXC18ZXxFXSspKCArW1xcZHxcXC58XFwrfFxcLXxlfEVdKykvO1xuXG5cdFx0Ly8gdnQgZmxvYXQgZmxvYXRcblx0XHRjb25zdCB1dlBhdHRlcm4gPSAvdnQoICtbXFxkfFxcLnxcXCt8XFwtfGV8RV0rKSggK1tcXGR8XFwufFxcK3xcXC18ZXxFXSspLztcblxuXHRcdC8vIGYgdmVydGV4IHZlcnRleCB2ZXJ0ZXggLi4uXG5cdFx0Y29uc3QgZmFjZVBhdHRlcm4xID0gL2YoICstP1xcZCspKCArLT9cXGQrKSggKy0/XFxkKykoICstP1xcZCspPy87XG5cblx0XHQvLyBmIHZlcnRleC91diB2ZXJ0ZXgvdXYgdmVydGV4L3V2IC4uLlxuXHRcdGNvbnN0IGZhY2VQYXR0ZXJuMiA9IC9mKCArKC0/XFxkKylcXC8oLT9cXGQrKSkoICsoLT9cXGQrKVxcLygtP1xcZCspKSggKygtP1xcZCspXFwvKC0/XFxkKykpKCArKC0/XFxkKylcXC8oLT9cXGQrKSk/LztcblxuXHRcdC8vIGYgdmVydGV4L3V2L25vcm1hbCB2ZXJ0ZXgvdXYvbm9ybWFsIHZlcnRleC91di9ub3JtYWwgLi4uXG5cdFx0Y29uc3QgZmFjZVBhdHRlcm4zID0gL2YoICsoLT9cXGQrKVxcLygtP1xcZCspXFwvKC0/XFxkKykpKCArKC0/XFxkKylcXC8oLT9cXGQrKVxcLygtP1xcZCspKSggKygtP1xcZCspXFwvKC0/XFxkKylcXC8oLT9cXGQrKSkoICsoLT9cXGQrKVxcLygtP1xcZCspXFwvKC0/XFxkKykpPy87XG5cblx0XHQvLyBmIHZlcnRleC8vbm9ybWFsIHZlcnRleC8vbm9ybWFsIHZlcnRleC8vbm9ybWFsIC4uLiBcblx0XHRjb25zdCBmYWNlUGF0dGVybjQgPSAvZiggKygtP1xcZCspXFwvXFwvKC0/XFxkKykpKCArKC0/XFxkKylcXC9cXC8oLT9cXGQrKSkoICsoLT9cXGQrKVxcL1xcLygtP1xcZCspKSggKygtP1xcZCspXFwvXFwvKC0/XFxkKykpPy87XG5cblxuXHRcdGZ1bmN0aW9uIHBhcnNlVmVydGV4SW5kZXgodmFsdWUpIHtcblx0XHRcdGNvbnN0IGluZGV4ID0gcGFyc2VJbnQodmFsdWUpO1xuXHRcdFx0cmV0dXJuIChpbmRleCA+PSAwID8gaW5kZXggLSAxIDogaW5kZXggKyB2ZXJ0aWNlcy5sZW5ndGggLyAzKSAqIDM7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VOb3JtYWxJbmRleCh2YWx1ZSkge1xuXHRcdFx0Y29uc3QgaW5kZXggPSBwYXJzZUludCh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gKGluZGV4ID49IDAgPyBpbmRleCAtIDEgOiBpbmRleCArIG5vcm1hbHMubGVuZ3RoIC8gMykgKiAzO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlVVZJbmRleCh2YWx1ZSkge1xuXHRcdFx0Y29uc3QgaW5kZXggPSBwYXJzZUludCh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gKGluZGV4ID49IDAgPyBpbmRleCAtIDEgOiBpbmRleCArIHV2cy5sZW5ndGggLyAyKSAqIDI7XG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiBhZGRWZXJ0ZXgoYSwgYiwgYykge1xuXHRcdFx0cG9zaXRpb25zLnB1c2goW3ZlcnRpY2VzW2FdLCB2ZXJ0aWNlc1thICsgMV0sIHZlcnRpY2VzW2EgKyAyXV0pO1xuXHRcdFx0cG9zaXRpb25zLnB1c2goW3ZlcnRpY2VzW2JdLCB2ZXJ0aWNlc1tiICsgMV0sIHZlcnRpY2VzW2IgKyAyXV0pO1xuXHRcdFx0cG9zaXRpb25zLnB1c2goW3ZlcnRpY2VzW2NdLCB2ZXJ0aWNlc1tjICsgMV0sIHZlcnRpY2VzW2MgKyAyXV0pO1xuXG5cdFx0XHRpbmRpY2VzLnB1c2goY291bnQgKiAzICsgMCk7XG5cdFx0XHRpbmRpY2VzLnB1c2goY291bnQgKiAzICsgMSk7XG5cdFx0XHRpbmRpY2VzLnB1c2goY291bnQgKiAzICsgMik7XG5cblx0XHRcdGNvdW50ICsrO1xuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gYWRkVVYoYSwgYiwgYykge1xuXHRcdFx0Y29vcmRzLnB1c2goW3V2c1thXSwgdXZzW2EgKyAxXV0pO1xuXHRcdFx0Y29vcmRzLnB1c2goW3V2c1tiXSwgdXZzW2IgKyAxXV0pO1xuXHRcdFx0Y29vcmRzLnB1c2goW3V2c1tjXSwgdXZzW2MgKyAxXV0pO1xuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gYWRkTm9ybWFsKGEsIGIsIGMpIHtcblx0XHRcdGZpbmFsTm9ybWFscy5wdXNoKFtub3JtYWxzW2FdLCBub3JtYWxzW2EgKyAxXSwgbm9ybWFsc1thICsgMl1dKTtcblx0XHRcdGZpbmFsTm9ybWFscy5wdXNoKFtub3JtYWxzW2JdLCBub3JtYWxzW2IgKyAxXSwgbm9ybWFsc1tiICsgMl1dKTtcblx0XHRcdGZpbmFsTm9ybWFscy5wdXNoKFtub3JtYWxzW2NdLCBub3JtYWxzW2MgKyAxXSwgbm9ybWFsc1tjICsgMl1dKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRGYWNlKGEsIGIsIGMsIGQsICB1YSwgdWIsIHVjLCB1ZCwgIG5hLCBuYiwgbmMsIG5kKSB7XG5cdFx0XHRsZXQgaWEgPSBwYXJzZVZlcnRleEluZGV4KGEpO1xuXHRcdFx0bGV0IGliID0gcGFyc2VWZXJ0ZXhJbmRleChiKTtcblx0XHRcdGxldCBpYyA9IHBhcnNlVmVydGV4SW5kZXgoYyk7XG5cdFx0XHRsZXQgaWQ7XG5cblx0XHRcdGlmIChkID09PSB1bmRlZmluZWQpIHtcblxuXHRcdFx0XHRhZGRWZXJ0ZXgoaWEsIGliLCBpYyk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWQgPSBwYXJzZVZlcnRleEluZGV4KGQpO1xuXG5cdFx0XHRcdGFkZFZlcnRleChpYSwgaWIsIGlkKTtcblx0XHRcdFx0YWRkVmVydGV4KGliLCBpYywgaWQpO1xuXG5cdFx0XHR9XG5cblxuXHRcdFx0aWYgKHVhICE9PSB1bmRlZmluZWQpIHtcblxuXHRcdFx0XHRpYSA9IHBhcnNlVVZJbmRleCh1YSk7XG5cdFx0XHRcdGliID0gcGFyc2VVVkluZGV4KHViKTtcblx0XHRcdFx0aWMgPSBwYXJzZVVWSW5kZXgodWMpO1xuXG5cdFx0XHRcdGlmIChkID09PSB1bmRlZmluZWQpIHtcblxuXHRcdFx0XHRcdGFkZFVWKGlhLCBpYiwgaWMpO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpZCA9IHBhcnNlVVZJbmRleCh1ZCk7XG5cblx0XHRcdFx0XHRhZGRVVihpYSwgaWIsIGlkKTtcblx0XHRcdFx0XHRhZGRVVihpYiwgaWMsIGlkKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKG5hICE9PSB1bmRlZmluZWQpIHtcblxuXHRcdFx0XHRpYSA9IHBhcnNlTm9ybWFsSW5kZXgobmEpO1xuXHRcdFx0XHRpYiA9IHBhcnNlTm9ybWFsSW5kZXgobmIpO1xuXHRcdFx0XHRpYyA9IHBhcnNlTm9ybWFsSW5kZXgobmMpO1xuXG5cdFx0XHRcdGlmIChkID09PSB1bmRlZmluZWQpIHtcblxuXHRcdFx0XHRcdGFkZE5vcm1hbChpYSwgaWIsIGljKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aWQgPSBwYXJzZU5vcm1hbEluZGV4KG5kKTtcblxuXHRcdFx0XHRcdGFkZE5vcm1hbChpYSwgaWIsIGlkKTtcblx0XHRcdFx0XHRhZGROb3JtYWwoaWIsIGljLCBpZCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cdFx0fVxuXG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArKykge1xuXHRcdFx0bGV0IGxpbmUgPSBsaW5lc1tpXTtcblx0XHRcdGxpbmUgPSBsaW5lLnRyaW0oKTtcblxuXHRcdFx0aWYgKGxpbmUubGVuZ3RoID09PSAwIHx8IGxpbmUuY2hhckF0KDApID09PSAnIycpIHtcblxuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0fSBlbHNlIGlmICgocmVzdWx0ID0gdmVydGV4UGF0dGVybi5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goXG5cdFx0XHRcdFx0cGFyc2VGbG9hdChyZXN1bHRbMV0pLFxuXHRcdFx0XHRcdHBhcnNlRmxvYXQocmVzdWx0WzJdKSxcblx0XHRcdFx0XHRwYXJzZUZsb2F0KHJlc3VsdFszXSlcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIGlmICgocmVzdWx0ID0gbm9ybWFsUGF0dGVybi5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xuXG5cdFx0XHRcdG5vcm1hbHMucHVzaChcblx0XHRcdFx0XHRwYXJzZUZsb2F0KHJlc3VsdFsxXSksXG5cdFx0XHRcdFx0cGFyc2VGbG9hdChyZXN1bHRbMl0pLFxuXHRcdFx0XHRcdHBhcnNlRmxvYXQocmVzdWx0WzNdKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2UgaWYgKChyZXN1bHQgPSB1dlBhdHRlcm4uZXhlYyhsaW5lKSkgIT09IG51bGwpIHtcblxuXHRcdFx0XHR1dnMucHVzaChcblx0XHRcdFx0XHRwYXJzZUZsb2F0KHJlc3VsdFsxXSksXG5cdFx0XHRcdFx0cGFyc2VGbG9hdChyZXN1bHRbMl0pXG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAoKHJlc3VsdCA9IGZhY2VQYXR0ZXJuMS5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xuXG5cdFx0XHRcdGFkZEZhY2UoXG5cdFx0XHRcdFx0cmVzdWx0WzFdLCByZXN1bHRbMl0sIHJlc3VsdFszXSwgcmVzdWx0WzRdXG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAoKHJlc3VsdCA9IGZhY2VQYXR0ZXJuMi5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xuXG5cdFx0XHRcdGFkZEZhY2UoXG5cdFx0XHRcdFx0cmVzdWx0WzJdLCByZXN1bHRbNV0sIHJlc3VsdFs4XSwgcmVzdWx0WzExXSxcblx0XHRcdFx0XHRyZXN1bHRbM10sIHJlc3VsdFs2XSwgcmVzdWx0WzldLCByZXN1bHRbMTJdXG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAoKHJlc3VsdCA9IGZhY2VQYXR0ZXJuMy5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xuXHRcdFx0XHRhZGRGYWNlKFxuXHRcdFx0XHRcdHJlc3VsdFsyXSwgcmVzdWx0WzZdLCByZXN1bHRbMTBdLCByZXN1bHRbMTRdLFxuXHRcdFx0XHRcdHJlc3VsdFszXSwgcmVzdWx0WzddLCByZXN1bHRbMTFdLCByZXN1bHRbMTVdLFxuXHRcdFx0XHRcdHJlc3VsdFs0XSwgcmVzdWx0WzhdLCByZXN1bHRbMTJdLCByZXN1bHRbMTZdXG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAoKHJlc3VsdCA9IGZhY2VQYXR0ZXJuNC5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xuXHRcdFx0XHRhZGRGYWNlKFxuXHRcdFx0XHRcdHJlc3VsdFsyXSwgcmVzdWx0WzVdLCByZXN1bHRbOF0sIHJlc3VsdFsxMV0sXG5cdFx0XHRcdFx0dW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLFxuXHRcdFx0XHRcdHJlc3VsdFszXSwgcmVzdWx0WzZdLCByZXN1bHRbOV0sIHJlc3VsdFsxMl1cblx0XHRcdFx0KTtcblxuXHRcdFx0fSBcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fZ2VuZXJhdGVNZXNoZXMoe1x0XG5cdFx0XHRwb3NpdGlvbnMsXG5cdFx0XHRjb29yZHMsXG5cdFx0XHRub3JtYWxzOmZpbmFsTm9ybWFscyxcblx0XHRcdGluZGljZXNcblx0XHR9KTtcblx0XHRcblx0fVxuXG5cdF9nZW5lcmF0ZU1lc2hlcyhvKSB7XG5cdFx0Y29uc3QgbWF4TnVtVmVydGljZXMgPSA2NTUzNTtcblx0XHRjb25zdCBoYXNOb3JtYWxzID0gby5ub3JtYWxzLmxlbmd0aCA+IDA7XG5cdFx0Y29uc3QgaGFzVVZzID0gby5jb29yZHMubGVuZ3RoID4gMDtcblx0XHRsZXQgbWVzaDtcblxuXHRcdGlmKG8ucG9zaXRpb25zLmxlbmd0aCA+IG1heE51bVZlcnRpY2VzKSB7XG5cdFx0XHRjb25zdCBtZXNoZXMgPSBbXTtcblx0XHRcdGxldCBsYXN0SW5kZXggPSAwO1xuXG5cdFx0XHRjb25zdCBvQ29weSAgICAgICA9IHt9O1xuXHRcdFx0b0NvcHkucG9zaXRpb25zID0gby5wb3NpdGlvbnMuY29uY2F0KCk7XG5cdFx0XHRvQ29weS5jb29yZHMgICAgPSBvLmNvb3Jkcy5jb25jYXQoKTtcblx0XHRcdG9Db3B5LmluZGljZXMgICA9IG8uaW5kaWNlcy5jb25jYXQoKTtcblx0XHRcdG9Db3B5Lm5vcm1hbHMgICA9IG8ubm9ybWFscy5jb25jYXQoKTtcblxuXHRcdFx0d2hpbGUoby5pbmRpY2VzLmxlbmd0aCA+IDApIHtcblxuXHRcdFx0XHRjb25zdCBzbGljZU51bSAgPSBNYXRoLm1pbihtYXhOdW1WZXJ0aWNlcywgby5wb3NpdGlvbnMubGVuZ3RoKTtcblx0XHRcdFx0Y29uc3QgaW5kaWNlcyAgID0gby5pbmRpY2VzLnNwbGljZSgwLCBzbGljZU51bSk7XG5cdFx0XHRcdGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuXHRcdFx0XHRjb25zdCBjb29yZHMgICAgPSBbXTtcblx0XHRcdFx0Y29uc3Qgbm9ybWFscyAgID0gW107XG5cdFx0XHRcdGxldCBpbmRleCwgdG1wSW5kZXggPSAwO1xuXG5cdFx0XHRcdGZvcihsZXQgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYoaW5kaWNlc1tpXSA+IHRtcEluZGV4KSB7XG5cdFx0XHRcdFx0XHR0bXBJbmRleCA9IGluZGljZXNbaV07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aW5kZXggPSBpbmRpY2VzW2ldO1xuXG5cdFx0XHRcdFx0cG9zaXRpb25zLnB1c2gob0NvcHkucG9zaXRpb25zW2luZGV4XSk7XG5cdFx0XHRcdFx0aWYoaGFzVVZzKSB7XG5cdFx0XHRcdFx0XHRjb29yZHMucHVzaChvQ29weS5jb29yZHNbaW5kZXhdKTtcdFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihoYXNOb3JtYWxzKSB7XG5cdFx0XHRcdFx0XHRub3JtYWxzLnB1c2gob0NvcHkubm9ybWFsc1tpbmRleF0pO1x0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGluZGljZXNbaV0gLT0gbGFzdEluZGV4O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGFzdEluZGV4ID0gdG1wSW5kZXggKyAxO1xuXG5cdFx0XHRcdG1lc2ggPSBuZXcgTWVzaCh0aGlzLl9kcmF3VHlwZSk7XG5cdFx0XHRcdG1lc2guYnVmZmVyVmVydGV4KHBvc2l0aW9ucyk7XG5cdFx0XHRcdGlmKGhhc1VWcykge1xuXHRcdFx0XHRcdG1lc2guYnVmZmVyVGV4Q29vcmQoY29vcmRzKTtcdFxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRtZXNoLmJ1ZmZlckluZGV4KGluZGljZXMpO1xuXHRcdFx0XHRpZihoYXNOb3JtYWxzKSB7XG5cdFx0XHRcdFx0bWVzaC5idWZmZXJOb3JtYWwobm9ybWFscyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtZXNoZXMucHVzaChtZXNoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYodGhpcy5fY2FsbGJhY2spIHtcblx0XHRcdFx0dGhpcy5fY2FsbGJhY2sobWVzaGVzLCBvQ29weSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtZXNoZXM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lc2ggPSBuZXcgTWVzaCh0aGlzLl9kcmF3VHlwZSk7XG5cdFx0XHRtZXNoLmJ1ZmZlclZlcnRleChvLnBvc2l0aW9ucyk7XG5cdFx0XHRpZihoYXNVVnMpIHtcblx0XHRcdFx0bWVzaC5idWZmZXJUZXhDb29yZChvLmNvb3Jkcyk7XHRcblx0XHRcdH1cblx0XHRcdG1lc2guYnVmZmVySW5kZXgoby5pbmRpY2VzKTtcblx0XHRcdGlmKGhhc05vcm1hbHMpIHtcblx0XHRcdFx0bWVzaC5idWZmZXJOb3JtYWwoby5ub3JtYWxzKTtcblx0XHRcdH1cblxuXHRcdFx0aWYodGhpcy5fY2FsbGJhY2spIHtcblx0XHRcdFx0dGhpcy5fY2FsbGJhY2sobWVzaCwgbyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtZXNoO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxufVxuXG5cbk9iakxvYWRlci5wYXJzZSA9IGZ1bmN0aW9uIChvYmpTdHIpIHtcblx0Y29uc3QgbG9hZGVyID0gbmV3IE9iakxvYWRlcigpO1xuXHRyZXR1cm4gbG9hZGVyLnBhcnNlT2JqKG9ialN0cik7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBPYmpMb2FkZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvbG9hZGVycy9PYmpMb2FkZXIuanMiLCIvLyBIRFJMb2FkZXIuanNcblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQmluYXJ5TG9hZGVyIGZyb20gJy4vQmluYXJ5TG9hZGVyJztcbmltcG9ydCBoZHJQYXJzZXIgZnJvbSAnLi4vdXRpbHMvSERSUGFyc2VyJztcblxuY2xhc3MgSERSTG9hZGVyIGV4dGVuZHMgQmluYXJ5TG9hZGVyIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIodHJ1ZSk7XG5cdH1cblxuXHRwYXJzZShtQXJyYXlCdWZmZXIpIHtcblx0XHRyZXR1cm4gaGRyUGFyc2VyKG1BcnJheUJ1ZmZlcik7XG5cdH1cblxuXHRfb25Mb2FkZWQoKSB7XG5cdFx0Y29uc3QgbyA9IHRoaXMucGFyc2UodGhpcy5fcmVxLnJlc3BvbnNlKTtcblx0XHRpZih0aGlzLl9jYWxsYmFjaykge1xuXHRcdFx0dGhpcy5fY2FsbGJhY2sobyk7XG5cdFx0fVxuXHR9XG5cbn1cblxuXG5IRFJMb2FkZXIucGFyc2UgPSBmdW5jdGlvbiAobUFycmF5QnVmZmVyKSB7XG5cdHJldHVybiBoZHJQYXJzZXIobUFycmF5QnVmZmVyKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEhEUkxvYWRlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9sb2FkZXJzL0hEUkxvYWRlci5qcyIsIi8vIEhEUlBhcnNlci5qc1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIENvZGUgcG9ydGVkIGJ5IE1hcmNpbiBJZ25hYyAoMjAxNClcbi8vIEJhc2VkIG9uIEphdmEgaW1wbGVtZW50YXRpb24gZnJvbVxuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vci9jeXMxMjM0NS1yZXNlYXJjaC9zb3VyY2UvYnJvd3NlL2hkci9pbWFnZV9wcm9jZXNzb3IvUkdCRS5qYXZhP3I9N2Q4NGU5ZmQ4NjZiMjQwNzlkYmU2MWZhMGE5NjZjZTgzNjVmNTcyNlxuY29uc3QgcmFkaWFuY2VQYXR0ZXJuID0gJyNcXFxcP1JBRElBTkNFJztcbmNvbnN0IGNvbW1lbnRQYXR0ZXJuID0gJyMuKic7XG4vLyBsZXQgZ2FtbWFQYXR0ZXJuID0gJ0dBTU1BPSc7XG5jb25zdCBleHBvc3VyZVBhdHRlcm4gPSAnRVhQT1NVUkU9XFxcXHMqKFswLTldKlsuXVswLTldKiknO1xuY29uc3QgZm9ybWF0UGF0dGVybiA9ICdGT1JNQVQ9MzItYml0X3JsZV9yZ2JlJztcbmNvbnN0IHdpZHRoSGVpZ2h0UGF0dGVybiA9ICctWSAoWzAtOV0rKSBcXFxcK1ggKFswLTldKyknO1xuXG4vLyBodHRwOi8vY3JvcXVldHdlYWsuYmxvZ3Nwb3QuY28udWsvMjAxNC8wOC9kZWNvbnN0cnVjdGluZy1mbG9hdHMtZnJleHAtYW5kLWxkZXhwLmh0bWxcbi8vIGZ1bmN0aW9uIGxkZXhwKG1hbnRpc3NhLCBleHBvbmVudCkge1xuLy8gICAgIHJldHVybiBleHBvbmVudCA+IDEwMjMgPyBtYW50aXNzYSAqIE1hdGgucG93KDIsIDEwMjMpICogTWF0aC5wb3coMiwgZXhwb25lbnQgLSAxMDIzKSA6IGV4cG9uZW50IDwgLTEwNzQgPyBtYW50aXNzYSAqIE1hdGgucG93KDIsIC0xMDc0KSAqIE1hdGgucG93KDIsIGV4cG9uZW50ICsgMTA3NCkgOiBtYW50aXNzYSAqIE1hdGgucG93KDIsIGV4cG9uZW50KTtcbi8vIH1cblxuZnVuY3Rpb24gcmVhZFBpeGVsc1Jhd1JMRShidWZmZXIsIGRhdGEsIG9mZnNldCwgZmlsZU9mZnNldCwgc2NhbmxpbmVXaWR0aCwgbnVtU2NhbmxpbmVzKSB7XG5cdGNvbnN0IHJnYmUgPSBuZXcgQXJyYXkoNCk7XG5cdGxldCBzY2FubGluZUJ1ZmZlciA9IG51bGw7XG5cdGxldCBwdHI7XG5cdGxldCBwdHJFbmQ7XG5cdGxldCBjb3VudDtcblx0Y29uc3QgYnVmID0gbmV3IEFycmF5KDIpO1xuXHRjb25zdCBidWZmZXJMZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuXG5cdGZ1bmN0aW9uIHJlYWRCdWYoYnVmKSB7XG5cdFx0bGV0IGJ5dGVzUmVhZCA9IDA7XG5cdFx0ZG8ge1xuXHRcdFx0YnVmW2J5dGVzUmVhZCsrXSA9IGJ1ZmZlcltmaWxlT2Zmc2V0XTtcblx0XHR9IHdoaWxlKCsrZmlsZU9mZnNldCA8IGJ1ZmZlckxlbmd0aCAmJiBieXRlc1JlYWQgPCBidWYubGVuZ3RoKTtcblx0XHRyZXR1cm4gYnl0ZXNSZWFkO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVhZEJ1Zk9mZnNldChidWYsIG9mZnNldCwgbGVuZ3RoKSB7XG5cdFx0bGV0IGJ5dGVzUmVhZCA9IDA7XG5cdFx0ZG8ge1xuXHRcdFx0YnVmW29mZnNldCArIGJ5dGVzUmVhZCsrXSA9IGJ1ZmZlcltmaWxlT2Zmc2V0XTtcblx0XHR9IHdoaWxlKCsrZmlsZU9mZnNldCA8IGJ1ZmZlckxlbmd0aCAmJiBieXRlc1JlYWQgPCBsZW5ndGgpO1xuXHRcdHJldHVybiBieXRlc1JlYWQ7XG5cdH1cblxuXHRmdW5jdGlvbiByZWFkUGl4ZWxzUmF3KGJ1ZmZlciwgZGF0YSwgb2Zmc2V0LCBudW1waXhlbHMpIHtcblx0XHRjb25zdCBudW1FeHBlY3RlZCA9IDQgKiBudW1waXhlbHM7XG5cdFx0Y29uc3QgbnVtUmVhZCA9IHJlYWRCdWZPZmZzZXQoZGF0YSwgb2Zmc2V0LCBudW1FeHBlY3RlZCk7XG5cdFx0aWYgKG51bVJlYWQgPCBudW1FeHBlY3RlZCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBFcnJvciByZWFkaW5nIHJhdyBwaXhlbHM6IGdvdCAke251bVJlYWR9IGJ5dGVzLCBleHBlY3RlZCAke251bUV4cGVjdGVkfWApO1xuXHRcdH1cblx0fVxuXG5cdHdoaWxlIChudW1TY2FubGluZXMgPiAwKSB7XG5cdFx0aWYgKHJlYWRCdWYocmdiZSkgPCByZ2JlLmxlbmd0aCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBFcnJvciByZWFkaW5nIGJ5dGVzOiBleHBlY3RlZCAke3JnYmUubGVuZ3RofWApO1xuXHRcdH1cblxuXHRcdGlmICgocmdiZVswXSAhPT0gMikgfHwgKHJnYmVbMV0gIT09IDIpIHx8ICgocmdiZVsyXSAmIDB4ODApICE9PSAwKSkge1xuXHRcdFx0Ly8gdGhpcyBmaWxlIGlzIG5vdCBydW4gbGVuZ3RoIGVuY29kZWRcblx0XHRcdGRhdGFbb2Zmc2V0KytdID0gcmdiZVswXTtcblx0XHRcdGRhdGFbb2Zmc2V0KytdID0gcmdiZVsxXTtcblx0XHRcdGRhdGFbb2Zmc2V0KytdID0gcmdiZVsyXTtcblx0XHRcdGRhdGFbb2Zmc2V0KytdID0gcmdiZVszXTtcblx0XHRcdHJlYWRQaXhlbHNSYXcoYnVmZmVyLCBkYXRhLCBvZmZzZXQsIHNjYW5saW5lV2lkdGggKiBudW1TY2FubGluZXMgLSAxKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoKCgocmdiZVsyXSAmIDB4RkYpIDw8IDgpIHwgKHJnYmVbM10gJiAweEZGKSkgIT09IHNjYW5saW5lV2lkdGgpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgV3Jvbmcgc2NhbmxpbmUgd2lkdGggJHsoKChyZ2JlWzJdICYgMHhGRikgPDwgOCkgfCAocmdiZVszXSAmIDB4RkYpKX0sIGV4cGVjdGVkICR7c2NhbmxpbmVXaWR0aH1gKTtcblx0XHR9XG5cblx0XHRpZiAoc2NhbmxpbmVCdWZmZXIgPT09IG51bGwpIHtcblx0XHRcdHNjYW5saW5lQnVmZmVyID0gbmV3IEFycmF5KDQgKiBzY2FubGluZVdpZHRoKTtcblx0XHR9XG5cblx0XHRwdHIgPSAwO1xuXHRcdC8qIHJlYWQgZWFjaCBvZiB0aGUgZm91ciBjaGFubmVscyBmb3IgdGhlIHNjYW5saW5lIGludG8gdGhlIGJ1ZmZlciAqL1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdFx0XHRwdHJFbmQgPSAoaSArIDEpICogc2NhbmxpbmVXaWR0aDtcblx0XHRcdHdoaWxlKHB0ciA8IHB0ckVuZCkge1xuXHRcdFx0XHRpZiAocmVhZEJ1ZihidWYpIDwgYnVmLmxlbmd0aCkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignRXJyb3IgcmVhZGluZyAyLWJ5dGUgYnVmZmVyJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKChidWZbMF0gJiAweEZGKSA+IDEyOCkge1xuXHRcdFx0XHRcdC8qIGEgcnVuIG9mIHRoZSBzYW1lIHZhbHVlICovXG5cdFx0XHRcdFx0Y291bnQgPSAoYnVmWzBdICYgMHhGRikgLSAxMjg7XG5cdFx0XHRcdFx0aWYgKChjb3VudCA9PT0gMCkgfHwgKGNvdW50ID4gcHRyRW5kIC0gcHRyKSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdCYWQgc2NhbmxpbmUgZGF0YScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZShjb3VudC0tID4gMCkge1xuXHRcdFx0XHRcdFx0c2NhbmxpbmVCdWZmZXJbcHRyKytdID0gYnVmWzFdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvKiBhIG5vbi1ydW4gKi9cblx0XHRcdFx0XHRjb3VudCA9IGJ1ZlswXSAmIDB4RkY7XG5cdFx0XHRcdFx0aWYgKChjb3VudCA9PT0gMCkgfHwgKGNvdW50ID4gcHRyRW5kIC0gcHRyKSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdCYWQgc2NhbmxpbmUgZGF0YScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzY2FubGluZUJ1ZmZlcltwdHIrK10gPSBidWZbMV07XG5cdFx0XHRcdFx0aWYgKC0tY291bnQgPiAwKSB7XG5cdFx0XHRcdFx0XHRpZiAocmVhZEJ1Zk9mZnNldChzY2FubGluZUJ1ZmZlciwgcHRyLCBjb3VudCkgPCBjb3VudCkge1xuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHJlYWRpbmcgbm9uLXJ1biBkYXRhJyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwdHIgKz0gY291bnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyogY29weSBieXRlIGRhdGEgdG8gb3V0cHV0ICovXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHNjYW5saW5lV2lkdGg7IGkrKykge1xuXHRcdFx0ZGF0YVtvZmZzZXQgKyAwXSA9IHNjYW5saW5lQnVmZmVyW2ldO1xuXHRcdFx0ZGF0YVtvZmZzZXQgKyAxXSA9IHNjYW5saW5lQnVmZmVyW2kgKyBzY2FubGluZVdpZHRoXTtcblx0XHRcdGRhdGFbb2Zmc2V0ICsgMl0gPSBzY2FubGluZUJ1ZmZlcltpICsgMiAqIHNjYW5saW5lV2lkdGhdO1xuXHRcdFx0ZGF0YVtvZmZzZXQgKyAzXSA9IHNjYW5saW5lQnVmZmVyW2kgKyAzICogc2NhbmxpbmVXaWR0aF07XG5cdFx0XHRvZmZzZXQgKz0gNDtcblx0XHR9XG5cblx0XHRudW1TY2FubGluZXMtLTtcblx0fVxuXG59XG5cbi8vIFJldHVybnMgZGF0YSBhcyBmbG9hdHMgYW5kIGZsaXBwZWQgYWxvbmcgWSBieSBkZWZhdWx0XG5mdW5jdGlvbiBwYXJzZUhkcihidWZmZXIpIHtcblx0aWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG5cdFx0YnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcblx0fVxuXG5cdGxldCBmaWxlT2Zmc2V0ID0gMDtcblx0Y29uc3QgYnVmZmVyTGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcblxuXHRjb25zdCBORVdfTElORSA9IDEwO1xuXG5cdGZ1bmN0aW9uIHJlYWRMaW5lKCkge1xuXHRcdGxldCBidWYgPSAnJztcblx0XHRkbyB7XG5cdFx0XHRjb25zdCBiID0gYnVmZmVyW2ZpbGVPZmZzZXRdO1xuXHRcdFx0aWYgKGIgPT09IE5FV19MSU5FKSB7XG5cdFx0XHRcdCsrZmlsZU9mZnNldDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRidWYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiKTtcblx0XHR9IHdoaWxlKCsrZmlsZU9mZnNldCA8IGJ1ZmZlckxlbmd0aCk7XG5cdFx0cmV0dXJuIGJ1Zjtcblx0fVxuXG5cdGxldCB3aWR0aCA9IDA7XG5cdGxldCBoZWlnaHQgPSAwO1xuXHRsZXQgZXhwb3N1cmUgPSAxO1xuXHRjb25zdCBnYW1tYSA9IDE7XG5cdGxldCBybGUgPSBmYWxzZTtcblxuXHRmb3IobGV0IGkgPSAwOyBpIDwgMjA7IGkrKykge1xuXHRcdGNvbnN0IGxpbmUgPSByZWFkTGluZSgpO1xuXHRcdGxldCBtYXRjaDtcblx0XHRpZiAobWF0Y2ggPSBsaW5lLm1hdGNoKHJhZGlhbmNlUGF0dGVybikpIHtcblx0XHR9IGVsc2UgaWYgKG1hdGNoID0gbGluZS5tYXRjaChmb3JtYXRQYXR0ZXJuKSkge1xuXHRcdFx0cmxlID0gdHJ1ZTtcblx0XHR9IGVsc2UgaWYgKG1hdGNoID0gbGluZS5tYXRjaChleHBvc3VyZVBhdHRlcm4pKSB7XG5cdFx0XHRleHBvc3VyZSA9IE51bWJlcihtYXRjaFsxXSk7XG5cdFx0fSBlbHNlIGlmIChtYXRjaCA9IGxpbmUubWF0Y2goY29tbWVudFBhdHRlcm4pKSB7XG5cdFx0fSBlbHNlIGlmIChtYXRjaCA9IGxpbmUubWF0Y2god2lkdGhIZWlnaHRQYXR0ZXJuKSkge1xuXHRcdFx0aGVpZ2h0ID0gTnVtYmVyKG1hdGNoWzFdKTtcblx0XHRcdHdpZHRoID0gTnVtYmVyKG1hdGNoWzJdKTtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdGlmICghcmxlKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdGaWxlIGlzIG5vdCBydW4gbGVuZ3RoIGVuY29kZWQhJyk7XG5cdH1cblxuXHRjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcblx0Y29uc3Qgc2NhbmxpbmVXaWR0aCA9IHdpZHRoO1xuXHRjb25zdCBudW1TY2FubGluZXMgPSBoZWlnaHQ7XG5cblx0cmVhZFBpeGVsc1Jhd1JMRShidWZmZXIsIGRhdGEsIDAsIGZpbGVPZmZzZXQsIHNjYW5saW5lV2lkdGgsIG51bVNjYW5saW5lcyk7XG5cblx0Ly8gVE9ETzogU2hvdWxkIGJlIEZsb2F0MTZcblx0Y29uc3QgZmxvYXREYXRhID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuXHRmb3IobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IGRhdGEubGVuZ3RoOyBvZmZzZXQgKz0gNCkge1xuXHRcdGxldCByID0gZGF0YVtvZmZzZXQgKyAwXSAvIDI1NTtcblx0XHRsZXQgZyA9IGRhdGFbb2Zmc2V0ICsgMV0gLyAyNTU7XG5cdFx0bGV0IGIgPSBkYXRhW29mZnNldCArIDJdIC8gMjU1O1xuXHRcdGNvbnN0IGUgPSBkYXRhW29mZnNldCArIDNdO1xuXHRcdGNvbnN0IGYgPSBNYXRoLnBvdygyLjAsIGUgLSAxMjguMCk7XG5cblx0XHRyICo9IGY7XG5cdFx0ZyAqPSBmO1xuXHRcdGIgKj0gZjtcblxuXHRcdGNvbnN0IGZsb2F0T2Zmc2V0ID0gb2Zmc2V0O1xuXG5cdFx0ZmxvYXREYXRhW2Zsb2F0T2Zmc2V0ICsgMF0gPSByO1xuXHRcdGZsb2F0RGF0YVtmbG9hdE9mZnNldCArIDFdID0gZztcblx0XHRmbG9hdERhdGFbZmxvYXRPZmZzZXQgKyAyXSA9IGI7XG5cdFx0ZmxvYXREYXRhW2Zsb2F0T2Zmc2V0ICsgM10gPSAxLjA7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHNoYXBlOiBbd2lkdGgsIGhlaWdodF0sXG5cdFx0ZXhwb3N1cmUsXG5cdFx0Z2FtbWEsXG5cdFx0ZGF0YTogZmxvYXREYXRhXG5cdH07XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgcGFyc2VIZHI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvSERSUGFyc2VyLmpzIiwiLy8gQ29sbGFkYVBhcnNlci5qc1xuXG5pbXBvcnQgcGFyc2VyIGZyb20gJ2NvbGxhZGEtcGFyc2VyJztcbmltcG9ydCBNZXNoIGZyb20gJy4uL01lc2gnO1xuXG5cbmNvbnN0IGdlbmVyYXRlTWVzaCA9IGZ1bmN0aW9uIChtZXNoZXMpIHtcblx0Y29uc3QgY2FjaGVzID0ge307XG5cblx0bWVzaGVzLmZvckVhY2goKG1lc2gpPT4ge1xuXHRcdGNvbnN0IHsgdmVydGljZXMsIG5vcm1hbHMsIGNvb3JkcywgdHJpYW5nbGVzLCBuYW1lIH0gPSBtZXNoLm1lc2g7XG5cdFx0aWYoIWNhY2hlc1tuYW1lXSkge1xuXHRcdFx0Y29uc3QgZ2xNZXNoID0gbmV3IE1lc2goKVxuXHRcdFx0XHQuYnVmZmVyRmxhdHRlbkRhdGEodmVydGljZXMsICdhVmVydGV4UG9zaXRpb24nLCAzKVxuXHRcdFx0XHQuYnVmZmVyRmxhdHRlbkRhdGEoY29vcmRzLCAnYVRleHR1cmVDb29yZCcsIDIpXG5cdFx0XHRcdC5idWZmZXJGbGF0dGVuRGF0YShub3JtYWxzLCAnYU5vcm1hbCcsIDMpXG5cdFx0XHRcdC5idWZmZXJJbmRleCh0cmlhbmdsZXMpO1xuXG5cdFx0XHRjYWNoZXNbbmFtZV0gPSBnbE1lc2g7XG5cdFx0fVxuXG5cdFx0bWVzaC5nbE1lc2ggPSBjYWNoZXNbbmFtZV07XG5cdH0pO1xufTtcblxuY29uc3QgcGFyc2UgPSBmdW5jdGlvbiAobURhdGEpIHtcblx0Y29uc3QgbWVzaGVzID0gcGFyc2VyLnBhcnNlKG1EYXRhKTtcblx0Z2VuZXJhdGVNZXNoKG1lc2hlcyk7XG5cblx0cmV0dXJuIG1lc2hlcztcbn07XG5cbmNvbnN0IGxvYWQgPSBmdW5jdGlvbiAobVBhdGgsIG1DYWxsYmFjaykge1xuXHRwYXJzZXIubG9hZChtUGF0aCwgKG1lc2hlcyk9PiB7XG5cdFx0Z2VuZXJhdGVNZXNoKG1lc2hlcyk7XG5cdFx0bUNhbGxiYWNrKG1lc2hlcyk7XG5cdH0pO1xufTtcblxuY29uc3QgQ29sbGFkYVBhcnNlciA9IHtcblx0cGFyc2UsXG5cdGxvYWRcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgQ29sbGFkYVBhcnNlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9sb2FkZXJzL0NvbGxhZGFQYXJzZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfQ29sbGFkYSA9IHJlcXVpcmUoJy4vQ29sbGFkYScpO1xuXG52YXIgX0NvbGxhZGEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29sbGFkYSk7XG5cbnZhciBfZ2xNYXRyaXggPSByZXF1aXJlKCdnbC1tYXRyaXgnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gQ29sbGFkYVBhcnNlci5qc1xuXG52YXIgcGFyc2VEYXRhID0gZnVuY3Rpb24gcGFyc2VEYXRhKG1EYXRhKSB7XG5cdHZhciBtYXRlcmlhbHMgPSBtRGF0YS5tYXRlcmlhbHMsXG5cdCAgICBtZXNoZXMgPSBtRGF0YS5tZXNoZXM7XG5cblxuXHR2YXIgZmluYWxNZXNoZXMgPSBbXTtcblx0dmFyIG1lc2hPYmpzID0gW107XG5cdHZhciBhbGxNZXNoZXMgPSBbXTtcblxuXHQvL1x0Z2V0dGluZyBhbGwgbWVzaGVzJyBidWZmZXJzXG5cdGZvciAodmFyIHMgaW4gbWVzaGVzKSB7XG5cdFx0dmFyIG9NZXNoID0gbWVzaGVzW3NdO1xuXHRcdHZhciB2ZXJ0aWNlcyA9IG9NZXNoLnZlcnRpY2VzLFxuXHRcdCAgICBub3JtYWxzID0gb01lc2gubm9ybWFscyxcblx0XHQgICAgY29vcmRzID0gb01lc2guY29vcmRzLFxuXHRcdCAgICB0cmlhbmdsZXMgPSBvTWVzaC50cmlhbmdsZXM7XG5cblx0XHR2YXIgYnVmZmVycyA9IHtcblx0XHRcdHZlcnRpY2VzOiB2ZXJ0aWNlcywgbm9ybWFsczogbm9ybWFscywgY29vcmRzOiBjb29yZHMsIHRyaWFuZ2xlczogdHJpYW5nbGVzXG5cdFx0fTtcblx0XHRhbGxNZXNoZXMucHVzaCh7XG5cdFx0XHRpZDogcyxcblx0XHRcdGJ1ZmZlcnM6IGJ1ZmZlcnNcblx0XHR9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldE1hdGVyaWFsKGlkKSB7XG5cdFx0dmFyIG1hdCA9IHZvaWQgMDtcblx0XHRmb3IgKHZhciBfcyBpbiBtYXRlcmlhbHMpIHtcblx0XHRcdGlmIChfcyA9PT0gaWQpIHtcblx0XHRcdFx0bWF0ID0gbWF0ZXJpYWxzW19zXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgb01hdGVyaWFsID0ge307XG5cdFx0aWYgKG1hdC5kaWZmdXNlKSB7XG5cdFx0XHRvTWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gbWF0LmRpZmZ1c2U7XG5cdFx0fVxuXG5cdFx0b01hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IG1hdC5kaWZmdXNlIHx8IFswLCAwLCAwXTtcblx0XHRvTWF0ZXJpYWwuc2hpbmluZXNzID0gbWF0LnNoaW5pbmVzcyB8fCAwO1xuXHRcdGlmIChtYXQudGV4dHVyZXMpIHtcblx0XHRcdGlmIChtYXQudGV4dHVyZXMuZGlmZnVzZSkge1xuXHRcdFx0XHRvTWF0ZXJpYWwuZGlmZnVzZU1hcElEID0gbWF0LnRleHR1cmVzLmRpZmZ1c2UubWFwX2lkO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0LnRleHR1cmVzLm5vcm1hbCkge1xuXHRcdFx0XHRvTWF0ZXJpYWwubm9ybWFsTWFwSUQgPSBtYXQudGV4dHVyZXMubm9ybWFsLm1hcF9pZDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb01hdGVyaWFsO1xuXHR9XG5cblx0ZnVuY3Rpb24gd2Fsayhub2RlLCBtdHhQYXJlbnQpIHtcblx0XHR2YXIgbSA9IF9nbE1hdHJpeC5tYXQ0LmNyZWF0ZSgpO1xuXHRcdGlmIChub2RlLm1vZGVsKSB7XG5cdFx0XHRfZ2xNYXRyaXgubWF0NC5tdWx0aXBseShtLCBtdHhQYXJlbnQsIG5vZGUubW9kZWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRfZ2xNYXRyaXgubWF0NC5jb3B5KG0sIG10eFBhcmVudCk7XG5cdFx0fVxuXG5cdFx0aWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuXHRcdFx0bm9kZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuXHRcdFx0XHR3YWxrKGNoaWxkLCBtKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmIChub2RlLm1lc2gpIHtcblx0XHRcdHZhciBfb01lc2ggPSB7fTtcblx0XHRcdF9vTWVzaC5tb2RlbE1hdHJpeCA9IG07XG5cdFx0XHRfb01lc2gubWVzaCA9IG1lc2hlc1tub2RlLm1lc2hdO1xuXHRcdFx0X29NZXNoLmlkID0gbm9kZS5pZDtcblx0XHRcdF9vTWVzaC5uYW1lID0gbm9kZS5uYW1lO1xuXHRcdFx0X29NZXNoLm1hdGVyaWFsID0gZ2V0TWF0ZXJpYWwobm9kZS5tYXRlcmlhbCk7XG5cdFx0XHRtZXNoT2Jqcy5wdXNoKF9vTWVzaCk7XG5cdFx0fVxuXHR9XG5cblx0dmFyIG10eCA9IF9nbE1hdHJpeC5tYXQ0LmNyZWF0ZSgpO1xuXHR3YWxrKG1EYXRhLnJvb3QsIG10eCk7XG5cblx0cmV0dXJuIG1lc2hPYmpzO1xufTtcblxudmFyIHBhcnNlID0gZnVuY3Rpb24gcGFyc2UobUZpbGUpIHtcblx0dmFyIG8gPSBfQ29sbGFkYTIuZGVmYXVsdC5wYXJzZShtRmlsZSk7XG5cdHJldHVybiBwYXJzZURhdGEobyk7XG59O1xuXG52YXIgbG9hZCA9IGZ1bmN0aW9uIGxvYWQobVBhdGgsIG1DYWxsQmFjaykge1xuXHRfQ29sbGFkYTIuZGVmYXVsdC5sb2FkKG1QYXRoLCBmdW5jdGlvbiAobURhdGEpIHtcblx0XHRtQ2FsbEJhY2socGFyc2VEYXRhKG1EYXRhKSk7XG5cdH0pO1xufTtcblxudmFyIENvbGxhZGFQYXJzZXIgPSB7XG5cdGxvYWQ6IGxvYWQsXG5cdHBhcnNlOiBwYXJzZVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQ29sbGFkYVBhcnNlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29sbGFkYVBhcnNlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb2xsYWRhLXBhcnNlci9saWIvQ29sbGFkYVBhcnNlci5qc1xuLy8gbW9kdWxlIGlkID0gNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nbE1hdHJpeCA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIik7XG5cbnZhciBpc1dvcmtlciA9IGdsb2JhbC5kb2N1bWVudCA9PT0gdW5kZWZpbmVkOyAvLyBDb2xsYWRhLmpzXG5cbnZhciBERUcyUkFEID0gTWF0aC5QSSAqIDIgLyAzNjA7XG5cbi8vZ2xvYmFsIHRlbXBvcmFsIHZhcmlhYmxlc1xudmFyIHRlbXBfbWF0NCA9IG51bGw7XG52YXIgdGVtcF92ZWMyID0gbnVsbDtcbnZhciB0ZW1wX3ZlYzMgPSBudWxsO1xudmFyIHRlbXBfdmVjNCA9IG51bGw7XG52YXIgdGVtcF9xdWF0ID0gbnVsbDtcblxuZnVuY3Rpb24gcmVxdWVzdCh1cmwsIGNhbGxiYWNrKSB7XG5cdHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0cmVxLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmVzcG9uc2UgPSB0aGlzLnJlc3BvbnNlO1xuXHRcdGlmICh0aGlzLnN0YXR1cyAhPSAyMDApIHJldHVybjtcblx0XHRpZiAoY2FsbGJhY2spIGNhbGxiYWNrKHRoaXMucmVzcG9uc2UpO1xuXHR9O1xuXHRyZXEub3BlbihcImdldFwiLCB1cmwsIHRydWUpO1xuXHRyZXEuc2VuZCgpO1xufVxuXG52YXIgQ29sbGFkYSA9IHtcblxuXHRsaWJzUGF0aDogXCIuL1wiLFxuXHR3b3JrZXJQYXRoOiBcIi4vXCIsXG5cdG5vX2ZsaXA6IHRydWUsXG5cdHVzZV90cmFuc2ZlcmFibGVzOiB0cnVlLCAvL2ZvciB3b3JrZXJzXG5cdG9uZXJyb3I6IG51bGwsXG5cdHZlcmJvc2U6IGZhbHNlLFxuXHRjb25maWc6IHsgZm9yY2VQYXJzZXI6IGZhbHNlIH0sXG5cblx0aW5pdDogZnVuY3Rpb24gaW5pdChjb25maWcpIHtcblx0XHRjb25maWcgPSBjb25maWcgfHwge307XG5cdFx0Zm9yICh2YXIgaSBpbiBjb25maWcpIHtcblx0XHRcdHRoaXNbaV0gPSBjb25maWdbaV07XG5cdFx0fXRoaXMuY29uZmlnID0gY29uZmlnO1xuXG5cdFx0aWYgKGlzV29ya2VyKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpbXBvcnRTY3JpcHRzKHRoaXMubGlic1BhdGggKyBcImdsLW1hdHJpeC1taW4uanNcIiwgdGhpcy5saWJzUGF0aCArIFwidGlueXhtbC5qc1wiKTtcblx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRDb2xsYWRhLnRocm93RXhjZXB0aW9uKENvbGxhZGEuTElCTUlTU0lOR19FUlJPUik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9pbml0IGdsTWF0cml4XG5cdFx0dGVtcF9tYXQ0ID0gX2dsTWF0cml4Lm1hdDQuY3JlYXRlKCk7XG5cdFx0dGVtcF92ZWMyID0gdmVjMy5jcmVhdGUoKTtcblx0XHR0ZW1wX3ZlYzMgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdHRlbXBfdmVjNCA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0dGVtcF9xdWF0ID0gX2dsTWF0cml4LnF1YXQuY3JlYXRlKCk7XG5cblx0XHRpZiAoaXNXb3JrZXIpIGNvbnNvbGUubG9nKFwiQ29sbGFkYSB3b3JrZXIgcmVhZHlcIik7XG5cdH0sXG5cblx0bG9hZDogZnVuY3Rpb24gbG9hZCh1cmwsIGNhbGxiYWNrKSB7XG5cdFx0cmVxdWVzdCh1cmwsIGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0XHRpZiAoIWRhdGEpIGNhbGxiYWNrKG51bGwpO2Vsc2UgY2FsbGJhY2soQ29sbGFkYS5wYXJzZShkYXRhKSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X3htbHJvb3Q6IG51bGwsXG5cdF9ub2Rlc19ieV9pZDogbnVsbCxcblx0X3RyYW5zZmVyYWJsZXM6IG51bGwsXG5cdF9jb250cm9sbGVyc19mb3VuZDogbnVsbCxcblx0X2dlb21ldHJpZXNfZm91bmQ6IG51bGwsXG5cblx0c2FmZVN0cmluZzogZnVuY3Rpb24gc2FmZVN0cmluZyhzdHIpIHtcblx0XHRpZiAoIXN0cikgcmV0dXJuIFwiXCI7XG5cblx0XHRpZiAodGhpcy5jb252ZXJ0SUQpIHJldHVybiB0aGlzLmNvbnZlcnRJRChzdHIpO1xuXG5cdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC8gL2csIFwiX1wiKTtcblx0fSxcblxuXHRMSUJNSVNTSU5HX0VSUk9SOiBcIkxpYnJhcmllcyBsb2FkaW5nIGVycm9yLCB3aGVuIHVzaW5nIHdvcmtlcnMgcmVtZW1iZXIgdG8gcGFzcyB0aGUgVVJMIHRvIHRoZSB0aW55eG1sLmpzIGluIHRoZSBvcHRpb25zLmxpYnNQYXRoXCIsXG5cdE5PWE1MUEFSU0VSX0VSUk9SOiBcIlRpbnlYTUwgbm90IGZvdW5kLCB3aGVuIHVzaW5nIHdvcmtlcnMgcmVtZW1iZXIgdG8gcGFzcyB0aGUgVVJMIHRvIHRoZSB0aW55eG1sLmpzIGluIHRoZSBvcHRpb25zLmxpYnNQYXRoIChXb3JrZXJzIGRvIG5vdCBhbGxvdyB0byBhY2Nlc3MgdGhlIG5hdGl2ZSBYTUwgRE9NUGFyc2VyKVwiLFxuXHR0aHJvd0V4Y2VwdGlvbjogZnVuY3Rpb24gdGhyb3dFeGNlcHRpb24obXNnKSB7XG5cdFx0aWYgKGlzV29ya2VyKSBzZWxmLnBvc3RNZXNzYWdlKHsgYWN0aW9uOiBcImV4Y2VwdGlvblwiLCBtc2c6IG1zZyB9KTtlbHNlIGlmIChDb2xsYWRhLm9uZXJyb3IpIENvbGxhZGEub25lcnJvcihtc2cpO1xuXHRcdHRocm93IG1zZztcblx0fSxcblxuXHRnZXRGaWxlbmFtZTogZnVuY3Rpb24gZ2V0RmlsZW5hbWUoZmlsZW5hbWUpIHtcblx0XHR2YXIgcG9zID0gZmlsZW5hbWUubGFzdEluZGV4T2YoXCJcXFxcXCIpO1xuXHRcdGlmIChwb3MgIT0gLTEpIGZpbGVuYW1lID0gZmlsZW5hbWUuc3Vic3RyKHBvcyArIDEpO1xuXHRcdC8vc3RyaXAgdW5peCBzbGFzaGVzXG5cdFx0cG9zID0gZmlsZW5hbWUubGFzdEluZGV4T2YoXCIvXCIpO1xuXHRcdGlmIChwb3MgIT0gLTEpIGZpbGVuYW1lID0gZmlsZW5hbWUuc3Vic3RyKHBvcyArIDEpO1xuXHRcdHJldHVybiBmaWxlbmFtZTtcblx0fSxcblxuXHRsYXN0X25hbWU6IDAsXG5cblx0Z2VuZXJhdGVOYW1lOiBmdW5jdGlvbiBnZW5lcmF0ZU5hbWUodikge1xuXHRcdHYgPSB2IHx8IFwibmFtZV9cIjtcblx0XHR2YXIgbmFtZSA9IHYgKyB0aGlzLmxhc3RfbmFtZTtcblx0XHR0aGlzLmxhc3RfbmFtZSsrO1xuXHRcdHJldHVybiBuYW1lO1xuXHR9LFxuXG5cdHBhcnNlOiBmdW5jdGlvbiBwYXJzZShkYXRhLCBvcHRpb25zLCBmaWxlbmFtZSkge1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdGZpbGVuYW1lID0gZmlsZW5hbWUgfHwgXCJfZGFlX1wiICsgRGF0ZS5ub3coKSArIFwiLmRhZVwiO1xuXG5cdFx0Ly9jb25zb2xlLmxvZyhcIlBhcnNpbmcgY29sbGFkYVwiKTtcblx0XHR2YXIgZmxpcCA9IGZhbHNlO1xuXG5cdFx0dmFyIHhtbHBhcnNlciA9IG51bGw7XG5cdFx0dmFyIHJvb3QgPSBudWxsO1xuXHRcdHRoaXMuX3RyYW5zZmVyYWJsZXMgPSBbXTtcblxuXHRcdGlmICh0aGlzLnZlcmJvc2UpIGNvbnNvbGUubG9nKFwiIC0gWE1MIHBhcnNpbmcuLi5cIik7XG5cblx0XHRpZiAoZ2xvYmFsW1wiRE9NUGFyc2VyXCJdICYmICF0aGlzLmNvbmZpZy5mb3JjZVBhcnNlcikge1xuXHRcdFx0eG1scGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuXHRcdFx0cm9vdCA9IHhtbHBhcnNlci5wYXJzZUZyb21TdHJpbmcoZGF0YSwgXCJ0ZXh0L3htbFwiKTtcblx0XHRcdGlmICh0aGlzLnZlcmJvc2UpIGNvbnNvbGUubG9nKFwiIC0gWE1MIHBhcnNlZFwiKTtcblx0XHR9IGVsc2UgLy9VU0lORyBKUyBYTUwgUEFSU0VSIElNUExFTUVOVEFUSU9OIChtdWNoIHNsb3dlcilcblx0XHRcdHtcblx0XHRcdFx0aWYgKCFnbG9iYWxbXCJET01JbXBsZW1lbnRhdGlvblwiXSkgcmV0dXJuIENvbGxhZGEudGhyb3dFeGNlcHRpb24oQ29sbGFkYS5OT1hNTFBBUlNFUl9FUlJPUik7XG5cdFx0XHRcdC8vdXNlIHRpbnl4bWxwYXJzZXJcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR4bWxwYXJzZXIgPSBuZXcgRE9NSW1wbGVtZW50YXRpb24oKTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIENvbGxhZGEudGhyb3dFeGNlcHRpb24oQ29sbGFkYS5OT1hNTFBBUlNFUl9FUlJPUik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyb290ID0geG1scGFyc2VyLmxvYWRYTUwoZGF0YSk7XG5cdFx0XHRcdGlmICh0aGlzLnZlcmJvc2UpIGNvbnNvbGUubG9nKFwiIC0gWE1MIHBhcnNlZFwiKTtcblxuXHRcdFx0XHQvL2ZvciBldmVyeSBub2RlLi4uXG5cdFx0XHRcdHZhciBieV9pZHMgPSByb290Ll9ub2Rlc19ieV9pZCA9IHt9O1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHJvb3QuYWxsLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuXHRcdFx0XHRcdHZhciBub2RlID0gcm9vdC5hbGxbaV07XG5cdFx0XHRcdFx0YnlfaWRzW25vZGUuaWRdID0gbm9kZTtcblx0XHRcdFx0XHRpZiAobm9kZS5nZXRBdHRyaWJ1dGUoXCJzaWRcIikpIGJ5X2lkc1tub2RlLmdldEF0dHJpYnV0ZShcInNpZFwiKV0gPSBub2RlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCF0aGlzLmV4dHJhX2Z1bmN0aW9ucykge1xuXHRcdFx0XHRcdHRoaXMuZXh0cmFfZnVuY3Rpb25zID0gdHJ1ZTtcblx0XHRcdFx0XHQvL3RoZXNlIG1ldGhvZHMgYXJlIG1pc3Npbmcgc28gaGVyZSBpcyBhIGxvdXN5IGltcGxlbWVudGF0aW9uXG5cdFx0XHRcdFx0RE9NRG9jdW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3IgPSBET01FbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG5cdFx0XHRcdFx0XHR2YXIgdGFncyA9IHNlbGVjdG9yLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0XHRcdHZhciBjdXJyZW50X2VsZW1lbnQgPSB0aGlzO1xuXG5cdFx0XHRcdFx0XHR3aGlsZSAodGFncy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGN1cnJlbnQgPSB0YWdzLnNoaWZ0KCk7XG5cdFx0XHRcdFx0XHRcdHZhciB0b2tlbnMgPSBjdXJyZW50LnNwbGl0KFwiI1wiKTtcblx0XHRcdFx0XHRcdFx0dmFyIHRhZ25hbWUgPSB0b2tlbnNbMF07XG5cdFx0XHRcdFx0XHRcdHZhciBpZCA9IHRva2Vuc1sxXTtcblx0XHRcdFx0XHRcdFx0dmFyIGVsZW1lbnRzID0gdGFnbmFtZSA/IGN1cnJlbnRfZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWduYW1lKSA6IGN1cnJlbnRfZWxlbWVudC5jaGlsZE5vZGVzO1xuXHRcdFx0XHRcdFx0XHRpZiAoIWlkKSAvL25vIGlkIGZpbHRlclxuXHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICh0YWdzLmxlbmd0aCA9PSAwKSByZXR1cm4gZWxlbWVudHMuaXRlbSgwKTtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRfZWxlbWVudCA9IGVsZW1lbnRzLml0ZW0oMCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly9oYXMgaWQ/IGNoZWNrIGZvciBhbGwgdG8gc2VlIGlmIG9uZSBtYXRjaGVzIHRoZSBpZFxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGVsZW1lbnRzLml0ZW0oaSkuZ2V0QXR0cmlidXRlKFwiaWRcIikgPT0gaWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICh0YWdzLmxlbmd0aCA9PSAwKSByZXR1cm4gZWxlbWVudHMuaXRlbShpKTtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRfZWxlbWVudCA9IGVsZW1lbnRzLml0ZW0oaSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRET01Eb2N1bWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbCA9IERPTUVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcblx0XHRcdFx0XHRcdHZhciB0YWdzID0gc2VsZWN0b3Iuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdFx0aWYgKHRhZ3MubGVuZ3RoID09IDEpIHJldHVybiB0aGlzLmdldEVsZW1lbnRzQnlUYWdOYW1lKHNlbGVjdG9yKTtcblxuXHRcdFx0XHRcdFx0dmFyIGN1cnJlbnRfZWxlbWVudCA9IHRoaXM7XG5cdFx0XHRcdFx0XHR2YXIgcmVzdWx0ID0gW107XG5cblx0XHRcdFx0XHRcdGlubmVyKHRoaXMsIHRhZ3MpO1xuXG5cdFx0XHRcdFx0XHRmdW5jdGlvbiBpbm5lcihyb290LCB0YWdzKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghdGFncykgcmV0dXJuO1xuXG5cdFx0XHRcdFx0XHRcdHZhciBjdXJyZW50ID0gdGFncy5zaGlmdCgpO1xuXHRcdFx0XHRcdFx0XHR2YXIgZWxlbWVudHMgPSByb290LmdldEVsZW1lbnRzQnlUYWdOYW1lKGN1cnJlbnQpO1xuXHRcdFx0XHRcdFx0XHRpZiAodGFncy5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKGVsZW1lbnRzLml0ZW0oaSkpO1xuXHRcdFx0XHRcdFx0XHRcdH1yZXR1cm47XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5uZXIoZWxlbWVudHMuaXRlbShpKSwgdGFncy5jb25jYXQoKSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dmFyIGxpc3QgPSBuZXcgRE9NTm9kZUxpc3QodGhpcy5kb2N1bWVudEVsZW1lbnQpO1xuXHRcdFx0XHRcdFx0bGlzdC5fbm9kZXMgPSByZXN1bHQ7XG5cdFx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cblx0XHRcdFx0XHRcdHJldHVybiBsaXN0O1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoRE9NRWxlbWVudC5wcm90b3R5cGUsIFwidGV4dENvbnRlbnRcIiwge1xuXHRcdFx0XHRcdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBub2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbm9kZXMuaXRlbSgwKS50b1N0cmluZygpO1xuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdHNldDogZnVuY3Rpb24gc2V0KCkge31cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdHRoaXMuX3htbHJvb3QgPSByb290O1xuXHRcdHZhciB4bWxjb2xsYWRhID0gcm9vdC5xdWVyeVNlbGVjdG9yKFwiQ09MTEFEQVwiKTtcblx0XHRpZiAoeG1sY29sbGFkYSkge1xuXHRcdFx0dGhpcy5fY3VycmVudF9EQUVfdmVyc2lvbiA9IHhtbGNvbGxhZGEuZ2V0QXR0cmlidXRlKFwidmVyc2lvblwiKTtcblx0XHRcdGNvbnNvbGUubG9nKFwiREFFIFZlcnNpb246XCIgKyB0aGlzLl9jdXJyZW50X0RBRV92ZXJzaW9uKTtcblx0XHR9XG5cblx0XHQvL3ZhciB4bWx2aXN1YWxfc2NlbmUgPSByb290LnF1ZXJ5U2VsZWN0b3IoXCJ2aXN1YWxfc2NlbmVcIik7XG5cdFx0dmFyIHhtbHZpc3VhbF9zY2VuZSA9IHJvb3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ2aXN1YWxfc2NlbmVcIikuaXRlbSgwKTtcblx0XHRpZiAoIXhtbHZpc3VhbF9zY2VuZSkgdGhyb3cgXCJ2aXN1YWxfc2NlbmUgWE1MIG5vZGUgbm90IGZvdW5kIGluIERBRVwiO1xuXG5cdFx0Ly9oYWNrIHRvIGF2b2lkIHByb2JsZW1zIHdpdGggYm9uZXMgd2l0aCBzcGFjZXMgaW4gbmFtZXNcblx0XHR0aGlzLl9ub2Rlc19ieV9pZCA9IHt9OyAvL2NsZWFyXG5cdFx0dGhpcy5fY29udHJvbGxlcnNfZm91bmQgPSB7fTsgLy93ZSBuZWVkIHRvIGNoZWNrIHdoYXQgY29udHJvbGxlcnMgaGFkIGJlZW4gZm91bmQsIGluIGNhc2Ugd2UgbWlzcyBvbmUgYXQgdGhlIGVuZFxuXHRcdHRoaXMuX2dlb21ldHJpZXNfZm91bmQgPSB7fTtcblxuXHRcdC8vQ3JlYXRlIGEgc2NlbmUgdHJlZVxuXHRcdHZhciBzY2VuZSA9IHtcblx0XHRcdG9iamVjdF90eXBlOiBcIlNjZW5lVHJlZVwiLFxuXHRcdFx0bGlnaHQ6IG51bGwsXG5cdFx0XHRtYXRlcmlhbHM6IHt9LFxuXHRcdFx0bWVzaGVzOiB7fSxcblx0XHRcdHJlc291cmNlczoge30sIC8vdXNlZCB0byBzdG9yZSBhbmltYXRpb24gdHJhY2tzXG5cdFx0XHRyb290OiB7IGNoaWxkcmVuOiBbXSB9LFxuXHRcdFx0ZXh0ZXJuYWxfZmlsZXM6IHt9IC8vc3RvcmUgaW5mbyBhYm91dCBleHRlcm5hbCBmaWxlcyBtZW50aW9uZWQgaW4gdGhpcyBcblx0XHR9O1xuXG5cdFx0Ly9zY2VuZSBtZXRhZGF0YSAobGlrZSBhdXRob3IsIHRvb2wsIHVwIHZlY3RvciwgZGF0ZXMsIGV0Yylcblx0XHR2YXIgeG1sYXNzZXQgPSByb290LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYXNzZXRcIilbMF07XG5cdFx0aWYgKHhtbGFzc2V0KSBzY2VuZS5tZXRhZGF0YSA9IHRoaXMucmVhZEFzc2V0KHhtbGFzc2V0KTtcblxuXHRcdC8vcGFyc2Ugbm9kZXMgdHJlZSB0byBleHRyYWN0IG5hbWVzIGFuZCBpZXJhcmNoeSBvbmx5XG5cdFx0dmFyIHhtbG5vZGVzID0geG1sdmlzdWFsX3NjZW5lLmNoaWxkTm9kZXM7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWxub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHhtbG5vZGVzLml0ZW0oaSkubG9jYWxOYW1lICE9IFwibm9kZVwiKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIG5vZGUgPSB0aGlzLnJlYWROb2RlVHJlZSh4bWxub2Rlcy5pdGVtKGkpLCBzY2VuZSwgMCwgZmxpcCk7XG5cdFx0XHRpZiAobm9kZSkgc2NlbmUucm9vdC5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuXHRcdH1cblxuXHRcdC8vcGFyc2Ugbm9kZXMgY29udGVudCAodHdvIHN0ZXBzIHNvIHdlIGhhdmUgZmlyc3QgYWxsIHRoZSBzY2VuZSB0cmVlIGluZm8pXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWxub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHhtbG5vZGVzLml0ZW0oaSkubG9jYWxOYW1lICE9IFwibm9kZVwiKSBjb250aW51ZTtcblx0XHRcdHRoaXMucmVhZE5vZGVJbmZvKHhtbG5vZGVzLml0ZW0oaSksIHNjZW5lLCAwLCBmbGlwKTtcblx0XHR9XG5cblx0XHQvL3JlYWQgcmVtYWluaW5nIGNvbnRyb2xsZXJzIChpbiBzb21lIGNhc2VzIHNvbWUgY29udHJvbGxlcnMgYXJlIG5vdCBsaW5rZWQgZnJvbSB0aGUgbm9kZXMgb3IgdGhlIGdlb21ldHJpZXMpXG5cdFx0dGhpcy5yZWFkTGlicmFyeUNvbnRyb2xsZXJzKHNjZW5lKTtcblxuXHRcdC8vcmVhZCBhbmltYXRpb25zXG5cdFx0dmFyIGFuaW1hdGlvbnMgPSB0aGlzLnJlYWRBbmltYXRpb25zKHJvb3QsIHNjZW5lKTtcblx0XHRpZiAoYW5pbWF0aW9ucykge1xuXHRcdFx0dmFyIGFuaW1hdGlvbnNfbmFtZSA9IFwiI2FuaW1hdGlvbnNfXCIgKyBmaWxlbmFtZS5zdWJzdHIoMCwgZmlsZW5hbWUuaW5kZXhPZihcIi5cIikpO1xuXHRcdFx0c2NlbmUucmVzb3VyY2VzW2FuaW1hdGlvbnNfbmFtZV0gPSBhbmltYXRpb25zO1xuXHRcdFx0c2NlbmUucm9vdC5hbmltYXRpb25zID0gYW5pbWF0aW9uc19uYW1lO1xuXHRcdH1cblxuXHRcdC8vcmVhZCBleHRlcm5hbCBmaWxlcyAoaW1hZ2VzKVxuXHRcdHNjZW5lLmltYWdlcyA9IHRoaXMucmVhZEltYWdlcyhyb290KTtcblxuXHRcdC8vY2xlYXIgbWVtb3J5XG5cdFx0dGhpcy5fbm9kZXNfYnlfaWQgPSB7fTtcblx0XHR0aGlzLl9jb250cm9sbGVyc19mb3VuZCA9IHt9O1xuXHRcdHRoaXMuX2dlb21ldHJpZXNfZm91bmQgPSB7fTtcblx0XHR0aGlzLl94bWxyb290ID0gbnVsbDtcblxuXHRcdC8vY29uc29sZS5sb2coc2NlbmUpO1xuXHRcdHJldHVybiBzY2VuZTtcblx0fSxcblxuXHQvKiBDb2xsZWN0IG5vZGUgaWRzLCBpbiBjYXNlIHRoZXJlIGlzIGJvbmVzICh3aXRoIHNwYWNlcyBpbiBuYW1lKSBJIG5lZWQgdG8ga25vdyB0aGUgbm9kZW5hbWVzIGluIGFkdmFuY2UgKi9cblx0LypcbiByZWFkQWxsTm9kZU5hbWVzOiBmdW5jdGlvbih4bWxub2RlKVxuIHtcbiBcdHZhciBub2RlX2lkID0gdGhpcy5zYWZlU3RyaW5nKCB4bWxub2RlLmdldEF0dHJpYnV0ZShcImlkXCIpICk7XG4gXHRpZihub2RlX2lkKVxuIFx0XHR0aGlzLl9ub2Rlc19ieV9pZFtub2RlX2lkXSA9IHRydWU7IC8vbm9kZSBmb3VuZFxuIFx0Ly9ub2RlcyBzZWVtIHRvIGhhdmUgdG8gcG9zc2libGUgaWRzLCBpZCBhbmQgc2lkLCBJIGd1ZXNzIG9uZSBpcyB1bmlxdWUsIHRoZSBvdGhlciB1c2VyLWRlZmluZWRcbiBcdHZhciBub2RlX3NpZCA9IHRoaXMuc2FmZVN0cmluZyggeG1sbm9kZS5nZXRBdHRyaWJ1dGUoXCJzaWRcIikgKTtcbiBcdGlmKG5vZGVfc2lkKVxuIFx0XHR0aGlzLl9ub2Rlc19ieV9pZFtub2RlX3NpZF0gPSB0cnVlOyAvL25vZGUgZm91bmRcbiBcbiBcdGZvciggdmFyIGkgPSAwOyBpIDwgeG1sbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrIClcbiBcdHtcbiBcdFx0dmFyIHhtbGNoaWxkID0geG1sbm9kZS5jaGlsZE5vZGVzLml0ZW0oaSk7XG4gXHRcdFx0Ly9jaGlsZHJlblxuIFx0XHRpZih4bWxjaGlsZC5sb2NhbE5hbWUgIT0gXCJub2RlXCIpXG4gXHRcdFx0Y29udGludWU7XG4gXHRcdHRoaXMucmVhZEFsbE5vZGVOYW1lcyh4bWxjaGlsZCk7XG4gXHR9XG4gfSxcbiBcdCovXG5cblx0cmVhZEFzc2V0OiBmdW5jdGlvbiByZWFkQXNzZXQoeG1sYXNzZXQpIHtcblx0XHR2YXIgbWV0YWRhdGEgPSB7fTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1sYXNzZXQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHhtbGNoaWxkID0geG1sYXNzZXQuY2hpbGROb2Rlcy5pdGVtKGkpO1xuXHRcdFx0aWYgKHhtbGNoaWxkLm5vZGVUeXBlICE9IDEpIC8vbm90IHRhZ1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdHN3aXRjaCAoeG1sY2hpbGQubG9jYWxOYW1lKSB7XG5cdFx0XHRcdGNhc2UgXCJjb250cmlidXRvclwiOlxuXHRcdFx0XHRcdHZhciB0b29sID0geG1sY2hpbGQucXVlcnlTZWxlY3RvcihcImF1dGhvcmluZ190b29sXCIpO1xuXHRcdFx0XHRcdGlmICh0b29sKSBtZXRhZGF0YVtcImF1dGhvcmluZ190b29sXCJdID0gdG9vbC50ZXh0Q29udGV4dDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInVuaXRcIjpcblx0XHRcdFx0XHRtZXRhZGF0YVtcInVuaXRcIl0gPSB4bWxjaGlsZC5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpO2JyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdG1ldGFkYXRhW3htbGNoaWxkLmxvY2FsTmFtZV0gPSB4bWxjaGlsZC50ZXh0Q29udGVudDticmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWV0YWRhdGE7XG5cdH0sXG5cblx0cmVhZE5vZGVUcmVlOiBmdW5jdGlvbiByZWFkTm9kZVRyZWUoeG1sbm9kZSwgc2NlbmUsIGxldmVsLCBmbGlwKSB7XG5cdFx0dmFyIG5vZGVfaWQgPSB0aGlzLnNhZmVTdHJpbmcoeG1sbm9kZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSk7XG5cdFx0dmFyIG5vZGVfc2lkID0gdGhpcy5zYWZlU3RyaW5nKHhtbG5vZGUuZ2V0QXR0cmlidXRlKFwic2lkXCIpKTtcblxuXHRcdGlmICghbm9kZV9pZCAmJiAhbm9kZV9zaWQpIHJldHVybiBudWxsO1xuXG5cdFx0Ly9oZXJlIHdlIGNyZWF0ZSB0aGUgbm9kZVxuXHRcdHZhciBub2RlID0ge1xuXHRcdFx0aWQ6IG5vZGVfc2lkIHx8IG5vZGVfaWQsXG5cdFx0XHRjaGlsZHJlbjogW10sXG5cdFx0XHRfZGVwdGg6IGxldmVsXG5cdFx0fTtcblxuXHRcdHZhciBub2RlX3R5cGUgPSB4bWxub2RlLmdldEF0dHJpYnV0ZShcInR5cGVcIik7XG5cdFx0aWYgKG5vZGVfdHlwZSkgbm9kZS50eXBlID0gbm9kZV90eXBlO1xuXG5cdFx0dmFyIG5vZGVfbmFtZSA9IHhtbG5vZGUuZ2V0QXR0cmlidXRlKFwibmFtZVwiKTtcblx0XHRpZiAobm9kZV9uYW1lKSBub2RlLm5hbWUgPSBub2RlX25hbWU7XG5cdFx0dGhpcy5fbm9kZXNfYnlfaWRbbm9kZS5pZF0gPSBub2RlO1xuXHRcdGlmIChub2RlX2lkKSB0aGlzLl9ub2Rlc19ieV9pZFtub2RlX2lkXSA9IG5vZGU7XG5cdFx0aWYgKG5vZGVfc2lkKSB0aGlzLl9ub2Rlc19ieV9pZFtub2RlX3NpZF0gPSBub2RlO1xuXG5cdFx0Ly90cmFuc2Zvcm1cblx0XHRub2RlLm1vZGVsID0gdGhpcy5yZWFkVHJhbnNmb3JtKHhtbG5vZGUsIGxldmVsLCBmbGlwKTtcblxuXHRcdC8vbm9kZSBlbGVtZW50c1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1sbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgeG1sY2hpbGQgPSB4bWxub2RlLmNoaWxkTm9kZXMuaXRlbShpKTtcblx0XHRcdGlmICh4bWxjaGlsZC5ub2RlVHlwZSAhPSAxKSAvL25vdCB0YWdcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdC8vY2hpbGRyZW5cblx0XHRcdGlmICh4bWxjaGlsZC5sb2NhbE5hbWUgPT0gXCJub2RlXCIpIHtcblx0XHRcdFx0dmFyIGNoaWxkX25vZGUgPSB0aGlzLnJlYWROb2RlVHJlZSh4bWxjaGlsZCwgc2NlbmUsIGxldmVsICsgMSwgZmxpcCk7XG5cdFx0XHRcdGlmIChjaGlsZF9ub2RlKSBub2RlLmNoaWxkcmVuLnB1c2goY2hpbGRfbm9kZSk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBub2RlO1xuXHR9LFxuXG5cdHJlYWROb2RlSW5mbzogZnVuY3Rpb24gcmVhZE5vZGVJbmZvKHhtbG5vZGUsIHNjZW5lLCBsZXZlbCwgZmxpcCwgcGFyZW50KSB7XG5cdFx0dmFyIG5vZGVfaWQgPSB0aGlzLnNhZmVTdHJpbmcoeG1sbm9kZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSk7XG5cdFx0dmFyIG5vZGVfc2lkID0gdGhpcy5zYWZlU3RyaW5nKHhtbG5vZGUuZ2V0QXR0cmlidXRlKFwic2lkXCIpKTtcblxuXHRcdC8qXG4gIGlmKCFub2RlX2lkICYmICFub2RlX3NpZClcbiAge1xuICBcdGNvbnNvbGUud2FybihcIkNvbGxhZGE6IG5vZGUgd2l0aG91dCBpZCwgY3JlYXRpbmcgYSByYW5kb20gb25lXCIpO1xuICBcdG5vZGVfaWQgPSB0aGlzLmdlbmVyYXRlTmFtZShcIm5vZGVfXCIpO1xuICBcdHJldHVybiBudWxsO1xuICB9XG4gICovXG5cblx0XHR2YXIgbm9kZTtcblx0XHRpZiAoIW5vZGVfaWQgJiYgIW5vZGVfc2lkKSB7XG5cdFx0XHQvL2lmIHRoZXJlIGlzIG5vIGlkLCB0aGVuIGVpdGhlciBhbGwgb2YgdGhpcyBub2RlJ3MgcHJvcGVydGllcyBcblx0XHRcdC8vc2hvdWxkIGJlIGFzc2lnbmVkIGRpcmVjdGx5IHRvIGl0cyBwYXJlbnQgbm9kZSwgb3IgdGhlIG5vZGUgZG9lc24ndFxuXHRcdFx0Ly9oYXZlIGEgcGFyZW50IG5vZGUsIGluIHdoaWNoIGNhc2UgaXRzIGEgbGlnaHQgb3Igc29tZXRoaW5nLiBcblx0XHRcdC8vU28gd2UgZ2V0IHRoZSBwYXJlbnQgYnkgaXRzIGlkLCBhbmQgaWYgdGhlcmUgaXMgbm8gcGFyZW50LCB3ZSByZXR1cm4gbnVsbFxuXHRcdFx0aWYgKHBhcmVudCkgbm9kZSA9IHRoaXMuX25vZGVzX2J5X2lkW3BhcmVudC5pZCB8fCBwYXJlbnQuc2lkXTtlbHNlIHJldHVybiBudWxsO1xuXHRcdH0gZWxzZSBub2RlID0gdGhpcy5fbm9kZXNfYnlfaWRbbm9kZV9pZCB8fCBub2RlX3NpZF07XG5cblx0XHRpZiAoIW5vZGUpIHtcblx0XHRcdGNvbnNvbGUud2FybihcIkNvbGxhZGE6IE5vZGUgbm90IGZvdW5kIGJ5IGlkOiBcIiArIChub2RlX2lkIHx8IG5vZGVfc2lkKSk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHQvL25vZGUgZWxlbWVudHNcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHhtbGNoaWxkID0geG1sbm9kZS5jaGlsZE5vZGVzLml0ZW0oaSk7XG5cdFx0XHRpZiAoeG1sY2hpbGQubm9kZVR5cGUgIT0gMSkgLy9ub3QgdGFnXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHQvL2NoaWxkcmVuXG5cdFx0XHRpZiAoeG1sY2hpbGQubG9jYWxOYW1lID09IFwibm9kZVwiKSB7XG5cdFx0XHRcdC8vcGFzcyBwYXJlbnQgbm9kZSBpbiBjYXNlIGNoaWxkIG5vZGUgaXMgYSAnZGVhZCcgbm9kZSAoaGFzIG5vIGlkIG9yIHNpZClcblx0XHRcdFx0dGhpcy5yZWFkTm9kZUluZm8oeG1sY2hpbGQsIHNjZW5lLCBsZXZlbCArIDEsIGZsaXAsIHhtbG5vZGUpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly9nZW9tZXRyeVxuXHRcdFx0aWYgKHhtbGNoaWxkLmxvY2FsTmFtZSA9PSBcImluc3RhbmNlX2dlb21ldHJ5XCIpIHtcblx0XHRcdFx0dmFyIHVybCA9IHhtbGNoaWxkLmdldEF0dHJpYnV0ZShcInVybFwiKTtcblx0XHRcdFx0dmFyIG1lc2hfaWQgPSB1cmwudG9TdHJpbmcoKS5zdWJzdHIoMSk7XG5cdFx0XHRcdG5vZGUubWVzaCA9IG1lc2hfaWQ7XG5cblx0XHRcdFx0aWYgKCFzY2VuZS5tZXNoZXNbdXJsXSkge1xuXHRcdFx0XHRcdHZhciBtZXNoX2RhdGEgPSB0aGlzLnJlYWRHZW9tZXRyeSh1cmwsIGZsaXApO1xuXHRcdFx0XHRcdGlmIChtZXNoX2RhdGEpIHtcblx0XHRcdFx0XHRcdG1lc2hfZGF0YS5uYW1lID0gbWVzaF9pZDtcblx0XHRcdFx0XHRcdHNjZW5lLm1lc2hlc1ttZXNoX2lkXSA9IG1lc2hfZGF0YTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL2JpbmRlZCBtYXRlcmlhbFxuXHRcdFx0XHR2YXIgeG1sbWF0ZXJpYWxzID0geG1sY2hpbGQucXVlcnlTZWxlY3RvckFsbChcImluc3RhbmNlX21hdGVyaWFsXCIpO1xuXHRcdFx0XHRpZiAoeG1sbWF0ZXJpYWxzKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaU1hdCA9IDA7IGlNYXQgPCB4bWxtYXRlcmlhbHMubGVuZ3RoOyArK2lNYXQpIHtcblx0XHRcdFx0XHRcdHZhciB4bWxtYXRlcmlhbCA9IHhtbG1hdGVyaWFscy5pdGVtKGlNYXQpO1xuXHRcdFx0XHRcdFx0aWYgKCF4bWxtYXRlcmlhbCkge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oXCJpbnN0YW5jZV9tYXRlcmlhbCBub3QgZm91bmQ6IFwiICsgaSk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2YXIgbWF0bmFtZSA9IHhtbG1hdGVyaWFsLmdldEF0dHJpYnV0ZShcInRhcmdldFwiKS50b1N0cmluZygpLnN1YnN0cigxKTtcblx0XHRcdFx0XHRcdC8vbWF0bmFtZSA9IG1hdG5hbWUucmVwbGFjZSgvIC9nLFwiX1wiKTsgLy9uYW1lcyBjYW5ub3QgaGF2ZSBzcGFjZXNcblx0XHRcdFx0XHRcdGlmICghc2NlbmUubWF0ZXJpYWxzW21hdG5hbWVdKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIG1hdGVyaWFsID0gdGhpcy5yZWFkTWF0ZXJpYWwobWF0bmFtZSk7XG5cdFx0XHRcdFx0XHRcdGlmIChtYXRlcmlhbCkge1xuXHRcdFx0XHRcdFx0XHRcdG1hdGVyaWFsLmlkID0gbWF0bmFtZTtcblx0XHRcdFx0XHRcdFx0XHRzY2VuZS5tYXRlcmlhbHNbbWF0ZXJpYWwuaWRdID0gbWF0ZXJpYWw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChpTWF0ID09IDApIG5vZGUubWF0ZXJpYWwgPSBtYXRuYW1lO2Vsc2Uge1xuXHRcdFx0XHRcdFx0XHRpZiAoIW5vZGUubWF0ZXJpYWxzKSBub2RlLm1hdGVyaWFscyA9IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlLm1hdGVyaWFscy5wdXNoKG1hdG5hbWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvL3RoaXMgbm9kZSBoYXMgYSBjb250cm9sbGVyOiBza2lubmluZywgbW9ycGggdGFyZ2V0cyBvciBldmVuIG11bHRpbWF0ZXJpYWwgYXJlIGNvbnRyb2xsZXJzXG5cdFx0XHQvL3dhcm5pbmc6IEkgZGV0ZWN0ZWQgdGhhdCBzb21lIG5vZGVzIGNvdWxkIGhhdmUgYSBjb250cm9sbGVyIGJ1dCB0aGV5IGFyZSBub3QgcmVmZXJlbmNlZCBoZXJlLiAgPz9cblx0XHRcdGlmICh4bWxjaGlsZC5sb2NhbE5hbWUgPT0gXCJpbnN0YW5jZV9jb250cm9sbGVyXCIpIHtcblx0XHRcdFx0dmFyIHVybCA9IHhtbGNoaWxkLmdldEF0dHJpYnV0ZShcInVybFwiKTtcblx0XHRcdFx0dmFyIHhtbGNvbnRyb2xsZXIgPSB0aGlzLl94bWxyb290LnF1ZXJ5U2VsZWN0b3IoXCJjb250cm9sbGVyXCIgKyB1cmwpO1xuXG5cdFx0XHRcdGlmICh4bWxjb250cm9sbGVyKSB7XG5cblx0XHRcdFx0XHR2YXIgbWVzaF9kYXRhID0gdGhpcy5yZWFkQ29udHJvbGxlcih4bWxjb250cm9sbGVyLCBmbGlwLCBzY2VuZSk7XG5cblx0XHRcdFx0XHQvL2JpbmRlZCBtYXRlcmlhbHNcblx0XHRcdFx0XHR2YXIgeG1sYmluZF9tYXRlcmlhbCA9IHhtbGNoaWxkLnF1ZXJ5U2VsZWN0b3IoXCJiaW5kX21hdGVyaWFsXCIpO1xuXHRcdFx0XHRcdGlmICh4bWxiaW5kX21hdGVyaWFsKSB7XG5cdFx0XHRcdFx0XHQvL3JlbW92ZWQgcmVhZEJpbmRNYXRlcmlhbHMgdXAgaGVyZSBmb3IgY29uc2lzdGVuY3lcblx0XHRcdFx0XHRcdHZhciB4bWx0ZWNobmlxdWVzID0geG1sYmluZF9tYXRlcmlhbC5xdWVyeVNlbGVjdG9yQWxsKFwidGVjaG5pcXVlX2NvbW1vblwiKTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGlUZWMgPSAwOyBpVGVjIDwgeG1sdGVjaG5pcXVlcy5sZW5ndGg7IGlUZWMrKykge1xuXHRcdFx0XHRcdFx0XHR2YXIgeG1sdGVjaG5pcXVlID0geG1sdGVjaG5pcXVlcy5pdGVtKGlUZWMpO1xuXHRcdFx0XHRcdFx0XHR2YXIgeG1saW5zdGFuY2VfbWF0ZXJpYWxzID0geG1sdGVjaG5pcXVlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnN0YW5jZV9tYXRlcmlhbFwiKTtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaU1hdCA9IDA7IGlNYXQgPCB4bWxpbnN0YW5jZV9tYXRlcmlhbHMubGVuZ3RoOyBpTWF0KyspIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgeG1saW5zdGFuY2VfbWF0ZXJpYWwgPSB4bWxpbnN0YW5jZV9tYXRlcmlhbHMuaXRlbShpTWF0KTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIXhtbGluc3RhbmNlX21hdGVyaWFsKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oXCJpbnN0YW5jZV9tYXRlcmlhbCBmb3IgY29udHJvbGxlciBub3QgZm91bmQ6IFwiICsgeG1saW5zdGFuY2VfbWF0ZXJpYWwpO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHZhciBtYXRuYW1lID0geG1saW5zdGFuY2VfbWF0ZXJpYWwuZ2V0QXR0cmlidXRlKFwidGFyZ2V0XCIpLnRvU3RyaW5nKCkuc3Vic3RyKDEpO1xuXHRcdFx0XHRcdFx0XHRcdGlmICghc2NlbmUubWF0ZXJpYWxzW21hdG5hbWVdKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHZhciBtYXRlcmlhbCA9IHRoaXMucmVhZE1hdGVyaWFsKG1hdG5hbWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKG1hdGVyaWFsKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG1hdGVyaWFsLmlkID0gbWF0bmFtZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0c2NlbmUubWF0ZXJpYWxzW21hdGVyaWFsLmlkXSA9IG1hdGVyaWFsO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAoaU1hdCA9PSAwKSBub2RlLm1hdGVyaWFsID0gbWF0bmFtZTtlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICghbm9kZS5tYXRlcmlhbHMpIG5vZGUubWF0ZXJpYWxzID0gW107XG5cdFx0XHRcdFx0XHRcdFx0XHRub2RlLm1hdGVyaWFscy5wdXNoKG1hdG5hbWUpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChtZXNoX2RhdGEpIHtcblx0XHRcdFx0XHRcdHZhciBtZXNoID0gbWVzaF9kYXRhO1xuXHRcdFx0XHRcdFx0aWYgKG1lc2hfZGF0YS50eXBlID09IFwibW9ycGhcIikge1xuXHRcdFx0XHRcdFx0XHRtZXNoID0gbWVzaF9kYXRhLm1lc2g7XG5cdFx0XHRcdFx0XHRcdG5vZGUubW9ycGhfdGFyZ2V0cyA9IG1lc2hfZGF0YS5tb3JwaF90YXJnZXRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRtZXNoLm5hbWUgPSB1cmwudG9TdHJpbmcoKTtcblx0XHRcdFx0XHRcdG5vZGUubWVzaCA9IHVybC50b1N0cmluZygpO1xuXHRcdFx0XHRcdFx0c2NlbmUubWVzaGVzW3VybF0gPSBtZXNoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvL2xpZ2h0XG5cdFx0XHRpZiAoeG1sY2hpbGQubG9jYWxOYW1lID09IFwiaW5zdGFuY2VfbGlnaHRcIikge1xuXHRcdFx0XHR2YXIgdXJsID0geG1sY2hpbGQuZ2V0QXR0cmlidXRlKFwidXJsXCIpO1xuXHRcdFx0XHR0aGlzLnJlYWRMaWdodChub2RlLCB1cmwpO1xuXHRcdFx0fVxuXG5cdFx0XHQvL2NhbWVyYVxuXHRcdFx0aWYgKHhtbGNoaWxkLmxvY2FsTmFtZSA9PSBcImluc3RhbmNlX2NhbWVyYVwiKSB7XG5cdFx0XHRcdHZhciB1cmwgPSB4bWxjaGlsZC5nZXRBdHRyaWJ1dGUoXCJ1cmxcIik7XG5cdFx0XHRcdHRoaXMucmVhZENhbWVyYShub2RlLCB1cmwpO1xuXHRcdFx0fVxuXG5cdFx0XHQvL290aGVyIHBvc3NpYmxlIHRhZ3M/XG5cdFx0fVxuXHR9LFxuXG5cdC8vaWYgeW91IHdhbnQgdG8gcmVuYW1lIHNvbWUgbWF0ZXJpYWwgbmFtZXNcblx0bWF0ZXJpYWxfdHJhbnNsYXRlX3RhYmxlOiB7XG5cdFx0LypcbiAgdHJhbnNwYXJlbmN5OiBcIm9wYWNpdHlcIixcbiAgcmVmbGVjdGl2aXR5OiBcInJlZmxlY3Rpb25fZmFjdG9yXCIsXG4gIHNwZWN1bGFyOiBcInNwZWN1bGFyX2ZhY3RvclwiLFxuICBzaGluaW5lc3M6IFwic3BlY3VsYXJfZ2xvc3NcIixcbiAgZW1pc3Npb246IFwiZW1pc3NpdmVcIixcbiAgZGlmZnVzZTogXCJjb2xvclwiXG4gICovXG5cdH0sXG5cblx0bGlnaHRfdHJhbnNsYXRlX3RhYmxlOiB7XG5cblx0XHRwb2ludDogXCJvbW5pXCIsXG5cdFx0ZGlyZWN0aW9uYWw6IFwiZGlyZWN0aW9uYWxcIixcblx0XHRzcG90OiBcInNwb3RcIlxuXHR9LFxuXG5cdGNhbWVyYV90cmFuc2xhdGVfdGFibGU6IHtcblx0XHR4Zm92OiBcImZvdlwiLFxuXHRcdGFzcGVjdF9yYXRpbzogXCJhc3BlY3RcIixcblx0XHR6bmVhcjogXCJuZWFyXCIsXG5cdFx0emZhcjogXCJmYXJcIlxuXHR9LFxuXG5cdC8vdXNlZCB3aGVuIGlkIGhhdmUgc3BhY2VzIChyZWd1bGFyIHNlbGVjdG9yIGRvIG5vdCBzdXBwb3J0IHNwYWNlcylcblx0cXVlcnlTZWxlY3RvckFuZElkOiBmdW5jdGlvbiBxdWVyeVNlbGVjdG9yQW5kSWQocm9vdCwgc2VsZWN0b3IsIGlkKSB7XG5cdFx0dmFyIG5vZGVzID0gcm9vdC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXR0cl9pZCA9IG5vZGVzLml0ZW0oaSkuZ2V0QXR0cmlidXRlKFwiaWRcIik7XG5cdFx0XHRpZiAoIWF0dHJfaWQpIGNvbnRpbnVlO1xuXHRcdFx0YXR0cl9pZCA9IGF0dHJfaWQudG9TdHJpbmcoKTtcblx0XHRcdGlmIChhdHRyX2lkID09IGlkKSByZXR1cm4gbm9kZXMuaXRlbShpKTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Ly9yZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgbWF0Y2hlcyBhIHRhZyBuYW1lLCBpZiBub3QgdGFnbmFtZSBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgdGFnIGVsZW1lbnRcblx0Z2V0Rmlyc3RDaGlsZEVsZW1lbnQ6IGZ1bmN0aW9uIGdldEZpcnN0Q2hpbGRFbGVtZW50KHJvb3QsIGxvY2FsTmFtZSkge1xuXHRcdHZhciBjID0gcm9vdC5jaGlsZE5vZGVzO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYy5sZW5ndGg7ICsraSkge1xuXHRcdFx0dmFyIGl0ZW0gPSBjLml0ZW0oaSk7XG5cdFx0XHRpZiAoaXRlbS5sb2NhbE5hbWUgJiYgIWxvY2FsTmFtZSB8fCBsb2NhbE5hbWUgJiYgbG9jYWxOYW1lID09IGl0ZW0ubG9jYWxOYW1lKSByZXR1cm4gaXRlbTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0cmVhZE1hdGVyaWFsOiBmdW5jdGlvbiByZWFkTWF0ZXJpYWwodXJsKSB7XG5cdFx0dmFyIHhtbG1hdGVyaWFsID0gdGhpcy5xdWVyeVNlbGVjdG9yQW5kSWQodGhpcy5feG1scm9vdCwgXCJsaWJyYXJ5X21hdGVyaWFscyBtYXRlcmlhbFwiLCB1cmwpO1xuXG5cdFx0aWYgKCF4bWxtYXRlcmlhbCkgcmV0dXJuIG51bGw7XG5cblx0XHQvL2dldCBlZmZlY3QgbmFtZVxuXHRcdHZhciB4bWxlZmZlY3QgPSB4bWxtYXRlcmlhbC5xdWVyeVNlbGVjdG9yKFwiaW5zdGFuY2VfZWZmZWN0XCIpO1xuXHRcdGlmICgheG1sZWZmZWN0KSByZXR1cm4gbnVsbDtcblxuXHRcdHZhciBlZmZlY3RfdXJsID0geG1sZWZmZWN0LmdldEF0dHJpYnV0ZShcInVybFwiKS5zdWJzdHIoMSk7XG5cblx0XHQvL2dldCBlZmZlY3Rcblx0XHR2YXIgeG1sZWZmZWN0cyA9IHRoaXMucXVlcnlTZWxlY3RvckFuZElkKHRoaXMuX3htbHJvb3QsIFwibGlicmFyeV9lZmZlY3RzIGVmZmVjdFwiLCBlZmZlY3RfdXJsKTtcblxuXHRcdGlmICgheG1sZWZmZWN0cykgcmV0dXJuIG51bGw7XG5cblx0XHQvL2dldCBjb21tb25cblx0XHR2YXIgeG1sdGVjaG5pcXVlID0geG1sZWZmZWN0cy5xdWVyeVNlbGVjdG9yKFwidGVjaG5pcXVlXCIpO1xuXHRcdGlmICgheG1sdGVjaG5pcXVlKSByZXR1cm4gbnVsbDtcblxuXHRcdC8vZ2V0IG5ld3BhcmFtcyBhbmQgY29udmVydCB0byBqcyBvYmplY3Rcblx0XHR2YXIgeG1sbmV3cGFyYW1zID0geG1sZWZmZWN0cy5xdWVyeVNlbGVjdG9yQWxsKFwibmV3cGFyYW1cIik7XG5cdFx0dmFyIG5ld3BhcmFtcyA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1sbmV3cGFyYW1zLmxlbmd0aDsgaSsrKSB7XG5cblx0XHRcdHZhciBpbml0X2Zyb20gPSB4bWxuZXdwYXJhbXNbaV0ucXVlcnlTZWxlY3RvcihcImluaXRfZnJvbVwiKTtcblx0XHRcdHZhciBwYXJlbnQ7XG5cdFx0XHRpZiAoaW5pdF9mcm9tKSBwYXJlbnQgPSBpbml0X2Zyb20uaW5uZXJIVE1MO2Vsc2Uge1xuXHRcdFx0XHR2YXIgc291cmNlID0geG1sbmV3cGFyYW1zW2ldLnF1ZXJ5U2VsZWN0b3IoXCJzb3VyY2VcIik7XG5cdFx0XHRcdHBhcmVudCA9IHNvdXJjZS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdG5ld3BhcmFtc1t4bWxuZXdwYXJhbXNbaV0uZ2V0QXR0cmlidXRlKFwic2lkXCIpXSA9IHtcblx0XHRcdFx0cGFyZW50OiBwYXJlbnRcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0dmFyIG1hdGVyaWFsID0ge307XG5cblx0XHQvL3JlYWQgdGhlIGltYWdlcyBoZXJlIGJlY2F1c2Ugd2UgbmVlZCB0byBhY2Nlc3MgdGhlbSB0byBhc3NpZ24gdGV4dHVyZSBuYW1lc1xuXHRcdHZhciBpbWFnZXMgPSB0aGlzLnJlYWRJbWFnZXModGhpcy5feG1scm9vdCk7XG5cblx0XHR2YXIgeG1scGhvbmcgPSB4bWx0ZWNobmlxdWUucXVlcnlTZWxlY3RvcihcInBob25nXCIpO1xuXHRcdGlmICgheG1scGhvbmcpIHhtbHBob25nID0geG1sdGVjaG5pcXVlLnF1ZXJ5U2VsZWN0b3IoXCJibGlublwiKTtcblx0XHRpZiAoIXhtbHBob25nKSB4bWxwaG9uZyA9IHhtbHRlY2huaXF1ZS5xdWVyeVNlbGVjdG9yKFwibGFtYmVydFwiKTtcblx0XHRpZiAoIXhtbHBob25nKSByZXR1cm4gbnVsbDtcblxuXHRcdC8vZm9yIGV2ZXJ5IHRhZyBvZiBwcm9wZXJ0aWVzXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWxwaG9uZy5jaGlsZE5vZGVzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHR2YXIgeG1scGFyYW0gPSB4bWxwaG9uZy5jaGlsZE5vZGVzLml0ZW0oaSk7XG5cblx0XHRcdGlmICgheG1scGFyYW0ubG9jYWxOYW1lKSAvL3RleHQgdGFnXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHQvL3RyYW5zbGF0ZSBuYW1lXG5cdFx0XHR2YXIgcGFyYW1fbmFtZSA9IHhtbHBhcmFtLmxvY2FsTmFtZS50b1N0cmluZygpO1xuXHRcdFx0aWYgKHRoaXMubWF0ZXJpYWxfdHJhbnNsYXRlX3RhYmxlW3BhcmFtX25hbWVdKSBwYXJhbV9uYW1lID0gdGhpcy5tYXRlcmlhbF90cmFuc2xhdGVfdGFibGVbcGFyYW1fbmFtZV07XG5cblx0XHRcdC8vdmFsdWVcblx0XHRcdHZhciB4bWxwYXJhbV92YWx1ZSA9IHRoaXMuZ2V0Rmlyc3RDaGlsZEVsZW1lbnQoeG1scGFyYW0pO1xuXHRcdFx0aWYgKCF4bWxwYXJhbV92YWx1ZSkgY29udGludWU7XG5cblx0XHRcdGlmICh4bWxwYXJhbV92YWx1ZS5sb2NhbE5hbWUudG9TdHJpbmcoKSA9PSBcImNvbG9yXCIpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcy5yZWFkQ29udGVudEFzRmxvYXRzKHhtbHBhcmFtX3ZhbHVlKTtcblx0XHRcdFx0aWYgKHhtbHBhcmFtLmdldEF0dHJpYnV0ZShcIm9wYXF1ZVwiKSA9PSBcIlJHQl9aRVJPXCIpIG1hdGVyaWFsW3BhcmFtX25hbWVdID0gdmFsdWUuc3ViYXJyYXkoMCwgNCk7ZWxzZSBtYXRlcmlhbFtwYXJhbV9uYW1lXSA9IHZhbHVlLnN1YmFycmF5KDAsIDMpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gZWxzZSBpZiAoeG1scGFyYW1fdmFsdWUubG9jYWxOYW1lLnRvU3RyaW5nKCkgPT0gXCJmbG9hdFwiKSB7XG5cdFx0XHRcdG1hdGVyaWFsW3BhcmFtX25hbWVdID0gdGhpcy5yZWFkQ29udGVudEFzRmxvYXRzKHhtbHBhcmFtX3ZhbHVlKVswXTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9IGVsc2UgaWYgKHhtbHBhcmFtX3ZhbHVlLmxvY2FsTmFtZS50b1N0cmluZygpID09IFwidGV4dHVyZVwiKSB7XG5cdFx0XHRcdGlmICghbWF0ZXJpYWwudGV4dHVyZXMpIG1hdGVyaWFsLnRleHR1cmVzID0ge307XG5cdFx0XHRcdHZhciBtYXBfaWQgPSB4bWxwYXJhbV92YWx1ZS5nZXRBdHRyaWJ1dGUoXCJ0ZXh0dXJlXCIpO1xuXHRcdFx0XHRpZiAoIW1hcF9pZCkgY29udGludWU7XG5cblx0XHRcdFx0Ly8gaWYgbWFwX2lkIGlzIG5vdCBhIGZpbGVuYW1lLCBsZXRzIGdvIGFuZCBsb29rIGZvciBpdC5cblx0XHRcdFx0aWYgKG1hcF9pZC5pbmRleE9mKCcuJykgPT09IC0xKSB7XG5cdFx0XHRcdFx0Ly9jaGVjayBlZmZlY3QgcGFyZW50c1xuXHRcdFx0XHRcdG1hcF9pZCA9IHRoaXMuZ2V0UGFyZW50UGFyYW0obmV3cGFyYW1zLCBtYXBfaWQpO1xuXG5cdFx0XHRcdFx0aWYgKGltYWdlc1ttYXBfaWRdKSBtYXBfaWQgPSBpbWFnZXNbbWFwX2lkXS5wYXRoO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9ub3cgZ2V0IHRoZSB0ZXh0dXJlIGZpbGVuYW1lIGZyb20gaW1hZ2VzXG5cblx0XHRcdFx0dmFyIG1hcF9pbmZvID0geyBtYXBfaWQ6IG1hcF9pZCB9O1xuXHRcdFx0XHR2YXIgdXZzID0geG1scGFyYW1fdmFsdWUuZ2V0QXR0cmlidXRlKFwidGV4Y29vcmRcIik7XG5cdFx0XHRcdG1hcF9pbmZvLnV2cyA9IHV2cztcblx0XHRcdFx0bWF0ZXJpYWwudGV4dHVyZXNbcGFyYW1fbmFtZV0gPSBtYXBfaW5mbztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRtYXRlcmlhbC5vYmplY3RfdHlwZSA9IFwiTWF0ZXJpYWxcIjtcblx0XHRyZXR1cm4gbWF0ZXJpYWw7XG5cdH0sXG5cblx0Z2V0UGFyZW50UGFyYW06IGZ1bmN0aW9uIGdldFBhcmVudFBhcmFtKG5ld3BhcmFtcywgcGFyYW0pIHtcblx0XHRpZiAoIW5ld3BhcmFtc1twYXJhbV0pIHJldHVybiBwYXJhbTtcblxuXHRcdGlmIChuZXdwYXJhbXNbcGFyYW1dLnBhcmVudCkgcmV0dXJuIHRoaXMuZ2V0UGFyZW50UGFyYW0obmV3cGFyYW1zLCBuZXdwYXJhbXNbcGFyYW1dLnBhcmVudCk7ZWxzZSByZXR1cm4gcGFyYW07XG5cdH0sXG5cblx0cmVhZExpZ2h0OiBmdW5jdGlvbiByZWFkTGlnaHQobm9kZSwgdXJsKSB7XG5cdFx0dmFyIGxpZ2h0ID0ge307XG5cblx0XHR2YXIgeG1sbm9kZSA9IG51bGw7XG5cblx0XHRpZiAodXJsLmxlbmd0aCA+IDEpIC8vd2VpcmQgY2FzZXMgd2l0aCBpZCA9PSAjXG5cdFx0XHR4bWxub2RlID0gdGhpcy5feG1scm9vdC5xdWVyeVNlbGVjdG9yKFwibGlicmFyeV9saWdodHMgXCIgKyB1cmwpO2Vsc2Uge1xuXHRcdFx0dmFyIHhtbGxpYmxpZ2h0cyA9IHRoaXMuX3htbHJvb3QucXVlcnlTZWxlY3RvcihcImxpYnJhcnlfbGlnaHRzXCIpO1xuXHRcdFx0eG1sbm9kZSA9IHRoaXMuZ2V0Rmlyc3RDaGlsZEVsZW1lbnQoeG1sbGlibGlnaHRzLCBcImxpZ2h0XCIpO1xuXHRcdH1cblxuXHRcdGlmICgheG1sbm9kZSkgcmV0dXJuIG51bGw7XG5cblx0XHQvL3BhY2tcblx0XHR2YXIgY2hpbGRyZW4gPSBbXTtcblx0XHR2YXIgeG1sID0geG1sbm9kZS5xdWVyeVNlbGVjdG9yKFwidGVjaG5pcXVlX2NvbW1vblwiKTtcblx0XHRpZiAoeG1sKSBmb3IgKHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoeG1sLmNoaWxkTm9kZXMuaXRlbShpKS5ub2RlVHlwZSA9PSAxKSAvL3RhZ1xuXHRcdFx0XHRjaGlsZHJlbi5wdXNoKHhtbC5jaGlsZE5vZGVzLml0ZW0oaSkpO1xuXHRcdH12YXIgeG1scyA9IHhtbG5vZGUucXVlcnlTZWxlY3RvckFsbChcInRlY2huaXF1ZVwiKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB4bWwyID0geG1scy5pdGVtKGkpO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCB4bWwyLmNoaWxkTm9kZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0aWYgKHhtbDIuY2hpbGROb2Rlcy5pdGVtKGopLm5vZGVUeXBlID09IDEpIC8vdGFnXG5cdFx0XHRcdFx0Y2hpbGRyZW4ucHVzaCh4bWwyLmNoaWxkTm9kZXMuaXRlbShqKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9nZXRcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgeG1sID0gY2hpbGRyZW5baV07XG5cdFx0XHRzd2l0Y2ggKHhtbC5sb2NhbE5hbWUpIHtcblx0XHRcdFx0Y2FzZSBcInBvaW50XCI6XG5cdFx0XHRcdFx0bGlnaHQudHlwZSA9IHRoaXMubGlnaHRfdHJhbnNsYXRlX3RhYmxlW3htbC5sb2NhbE5hbWVdO1xuXHRcdFx0XHRcdHBhcnNlX3BhcmFtcyhsaWdodCwgeG1sKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImRpcmVjdGlvbmFsXCI6XG5cdFx0XHRcdFx0bGlnaHQudHlwZSA9IHRoaXMubGlnaHRfdHJhbnNsYXRlX3RhYmxlW3htbC5sb2NhbE5hbWVdO1xuXHRcdFx0XHRcdHBhcnNlX3BhcmFtcyhsaWdodCwgeG1sKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInNwb3RcIjpcblx0XHRcdFx0XHRsaWdodC50eXBlID0gdGhpcy5saWdodF90cmFuc2xhdGVfdGFibGVbeG1sLmxvY2FsTmFtZV07XG5cdFx0XHRcdFx0cGFyc2VfcGFyYW1zKGxpZ2h0LCB4bWwpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgXCJpbnRlbnNpdHlcIjpcblx0XHRcdFx0XHRsaWdodC5pbnRlbnNpdHkgPSB0aGlzLnJlYWRDb250ZW50QXNGbG9hdHMoeG1sKVswXTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZV9wYXJhbXMobGlnaHQsIHhtbCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlcy5pdGVtKGkpO1xuXHRcdFx0XHRpZiAoIWNoaWxkIHx8IGNoaWxkLm5vZGVUeXBlICE9IDEpIC8vdGFnXG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoIChjaGlsZC5sb2NhbE5hbWUpIHtcblx0XHRcdFx0XHRjYXNlIFwiY29sb3JcIjpcblx0XHRcdFx0XHRcdGxpZ2h0LmNvbG9yID0gQ29sbGFkYS5yZWFkQ29udGVudEFzRmxvYXRzKGNoaWxkKTticmVhaztcblx0XHRcdFx0XHRjYXNlIFwiZmFsbG9mZl9hbmdsZVwiOlxuXHRcdFx0XHRcdFx0bGlnaHQuYW5nbGVfZW5kID0gQ29sbGFkYS5yZWFkQ29udGVudEFzRmxvYXRzKGNoaWxkKVswXTtcblx0XHRcdFx0XHRcdGxpZ2h0LmFuZ2xlID0gbGlnaHQuYW5nbGVfZW5kIC0gMTA7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChub2RlLm1vZGVsKSB7XG5cdFx0XHQvL2xpZ2h0IHBvc2l0aW9uIGlzIGZpbmFsIGNvbHVtbiBvZiBtb2RlbFxuXHRcdFx0bGlnaHQucG9zaXRpb24gPSBbbm9kZS5tb2RlbFsxMl0sIG5vZGUubW9kZWxbMTNdLCBub2RlLm1vZGVsWzE0XV07XG5cdFx0XHQvL2xpZ2h0IGZvcndhcmQgdmVjdG9yIGlzIHJldmVyc2Ugb2YgdGhpcmQgY29sdW1uIG9mIG1vZGVsXG5cdFx0XHR2YXIgZm9yd2FyZCA9IFstbm9kZS5tb2RlbFs4XSwgLW5vZGUubW9kZWxbOV0sIC1ub2RlLm1vZGVsWzEwXV07XG5cdFx0XHQvL3NvIGxpZ2h0IHRhcmdldCBpcyBwb3NpdGlvbiArIGZvcndhcmRcblx0XHRcdGxpZ2h0LnRhcmdldCA9IFtsaWdodC5wb3NpdGlvblswXSArIGZvcndhcmRbMF0sIGxpZ2h0LnBvc2l0aW9uWzFdICsgZm9yd2FyZFsxXSwgbGlnaHQucG9zaXRpb25bMl0gKyBmb3J3YXJkWzJdXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS53YXJuKFwiQ291bGQgbm90IHJlYWQgbGlnaHQgcG9zaXRpb24gZm9yIGxpZ2h0OiBcIiArIG5vZGUubmFtZSArIFwiLiBTZXR0aW5nIGRlZmF1bHRzLlwiKTtcblx0XHRcdGxpZ2h0LnBvc2l0aW9uID0gWzAsIDAsIDBdO1xuXHRcdFx0bGlnaHQudGFyZ2V0ID0gWzAsIC0xLCAwXTtcblx0XHR9XG5cblx0XHRub2RlLmxpZ2h0ID0gbGlnaHQ7XG5cdH0sXG5cblx0cmVhZENhbWVyYTogZnVuY3Rpb24gcmVhZENhbWVyYShub2RlLCB1cmwpIHtcblx0XHR2YXIgY2FtZXJhID0ge307XG5cblx0XHR2YXIgeG1sbm9kZSA9IHRoaXMuX3htbHJvb3QucXVlcnlTZWxlY3RvcihcImxpYnJhcnlfY2FtZXJhcyBcIiArIHVybCk7XG5cdFx0aWYgKCF4bWxub2RlKSByZXR1cm4gbnVsbDtcblxuXHRcdC8vcGFja1xuXHRcdHZhciBjaGlsZHJlbiA9IFtdO1xuXHRcdHZhciB4bWwgPSB4bWxub2RlLnF1ZXJ5U2VsZWN0b3IoXCJ0ZWNobmlxdWVfY29tbW9uXCIpO1xuXHRcdGlmICh4bWwpIC8vZ3JhYiBhbGwgaW50ZXJuYWwgc3R1ZmZcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHhtbC5jaGlsZE5vZGVzLml0ZW0oaSkubm9kZVR5cGUgPT0gMSkgLy90YWdcblx0XHRcdFx0XHRjaGlsZHJlbi5wdXNoKHhtbC5jaGlsZE5vZGVzLml0ZW0oaSkpO1xuXHRcdFx0fSAvL1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB0YWcgPSBjaGlsZHJlbltpXTtcblx0XHRcdHBhcnNlX3BhcmFtcyhjYW1lcmEsIHRhZyk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VfcGFyYW1zKGNhbWVyYSwgeG1sKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzLml0ZW0oaSk7XG5cdFx0XHRcdGlmICghY2hpbGQgfHwgY2hpbGQubm9kZVR5cGUgIT0gMSkgLy90YWdcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0dmFyIHRyYW5zbGF0ZWQgPSBDb2xsYWRhLmNhbWVyYV90cmFuc2xhdGVfdGFibGVbY2hpbGQubG9jYWxOYW1lXSB8fCBjaGlsZC5sb2NhbE5hbWU7XG5cdFx0XHRcdGNhbWVyYVt0cmFuc2xhdGVkXSA9IHBhcnNlRmxvYXQoY2hpbGQudGV4dENvbnRlbnQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vcGFyc2UgdG8gY29udmVydCB5Zm92IHRvIHN0YW5kYXJkICh4KSBmb3Zcblx0XHRpZiAoY2FtZXJhLnlmb3YgJiYgIWNhbWVyYS5mb3YpIHtcblx0XHRcdGlmIChjYW1lcmEuYXNwZWN0KSB7XG5cdFx0XHRcdGNhbWVyYS5mb3YgPSBjYW1lcmEueWZvdiAqIGNhbWVyYS5hc3BlY3Q7XG5cdFx0XHR9IGVsc2UgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGNvbnZlcnQgY2FtZXJhIHlmb3YgdG8geGZvdiBiZWNhdXNlIGFzcGVjdCByYXRpbyBub3Qgc2V0XCIpO1xuXHRcdH1cblxuXHRcdG5vZGUuY2FtZXJhID0gY2FtZXJhO1xuXHR9LFxuXG5cdHJlYWRUcmFuc2Zvcm06IGZ1bmN0aW9uIHJlYWRUcmFuc2Zvcm0oeG1sbm9kZSwgbGV2ZWwsIGZsaXApIHtcblx0XHQvL2lkZW50aXR5XG5cdFx0dmFyIG1hdHJpeCA9IF9nbE1hdHJpeC5tYXQ0LmNyZWF0ZSgpO1xuXHRcdHZhciB0ZW1wID0gX2dsTWF0cml4Lm1hdDQuY3JlYXRlKCk7XG5cdFx0dmFyIHRtcHEgPSBfZ2xNYXRyaXgucXVhdC5jcmVhdGUoKTtcblxuXHRcdHZhciBmbGlwX2ZpeCA9IGZhbHNlO1xuXG5cdFx0Ly9zZWFyY2ggZm9yIHRoZSBtYXRyaXhcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHhtbCA9IHhtbG5vZGUuY2hpbGROb2Rlcy5pdGVtKGkpO1xuXHRcdFx0aWYgKCF4bWwgfHwgeG1sLm5vZGVUeXBlICE9IDEpIC8vdGFnXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRpZiAoeG1sLmxvY2FsTmFtZSA9PSBcIm1hdHJpeFwiKSB7XG5cdFx0XHRcdHZhciBtYXRyaXggPSB0aGlzLnJlYWRDb250ZW50QXNGbG9hdHMoeG1sKTtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcIk5vZGVuYW1lOiBcIiArIHhtbG5vZGUuZ2V0QXR0cmlidXRlKFwiaWRcIikpO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKG1hdHJpeCk7XG5cdFx0XHRcdHRoaXMudHJhbnNmb3JtTWF0cml4KG1hdHJpeCwgbGV2ZWwgPT0gMCk7XG5cdFx0XHRcdC8vY29uc29sZS5sb2cobWF0cml4KTtcblx0XHRcdFx0cmV0dXJuIG1hdHJpeDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHhtbC5sb2NhbE5hbWUgPT0gXCJ0cmFuc2xhdGVcIikge1xuXHRcdFx0XHR2YXIgdmFsdWVzID0gdGhpcy5yZWFkQ29udGVudEFzRmxvYXRzKHhtbCk7XG5cdFx0XHRcdGlmIChmbGlwICYmIGxldmVsID4gMCkge1xuXHRcdFx0XHRcdHZhciB0bXAgPSB2YWx1ZXNbMV07XG5cdFx0XHRcdFx0dmFsdWVzWzFdID0gdmFsdWVzWzJdO1xuXHRcdFx0XHRcdHZhbHVlc1syXSA9IC10bXA7IC8vc3dhcCBjb29yZHNcblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9nbE1hdHJpeC5tYXQ0LnRyYW5zbGF0ZShtYXRyaXgsIG1hdHJpeCwgdmFsdWVzKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vcm90YXRlXG5cdFx0XHRpZiAoeG1sLmxvY2FsTmFtZSA9PSBcInJvdGF0ZVwiKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXMgPSB0aGlzLnJlYWRDb250ZW50QXNGbG9hdHMoeG1sKTtcblx0XHRcdFx0aWYgKHZhbHVlcy5sZW5ndGggPT0gNCkgLy94LHkseiwgYW5nbGVcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR2YXIgaWQgPSB4bWwuZ2V0QXR0cmlidXRlKFwic2lkXCIpO1xuXHRcdFx0XHRcdFx0aWYgKGlkID09IFwiam9pbnRPcmllbnRYXCIpIHtcblx0XHRcdFx0XHRcdFx0dmFsdWVzWzNdICs9IDkwO1xuXHRcdFx0XHRcdFx0XHRmbGlwX2ZpeCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvL3JvdGF0ZVggJiByb3RhdGVZICYgcm90YXRlWiBkb25lIGJlbG93XG5cblx0XHRcdFx0XHRcdGlmIChmbGlwKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0bXAgPSB2YWx1ZXNbMV07XG5cdFx0XHRcdFx0XHRcdHZhbHVlc1sxXSA9IHZhbHVlc1syXTtcblx0XHRcdFx0XHRcdFx0dmFsdWVzWzJdID0gLXRtcDsgLy9zd2FwIGNvb3Jkc1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAodmFsdWVzWzNdICE9IDAuMCkge1xuXHRcdFx0XHRcdFx0XHRfZ2xNYXRyaXgucXVhdC5zZXRBeGlzQW5nbGUodG1wcSwgdmFsdWVzLnN1YmFycmF5KDAsIDMpLCB2YWx1ZXNbM10gKiBERUcyUkFEKTtcblx0XHRcdFx0XHRcdFx0X2dsTWF0cml4Lm1hdDQuZnJvbVF1YXQodGVtcCwgdG1wcSk7XG5cdFx0XHRcdFx0XHRcdF9nbE1hdHJpeC5tYXQ0Lm11bHRpcGx5KG1hdHJpeCwgbWF0cml4LCB0ZW1wKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvL3NjYWxlXG5cdFx0XHRpZiAoeG1sLmxvY2FsTmFtZSA9PSBcInNjYWxlXCIpIHtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IHRoaXMucmVhZENvbnRlbnRBc0Zsb2F0cyh4bWwpO1xuXHRcdFx0XHRpZiAoZmxpcCkge1xuXHRcdFx0XHRcdHZhciB0bXAgPSB2YWx1ZXNbMV07XG5cdFx0XHRcdFx0dmFsdWVzWzFdID0gdmFsdWVzWzJdO1xuXHRcdFx0XHRcdHZhbHVlc1syXSA9IC10bXA7IC8vc3dhcCBjb29yZHNcblx0XHRcdFx0fVxuXHRcdFx0XHRfZ2xNYXRyaXgubWF0NC5zY2FsZShtYXRyaXgsIG1hdHJpeCwgdmFsdWVzKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0cml4O1xuXHR9LFxuXG5cdHJlYWRUcmFuc2Zvcm0yOiBmdW5jdGlvbiByZWFkVHJhbnNmb3JtMih4bWxub2RlLCBsZXZlbCwgZmxpcCkge1xuXHRcdC8vaWRlbnRpdHlcblx0XHR2YXIgbWF0cml4ID0gX2dsTWF0cml4Lm1hdDQuY3JlYXRlKCk7XG5cdFx0dmFyIHJvdGF0aW9uID0gX2dsTWF0cml4LnF1YXQuY3JlYXRlKCk7XG5cdFx0dmFyIHRtcG1hdHJpeCA9IF9nbE1hdHJpeC5tYXQ0LmNyZWF0ZSgpO1xuXHRcdHZhciB0bXBxID0gX2dsTWF0cml4LnF1YXQuY3JlYXRlKCk7XG5cdFx0dmFyIHRyYW5zbGF0ZSA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0dmFyIHNjYWxlID0gdmVjMy5mcm9tVmFsdWVzKDEsIDEsIDEpO1xuXG5cdFx0dmFyIGZsaXBfZml4ID0gZmFsc2U7XG5cblx0XHQvL3NlYXJjaCBmb3IgdGhlIG1hdHJpeFxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1sbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgeG1sID0geG1sbm9kZS5jaGlsZE5vZGVzLml0ZW0oaSk7XG5cblx0XHRcdGlmICh4bWwubG9jYWxOYW1lID09IFwibWF0cml4XCIpIHtcblx0XHRcdFx0dmFyIG1hdHJpeCA9IHRoaXMucmVhZENvbnRlbnRBc0Zsb2F0cyh4bWwpO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKFwiTm9kZW5hbWU6IFwiICsgeG1sbm9kZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSk7XG5cdFx0XHRcdC8vY29uc29sZS5sb2cobWF0cml4KTtcblx0XHRcdFx0dGhpcy50cmFuc2Zvcm1NYXRyaXgobWF0cml4LCBsZXZlbCA9PSAwKTtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhtYXRyaXgpO1xuXHRcdFx0XHRyZXR1cm4gbWF0cml4O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoeG1sLmxvY2FsTmFtZSA9PSBcInRyYW5zbGF0ZVwiKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXMgPSB0aGlzLnJlYWRDb250ZW50QXNGbG9hdHMoeG1sKTtcblx0XHRcdFx0dHJhbnNsYXRlLnNldCh2YWx1ZXMpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly9yb3RhdGVcblx0XHRcdGlmICh4bWwubG9jYWxOYW1lID09IFwicm90YXRlXCIpIHtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IHRoaXMucmVhZENvbnRlbnRBc0Zsb2F0cyh4bWwpO1xuXHRcdFx0XHRpZiAodmFsdWVzLmxlbmd0aCA9PSA0KSAvL3gseSx6LCBhbmdsZVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHZhciBpZCA9IHhtbC5nZXRBdHRyaWJ1dGUoXCJzaWRcIik7XG5cdFx0XHRcdFx0XHRpZiAoaWQgPT0gXCJqb2ludE9yaWVudFhcIikge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXNbM10gKz0gOTA7XG5cdFx0XHRcdFx0XHRcdGZsaXBfZml4ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vcm90YXRlWCAmIHJvdGF0ZVkgJiByb3RhdGVaIGRvbmUgYmVsb3dcblxuXHRcdFx0XHRcdFx0aWYgKGZsaXApIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRtcCA9IHZhbHVlc1sxXTtcblx0XHRcdFx0XHRcdFx0dmFsdWVzWzFdID0gdmFsdWVzWzJdO1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXNbMl0gPSAtdG1wOyAvL3N3YXAgY29vcmRzXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICh2YWx1ZXNbM10gIT0gMC4wKSB7XG5cdFx0XHRcdFx0XHRcdF9nbE1hdHJpeC5xdWF0LnNldEF4aXNBbmdsZSh0bXBxLCB2YWx1ZXMuc3ViYXJyYXkoMCwgMyksIHZhbHVlc1szXSAqIERFRzJSQUQpO1xuXHRcdFx0XHRcdFx0XHRfZ2xNYXRyaXgucXVhdC5tdWx0aXBseShyb3RhdGlvbiwgcm90YXRpb24sIHRtcHEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vc2NhbGVcblx0XHRcdGlmICh4bWwubG9jYWxOYW1lID09IFwic2NhbGVcIikge1xuXHRcdFx0XHR2YXIgdmFsdWVzID0gdGhpcy5yZWFkQ29udGVudEFzRmxvYXRzKHhtbCk7XG5cdFx0XHRcdGlmIChmbGlwKSB7XG5cdFx0XHRcdFx0dmFyIHRtcCA9IHZhbHVlc1sxXTtcblx0XHRcdFx0XHR2YWx1ZXNbMV0gPSB2YWx1ZXNbMl07XG5cdFx0XHRcdFx0dmFsdWVzWzJdID0gLXRtcDsgLy9zd2FwIGNvb3Jkc1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNjYWxlLnNldCh2YWx1ZXMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChmbGlwICYmIGxldmVsID4gMCkge1xuXHRcdFx0dmFyIHRtcCA9IHRyYW5zbGF0ZVsxXTtcblx0XHRcdHRyYW5zbGF0ZVsxXSA9IHRyYW5zbGF0ZVsyXTtcblx0XHRcdHRyYW5zbGF0ZVsyXSA9IC10bXA7IC8vc3dhcCBjb29yZHNcblx0XHR9XG5cdFx0X2dsTWF0cml4Lm1hdDQudHJhbnNsYXRlKG1hdHJpeCwgbWF0cml4LCB0cmFuc2xhdGUpO1xuXG5cdFx0X2dsTWF0cml4Lm1hdDQuZnJvbVF1YXQodG1wbWF0cml4LCByb3RhdGlvbik7XG5cdFx0Ly9tYXQ0LnJvdGF0ZVgodG1wbWF0cml4LCB0bXBtYXRyaXgsIE1hdGguUEkgKiAwLjUpO1xuXHRcdF9nbE1hdHJpeC5tYXQ0Lm11bHRpcGx5KG1hdHJpeCwgbWF0cml4LCB0bXBtYXRyaXgpO1xuXHRcdF9nbE1hdHJpeC5tYXQ0LnNjYWxlKG1hdHJpeCwgbWF0cml4LCBzY2FsZSk7XG5cblx0XHRyZXR1cm4gbWF0cml4O1xuXHR9LFxuXG5cdC8vZm9yIGhlbHAgcmVhZCB0aGlzOiBodHRwczovL3d3dy5raHJvbm9zLm9yZy9jb2xsYWRhL3dpa2kvVXNpbmdfYWNjZXNzb3JzXG5cdHJlYWRHZW9tZXRyeTogZnVuY3Rpb24gcmVhZEdlb21ldHJ5KGlkLCBmbGlwLCBzY2VuZSkge1xuXHRcdC8vYWxyZWFkeSByZWFkLCBjb3VsZCBoYXBwZW5kIGlmIHNldmVyYWwgY29udHJvbGxlcnMgcG9pbnQgdG8gdGhlIHNhbWUgbWVzaFxuXHRcdGlmICh0aGlzLl9nZW9tZXRyaWVzX2ZvdW5kW2lkXSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5fZ2VvbWV0cmllc19mb3VuZFtpZF07XG5cblx0XHQvL3ZhciB4bWxnZW9tZXRyeSA9IHRoaXMuX3htbHJvb3QucXVlcnlTZWxlY3RvcihcImdlb21ldHJ5XCIgKyBpZCk7XG5cdFx0dmFyIHhtbGdlb21ldHJ5ID0gdGhpcy5feG1scm9vdC5nZXRFbGVtZW50QnlJZChpZC5zdWJzdHIoMSkpO1xuXHRcdGlmICgheG1sZ2VvbWV0cnkpIHtcblx0XHRcdGNvbnNvbGUud2FybihcInJlYWRHZW9tZXRyeTogZ2VvbWV0cnkgbm90IGZvdW5kOiBcIiArIGlkKTtcblx0XHRcdHRoaXMuX2dlb21ldHJpZXNfZm91bmRbaWRdID0gbnVsbDtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdC8vaWYgdGhlIGdlb21ldHJ5IGhhcyBtb3JwaCB0YXJnZXRzIHRoZW4gaW5zdGVhZCBvZiBzdG9yaW5nIGl0IGluIGEgZ2VvbWV0cnksIGl0IGlzIGluIGEgY29udHJvbGxlclxuXHRcdGlmICh4bWxnZW9tZXRyeS5sb2NhbE5hbWUgPT0gXCJjb250cm9sbGVyXCIpIHtcblx0XHRcdHZhciBnZW9tZXRyeSA9IHRoaXMucmVhZENvbnRyb2xsZXIoeG1sZ2VvbWV0cnksIGZsaXAsIHNjZW5lKTtcblx0XHRcdHRoaXMuX2dlb21ldHJpZXNfZm91bmRbaWRdID0gZ2VvbWV0cnk7XG5cdFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cdFx0fVxuXG5cdFx0aWYgKHhtbGdlb21ldHJ5LmxvY2FsTmFtZSAhPSBcImdlb21ldHJ5XCIpIHtcblx0XHRcdGNvbnNvbGUud2FybihcInJlYWRHZW9tZXRyeTogdGFnIHNob3VsZCBiZSBnZW9tZXRyeSwgaW5zdGVhZCBpdCB3YXMgZm91bmQ6IFwiICsgeG1sZ2VvbWV0cnkubG9jYWxOYW1lKTtcblx0XHRcdHRoaXMuX2dlb21ldHJpZXNfZm91bmRbaWRdID0gbnVsbDtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHZhciB4bWxtZXNoID0geG1sZ2VvbWV0cnkucXVlcnlTZWxlY3RvcihcIm1lc2hcIik7XG5cdFx0aWYgKCF4bWxtZXNoKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oXCJyZWFkR2VvbWV0cnk6IG1lc2ggbm90IGZvdW5kIGluIGdlb21ldHJ5OiBcIiArIGlkKTtcblx0XHRcdHRoaXMuX2dlb21ldHJpZXNfZm91bmRbaWRdID0gbnVsbDtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdC8vZ2V0IGRhdGEgc291cmNlc1xuXHRcdHZhciBzb3VyY2VzID0ge307XG5cdFx0dmFyIHhtbHNvdXJjZXMgPSB4bWxtZXNoLnF1ZXJ5U2VsZWN0b3JBbGwoXCJzb3VyY2VcIik7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWxzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgeG1sc291cmNlID0geG1sc291cmNlcy5pdGVtKGkpO1xuXHRcdFx0aWYgKCF4bWxzb3VyY2UucXVlcnlTZWxlY3RvcikgY29udGludWU7XG5cdFx0XHR2YXIgZmxvYXRfYXJyYXkgPSB4bWxzb3VyY2UucXVlcnlTZWxlY3RvcihcImZsb2F0X2FycmF5XCIpO1xuXHRcdFx0aWYgKCFmbG9hdF9hcnJheSkgY29udGludWU7XG5cdFx0XHR2YXIgZmxvYXRzID0gdGhpcy5yZWFkQ29udGVudEFzRmxvYXRzKGZsb2F0X2FycmF5KTtcblxuXHRcdFx0dmFyIHhtbGFjY2Vzc29yID0geG1sc291cmNlLnF1ZXJ5U2VsZWN0b3IoXCJhY2Nlc3NvclwiKTtcblx0XHRcdHZhciBzdHJpZGUgPSBwYXJzZUludCh4bWxhY2Nlc3Nvci5nZXRBdHRyaWJ1dGUoXCJzdHJpZGVcIikpO1xuXG5cdFx0XHRzb3VyY2VzW3htbHNvdXJjZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKV0gPSB7IHN0cmlkZTogc3RyaWRlLCBkYXRhOiBmbG9hdHMgfTtcblx0XHR9XG5cblx0XHQvL2dldCBzdHJlYW1zXG5cdFx0dmFyIHhtbHZlcnRpY2VzID0geG1sbWVzaC5xdWVyeVNlbGVjdG9yKFwidmVydGljZXMgaW5wdXRcIik7XG5cdFx0dmFyIHZlcnRpY2VzX3NvdXJjZSA9IHNvdXJjZXNbeG1sdmVydGljZXMuZ2V0QXR0cmlidXRlKFwic291cmNlXCIpLnN1YnN0cigxKV07XG5cdFx0c291cmNlc1t4bWxtZXNoLnF1ZXJ5U2VsZWN0b3IoXCJ2ZXJ0aWNlc1wiKS5nZXRBdHRyaWJ1dGUoXCJpZFwiKV0gPSB2ZXJ0aWNlc19zb3VyY2U7XG5cblx0XHR2YXIgbWVzaCA9IG51bGw7XG5cdFx0dmFyIHhtbHBvbHlnb25zID0geG1sbWVzaC5xdWVyeVNlbGVjdG9yKFwicG9seWdvbnNcIik7XG5cdFx0aWYgKHhtbHBvbHlnb25zKSBtZXNoID0gdGhpcy5yZWFkVHJpYW5nbGVzKHhtbHBvbHlnb25zLCBzb3VyY2VzKTtcblxuXHRcdGlmICghbWVzaCkge1xuXHRcdFx0dmFyIHhtbHRyaWFuZ2xlcyA9IHhtbG1lc2gucXVlcnlTZWxlY3RvckFsbChcInRyaWFuZ2xlc1wiKTtcblx0XHRcdGlmICh4bWx0cmlhbmdsZXMgJiYgeG1sdHJpYW5nbGVzLmxlbmd0aCkgbWVzaCA9IHRoaXMucmVhZFRyaWFuZ2xlcyh4bWx0cmlhbmdsZXMsIHNvdXJjZXMpO1xuXHRcdH1cblxuXHRcdGlmICghbWVzaCkge1xuXHRcdFx0Ly9wb2x5bGlzdCA9IHRydWU7XG5cdFx0XHQvL3ZhciB2Y291bnQgPSBudWxsO1xuXHRcdFx0Ly92YXIgeG1sdmNvdW50ID0geG1scG9seWdvbnMucXVlcnlTZWxlY3RvcihcInZjb3VudFwiKTtcblx0XHRcdC8vdmFyIHZjb3VudCA9IHRoaXMucmVhZENvbnRlbnRBc1VJbnQzMiggeG1sdmNvdW50ICk7XG5cdFx0XHR2YXIgeG1scG9seWxpc3QgPSB4bWxtZXNoLnF1ZXJ5U2VsZWN0b3IoXCJwb2x5bGlzdFwiKTtcblx0XHRcdGlmICh4bWxwb2x5bGlzdCkgbWVzaCA9IHRoaXMucmVhZFBvbHlsaXN0KHhtbHBvbHlsaXN0LCBzb3VyY2VzKTtcblx0XHR9XG5cblx0XHRpZiAoIW1lc2gpIHtcblx0XHRcdHZhciB4bWxsaW5lc3RyaXAgPSB4bWxtZXNoLnF1ZXJ5U2VsZWN0b3IoXCJsaW5lc3RyaXBzXCIpO1xuXHRcdFx0aWYgKHhtbGxpbmVzdHJpcCkgbWVzaCA9IHRoaXMucmVhZExpbmVTdHJpcChzb3VyY2VzLCB4bWxsaW5lc3RyaXApO1xuXHRcdH1cblxuXHRcdGlmICghbWVzaCkge1xuXHRcdFx0Y29uc29sZS5sb2coXCJubyBwb2x5Z29ucyBvciB0cmlhbmdsZXMgaW4gbWVzaDogXCIgKyBpZCk7XG5cdFx0XHR0aGlzLl9nZW9tZXRyaWVzX2ZvdW5kW2lkXSA9IG51bGw7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHQvL3N3YXAgY29vcmRzIChYLFksWikgLT4gKFgsWiwtWSlcblx0XHRpZiAoZmxpcCAmJiAhdGhpcy5ub19mbGlwKSB7XG5cdFx0XHR2YXIgdG1wID0gMDtcblx0XHRcdHZhciBhcnJheSA9IG1lc2gudmVydGljZXM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKz0gMykge1xuXHRcdFx0XHR0bXAgPSBhcnJheVtpICsgMV07XG5cdFx0XHRcdGFycmF5W2kgKyAxXSA9IGFycmF5W2kgKyAyXTtcblx0XHRcdFx0YXJyYXlbaSArIDJdID0gLXRtcDtcblx0XHRcdH1cblxuXHRcdFx0YXJyYXkgPSBtZXNoLm5vcm1hbHM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKz0gMykge1xuXHRcdFx0XHR0bXAgPSBhcnJheVtpICsgMV07XG5cdFx0XHRcdGFycmF5W2kgKyAxXSA9IGFycmF5W2kgKyAyXTtcblx0XHRcdFx0YXJyYXlbaSArIDJdID0gLXRtcDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvL3RyYW5zZmVyYWJsZXMgZm9yIHdvcmtlclxuXHRcdGlmIChpc1dvcmtlciAmJiB0aGlzLnVzZV90cmFuc2ZlcmFibGVzKSB7XG5cdFx0XHRmb3IgKHZhciBpIGluIG1lc2gpIHtcblx0XHRcdFx0dmFyIGRhdGEgPSBtZXNoW2ldO1xuXHRcdFx0XHRpZiAoZGF0YSAmJiBkYXRhLmJ1ZmZlciAmJiBkYXRhLmxlbmd0aCA+IDEwMCkge1xuXHRcdFx0XHRcdHRoaXMuX3RyYW5zZmVyYWJsZXMucHVzaChkYXRhLmJ1ZmZlcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvL2V4dHJhIGluZm9cblx0XHRtZXNoLmZpbGVuYW1lID0gaWQ7XG5cdFx0bWVzaC5vYmplY3RfdHlwZSA9IFwiTWVzaFwiO1xuXG5cdFx0dGhpcy5fZ2VvbWV0cmllc19mb3VuZFtpZF0gPSBtZXNoO1xuXHRcdHJldHVybiBtZXNoO1xuXHR9LFxuXG5cdHJlYWRUcmlhbmdsZXM6IGZ1bmN0aW9uIHJlYWRUcmlhbmdsZXMoeG1sdHJpYW5nbGVzLCBzb3VyY2VzKSB7XG5cdFx0dmFyIHVzZV9pbmRpY2VzID0gZmFsc2U7XG5cblx0XHR2YXIgZ3JvdXBzID0gW107XG5cdFx0dmFyIGJ1ZmZlcnMgPSBbXTtcblx0XHR2YXIgbGFzdF9pbmRleCA9IDA7XG5cdFx0dmFyIGZhY2VtYXAgPSB7fTtcblx0XHR2YXIgdmVydGV4X3JlbWFwID0gW107IC8vbWFwcyBEQUUgdmVydGV4IGluZGV4IHRvIE1lc2ggdmVydGV4IGluZGV4IChiZWNhdXNlIHdoZW4gbWVzaGVzIGFyZSB0cmlhbmd1bGF0ZWQgaW5kaWNlcyBhcmUgY2hhbmdlZFxuXHRcdHZhciBpbmRpY2VzQXJyYXkgPSBbXTtcblx0XHR2YXIgbGFzdF9zdGFydCA9IDA7XG5cdFx0dmFyIGdyb3VwX25hbWUgPSBcIlwiO1xuXHRcdHZhciBtYXRlcmlhbF9uYW1lID0gXCJcIjtcblxuXHRcdC8vZm9yIGV2ZXJ5IHRyaWFuZ2xlcyBzZXQgKHdhcm5pbmcsIHNvbWUgdGltZXMgdGhleSBhcmUgcmVwZWF0ZWQuLi4pXG5cdFx0Zm9yICh2YXIgdHJpcyA9IDA7IHRyaXMgPCB4bWx0cmlhbmdsZXMubGVuZ3RoOyB0cmlzKyspIHtcblx0XHRcdHZhciB4bWxfc2hhcGVfcm9vdCA9IHhtbHRyaWFuZ2xlcy5pdGVtKHRyaXMpO1xuXHRcdFx0dmFyIHRyaWFuZ2xlcyA9IHhtbF9zaGFwZV9yb290LmxvY2FsTmFtZSA9PSBcInRyaWFuZ2xlc1wiO1xuXG5cdFx0XHRtYXRlcmlhbF9uYW1lID0geG1sX3NoYXBlX3Jvb3QuZ2V0QXR0cmlidXRlKFwibWF0ZXJpYWxcIik7XG5cblx0XHRcdC8vZm9yIGVhY2ggYnVmZmVyIChpbnB1dCkgYnVpbGQgdGhlIHN0cnVjdHVyZSBpbmZvXG5cdFx0XHRpZiAodHJpcyA9PSAwKSBidWZmZXJzID0gdGhpcy5yZWFkU2hhcGVJbnB1dHMoeG1sX3NoYXBlX3Jvb3QsIHNvdXJjZXMpO1xuXG5cdFx0XHQvL2Fzc3VtaW5nIGJ1ZmZlcnMgYXJlIG9yZGVyZWQgYnkgb2Zmc2V0XG5cblx0XHRcdC8vaXRlcmF0ZSBkYXRhXG5cdFx0XHR2YXIgeG1scHMgPSB4bWxfc2hhcGVfcm9vdC5xdWVyeVNlbGVjdG9yQWxsKFwicFwiKTtcblx0XHRcdHZhciBudW1fZGF0YV92ZXJ0ZXggPSBidWZmZXJzLmxlbmd0aDsgLy9vbmUgdmFsdWUgcGVyIGlucHV0IGJ1ZmZlclxuXG5cdFx0XHQvL2ZvciBldmVyeSBwb2x5Z29uIChjb3VsZCBiZSBvbmUgd2l0aCBhbGwgdGhlIGluZGljZXMsIGNvdWxkIGJlIHNldmVyYWwsIGRlcGVuZHMgb24gdGhlIHByb2dyYW0pXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbHBzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciB4bWxwID0geG1scHMuaXRlbShpKTtcblx0XHRcdFx0aWYgKCF4bWxwIHx8ICF4bWxwLnRleHRDb250ZW50KSBicmVhaztcblxuXHRcdFx0XHR2YXIgZGF0YSA9IHhtbHAudGV4dENvbnRlbnQudHJpbSgpLnNwbGl0KFwiIFwiKTtcblxuXHRcdFx0XHQvL3VzZWQgZm9yIHRyaWFuZ3VsYXRlIHBvbHlzXG5cdFx0XHRcdHZhciBmaXJzdF9pbmRleCA9IC0xO1xuXHRcdFx0XHR2YXIgY3VycmVudF9pbmRleCA9IC0xO1xuXHRcdFx0XHR2YXIgcHJldl9pbmRleCA9IC0xO1xuXG5cdFx0XHRcdC8vZGlzY29tbWVudCB0byBmb3JjZSAxNmJpdHMgaW5kaWNlc1xuXHRcdFx0XHQvL2lmKHVzZV9pbmRpY2VzICYmIGxhc3RfaW5kZXggPj0gMjU2KjI1Nilcblx0XHRcdFx0Ly9cdGJyZWFrO1xuXG5cdFx0XHRcdHZhciBudW1fdmFsdWVzX3Blcl92ZXJ0ZXggPSAxO1xuXHRcdFx0XHRmb3IgKHZhciBiIGluIGJ1ZmZlcnMpIHtcblx0XHRcdFx0XHRudW1fdmFsdWVzX3Blcl92ZXJ0ZXggPSBNYXRoLm1heChudW1fdmFsdWVzX3Blcl92ZXJ0ZXgsIGJ1ZmZlcnNbYl1bNF0gKyAxKTtcblx0XHRcdFx0fSAvL2ZvciBldmVyeSBwYWNrIG9mIGluZGljZXMgaW4gdGhlIHBvbHlnb24gKHZlcnRleCwgbm9ybWFsLCB1diwgLi4uIClcblx0XHRcdFx0dmFyIGN1cnJlbnRfZGF0YV9wb3MgPSAwO1xuXHRcdFx0XHRmb3IgKHZhciBrID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBrIDwgbDsgayArPSBudW1fdmFsdWVzX3Blcl92ZXJ0ZXgpIHtcblx0XHRcdFx0XHR2YXIgdmVydGV4X2lkID0gZGF0YS5zbGljZShrLCBrICsgbnVtX3ZhbHVlc19wZXJfdmVydGV4KS5qb2luKFwiIFwiKTsgLy9nZW5lcmF0ZSB1bmlxdWUgaWRcblxuXHRcdFx0XHRcdHByZXZfaW5kZXggPSBjdXJyZW50X2luZGV4O1xuXHRcdFx0XHRcdGlmIChmYWNlbWFwLmhhc093blByb3BlcnR5KHZlcnRleF9pZCkpIC8vYWRkIHRvIGFycmF5cywga2VlcCB0aGUgaW5kZXhcblx0XHRcdFx0XHRcdGN1cnJlbnRfaW5kZXggPSBmYWNlbWFwW3ZlcnRleF9pZF07ZWxzZSB7XG5cdFx0XHRcdFx0XHQvL2ZvciBldmVyeSBkYXRhIGJ1ZmZlciBhc3NvY2lhdGVkIHRvIHRoaXMgdmVydGV4XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGJ1ZmZlcnMubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0XHRcdFx0dmFyIGJ1ZmZlciA9IGJ1ZmZlcnNbal07XG5cdFx0XHRcdFx0XHRcdHZhciBhcnJheSA9IGJ1ZmZlclsxXTsgLy9hcnJheSB3aGVyZSB3ZSBhY2N1bXVsYXRlIHRoZSBmaW5hbCBkYXRhIGFzIHdlIGV4dHJhY3QgaWYgZnJvbSBzb3VyY2VzXG5cdFx0XHRcdFx0XHRcdHZhciBzb3VyY2UgPSBidWZmZXJbM107IC8vd2hlcmUgdG8gcmVhZCB0aGUgZGF0YSBmcm9tXG5cblx0XHRcdFx0XHRcdFx0Ly9jb21wdXRlIHRoZSBpbmRleCBpbnNpZGUgdGhlIGRhdGEgc291cmNlIGFycmF5XG5cdFx0XHRcdFx0XHRcdC8vdmFyIGluZGV4ID0gcGFyc2VJbnQoZGF0YVtrICsgal0pO1xuXHRcdFx0XHRcdFx0XHR2YXIgaW5kZXggPSBwYXJzZUludChkYXRhW2sgKyBidWZmZXJbNF1dKTtcblx0XHRcdFx0XHRcdFx0Ly9jdXJyZW50X2RhdGFfcG9zICs9IGJ1ZmZlcls0XTtcblxuXHRcdFx0XHRcdFx0XHQvL3JlbWVtYmVyIHRoaXMgaW5kZXggaW4gY2FzZSB3ZSBuZWVkIHRvIHJlbWFwXG5cdFx0XHRcdFx0XHRcdGlmIChqID09IDApIHZlcnRleF9yZW1hcFthcnJheS5sZW5ndGggLyBidWZmZXJbMl1dID0gaW5kZXg7IC8vbm90IHN1cmUgaWYgYnVmZmVyWzJdLCBpdCBzaG91bGQgYmUgbnVtYmVyIG9mIGZsb2F0cyBwZXIgdmVydGV4ICh1c3VhbGx5IDMpXG5cdFx0XHRcdFx0XHRcdC8vdmVydGV4X3JlbWFwWyBhcnJheS5sZW5ndGggLyBudW1fZGF0YV92ZXJ0ZXggXSA9IGluZGV4O1xuXG5cdFx0XHRcdFx0XHRcdC8vY29tcHV0ZSB0aGUgcG9zaXRpb24gaW5zaWRlIHRoZSBzb3VyY2UgYnVmZmVyIHdoZXJlIHRoZSBmaW5hbCBkYXRhIGlzIGxvY2F0ZWRcblx0XHRcdFx0XHRcdFx0aW5kZXggKj0gYnVmZmVyWzJdOyAvL3RoaXMgd29ya3MgaW4gbW9zdCBEQUVzIChub3QgYWxsKVxuXHRcdFx0XHRcdFx0XHQvL2luZGV4ID0gaW5kZXggKiBidWZmZXJbMl0gKyBidWZmZXJbNF07IC8vc3RyaWRlKDIpIG9mZnNldCg0KVxuXHRcdFx0XHRcdFx0XHQvL2luZGV4ICs9IGJ1ZmZlcls0XTsgLy9zdHJpZGUoMikgb2Zmc2V0KDQpXG5cdFx0XHRcdFx0XHRcdC8vZXh0cmFjdCBldmVyeSB2YWx1ZSBvZiB0aGlzIGVsZW1lbnQgYW5kIHN0b3JlIGl0IGluIGl0cyBmaW5hbCBhcnJheSAoZXZlcnkgeCx5LHosIGV0Yylcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgeCA9IDA7IHggPCBidWZmZXJbMl07ICsreCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChzb3VyY2VbaW5kZXggKyB4XSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBcIlVOREVGSU5FRCFcIjsgLy9ERUJVR1xuXHRcdFx0XHRcdFx0XHRcdGFycmF5LnB1c2goc291cmNlW2luZGV4ICsgeF0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGN1cnJlbnRfaW5kZXggPSBsYXN0X2luZGV4O1xuXHRcdFx0XHRcdFx0bGFzdF9pbmRleCArPSAxO1xuXHRcdFx0XHRcdFx0ZmFjZW1hcFt2ZXJ0ZXhfaWRdID0gY3VycmVudF9pbmRleDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIXRyaWFuZ2xlcykgLy90aGUgeG1sIGVsZW1lbnQgaXMgbm90IHRyaWFuZ2xlcz8gdGhlbiBzcGxpdCBwb2x5Z29ucyBpbiB0cmlhbmdsZXNcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0aWYgKGsgPT0gMCkgZmlyc3RfaW5kZXggPSBjdXJyZW50X2luZGV4O1xuXHRcdFx0XHRcdFx0XHQvL2lmKGsgPiAyICogbnVtX2RhdGFfdmVydGV4KSAvL25vdCBzdXJlIGlmIHVzZSB0aGlzIG9yIHRoZSBuZXh0IGxpbmUsIHRoZSBuZXh0IG9uZSB3b3JrcyBpbiBzb21lIERBRXMgYnV0IG5vdCBzdXJlIGlmIGl0IHdvcmtzIGluIGFsbFxuXHRcdFx0XHRcdFx0XHRpZiAoayA+IDIpIC8vdHJpYW5ndWxhdGUgcG9seWdvbnM6IGVuc3VyZSB0aGlzIHdvcmtzXG5cdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0aW5kaWNlc0FycmF5LnB1c2goZmlyc3RfaW5kZXgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aW5kaWNlc0FycmF5LnB1c2gocHJldl9pbmRleCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aW5kaWNlc0FycmF5LnB1c2goY3VycmVudF9pbmRleCk7XG5cdFx0XHRcdH0gLy9wZXIgdmVydGV4XG5cdFx0XHR9IC8vcGVyIHBvbHlnb25cblxuXHRcdFx0dmFyIGdyb3VwID0ge1xuXHRcdFx0XHRuYW1lOiBncm91cF9uYW1lIHx8IFwiZ3JvdXBcIiArIHRyaXMsXG5cdFx0XHRcdHN0YXJ0OiBsYXN0X3N0YXJ0LFxuXHRcdFx0XHRsZW5ndGg6IGluZGljZXNBcnJheS5sZW5ndGggLSBsYXN0X3N0YXJ0LFxuXHRcdFx0XHRtYXRlcmlhbDogbWF0ZXJpYWxfbmFtZSB8fCBcIlwiXG5cdFx0XHR9O1xuXHRcdFx0bGFzdF9zdGFydCA9IGluZGljZXNBcnJheS5sZW5ndGg7XG5cdFx0XHRncm91cHMucHVzaChncm91cCk7XG5cdFx0fSAvL3BlciB0cmlhbmdsZXMgZ3JvdXBcblxuXHRcdHZhciBtZXNoID0ge1xuXHRcdFx0dmVydGljZXM6IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyc1swXVsxXSksXG5cdFx0XHRpbmZvOiB7IGdyb3VwczogZ3JvdXBzIH0sXG5cdFx0XHRfcmVtYXA6IG5ldyBVaW50MzJBcnJheSh2ZXJ0ZXhfcmVtYXApXG5cdFx0fTtcblxuXHRcdHRoaXMudHJhbnNmb3JtTWVzaEluZm8obWVzaCwgYnVmZmVycywgaW5kaWNlc0FycmF5KTtcblxuXHRcdHJldHVybiBtZXNoO1xuXHR9LFxuXG5cdHJlYWRQb2x5bGlzdDogZnVuY3Rpb24gcmVhZFBvbHlsaXN0KHhtbF9zaGFwZV9yb290LCBzb3VyY2VzKSB7XG5cdFx0dmFyIHVzZV9pbmRpY2VzID0gZmFsc2U7XG5cblx0XHR2YXIgZ3JvdXBzID0gW107XG5cdFx0dmFyIGJ1ZmZlcnMgPSBbXTtcblx0XHR2YXIgbGFzdF9pbmRleCA9IDA7XG5cdFx0dmFyIGZhY2VtYXAgPSB7fTtcblx0XHR2YXIgdmVydGV4X3JlbWFwID0gW107XG5cdFx0dmFyIGluZGljZXNBcnJheSA9IFtdO1xuXHRcdHZhciBsYXN0X3N0YXJ0ID0gMDtcblx0XHR2YXIgZ3JvdXBfbmFtZSA9IFwiXCI7XG5cdFx0dmFyIG1hdGVyaWFsX25hbWUgPSBcIlwiO1xuXG5cdFx0bWF0ZXJpYWxfbmFtZSA9IHhtbF9zaGFwZV9yb290LmdldEF0dHJpYnV0ZShcIm1hdGVyaWFsXCIpO1xuXHRcdGJ1ZmZlcnMgPSB0aGlzLnJlYWRTaGFwZUlucHV0cyh4bWxfc2hhcGVfcm9vdCwgc291cmNlcyk7XG5cblx0XHR2YXIgeG1sdmNvdW50ID0geG1sX3NoYXBlX3Jvb3QucXVlcnlTZWxlY3RvcihcInZjb3VudFwiKTtcblx0XHR2YXIgdmNvdW50ID0gdGhpcy5yZWFkQ29udGVudEFzVUludDMyKHhtbHZjb3VudCk7XG5cblx0XHR2YXIgeG1scCA9IHhtbF9zaGFwZV9yb290LnF1ZXJ5U2VsZWN0b3IoXCJwXCIpO1xuXHRcdHZhciBkYXRhID0gdGhpcy5yZWFkQ29udGVudEFzVUludDMyKHhtbHApO1xuXG5cdFx0dmFyIG51bV9kYXRhX3ZlcnRleCA9IGJ1ZmZlcnMubGVuZ3RoO1xuXG5cdFx0dmFyIHBvcyA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB2Y291bnQubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG5cdFx0XHR2YXIgbnVtX3ZlcnRpY2VzID0gdmNvdW50W2ldO1xuXG5cdFx0XHR2YXIgZmlyc3RfaW5kZXggPSAtMTtcblx0XHRcdHZhciBjdXJyZW50X2luZGV4ID0gLTE7XG5cdFx0XHR2YXIgcHJldl9pbmRleCA9IC0xO1xuXG5cdFx0XHQvL2l0ZXJhdGUgdmVydGljZXMgb2YgdGhpcyBwb2x5Z29uXG5cdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IG51bV92ZXJ0aWNlczsgKytrKSB7XG5cdFx0XHRcdHZhciB2ZXJ0ZXhfaWQgPSBkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgbnVtX2RhdGFfdmVydGV4KS5qb2luKFwiIFwiKTtcblxuXHRcdFx0XHRwcmV2X2luZGV4ID0gY3VycmVudF9pbmRleDtcblx0XHRcdFx0aWYgKGZhY2VtYXAuaGFzT3duUHJvcGVydHkodmVydGV4X2lkKSkgLy9hZGQgdG8gYXJyYXlzLCBrZWVwIHRoZSBpbmRleFxuXHRcdFx0XHRcdGN1cnJlbnRfaW5kZXggPSBmYWNlbWFwW3ZlcnRleF9pZF07ZWxzZSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBidWZmZXJzLmxlbmd0aDsgKytqKSB7XG5cdFx0XHRcdFx0XHR2YXIgYnVmZmVyID0gYnVmZmVyc1tqXTtcblx0XHRcdFx0XHRcdHZhciBpbmRleCA9IHBhcnNlSW50KGRhdGFbcG9zICsgal0pOyAvL3Bcblx0XHRcdFx0XHRcdHZhciBhcnJheSA9IGJ1ZmZlclsxXTsgLy9hcnJheSB3aXRoIGFsbCB0aGUgZGF0YVxuXHRcdFx0XHRcdFx0dmFyIHNvdXJjZSA9IGJ1ZmZlclszXTsgLy93aGVyZSB0byByZWFkIHRoZSBkYXRhIGZyb21cblx0XHRcdFx0XHRcdGlmIChqID09IDApIHZlcnRleF9yZW1hcFthcnJheS5sZW5ndGggLyBudW1fZGF0YV92ZXJ0ZXhdID0gaW5kZXg7XG5cdFx0XHRcdFx0XHRpbmRleCAqPSBidWZmZXJbMl07IC8vc3RyaWRlXG5cdFx0XHRcdFx0XHRmb3IgKHZhciB4ID0gMDsgeCA8IGJ1ZmZlclsyXTsgKyt4KSB7XG5cdFx0XHRcdFx0XHRcdGFycmF5LnB1c2goc291cmNlW2luZGV4ICsgeF0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGN1cnJlbnRfaW5kZXggPSBsYXN0X2luZGV4O1xuXHRcdFx0XHRcdGxhc3RfaW5kZXggKz0gMTtcblx0XHRcdFx0XHRmYWNlbWFwW3ZlcnRleF9pZF0gPSBjdXJyZW50X2luZGV4O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG51bV92ZXJ0aWNlcyA+IDMpIC8vc3BsaXQgcG9seWdvbnMgdGhlblxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGlmIChrID09IDApIGZpcnN0X2luZGV4ID0gY3VycmVudF9pbmRleDtcblx0XHRcdFx0XHRcdC8vaWYoayA+IDIgKiBudW1fZGF0YV92ZXJ0ZXgpIC8vbm90IHN1cmUgaWYgdXNlIHRoaXMgb3IgdGhlIG5leHQgbGluZSwgdGhlIG5leHQgb25lIHdvcmtzIGluIHNvbWUgREFFcyBidXQgbm90IHN1cmUgaWYgaXQgd29ya3MgaW4gYWxsXG5cdFx0XHRcdFx0XHRpZiAoayA+IDIpIC8vdHJpYW5ndWxhdGUgcG9seWdvbnM6IHRlc3RlZCwgdGhpcyB3b3Jrc1xuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0aW5kaWNlc0FycmF5LnB1c2goZmlyc3RfaW5kZXgpO1xuXHRcdFx0XHRcdFx0XHRcdGluZGljZXNBcnJheS5wdXNoKHByZXZfaW5kZXgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdGluZGljZXNBcnJheS5wdXNoKGN1cnJlbnRfaW5kZXgpO1xuXHRcdFx0XHRwb3MgKz0gbnVtX2RhdGFfdmVydGV4O1xuXHRcdFx0fSAvL3BlciB2ZXJ0ZXhcblx0XHR9IC8vcGVyIHBvbHlnb25cblxuXHRcdHZhciBtZXNoID0ge1xuXHRcdFx0dmVydGljZXM6IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyc1swXVsxXSksXG5cdFx0XHRpbmZvOiB7fSxcblx0XHRcdF9yZW1hcDogbmV3IFVpbnQzMkFycmF5KHZlcnRleF9yZW1hcClcblx0XHR9O1xuXG5cdFx0dGhpcy50cmFuc2Zvcm1NZXNoSW5mbyhtZXNoLCBidWZmZXJzLCBpbmRpY2VzQXJyYXkpO1xuXG5cdFx0cmV0dXJuIG1lc2g7XG5cdH0sXG5cblx0cmVhZFNoYXBlSW5wdXRzOiBmdW5jdGlvbiByZWFkU2hhcGVJbnB1dHMoeG1sX3NoYXBlX3Jvb3QsIHNvdXJjZXMpIHtcblx0XHR2YXIgYnVmZmVycyA9IFtdO1xuXG5cdFx0dmFyIHhtbGlucHV0cyA9IHhtbF9zaGFwZV9yb290LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFwiKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbGlucHV0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHhtbGlucHV0ID0geG1saW5wdXRzLml0ZW0oaSk7XG5cdFx0XHRpZiAoIXhtbGlucHV0LmdldEF0dHJpYnV0ZSkgY29udGludWU7XG5cdFx0XHR2YXIgc2VtYW50aWMgPSB4bWxpbnB1dC5nZXRBdHRyaWJ1dGUoXCJzZW1hbnRpY1wiKS50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0dmFyIHN0cmVhbV9zb3VyY2UgPSBzb3VyY2VzW3htbGlucHV0LmdldEF0dHJpYnV0ZShcInNvdXJjZVwiKS5zdWJzdHIoMSldO1xuXHRcdFx0dmFyIG9mZnNldCA9IHBhcnNlSW50KHhtbGlucHV0LmdldEF0dHJpYnV0ZShcIm9mZnNldFwiKSk7XG5cdFx0XHR2YXIgZGF0YV9zZXQgPSAwO1xuXHRcdFx0aWYgKHhtbGlucHV0LmdldEF0dHJpYnV0ZShcInNldFwiKSkgZGF0YV9zZXQgPSBwYXJzZUludCh4bWxpbnB1dC5nZXRBdHRyaWJ1dGUoXCJzZXRcIikpO1xuXHRcdFx0YnVmZmVycy5wdXNoKFtzZW1hbnRpYywgW10sIHN0cmVhbV9zb3VyY2Uuc3RyaWRlLCBzdHJlYW1fc291cmNlLmRhdGEsIG9mZnNldCwgZGF0YV9zZXRdKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYnVmZmVycztcblx0fSxcblxuXHR0cmFuc2Zvcm1NZXNoSW5mbzogZnVuY3Rpb24gdHJhbnNmb3JtTWVzaEluZm8obWVzaCwgYnVmZmVycywgaW5kaWNlc0FycmF5KSB7XG5cdFx0Ly9yZW5hbWUgYnVmZmVycyAoREFFIGhhcyBvdGhlciBuYW1lcylcblx0XHR2YXIgdHJhbnNsYXRvciA9IHtcblx0XHRcdFwibm9ybWFsXCI6IFwibm9ybWFsc1wiLFxuXHRcdFx0XCJ0ZXhjb29yZFwiOiBcImNvb3Jkc1wiXG5cdFx0fTtcblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IGJ1ZmZlcnMubGVuZ3RoOyArK2kpIHtcblx0XHRcdHZhciBuYW1lID0gYnVmZmVyc1tpXVswXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0dmFyIGRhdGEgPSBidWZmZXJzW2ldWzFdO1xuXHRcdFx0aWYgKCFkYXRhLmxlbmd0aCkgY29udGludWU7XG5cblx0XHRcdGlmICh0cmFuc2xhdG9yW25hbWVdKSBuYW1lID0gdHJhbnNsYXRvcltuYW1lXTtcblx0XHRcdGlmIChtZXNoW25hbWVdKSBuYW1lID0gbmFtZSArIGJ1ZmZlcnNbaV1bNV07XG5cdFx0XHRtZXNoW25hbWVdID0gbmV3IEZsb2F0MzJBcnJheShkYXRhKTsgLy9hcmUgdGhleSBhbHdheXMgZmxvYXQzMj8gSSB0aGluayBzb1xuXHRcdH1cblxuXHRcdGlmIChpbmRpY2VzQXJyYXkgJiYgaW5kaWNlc0FycmF5Lmxlbmd0aCkge1xuXHRcdFx0aWYgKG1lc2gudmVydGljZXMubGVuZ3RoID4gMjU2ICogMjU2KSBtZXNoLnRyaWFuZ2xlcyA9IG5ldyBVaW50MzJBcnJheShpbmRpY2VzQXJyYXkpO2Vsc2UgbWVzaC50cmlhbmdsZXMgPSBuZXcgVWludDE2QXJyYXkoaW5kaWNlc0FycmF5KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWVzaDtcblx0fSxcblxuXHRyZWFkTGluZVN0cmlwOiBmdW5jdGlvbiByZWFkTGluZVN0cmlwKHNvdXJjZXMsIHhtbGxpbmVzdHJpcCkge1xuXHRcdHZhciB1c2VfaW5kaWNlcyA9IGZhbHNlO1xuXG5cdFx0dmFyIGJ1ZmZlcnMgPSBbXTtcblx0XHR2YXIgbGFzdF9pbmRleCA9IDA7XG5cdFx0dmFyIGZhY2VtYXAgPSB7fTtcblx0XHR2YXIgdmVydGV4X3JlbWFwID0gW107XG5cdFx0dmFyIGluZGljZXNBcnJheSA9IFtdO1xuXHRcdHZhciBsYXN0X3N0YXJ0ID0gMDtcblx0XHR2YXIgZ3JvdXBfbmFtZSA9IFwiXCI7XG5cdFx0dmFyIG1hdGVyaWFsX25hbWUgPSBcIlwiO1xuXG5cdFx0dmFyIHRyaXMgPSAwOyAvL3VzZWQgaW4gY2FzZSB0aGVyZSBhcmUgc2V2ZXJhbCBzdHJpcHNcblxuXHRcdC8vZm9yIGVhY2ggYnVmZmVyIChpbnB1dCkgYnVpbGQgdGhlIHN0cnVjdHVyZSBpbmZvXG5cdFx0dmFyIHhtbGlucHV0cyA9IHhtbGxpbmVzdHJpcC5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXRcIik7XG5cdFx0aWYgKHRyaXMgPT0gMCkgLy9maXJzdCBpdGVyYXRpb24sIGNyZWF0ZSBidWZmZXJzXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbGlucHV0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgeG1saW5wdXQgPSB4bWxpbnB1dHMuaXRlbShpKTtcblx0XHRcdFx0aWYgKCF4bWxpbnB1dC5nZXRBdHRyaWJ1dGUpIGNvbnRpbnVlO1xuXHRcdFx0XHR2YXIgc2VtYW50aWMgPSB4bWxpbnB1dC5nZXRBdHRyaWJ1dGUoXCJzZW1hbnRpY1wiKS50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0XHR2YXIgc3RyZWFtX3NvdXJjZSA9IHNvdXJjZXNbeG1saW5wdXQuZ2V0QXR0cmlidXRlKFwic291cmNlXCIpLnN1YnN0cigxKV07XG5cdFx0XHRcdHZhciBvZmZzZXQgPSBwYXJzZUludCh4bWxpbnB1dC5nZXRBdHRyaWJ1dGUoXCJvZmZzZXRcIikpO1xuXHRcdFx0XHR2YXIgZGF0YV9zZXQgPSAwO1xuXHRcdFx0XHRpZiAoeG1saW5wdXQuZ2V0QXR0cmlidXRlKFwic2V0XCIpKSBkYXRhX3NldCA9IHBhcnNlSW50KHhtbGlucHV0LmdldEF0dHJpYnV0ZShcInNldFwiKSk7XG5cblx0XHRcdFx0YnVmZmVycy5wdXNoKFtzZW1hbnRpYywgW10sIHN0cmVhbV9zb3VyY2Uuc3RyaWRlLCBzdHJlYW1fc291cmNlLmRhdGEsIG9mZnNldCwgZGF0YV9zZXRdKTtcblx0XHRcdH1cblx0XHQvL2Fzc3VtaW5nIGJ1ZmZlcnMgYXJlIG9yZGVyZWQgYnkgb2Zmc2V0XG5cblx0XHQvL2l0ZXJhdGUgZGF0YVxuXHRcdHZhciB4bWxwcyA9IHhtbGxpbmVzdHJpcC5xdWVyeVNlbGVjdG9yQWxsKFwicFwiKTtcblx0XHR2YXIgbnVtX2RhdGFfdmVydGV4ID0gYnVmZmVycy5sZW5ndGg7IC8vb25lIHZhbHVlIHBlciBpbnB1dCBidWZmZXJcblxuXHRcdC8vZm9yIGV2ZXJ5IHBvbHlnb24gKGNvdWxkIGJlIG9uZSB3aXRoIGFsbCB0aGUgaW5kaWNlcywgY291bGQgYmUgc2V2ZXJhbCwgZGVwZW5kcyBvbiB0aGUgcHJvZ3JhbSlcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbHBzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgeG1scCA9IHhtbHBzLml0ZW0oaSk7XG5cdFx0XHRpZiAoIXhtbHAgfHwgIXhtbHAudGV4dENvbnRlbnQpIGJyZWFrO1xuXG5cdFx0XHR2YXIgZGF0YSA9IHhtbHAudGV4dENvbnRlbnQudHJpbSgpLnNwbGl0KFwiIFwiKTtcblxuXHRcdFx0Ly91c2VkIGZvciB0cmlhbmd1bGF0ZSBwb2x5c1xuXHRcdFx0dmFyIGZpcnN0X2luZGV4ID0gLTE7XG5cdFx0XHR2YXIgY3VycmVudF9pbmRleCA9IC0xO1xuXHRcdFx0dmFyIHByZXZfaW5kZXggPSAtMTtcblxuXHRcdFx0Ly9pZih1c2VfaW5kaWNlcyAmJiBsYXN0X2luZGV4ID49IDI1NioyNTYpXG5cdFx0XHQvL1x0YnJlYWs7XG5cblx0XHRcdC8vZm9yIGV2ZXJ5IHBhY2sgb2YgaW5kaWNlcyBpbiB0aGUgcG9seWdvbiAodmVydGV4LCBub3JtYWwsIHV2LCAuLi4gKVxuXHRcdFx0Zm9yICh2YXIgayA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgayA8IGw7IGsgKz0gbnVtX2RhdGFfdmVydGV4KSB7XG5cdFx0XHRcdHZhciB2ZXJ0ZXhfaWQgPSBkYXRhLnNsaWNlKGssIGsgKyBudW1fZGF0YV92ZXJ0ZXgpLmpvaW4oXCIgXCIpOyAvL2dlbmVyYXRlIHVuaXF1ZSBpZFxuXG5cdFx0XHRcdHByZXZfaW5kZXggPSBjdXJyZW50X2luZGV4O1xuXHRcdFx0XHRpZiAoZmFjZW1hcC5oYXNPd25Qcm9wZXJ0eSh2ZXJ0ZXhfaWQpKSAvL2FkZCB0byBhcnJheXMsIGtlZXAgdGhlIGluZGV4XG5cdFx0XHRcdFx0Y3VycmVudF9pbmRleCA9IGZhY2VtYXBbdmVydGV4X2lkXTtlbHNlIHtcblx0XHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGJ1ZmZlcnMubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0XHRcdHZhciBidWZmZXIgPSBidWZmZXJzW2pdO1xuXHRcdFx0XHRcdFx0dmFyIGluZGV4ID0gcGFyc2VJbnQoZGF0YVtrICsgal0pO1xuXHRcdFx0XHRcdFx0dmFyIGFycmF5ID0gYnVmZmVyWzFdOyAvL2FycmF5IHdpdGggYWxsIHRoZSBkYXRhXG5cdFx0XHRcdFx0XHR2YXIgc291cmNlID0gYnVmZmVyWzNdOyAvL3doZXJlIHRvIHJlYWQgdGhlIGRhdGEgZnJvbVxuXHRcdFx0XHRcdFx0aWYgKGogPT0gMCkgdmVydGV4X3JlbWFwW2FycmF5Lmxlbmd0aCAvIG51bV9kYXRhX3ZlcnRleF0gPSBpbmRleDtcblx0XHRcdFx0XHRcdGluZGV4ICo9IGJ1ZmZlclsyXTsgLy9zdHJpZGVcblx0XHRcdFx0XHRcdGZvciAodmFyIHggPSAwOyB4IDwgYnVmZmVyWzJdOyArK3gpIHtcblx0XHRcdFx0XHRcdFx0YXJyYXkucHVzaChzb3VyY2VbaW5kZXggKyB4XSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y3VycmVudF9pbmRleCA9IGxhc3RfaW5kZXg7XG5cdFx0XHRcdFx0bGFzdF9pbmRleCArPSAxO1xuXHRcdFx0XHRcdGZhY2VtYXBbdmVydGV4X2lkXSA9IGN1cnJlbnRfaW5kZXg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpbmRpY2VzQXJyYXkucHVzaChjdXJyZW50X2luZGV4KTtcblx0XHRcdH0gLy9wZXIgdmVydGV4XG5cdFx0fSAvL3BlciBwb2x5Z29uXG5cblx0XHR2YXIgbWVzaCA9IHtcblx0XHRcdHByaW1pdGl2ZTogXCJsaW5lX3N0cmlwXCIsXG5cdFx0XHR2ZXJ0aWNlczogbmV3IEZsb2F0MzJBcnJheShidWZmZXJzWzBdWzFdKSxcblx0XHRcdGluZm86IHt9XG5cdFx0fTtcblxuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybU1lc2hJbmZvKG1lc2gsIGJ1ZmZlcnMsIGluZGljZXNBcnJheSk7XG5cdH0sXG5cblx0Ly9saWtlIHF1ZXJ5U2VsZWN0b3IgYnV0IGFsbG93cyBzcGFjZXMgaW4gbmFtZXMgYmVjYXVzZSBDT0xMQURBIGFsbG93cyBzcGFjZSBpbiBuYW1lc1xuXHRmaW5kWE1MTm9kZUJ5SWQ6IGZ1bmN0aW9uIGZpbmRYTUxOb2RlQnlJZChyb290LCBub2RlbmFtZSwgaWQpIHtcblx0XHQvL3ByZWNvbXB1dGVkXG5cdFx0aWYgKHRoaXMuX3htbHJvb3QuX25vZGVzX2J5X2lkKSB7XG5cdFx0XHR2YXIgbiA9IHRoaXMuX3htbHJvb3QuX25vZGVzX2J5X2lkW2lkXTtcblx0XHRcdGlmIChuICYmIG4ubG9jYWxOYW1lID09IG5vZGVuYW1lKSByZXR1cm4gbjtcblx0XHR9IGVsc2UgLy9mb3IgdGhlIG5hdGl2ZSBwYXJzZXJcblx0XHRcdHtcblx0XHRcdFx0dmFyIG4gPSB0aGlzLl94bWxyb290LmdldEVsZW1lbnRCeUlkKGlkKTtcblx0XHRcdFx0aWYgKG4pIHJldHVybiBuO1xuXHRcdFx0fVxuXG5cdFx0Ly9yZWN1cnNpdmU6IHNsb3dcblx0XHR2YXIgY2hpbGRzID0gcm9vdC5jaGlsZE5vZGVzO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHR2YXIgeG1sbm9kZSA9IGNoaWxkcy5pdGVtKGkpO1xuXHRcdFx0aWYgKHhtbG5vZGUubm9kZVR5cGUgIT0gMSkgLy9ubyB0YWdcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRpZiAoeG1sbm9kZS5sb2NhbE5hbWUgIT0gbm9kZW5hbWUpIGNvbnRpbnVlO1xuXHRcdFx0dmFyIG5vZGVfaWQgPSB4bWxub2RlLmdldEF0dHJpYnV0ZShcImlkXCIpO1xuXHRcdFx0aWYgKG5vZGVfaWQgPT0gaWQpIHJldHVybiB4bWxub2RlO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRyZWFkSW1hZ2VzOiBmdW5jdGlvbiByZWFkSW1hZ2VzKHJvb3QpIHtcblx0XHR2YXIgeG1saW1hZ2VzID0gcm9vdC5xdWVyeVNlbGVjdG9yKFwibGlicmFyeV9pbWFnZXNcIik7XG5cdFx0aWYgKCF4bWxpbWFnZXMpIHJldHVybiBudWxsO1xuXG5cdFx0dmFyIGltYWdlcyA9IHt9O1xuXG5cdFx0dmFyIHhtbGltYWdlc19jaGlsZHMgPSB4bWxpbWFnZXMuY2hpbGROb2Rlcztcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbGltYWdlc19jaGlsZHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdHZhciB4bWxpbWFnZSA9IHhtbGltYWdlc19jaGlsZHMuaXRlbShpKTtcblx0XHRcdGlmICh4bWxpbWFnZS5ub2RlVHlwZSAhPSAxKSAvL25vIHRhZ1xuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0dmFyIHhtbGluaXRmcm9tID0geG1saW1hZ2UucXVlcnlTZWxlY3RvcihcImluaXRfZnJvbVwiKTtcblx0XHRcdGlmICgheG1saW5pdGZyb20pIGNvbnRpbnVlO1xuXHRcdFx0aWYgKHhtbGluaXRmcm9tLnRleHRDb250ZW50KSB7XG5cdFx0XHRcdHZhciBmaWxlbmFtZSA9IHRoaXMuZ2V0RmlsZW5hbWUoeG1saW5pdGZyb20udGV4dENvbnRlbnQpO1xuXHRcdFx0XHR2YXIgaWQgPSB4bWxpbWFnZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKTtcblx0XHRcdFx0aW1hZ2VzW2lkXSA9IHsgZmlsZW5hbWU6IGZpbGVuYW1lLCBtYXA6IGlkLCBuYW1lOiB4bWxpbWFnZS5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpLCBwYXRoOiB4bWxpbml0ZnJvbS50ZXh0Q29udGVudCB9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBpbWFnZXM7XG5cdH0sXG5cblx0cmVhZEFuaW1hdGlvbnM6IGZ1bmN0aW9uIHJlYWRBbmltYXRpb25zKHJvb3QsIHNjZW5lKSB7XG5cdFx0dmFyIHhtbGFuaW1hdGlvbnMgPSByb290LnF1ZXJ5U2VsZWN0b3IoXCJsaWJyYXJ5X2FuaW1hdGlvbnNcIik7XG5cdFx0aWYgKCF4bWxhbmltYXRpb25zKSByZXR1cm4gbnVsbDtcblxuXHRcdHZhciB4bWxhbmltYXRpb25fY2hpbGRzID0geG1sYW5pbWF0aW9ucy5jaGlsZE5vZGVzO1xuXG5cdFx0dmFyIGFuaW1hdGlvbnMgPSB7XG5cdFx0XHRvYmplY3RfdHlwZTogXCJBbmltYXRpb25cIixcblx0XHRcdHRha2VzOiB7fVxuXHRcdH07XG5cblx0XHR2YXIgZGVmYXVsdF90YWtlID0geyB0cmFja3M6IFtdIH07XG5cdFx0dmFyIHRyYWNrcyA9IGRlZmF1bHRfdGFrZS50cmFja3M7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbGFuaW1hdGlvbl9jaGlsZHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdHZhciB4bWxhbmltYXRpb24gPSB4bWxhbmltYXRpb25fY2hpbGRzLml0ZW0oaSk7XG5cdFx0XHRpZiAoeG1sYW5pbWF0aW9uLm5vZGVUeXBlICE9IDEgfHwgeG1sYW5pbWF0aW9uLmxvY2FsTmFtZSAhPSBcImFuaW1hdGlvblwiKSAvL25vIHRhZ1xuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0dmFyIGFuaW1faWQgPSB4bWxhbmltYXRpb24uZ2V0QXR0cmlidXRlKFwiaWRcIik7XG5cdFx0XHRpZiAoIWFuaW1faWQpIC8vbmVzdGVkIGFuaW1hdGlvbiAoREFFIDEuNSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHZhciB4bWxhbmltYXRpb24yX2NoaWxkcyA9IHhtbGFuaW1hdGlvbi5xdWVyeVNlbGVjdG9yQWxsKFwiYW5pbWF0aW9uXCIpO1xuXHRcdFx0XHRcdGlmICh4bWxhbmltYXRpb24yX2NoaWxkcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgeG1sYW5pbWF0aW9uMl9jaGlsZHMubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0XHRcdFx0dmFyIHhtbGFuaW1hdGlvbjIgPSB4bWxhbmltYXRpb24yX2NoaWxkcy5pdGVtKGopO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnJlYWRBbmltYXRpb24oeG1sYW5pbWF0aW9uMiwgdHJhY2tzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgLy9zb3VyY2UgdHJhY2tzP1xuXHRcdFx0XHRcdFx0dGhpcy5yZWFkQW5pbWF0aW9uKHhtbGFuaW1hdGlvbiwgdHJhY2tzKTtcblx0XHRcdFx0fSBlbHNlIC8vbm8gbmVzdGVkIChEQUUgMS40KVxuXHRcdFx0XHR0aGlzLnJlYWRBbmltYXRpb24oeG1sYW5pbWF0aW9uLCB0cmFja3MpO1xuXHRcdH1cblxuXHRcdGlmICghdHJhY2tzLmxlbmd0aCkgcmV0dXJuIG51bGw7IC8vZW1wdHkgYW5pbWF0aW9uXG5cblx0XHQvL2NvbXB1dGUgYW5pbWF0aW9uIGR1cmF0aW9uXG5cdFx0dmFyIG1heF90aW1lID0gMDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0aWYgKG1heF90aW1lIDwgdHJhY2tzW2ldLmR1cmF0aW9uKSBtYXhfdGltZSA9IHRyYWNrc1tpXS5kdXJhdGlvbjtcblx0XHR9ZGVmYXVsdF90YWtlLm5hbWUgPSBcImRlZmF1bHRcIjtcblx0XHRkZWZhdWx0X3Rha2UuZHVyYXRpb24gPSBtYXhfdGltZTtcblx0XHRhbmltYXRpb25zLnRha2VzW2RlZmF1bHRfdGFrZS5uYW1lXSA9IGRlZmF1bHRfdGFrZTtcblx0XHRyZXR1cm4gYW5pbWF0aW9ucztcblx0fSxcblxuXHQvL2FuaW1hdGlvbiB4bWxcblx0cmVhZEFuaW1hdGlvbjogZnVuY3Rpb24gcmVhZEFuaW1hdGlvbih4bWxhbmltYXRpb24sIHJlc3VsdCkge1xuXHRcdGlmICh4bWxhbmltYXRpb24ubG9jYWxOYW1lICE9IFwiYW5pbWF0aW9uXCIpIHJldHVybiBudWxsO1xuXG5cdFx0Ly90aGlzIGNvdWxkIGJlIG1pc3Npbmcgd2hlbiB0aGVyZSBhcmUgbG90cyBvZiBhbmltcyBwYWNrZWQgaW4gb25lIDxhbmltYXRpb24+XG5cdFx0dmFyIGFuaW1faWQgPSB4bWxhbmltYXRpb24uZ2V0QXR0cmlidXRlKFwiaWRcIik7XG5cblx0XHQvL2NoYW5uZWxzIGFyZSBsaWtlIGFuaW1hdGVkIHByb3BlcnRpZXNcblx0XHR2YXIgeG1sY2hhbm5lbF9saXN0ID0geG1sYW5pbWF0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoXCJjaGFubmVsXCIpO1xuXHRcdGlmICgheG1sY2hhbm5lbF9saXN0Lmxlbmd0aCkgcmV0dXJuIG51bGw7XG5cblx0XHR2YXIgdHJhY2tzID0gcmVzdWx0IHx8IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWxjaGFubmVsX2xpc3QubGVuZ3RoOyArK2kpIHtcblx0XHRcdHZhciBhbmltID0gdGhpcy5yZWFkQ2hhbm5lbCh4bWxjaGFubmVsX2xpc3QuaXRlbShpKSwgeG1sYW5pbWF0aW9uKTtcblx0XHRcdGlmIChhbmltKSB0cmFja3MucHVzaChhbmltKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJhY2tzO1xuXHR9LFxuXG5cdHJlYWRDaGFubmVsOiBmdW5jdGlvbiByZWFkQ2hhbm5lbCh4bWxjaGFubmVsLCB4bWxhbmltYXRpb24pIHtcblx0XHRpZiAoeG1sY2hhbm5lbC5sb2NhbE5hbWUgIT0gXCJjaGFubmVsXCIgfHwgeG1sYW5pbWF0aW9uLmxvY2FsTmFtZSAhPSBcImFuaW1hdGlvblwiKSByZXR1cm4gbnVsbDtcblxuXHRcdHZhciBzb3VyY2UgPSB4bWxjaGFubmVsLmdldEF0dHJpYnV0ZShcInNvdXJjZVwiKTtcblx0XHR2YXIgdGFyZ2V0ID0geG1sY2hhbm5lbC5nZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIik7XG5cblx0XHQvL3NhbXBsZXIsIGlzIGluIGNoYXJnZSBvZiB0aGUgaW50ZXJwb2xhdGlvblxuXHRcdC8vdmFyIHhtbHNhbXBsZXIgPSB4bWxhbmltYXRpb24ucXVlcnlTZWxlY3RvcihcInNhbXBsZXJcIiArIHNvdXJjZSk7XG5cdFx0dmFyIHhtbHNhbXBsZXIgPSB0aGlzLmZpbmRYTUxOb2RlQnlJZCh4bWxhbmltYXRpb24sIFwic2FtcGxlclwiLCBzb3VyY2Uuc3Vic3RyKDEpKTtcblx0XHRpZiAoIXhtbHNhbXBsZXIpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciBEQUU6IFNhbXBsZXIgbm90IGZvdW5kIGluIFwiICsgc291cmNlKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHZhciBpbnB1dHMgPSB7fTtcblx0XHR2YXIgcGFyYW1zID0ge307XG5cdFx0dmFyIHNvdXJjZXMgPSB7fTtcblx0XHR2YXIgeG1saW5wdXRzID0geG1sc2FtcGxlci5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXRcIik7XG5cblx0XHR2YXIgdGltZV9kYXRhID0gbnVsbDtcblxuXHRcdC8vaXRlcmF0ZSBpbnB1dHM6IGNvbGxhZGEgc2VwYXJhdGVzIHRoZSBrZXlmcmFtZSBpbmZvIGluIGluZGVwZW5kZW50IHN0cmVhbXMsIGxpa2UgdGltZSwgaW50ZXJwb2xhdGlvbiBtZXRob2QsIHZhbHVlIClcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHhtbGlucHV0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0dmFyIHhtbGlucHV0ID0geG1saW5wdXRzLml0ZW0oaik7XG5cdFx0XHR2YXIgc291cmNlX25hbWUgPSB4bWxpbnB1dC5nZXRBdHRyaWJ1dGUoXCJzb3VyY2VcIik7XG5cblx0XHRcdC8vdGhlcmUgYXJlIHRocmVlIFxuXHRcdFx0dmFyIHNlbWFudGljID0geG1saW5wdXQuZ2V0QXR0cmlidXRlKFwic2VtYW50aWNcIik7XG5cblx0XHRcdC8vU2VhcmNoIGZvciBzb3VyY2Vcblx0XHRcdHZhciB4bWxzb3VyY2UgPSB0aGlzLmZpbmRYTUxOb2RlQnlJZCh4bWxhbmltYXRpb24sIFwic291cmNlXCIsIHNvdXJjZV9uYW1lLnN1YnN0cigxKSk7XG5cdFx0XHRpZiAoIXhtbHNvdXJjZSkgY29udGludWU7XG5cblx0XHRcdHZhciB4bWxwYXJhbSA9IHhtbHNvdXJjZS5xdWVyeVNlbGVjdG9yKFwicGFyYW1cIik7XG5cdFx0XHRpZiAoIXhtbHBhcmFtKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIHR5cGUgPSB4bWxwYXJhbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xuXHRcdFx0aW5wdXRzW3NlbWFudGljXSA9IHsgc291cmNlOiBzb3VyY2VfbmFtZSwgdHlwZTogdHlwZSB9O1xuXG5cdFx0XHR2YXIgZGF0YV9hcnJheSA9IG51bGw7XG5cblx0XHRcdGlmICh0eXBlID09IFwiZmxvYXRcIiB8fCB0eXBlID09IFwiZmxvYXQ0eDRcIikge1xuXHRcdFx0XHR2YXIgeG1sZmxvYXRhcnJheSA9IHhtbHNvdXJjZS5xdWVyeVNlbGVjdG9yKFwiZmxvYXRfYXJyYXlcIik7XG5cdFx0XHRcdHZhciBmbG9hdHMgPSB0aGlzLnJlYWRDb250ZW50QXNGbG9hdHMoeG1sZmxvYXRhcnJheSk7XG5cdFx0XHRcdHNvdXJjZXNbc291cmNlX25hbWVdID0gZmxvYXRzO1xuXHRcdFx0XHRkYXRhX2FycmF5ID0gZmxvYXRzO1xuXHRcdFx0fSBlbHNlIC8vb25seSBmbG9hdHMgYW5kIG1hdHJpY2VzIGFyZSBzdXBwb3J0ZWQgaW4gYW5pbWF0aW9uXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgcGFyYW1fbmFtZSA9IHhtbHBhcmFtLmdldEF0dHJpYnV0ZShcIm5hbWVcIik7XG5cdFx0XHRpZiAocGFyYW1fbmFtZSA9PSBcIlRJTUVcIikgdGltZV9kYXRhID0gZGF0YV9hcnJheTtcblx0XHRcdGlmIChzZW1hbnRpYyA9PSBcIk9VVFBVVFwiKSBwYXJhbV9uYW1lID0gc2VtYW50aWM7XG5cdFx0XHRpZiAocGFyYW1fbmFtZSkgcGFyYW1zW3BhcmFtX25hbWVdID0gdHlwZTtlbHNlIGNvbnNvbGUud2FybihcIkNvbGxhZGE6IDxwYXJhbT4gd2l0aG91dCBuYW1lIGF0dHJpYnV0ZSBpbiA8YW5pbWF0aW9uPlwiKTtcblx0XHR9XG5cblx0XHRpZiAoIXRpbWVfZGF0YSkge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcIkVycm9yIERBRTogbm8gVElNRSBpbmZvIGZvdW5kIGluIDxjaGFubmVsPjogXCIgKyB4bWxjaGFubmVsLmdldEF0dHJpYnV0ZShcInNvdXJjZVwiKSk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHQvL2NvbnN0cnVjdCBhbmltYXRpb25cblx0XHR2YXIgcGF0aCA9IHRhcmdldC5zcGxpdChcIi9cIik7XG5cblx0XHR2YXIgYW5pbSA9IHt9O1xuXHRcdHZhciBub2RlbmFtZSA9IHBhdGhbMF07IC8vc2FmZVN0cmluZyA/XG5cdFx0dmFyIG5vZGUgPSB0aGlzLl9ub2Rlc19ieV9pZFtub2RlbmFtZV07XG5cdFx0dmFyIGxvY2F0b3IgPSBub2RlLmlkICsgXCIvXCIgKyBwYXRoWzFdO1xuXHRcdC8vYW5pbS5ub2RlbmFtZSA9IHRoaXMuc2FmZVN0cmluZyggcGF0aFswXSApOyAvL3doZXJlIGl0IGdvZXNcblx0XHRhbmltLm5hbWUgPSBwYXRoWzFdO1xuXHRcdGFuaW0ucHJvcGVydHkgPSBsb2NhdG9yO1xuXHRcdHZhciB0eXBlID0gXCJudW1iZXJcIjtcblx0XHR2YXIgZWxlbWVudF9zaXplID0gMTtcblx0XHR2YXIgcGFyYW1fdHlwZSA9IHBhcmFtc1tcIk9VVFBVVFwiXTtcblx0XHRzd2l0Y2ggKHBhcmFtX3R5cGUpIHtcblx0XHRcdGNhc2UgXCJmbG9hdFwiOlxuXHRcdFx0XHRlbGVtZW50X3NpemUgPSAxO2JyZWFrO1xuXHRcdFx0Y2FzZSBcImZsb2F0M3gzXCI6XG5cdFx0XHRcdGVsZW1lbnRfc2l6ZSA9IDk7dHlwZSA9IFwibWF0M1wiO2JyZWFrO1xuXHRcdFx0Y2FzZSBcImZsb2F0NHg0XCI6XG5cdFx0XHRcdGVsZW1lbnRfc2l6ZSA9IDE2O3R5cGUgPSBcIm1hdDRcIjticmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdGFuaW0udHlwZSA9IHR5cGU7XG5cdFx0YW5pbS52YWx1ZV9zaXplID0gZWxlbWVudF9zaXplO1xuXHRcdGFuaW0uZHVyYXRpb24gPSB0aW1lX2RhdGFbdGltZV9kYXRhLmxlbmd0aCAtIDFdOyAvL2xhc3Qgc2FtcGxlXG5cblx0XHR2YXIgdmFsdWVfZGF0YSA9IHNvdXJjZXNbaW5wdXRzW1wiT1VUUFVUXCJdLnNvdXJjZV07XG5cdFx0aWYgKCF2YWx1ZV9kYXRhKSByZXR1cm4gbnVsbDtcblxuXHRcdC8vUGFjayBkYXRhICoqKioqKioqKioqKioqKipcblx0XHR2YXIgbnVtX3NhbXBsZXMgPSB0aW1lX2RhdGEubGVuZ3RoO1xuXHRcdHZhciBzYW1wbGVfc2l6ZSA9IGVsZW1lbnRfc2l6ZSArIDE7XG5cdFx0dmFyIGFuaW1fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkobnVtX3NhbXBsZXMgKiBzYW1wbGVfc2l6ZSk7XG5cdFx0Ly9mb3IgZXZlcnkgc2FtcGxlXG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCB0aW1lX2RhdGEubGVuZ3RoOyArK2opIHtcblx0XHRcdGFuaW1fZGF0YVtqICogc2FtcGxlX3NpemVdID0gdGltZV9kYXRhW2pdOyAvL3NldCB0aW1lXG5cdFx0XHR2YXIgdmFsdWUgPSB2YWx1ZV9kYXRhLnN1YmFycmF5KGogKiBlbGVtZW50X3NpemUsIChqICsgMSkgKiBlbGVtZW50X3NpemUpO1xuXHRcdFx0aWYgKHBhcmFtX3R5cGUgPT0gXCJmbG9hdDR4NFwiKSB7XG5cdFx0XHRcdHRoaXMudHJhbnNmb3JtTWF0cml4KHZhbHVlLCBub2RlID8gbm9kZS5fZGVwdGggPT0gMCA6IDApO1xuXHRcdFx0XHQvL21hdDQudHJhbnNwb3NlKHZhbHVlLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRhbmltX2RhdGEuc2V0KHZhbHVlLCBqICogc2FtcGxlX3NpemUgKyAxKTsgLy9zZXQgZGF0YVxuXHRcdH1cblxuXHRcdGlmIChpc1dvcmtlciAmJiB0aGlzLnVzZV90cmFuc2ZlcmFibGVzKSB7XG5cdFx0XHR2YXIgZGF0YSA9IGFuaW1fZGF0YTtcblx0XHRcdGlmIChkYXRhICYmIGRhdGEuYnVmZmVyICYmIGRhdGEubGVuZ3RoID4gMTAwKSB0aGlzLl90cmFuc2ZlcmFibGVzLnB1c2goZGF0YS5idWZmZXIpO1xuXHRcdH1cblxuXHRcdGFuaW0uZGF0YSA9IGFuaW1fZGF0YTtcblx0XHRyZXR1cm4gYW5pbTtcblx0fSxcblxuXHRmaW5kTm9kZTogZnVuY3Rpb24gZmluZE5vZGUocm9vdCwgaWQpIHtcblx0XHRpZiAocm9vdC5pZCA9PSBpZCkgcmV0dXJuIHJvb3Q7XG5cdFx0aWYgKHJvb3QuY2hpbGRyZW4pIGZvciAodmFyIGkgaW4gcm9vdC5jaGlsZHJlbikge1xuXHRcdFx0dmFyIHJldCA9IHRoaXMuZmluZE5vZGUocm9vdC5jaGlsZHJlbltpXSwgaWQpO1xuXHRcdFx0aWYgKHJldCkgcmV0dXJuIHJldDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Ly9yZWFkcyBjb250cm9sbGVycyBhbmQgc3RvcmVzIHRoZW0gaW4gXG5cdHJlYWRMaWJyYXJ5Q29udHJvbGxlcnM6IGZ1bmN0aW9uIHJlYWRMaWJyYXJ5Q29udHJvbGxlcnMoc2NlbmUpIHtcblx0XHR2YXIgeG1sbGlicmFyeWNvbnRyb2xsZXJzID0gdGhpcy5feG1scm9vdC5xdWVyeVNlbGVjdG9yKFwibGlicmFyeV9jb250cm9sbGVyc1wiKTtcblx0XHRpZiAoIXhtbGxpYnJhcnljb250cm9sbGVycykgcmV0dXJuIG51bGw7XG5cblx0XHR2YXIgeG1sbGlicmFyeWNvbnRyb2xsZXJzX2NoaWxkcyA9IHhtbGxpYnJhcnljb250cm9sbGVycy5jaGlsZE5vZGVzO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWxsaWJyYXJ5Y29udHJvbGxlcnNfY2hpbGRzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHR2YXIgeG1sY29udHJvbGxlciA9IHhtbGxpYnJhcnljb250cm9sbGVyc19jaGlsZHMuaXRlbShpKTtcblx0XHRcdGlmICh4bWxjb250cm9sbGVyLm5vZGVUeXBlICE9IDEgfHwgeG1sY29udHJvbGxlci5sb2NhbE5hbWUgIT0gXCJjb250cm9sbGVyXCIpIC8vbm8gdGFnXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0dmFyIGlkID0geG1sY29udHJvbGxlci5nZXRBdHRyaWJ1dGUoXCJpZFwiKTtcblx0XHRcdC8vd2UgaGF2ZSBhbHJlYWR5IHByb2Nlc3NlZCB0aGlzIGNvbnRyb2xsZXJcblx0XHRcdGlmICh0aGlzLl9jb250cm9sbGVyc19mb3VuZFtpZF0pIGNvbnRpbnVlO1xuXG5cdFx0XHQvL3JlYWQgaXQgKHdlIHdvbnQgdXNlIHRoZSByZXR1cm5zLCB3ZSB3aWxsIGdldCBpdCBmcm9tIHRoaXMuX2NvbnRyb2xsZXJzX2ZvdW5kXG5cdFx0XHR0aGlzLnJlYWRDb250cm9sbGVyKHhtbGNvbnRyb2xsZXIsIG51bGwsIHNjZW5lKTtcblx0XHR9XG5cdH0sXG5cblx0Ly91c2VkIGZvciBza2lubmluZyBhbmQgbW9ycGhpbmdcblx0cmVhZENvbnRyb2xsZXI6IGZ1bmN0aW9uIHJlYWRDb250cm9sbGVyKHhtbGNvbnRyb2xsZXIsIGZsaXAsIHNjZW5lKSB7XG5cdFx0aWYgKCF4bWxjb250cm9sbGVyLmxvY2FsTmFtZSA9PSBcImNvbnRyb2xsZXJcIikge1xuXHRcdFx0Y29uc29sZS53YXJuKFwicmVhZENvbnRyb2xsZXI6IG5vdCBhIGNvbnRyb2xsZXI6IFwiICsgeG1sY29udHJvbGxlci5sb2NhbE5hbWUpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0dmFyIGlkID0geG1sY29udHJvbGxlci5nZXRBdHRyaWJ1dGUoXCJpZFwiKTtcblx0XHQvL3VzZSBjYWNoZWRcblx0XHRpZiAodGhpcy5fY29udHJvbGxlcnNfZm91bmRbaWRdKSByZXR1cm4gdGhpcy5fY29udHJvbGxlcnNfZm91bmRbaWRdO1xuXG5cdFx0Ly9BR1VJTEFcblx0XHQvL1RPRE86IGRvZXMgdGhpcyB3b3JrP1xuXHRcdC8vIGlmICh0aGlzLl9jb250cm9sbGVyc19mb3VuZFsgaWQgXSlcblx0XHQvLyBcdHJldHVybiB0aGlzLl9jb250cm9sbGVyc19mb3VuZFsgaWQgXTtcblxuXHRcdHZhciB1c2VfaW5kaWNlcyA9IGZhbHNlO1xuXHRcdHZhciBtZXNoID0gbnVsbDtcblx0XHR2YXIgeG1sc2tpbiA9IHhtbGNvbnRyb2xsZXIucXVlcnlTZWxlY3RvcihcInNraW5cIik7XG5cdFx0aWYgKHhtbHNraW4pIHtcblx0XHRcdG1lc2ggPSB0aGlzLnJlYWRTa2luQ29udHJvbGxlcih4bWxza2luLCBmbGlwLCBzY2VuZSk7XG5cdFx0fVxuXG5cdFx0dmFyIHhtbG1vcnBoID0geG1sY29udHJvbGxlci5xdWVyeVNlbGVjdG9yKFwibW9ycGhcIik7XG5cdFx0aWYgKHhtbG1vcnBoKSBtZXNoID0gdGhpcy5yZWFkTW9ycGhDb250cm9sbGVyKHhtbG1vcnBoLCBmbGlwLCBzY2VuZSwgbWVzaCk7XG5cblx0XHQvL2NhY2hlIGFuZCByZXR1cm5cblx0XHRpZiAodGhpcy5fY29udHJvbGxlcnNfZm91bmRbaWRdKSB7XG5cdFx0XHRpZCArPSBcIl8xYmxhaFwiOyAvLz8/PyB0aGlzIGRvZXNudCBkbyBhbnl0aGluZ1xuXHRcdH0gZWxzZSB0aGlzLl9jb250cm9sbGVyc19mb3VuZFtpZF0gPSBtZXNoO1xuXG5cdFx0cmV0dXJuIG1lc2g7XG5cdH0sXG5cblx0Ly9yZWFkIHRoaXMgdG8gbW9yZSBpbmZvIGFib3V0IERBRSBhbmQgc2tpbm5pbmcgaHR0cHM6Ly9jb2xsYWRhLm9yZy9tZWRpYXdpa2kvaW5kZXgucGhwL1NraW5uaW5nXG5cdHJlYWRTa2luQ29udHJvbGxlcjogZnVuY3Rpb24gcmVhZFNraW5Db250cm9sbGVyKHhtbHNraW4sIGZsaXAsIHNjZW5lKSB7XG5cdFx0Ly9iYXNlIGdlb21ldHJ5XG5cdFx0dmFyIGlkX2dlb21ldHJ5ID0geG1sc2tpbi5nZXRBdHRyaWJ1dGUoXCJzb3VyY2VcIik7XG5cblx0XHR2YXIgbWVzaCA9IHRoaXMucmVhZEdlb21ldHJ5KGlkX2dlb21ldHJ5LCBmbGlwLCBzY2VuZSk7XG5cdFx0aWYgKCFtZXNoKSByZXR1cm4gbnVsbDtcblxuXHRcdHZhciBzb3VyY2VzID0gdGhpcy5yZWFkU291cmNlcyh4bWxza2luLCBmbGlwKTtcblx0XHRpZiAoIXNvdXJjZXMpIHJldHVybiBudWxsO1xuXG5cdFx0Ly9tYXRyaXhcblx0XHR2YXIgYmluZF9tYXRyaXggPSBudWxsO1xuXHRcdHZhciB4bWxiaW5kbWF0cml4ID0geG1sc2tpbi5xdWVyeVNlbGVjdG9yKFwiYmluZF9zaGFwZV9tYXRyaXhcIik7XG5cdFx0aWYgKHhtbGJpbmRtYXRyaXgpIHtcblx0XHRcdGJpbmRfbWF0cml4ID0gdGhpcy5yZWFkQ29udGVudEFzRmxvYXRzKHhtbGJpbmRtYXRyaXgpO1xuXHRcdFx0dGhpcy50cmFuc2Zvcm1NYXRyaXgoYmluZF9tYXRyaXgsIHRydWUsIHRydWUpO1xuXHRcdH0gZWxzZSBiaW5kX21hdHJpeCA9IF9nbE1hdHJpeC5tYXQ0LmNyZWF0ZSgpOyAvL2lkZW50aXR5XG5cblx0XHQvL2pvaW50c1xuXHRcdHZhciBqb2ludHMgPSBbXTtcblx0XHR2YXIgeG1sam9pbnRzID0geG1sc2tpbi5xdWVyeVNlbGVjdG9yKFwiam9pbnRzXCIpO1xuXHRcdGlmICh4bWxqb2ludHMpIHtcblx0XHRcdHZhciBqb2ludHNfc291cmNlID0gbnVsbDsgLy93aGljaCBib25lc1xuXHRcdFx0dmFyIGludl9iaW5kX3NvdXJjZSA9IG51bGw7IC8vYmluZCBtYXRyaWNlc1xuXHRcdFx0dmFyIHhtbGlucHV0cyA9IHhtbGpvaW50cy5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXRcIik7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbGlucHV0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgeG1saW5wdXQgPSB4bWxpbnB1dHNbaV07XG5cdFx0XHRcdHZhciBzZW0gPSB4bWxpbnB1dC5nZXRBdHRyaWJ1dGUoXCJzZW1hbnRpY1wiKS50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0XHR2YXIgc3JjID0geG1saW5wdXQuZ2V0QXR0cmlidXRlKFwic291cmNlXCIpO1xuXHRcdFx0XHR2YXIgc291cmNlID0gc291cmNlc1tzcmMuc3Vic3RyKDEpXTtcblx0XHRcdFx0aWYgKHNlbSA9PSBcIkpPSU5UXCIpIGpvaW50c19zb3VyY2UgPSBzb3VyY2U7ZWxzZSBpZiAoc2VtID09IFwiSU5WX0JJTkRfTUFUUklYXCIpIGludl9iaW5kX3NvdXJjZSA9IHNvdXJjZTtcblx0XHRcdH1cblxuXHRcdFx0Ly9zYXZlIGJvbmUgbmFtZXMgYW5kIGludiBtYXRyaXhcblx0XHRcdGlmICghaW52X2JpbmRfc291cmNlIHx8ICFqb2ludHNfc291cmNlKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciBEQUU6IG5vIGpvaW50cyBvciBpbnZfYmluZCBzb3VyY2VzIGZvdW5kXCIpO1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIgaSBpbiBqb2ludHNfc291cmNlKSB7XG5cdFx0XHRcdC8vZ2V0IHRoZSBpbnZlcnNlIG9mIHRoZSBiaW5kIHBvc2Vcblx0XHRcdFx0dmFyIGludl9tYXQgPSBpbnZfYmluZF9zb3VyY2Uuc3ViYXJyYXkoaSAqIDE2LCBpICogMTYgKyAxNik7XG5cdFx0XHRcdHZhciBub2RlbmFtZSA9IGpvaW50c19zb3VyY2VbaV07XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5fbm9kZXNfYnlfaWRbbm9kZW5hbWVdO1xuXHRcdFx0XHRpZiAoIW5vZGUpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oXCJOb2RlIFwiICsgbm9kZW5hbWUgKyBcIiBub3QgZm91bmRcIik7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy50cmFuc2Zvcm1NYXRyaXgoaW52X21hdCwgbm9kZS5fZGVwdGggPT0gMCwgdHJ1ZSk7XG5cdFx0XHRcdGpvaW50cy5wdXNoKFtub2RlbmFtZSwgaW52X21hdF0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vd2VpZ2h0c1xuXHRcdHZhciB4bWx2ZXJ0ZXh3ZWlnaHRzID0geG1sc2tpbi5xdWVyeVNlbGVjdG9yKFwidmVydGV4X3dlaWdodHNcIik7XG5cdFx0aWYgKHhtbHZlcnRleHdlaWdodHMpIHtcblxuXHRcdFx0Ly9oZXJlIHdlIHNlZSB0aGUgb3JkZXIgXG5cdFx0XHR2YXIgd2VpZ2h0c19pbmRleGVkX2FycmF5ID0gbnVsbDtcblx0XHRcdHZhciB4bWxpbnB1dHMgPSB4bWx2ZXJ0ZXh3ZWlnaHRzLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFwiKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1saW5wdXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmICh4bWxpbnB1dHNbaV0uZ2V0QXR0cmlidXRlKFwic2VtYW50aWNcIikudG9VcHBlckNhc2UoKSA9PSBcIldFSUdIVFwiKSB3ZWlnaHRzX2luZGV4ZWRfYXJyYXkgPSBzb3VyY2VzW3htbGlucHV0cy5pdGVtKGkpLmdldEF0dHJpYnV0ZShcInNvdXJjZVwiKS5zdWJzdHIoMSldO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXdlaWdodHNfaW5kZXhlZF9hcnJheSkgdGhyb3cgXCJubyB3ZWlnaHRzIGZvdW5kXCI7XG5cblx0XHRcdHZhciB4bWx2Y291bnQgPSB4bWx2ZXJ0ZXh3ZWlnaHRzLnF1ZXJ5U2VsZWN0b3IoXCJ2Y291bnRcIik7XG5cdFx0XHR2YXIgdmNvdW50ID0gdGhpcy5yZWFkQ29udGVudEFzVUludDMyKHhtbHZjb3VudCk7XG5cblx0XHRcdHZhciB4bWx2ID0geG1sdmVydGV4d2VpZ2h0cy5xdWVyeVNlbGVjdG9yKFwidlwiKTtcblx0XHRcdHZhciB2ID0gdGhpcy5yZWFkQ29udGVudEFzVUludDMyKHhtbHYpO1xuXG5cdFx0XHR2YXIgbnVtX3ZlcnRpY2VzID0gbWVzaC52ZXJ0aWNlcy5sZW5ndGggLyAzOyAvLzMgY29tcG9uZW50cyBwZXIgdmVydGV4XG5cdFx0XHR2YXIgd2VpZ2h0c19hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoNCAqIG51bV92ZXJ0aWNlcyk7IC8vNCBib25lcyBwZXIgdmVydGV4XG5cdFx0XHR2YXIgYm9uZV9pbmRleF9hcnJheSA9IG5ldyBVaW50OEFycmF5KDQgKiBudW1fdmVydGljZXMpOyAvLzQgYm9uZXMgcGVyIHZlcnRleFxuXG5cdFx0XHR2YXIgcG9zID0gMDtcblx0XHRcdHZhciByZW1hcCA9IG1lc2guX3JlbWFwO1xuXHRcdFx0dmFyIG1heF9ib25lID0gMDsgLy9tYXggYm9uZSBhZmZlY3RlZFxuXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHZjb3VudC5sZW5ndGg7IGkgPCBsOyArK2kpIHtcblx0XHRcdFx0dmFyIG51bV9ib25lcyA9IHZjb3VudFtpXTsgLy9udW0gYm9uZXMgaW5mbHVlbmNpbmcgdGhpcyB2ZXJ0ZXhcblxuXHRcdFx0XHQvL2ZpbmQgNCB3aXRoIG1vcmUgaW5mbHVlbmNlXG5cdFx0XHRcdC8vdmFyIHZfdHVwbGV0cyA9IHYuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBudW1fYm9uZXMqMik7XG5cblx0XHRcdFx0dmFyIG9mZnNldCA9IHBvcztcblx0XHRcdFx0dmFyIGIgPSBib25lX2luZGV4X2FycmF5LnN1YmFycmF5KGkgKiA0LCBpICogNCArIDQpO1xuXHRcdFx0XHR2YXIgdyA9IHdlaWdodHNfYXJyYXkuc3ViYXJyYXkoaSAqIDQsIGkgKiA0ICsgNCk7XG5cblx0XHRcdFx0dmFyIHN1bSA9IDA7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbnVtX2JvbmVzICYmIGogPCA0OyArK2opIHtcblx0XHRcdFx0XHRiW2pdID0gdltvZmZzZXQgKyBqICogMl07XG5cdFx0XHRcdFx0aWYgKGJbal0gPiBtYXhfYm9uZSkgbWF4X2JvbmUgPSBiW2pdO1xuXG5cdFx0XHRcdFx0d1tqXSA9IHdlaWdodHNfaW5kZXhlZF9hcnJheVt2W29mZnNldCArIGogKiAyICsgMV1dO1xuXHRcdFx0XHRcdHN1bSArPSB3W2pdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9ub3JtYWxpemUgd2VpZ2h0c1xuXHRcdFx0XHRpZiAobnVtX2JvbmVzID4gNCAmJiBzdW0gPCAxLjApIHtcblx0XHRcdFx0XHR2YXIgaW52X3N1bSA9IDEgLyBzdW07XG5cdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCA0OyArK2opIHtcblx0XHRcdFx0XHRcdHdbal0gKj0gaW52X3N1bTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwb3MgKz0gbnVtX2JvbmVzICogMjtcblx0XHRcdH1cblxuXHRcdFx0Ly9yZW1hcDogYmVjYXVzZSB2ZXJ0aWNlcyBvcmRlciBpcyBub3cgY2hhbmdlZCBhZnRlciBwYXJzaW5nIHRoZSBtZXNoXG5cdFx0XHR2YXIgZmluYWxfd2VpZ2h0cyA9IG5ldyBGbG9hdDMyQXJyYXkoNCAqIG51bV92ZXJ0aWNlcyk7IC8vNCBib25lcyBwZXIgdmVydGV4XG5cdFx0XHR2YXIgZmluYWxfYm9uZV9pbmRpY2VzID0gbmV3IFVpbnQ4QXJyYXkoNCAqIG51bV92ZXJ0aWNlcyk7IC8vNCBib25lcyBwZXIgdmVydGV4XG5cdFx0XHR2YXIgdXNlZF9qb2ludHMgPSBbXTtcblxuXHRcdFx0Ly9mb3IgZXZlcnkgdmVydGV4IGluIHRoZSBtZXNoLCBwcm9jZXNzIGJvbmUgaW5kaWNlcyBhbmQgd2VpZ2h0c1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBudW1fdmVydGljZXM7ICsraSkge1xuXHRcdFx0XHR2YXIgcCA9IHJlbWFwW2ldICogNDtcblx0XHRcdFx0dmFyIHcgPSB3ZWlnaHRzX2FycmF5LnN1YmFycmF5KHAsIHAgKyA0KTtcblx0XHRcdFx0dmFyIGIgPSBib25lX2luZGV4X2FycmF5LnN1YmFycmF5KHAsIHAgKyA0KTtcblxuXHRcdFx0XHQvL3NvcnQgYnkgd2VpZ2h0IHNvIHJlbGV2YW50IG9uZXMgZ29lcyBmaXJzdFxuXHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IDM7ICsraykge1xuXHRcdFx0XHRcdHZhciBtYXhfcG9zID0gaztcblx0XHRcdFx0XHR2YXIgbWF4X3ZhbHVlID0gd1trXTtcblx0XHRcdFx0XHRmb3IgKHZhciBqID0gayArIDE7IGogPCA0OyArK2opIHtcblx0XHRcdFx0XHRcdGlmICh3W2pdIDw9IG1heF92YWx1ZSkgY29udGludWU7XG5cdFx0XHRcdFx0XHRtYXhfcG9zID0gajtcblx0XHRcdFx0XHRcdG1heF92YWx1ZSA9IHdbal07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtYXhfcG9zICE9IGspIHtcblx0XHRcdFx0XHRcdHZhciB0bXAgPSB3W2tdO1xuXHRcdFx0XHRcdFx0d1trXSA9IHdbbWF4X3Bvc107XG5cdFx0XHRcdFx0XHR3W21heF9wb3NdID0gdG1wO1xuXHRcdFx0XHRcdFx0dG1wID0gYltrXTtcblx0XHRcdFx0XHRcdGJba10gPSBiW21heF9wb3NdO1xuXHRcdFx0XHRcdFx0YlttYXhfcG9zXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL3N0b3JlXG5cdFx0XHRcdGZpbmFsX3dlaWdodHMuc2V0KHcsIGkgKiA0KTtcblx0XHRcdFx0ZmluYWxfYm9uZV9pbmRpY2VzLnNldChiLCBpICogNCk7XG5cblx0XHRcdFx0Ly9tYXJrIGJvbmVzIHVzZWRcblx0XHRcdFx0aWYgKHdbMF0pIHVzZWRfam9pbnRzW2JbMF1dID0gdHJ1ZTtcblx0XHRcdFx0aWYgKHdbMV0pIHVzZWRfam9pbnRzW2JbMV1dID0gdHJ1ZTtcblx0XHRcdFx0aWYgKHdbMl0pIHVzZWRfam9pbnRzW2JbMl1dID0gdHJ1ZTtcblx0XHRcdFx0aWYgKHdbM10pIHVzZWRfam9pbnRzW2JbM11dID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1heF9ib25lID49IGpvaW50cy5sZW5ndGgpIGNvbnNvbGUud2FybihcIk1lc2ggdXNlcyBoaWdoZXIgYm9uZSBpbmRleCB0aGFuIGJvbmVzIGZvdW5kXCIpO1xuXG5cdFx0XHQvL3RyaW0gdW51c2VkIGJvbmVzIChjb2xsYWRhIGNvdWxkIGdpdmUgeW91IDEwMCBib25lcyBmb3IgYW4gb2JqZWN0IHRoYXQgb25seSB1c2VzIGEgZnJhY3Rpb24gb2YgdGhlbSlcblx0XHRcdGlmICgxKSB7XG5cdFx0XHRcdHZhciBuZXdfYm9uZXMgPSBbXTtcblx0XHRcdFx0dmFyIGJvbmVzX3RyYW5zbGF0aW9uID0ge307XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdXNlZF9qb2ludHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0XHRpZiAodXNlZF9qb2ludHNbaV0pIHtcblx0XHRcdFx0XHRcdGJvbmVzX3RyYW5zbGF0aW9uW2ldID0gbmV3X2JvbmVzLmxlbmd0aDtcblx0XHRcdFx0XHRcdG5ld19ib25lcy5wdXNoKGpvaW50c1tpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IC8vaW4gY2FzZSB0aGVyZSBhcmUgbGVzcyBib25lcyBpbiB1c2UuLi5cblx0XHRcdFx0aWYgKG5ld19ib25lcy5sZW5ndGggPCBqb2ludHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0Ly9yZW1hcFxuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZmluYWxfYm9uZV9pbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRmaW5hbF9ib25lX2luZGljZXNbaV0gPSBib25lc190cmFuc2xhdGlvbltmaW5hbF9ib25lX2luZGljZXNbaV1dO1xuXHRcdFx0XHRcdH1qb2ludHMgPSBuZXdfYm9uZXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcIkJvbmVzOiBcIiwgam9pbnRzLmxlbmd0aCwgXCIgdXNlZDpcIiwgbnVtX3VzZWRfam9pbnRzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vY29uc29sZS5sb2coXCJCb25lczogXCIsIGpvaW50cy5sZW5ndGgsIFwiTWF4IGJvbmU6IFwiLCBtYXhfYm9uZSk7XG5cblx0XHRcdG1lc2gud2VpZ2h0cyA9IGZpbmFsX3dlaWdodHM7XG5cdFx0XHRtZXNoLmJvbmVfaW5kaWNlcyA9IGZpbmFsX2JvbmVfaW5kaWNlcztcblx0XHRcdG1lc2guYm9uZXMgPSBqb2ludHM7XG5cdFx0XHRtZXNoLmJpbmRfbWF0cml4ID0gYmluZF9tYXRyaXg7XG5cblx0XHRcdC8vZGVsZXRlIG1lc2hbXCJfcmVtYXBcIl07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lc2g7XG5cdH0sXG5cblx0Ly9OT1QgVEVTVEVEXG5cdHJlYWRNb3JwaENvbnRyb2xsZXI6IGZ1bmN0aW9uIHJlYWRNb3JwaENvbnRyb2xsZXIoeG1sbW9ycGgsIGZsaXAsIHNjZW5lLCBtZXNoKSB7XG5cdFx0dmFyIGlkX2dlb21ldHJ5ID0geG1sbW9ycGguZ2V0QXR0cmlidXRlKFwic291cmNlXCIpO1xuXHRcdHZhciBiYXNlX21lc2ggPSB0aGlzLnJlYWRHZW9tZXRyeShpZF9nZW9tZXRyeSwgZmxpcCwgc2NlbmUpO1xuXHRcdGlmICghYmFzZV9tZXNoKSByZXR1cm4gbnVsbDtcblxuXHRcdC8vcmVhZCBzb3VyY2VzIHdpdGggYmxlbmQgc2hhcGVzIGluZm8gKHdoaWNoIG9uZXMsIGFuZCB0aGUgd2VpZ2h0KVxuXHRcdHZhciBzb3VyY2VzID0gdGhpcy5yZWFkU291cmNlcyh4bWxtb3JwaCwgZmxpcCk7XG5cblx0XHR2YXIgbW9ycGhzID0gW107XG5cblx0XHQvL3RhcmdldHNcblx0XHR2YXIgeG1sdGFyZ2V0cyA9IHhtbG1vcnBoLnF1ZXJ5U2VsZWN0b3IoXCJ0YXJnZXRzXCIpO1xuXHRcdGlmICgheG1sdGFyZ2V0cykgcmV0dXJuIG51bGw7XG5cblx0XHR2YXIgeG1saW5wdXRzID0geG1sdGFyZ2V0cy5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXRcIik7XG5cdFx0dmFyIHRhcmdldHMgPSBudWxsO1xuXHRcdHZhciB3ZWlnaHRzID0gbnVsbDtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1saW5wdXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgeG1saW5wdXQgPSB4bWxpbnB1dHMuaXRlbShpKTtcblx0XHRcdHZhciBzZW1hbnRpYyA9IHhtbGlucHV0LmdldEF0dHJpYnV0ZShcInNlbWFudGljXCIpLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHR2YXIgZGF0YSA9IHNvdXJjZXNbeG1saW5wdXQuZ2V0QXR0cmlidXRlKFwic291cmNlXCIpLnN1YnN0cigxKV07XG5cdFx0XHRpZiAoc2VtYW50aWMgPT0gXCJNT1JQSF9UQVJHRVRcIikgdGFyZ2V0cyA9IGRhdGE7ZWxzZSBpZiAoc2VtYW50aWMgPT0gXCJNT1JQSF9XRUlHSFRcIikgd2VpZ2h0cyA9IGRhdGE7XG5cdFx0fVxuXG5cdFx0aWYgKCF0YXJnZXRzIHx8ICF3ZWlnaHRzKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oXCJNb3JwaCBjb250cm9sbGVyIHdpdGhvdXQgdGFyZ2V0cyBvciB3ZWlnaHRzLiBTa2lwcGluZyBpdC5cIik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHQvL2dldCB0YXJnZXRzXG5cdFx0Zm9yICh2YXIgaSBpbiB0YXJnZXRzKSB7XG5cdFx0XHR2YXIgaWQgPSBcIiNcIiArIHRhcmdldHNbaV07XG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSB0aGlzLnJlYWRHZW9tZXRyeShpZCwgZmxpcCwgc2NlbmUpO1xuXHRcdFx0c2NlbmUubWVzaGVzW2lkXSA9IGdlb21ldHJ5O1xuXHRcdFx0bW9ycGhzLnB1c2goeyBtZXNoOiBpZCwgd2VpZ2h0OiB3ZWlnaHRzW2ldIH0pO1xuXHRcdH1cblxuXHRcdGJhc2VfbWVzaC5tb3JwaF90YXJnZXRzID0gbW9ycGhzO1xuXHRcdHJldHVybiBiYXNlX21lc2g7XG5cdH0sXG5cblx0cmVhZEJpbmRNYXRlcmlhbHM6IGZ1bmN0aW9uIHJlYWRCaW5kTWF0ZXJpYWxzKHhtbGJpbmRfbWF0ZXJpYWwsIG1lc2gpIHtcblx0XHR2YXIgbWF0ZXJpYWxzID0gW107XG5cblx0XHR2YXIgeG1sdGVjaG5pcXVlcyA9IHhtbGJpbmRfbWF0ZXJpYWwucXVlcnlTZWxlY3RvckFsbChcInRlY2huaXF1ZV9jb21tb25cIik7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWx0ZWNobmlxdWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgeG1sdGVjaG5pcXVlID0geG1sdGVjaG5pcXVlcy5pdGVtKGkpO1xuXHRcdFx0dmFyIHhtbGluc3RhbmNlX21hdGVyaWFscyA9IHhtbHRlY2huaXF1ZS5xdWVyeVNlbGVjdG9yQWxsKFwiaW5zdGFuY2VfbWF0ZXJpYWxcIik7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHhtbGluc3RhbmNlX21hdGVyaWFscy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHR2YXIgeG1saW5zdGFuY2VfbWF0ZXJpYWwgPSB4bWxpbnN0YW5jZV9tYXRlcmlhbHMuaXRlbShqKTtcblx0XHRcdFx0aWYgKHhtbGluc3RhbmNlX21hdGVyaWFsKSBtYXRlcmlhbHMucHVzaCh4bWxpbnN0YW5jZV9tYXRlcmlhbC5nZXRBdHRyaWJ1dGUoXCJzeW1ib2xcIikpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRlcmlhbHM7XG5cdH0sXG5cblx0cmVhZFNvdXJjZXM6IGZ1bmN0aW9uIHJlYWRTb3VyY2VzKHhtbG5vZGUsIGZsaXApIHtcblx0XHQvL2ZvciBkYXRhIHNvdXJjZXNcblx0XHR2YXIgc291cmNlcyA9IHt9O1xuXHRcdHZhciB4bWxzb3VyY2VzID0geG1sbm9kZS5xdWVyeVNlbGVjdG9yQWxsKFwic291cmNlXCIpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1sc291cmNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHhtbHNvdXJjZSA9IHhtbHNvdXJjZXMuaXRlbShpKTtcblx0XHRcdGlmICgheG1sc291cmNlLnF1ZXJ5U2VsZWN0b3IpIC8vPz9cblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdHZhciBmbG9hdF9hcnJheSA9IHhtbHNvdXJjZS5xdWVyeVNlbGVjdG9yKFwiZmxvYXRfYXJyYXlcIik7XG5cdFx0XHRpZiAoZmxvYXRfYXJyYXkpIHtcblx0XHRcdFx0dmFyIGZsb2F0cyA9IHRoaXMucmVhZENvbnRlbnRBc0Zsb2F0cyh4bWxzb3VyY2UpO1xuXHRcdFx0XHRzb3VyY2VzW3htbHNvdXJjZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKV0gPSBmbG9hdHM7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbmFtZV9hcnJheSA9IHhtbHNvdXJjZS5xdWVyeVNlbGVjdG9yKFwiTmFtZV9hcnJheVwiKTtcblx0XHRcdGlmIChuYW1lX2FycmF5KSB7XG5cdFx0XHRcdHZhciBuYW1lcyA9IHRoaXMucmVhZENvbnRlbnRBc1N0cmluZ3NBcnJheShuYW1lX2FycmF5KTtcblx0XHRcdFx0aWYgKCFuYW1lcykgY29udGludWU7XG5cdFx0XHRcdHNvdXJjZXNbeG1sc291cmNlLmdldEF0dHJpYnV0ZShcImlkXCIpXSA9IG5hbWVzO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHJlZl9hcnJheSA9IHhtbHNvdXJjZS5xdWVyeVNlbGVjdG9yKFwiSURSRUZfYXJyYXlcIik7XG5cdFx0XHRpZiAocmVmX2FycmF5KSB7XG5cdFx0XHRcdHZhciBuYW1lcyA9IHRoaXMucmVhZENvbnRlbnRBc1N0cmluZ3NBcnJheShyZWZfYXJyYXkpO1xuXHRcdFx0XHRpZiAoIW5hbWVzKSBjb250aW51ZTtcblx0XHRcdFx0c291cmNlc1t4bWxzb3VyY2UuZ2V0QXR0cmlidXRlKFwiaWRcIildID0gbmFtZXM7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBzb3VyY2VzO1xuXHR9LFxuXG5cdHJlYWRDb250ZW50QXNVSW50MzI6IGZ1bmN0aW9uIHJlYWRDb250ZW50QXNVSW50MzIoeG1sbm9kZSkge1xuXHRcdGlmICgheG1sbm9kZSkgcmV0dXJuIG51bGw7XG5cdFx0dmFyIHRleHQgPSB4bWxub2RlLnRleHRDb250ZW50O1xuXHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcbi9naSwgXCIgXCIpOyAvL3JlbW92ZSBsaW5lIGJyZWFrc1xuXHRcdHRleHQgPSB0ZXh0LnRyaW0oKTsgLy9yZW1vdmUgZW1wdHkgc3BhY2VzXG5cdFx0aWYgKHRleHQubGVuZ3RoID09IDApIHJldHVybiBudWxsO1xuXHRcdHZhciBudW1iZXJzID0gdGV4dC5zcGxpdChcIiBcIik7IC8vY3JlYXRlIGFycmF5XG5cdFx0dmFyIGZsb2F0cyA9IG5ldyBVaW50MzJBcnJheShudW1iZXJzLmxlbmd0aCk7XG5cdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBudW1iZXJzLmxlbmd0aDsgaysrKSB7XG5cdFx0XHRmbG9hdHNba10gPSBwYXJzZUludChudW1iZXJzW2tdKTtcblx0XHR9cmV0dXJuIGZsb2F0cztcblx0fSxcblxuXHRyZWFkQ29udGVudEFzRmxvYXRzOiBmdW5jdGlvbiByZWFkQ29udGVudEFzRmxvYXRzKHhtbG5vZGUpIHtcblx0XHRpZiAoIXhtbG5vZGUpIHJldHVybiBudWxsO1xuXHRcdHZhciB0ZXh0ID0geG1sbm9kZS50ZXh0Q29udGVudDtcblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXG4vZ2ksIFwiIFwiKTsgLy9yZW1vdmUgbGluZSBicmVha3Ncblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHNcXHMrL2dpLCBcIiBcIik7XG5cdFx0dGV4dCA9IHRleHQucmVwbGFjZSgvXFx0L2dpLCBcIlwiKTtcblx0XHR0ZXh0ID0gdGV4dC50cmltKCk7IC8vcmVtb3ZlIGVtcHR5IHNwYWNlc1xuXHRcdHZhciBudW1iZXJzID0gdGV4dC5zcGxpdChcIiBcIik7IC8vY3JlYXRlIGFycmF5XG5cdFx0dmFyIGNvdW50ID0geG1sbm9kZS5nZXRBdHRyaWJ1dGUoXCJjb3VudFwiKTtcblx0XHR2YXIgbGVuZ3RoID0gY291bnQgPyBwYXJzZUludChjb3VudCkgOiBudW1iZXJzLmxlbmd0aDtcblx0XHR2YXIgZmxvYXRzID0gbmV3IEZsb2F0MzJBcnJheShsZW5ndGgpO1xuXHRcdGZvciAodmFyIGsgPSAwOyBrIDwgbnVtYmVycy5sZW5ndGg7IGsrKykge1xuXHRcdFx0ZmxvYXRzW2tdID0gcGFyc2VGbG9hdChudW1iZXJzW2tdKTtcblx0XHR9cmV0dXJuIGZsb2F0cztcblx0fSxcblxuXHRyZWFkQ29udGVudEFzU3RyaW5nc0FycmF5OiBmdW5jdGlvbiByZWFkQ29udGVudEFzU3RyaW5nc0FycmF5KHhtbG5vZGUpIHtcblx0XHRpZiAoIXhtbG5vZGUpIHJldHVybiBudWxsO1xuXHRcdHZhciB0ZXh0ID0geG1sbm9kZS50ZXh0Q29udGVudDtcblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXG4vZ2ksIFwiIFwiKTsgLy9yZW1vdmUgbGluZSBicmVha3Ncblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHNcXHMvZ2ksIFwiIFwiKTtcblx0XHR0ZXh0ID0gdGV4dC50cmltKCk7IC8vcmVtb3ZlIGVtcHR5IHNwYWNlc1xuXHRcdHZhciB3b3JkcyA9IHRleHQuc3BsaXQoXCIgXCIpOyAvL2NyZWF0ZSBhcnJheVxuXHRcdGZvciAodmFyIGsgPSAwOyBrIDwgd29yZHMubGVuZ3RoOyBrKyspIHtcblx0XHRcdHdvcmRzW2tdID0gd29yZHNba10udHJpbSgpO1xuXHRcdH1pZiAoeG1sbm9kZS5nZXRBdHRyaWJ1dGUoXCJjb3VudFwiKSAmJiBwYXJzZUludCh4bWxub2RlLmdldEF0dHJpYnV0ZShcImNvdW50XCIpKSAhPSB3b3Jkcy5sZW5ndGgpIHtcblx0XHRcdHZhciBtZXJnZWRfd29yZHMgPSBbXTtcblx0XHRcdHZhciBuYW1lID0gXCJcIjtcblx0XHRcdGZvciAodmFyIGkgaW4gd29yZHMpIHtcblx0XHRcdFx0aWYgKCFuYW1lKSBuYW1lID0gd29yZHNbaV07ZWxzZSBuYW1lICs9IFwiIFwiICsgd29yZHNbaV07XG5cdFx0XHRcdGlmICghdGhpcy5fbm9kZXNfYnlfaWRbdGhpcy5zYWZlU3RyaW5nKG5hbWUpXSkgY29udGludWU7XG5cdFx0XHRcdG1lcmdlZF93b3Jkcy5wdXNoKHRoaXMuc2FmZVN0cmluZyhuYW1lKSk7XG5cdFx0XHRcdG5hbWUgPSBcIlwiO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY291bnQgPSBwYXJzZUludCh4bWxub2RlLmdldEF0dHJpYnV0ZShcImNvdW50XCIpKTtcblx0XHRcdGlmIChtZXJnZWRfd29yZHMubGVuZ3RoID09IGNvdW50KSByZXR1cm4gbWVyZ2VkX3dvcmRzO1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKFwiRXJyb3I6IGJvbmUgbmFtZXMgaGF2ZSBzcGFjZXMsIGF2b2lkIHVzaW5nIHNwYWNlcyBpbiBuYW1lc1wiKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gd29yZHM7XG5cdH0sXG5cblx0bWF4M2RfbWF0cml4XzA6IG5ldyBGbG9hdDMyQXJyYXkoWzAsIC0xLCAwLCAwLCAwLCAwLCAtMSwgMCwgMSwgMCwgMCwgLTAsIDAsIDAsIDAsIDFdKSxcblx0Ly9tYXgzZF9tYXRyaXhfb3RoZXI6IG5ldyBGbG9hdDMyQXJyYXkoWzAsIC0xLCAwLCAwLCAwLCAwLCAtMSwgMCwgMSwgMCwgMCwgLTAsIDAsIDAsIDAsIDFdKSxcblxuXHR0cmFuc2Zvcm1NYXRyaXg6IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdHJpeChtYXRyaXgsIGZpcnN0X2xldmVsLCBpbnZlcnRlZCkge1xuXHRcdF9nbE1hdHJpeC5tYXQ0LnRyYW5zcG9zZShtYXRyaXgsIG1hdHJpeCk7XG5cblx0XHRpZiAodGhpcy5ub19mbGlwKSByZXR1cm4gbWF0cml4O1xuXG5cdFx0Ly9XQVJOSU5HOiBETyBOT1QgQ0hBTkdFIFRISVMgRlVOQ1RJT04sIFRIRSBTS1kgV0lMTCBGQUxMXG5cdFx0aWYgKGZpcnN0X2xldmVsKSB7XG5cblx0XHRcdC8vZmxpcCByb3cgdHdvIGFuZCB0cmVlXG5cdFx0XHR2YXIgdGVtcCA9IG5ldyBGbG9hdDMyQXJyYXkobWF0cml4LnN1YmFycmF5KDQsIDgpKTsgLy9zd2FwIHJvd3Ncblx0XHRcdG1hdHJpeC5zZXQobWF0cml4LnN1YmFycmF5KDgsIDEyKSwgNCk7XG5cdFx0XHRtYXRyaXguc2V0KHRlbXAsIDgpO1xuXG5cdFx0XHQvL3JldmVyc2UgWlxuXHRcdFx0dGVtcCA9IG1hdHJpeC5zdWJhcnJheSg4LCAxMik7XG5cdFx0XHR2ZWM0LnNjYWxlKHRlbXAsIHRlbXAsIC0xKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIE0gPSBfZ2xNYXRyaXgubWF0NC5jcmVhdGUoKTtcblx0XHRcdHZhciBtID0gbWF0cml4O1xuXG5cdFx0XHQvL2lmKGludmVydGVkKSBtYXQ0LmludmVydChtLG0pO1xuXG5cdFx0XHQvKiBub24gdHJhc3Bvc2VkXG4gICBNLnNldChbbVswXSxtWzhdLC1tWzRdXSwgMCk7XG4gICBNLnNldChbbVsyXSxtWzEwXSwtbVs2XV0sIDQpO1xuICAgTS5zZXQoWy1tWzFdLC1tWzldLG1bNV1dLCA4KTtcbiAgIE0uc2V0KFttWzNdLG1bMTFdLC1tWzddXSwgMTIpO1xuICAgKi9cblxuXHRcdFx0TS5zZXQoW21bMF0sIG1bMl0sIC1tWzFdXSwgMCk7XG5cdFx0XHRNLnNldChbbVs4XSwgbVsxMF0sIC1tWzldXSwgNCk7XG5cdFx0XHRNLnNldChbLW1bNF0sIC1tWzZdLCBtWzVdXSwgOCk7XG5cdFx0XHRNLnNldChbbVsxMl0sIG1bMTRdLCAtbVsxM11dLCAxMik7XG5cblx0XHRcdG0uc2V0KE0pO1xuXG5cdFx0XHQvL2lmKGludmVydGVkKSBtYXQ0LmludmVydChtLG0pO1xuXHRcdH1cblx0XHRyZXR1cm4gbWF0cml4O1xuXHR9XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDb2xsYWRhO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xsYWRhLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvbGxhZGEtcGFyc2VyL2xpYi9Db2xsYWRhLmpzXG4vLyBtb2R1bGUgaWQgPSA3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIEdsdGZMb2FkZXIuanNcblxuaW1wb3J0IHhociBmcm9tICcuL3hocic7XG5pbXBvcnQgTWVzaCBmcm9tICcuLi9NZXNoJztcblxuY29uc3QgQVJSQVlfQ1RPUl9NQVAgPSB7XG5cdDUxMjA6IEludDhBcnJheSxcblx0NTEyMTogVWludDhBcnJheSxcblx0NTEyMjogSW50MTZBcnJheSxcblx0NTEyMzogVWludDE2QXJyYXksXG5cdDUxMjU6IFVpbnQzMkFycmF5LFxuXHQ1MTI2OiBGbG9hdDMyQXJyYXlcbn07XG5cbmNvbnN0IFNJWkVfTUFQID0ge1xuXHRTQ0FMQVI6IDEsXG5cdFZFQzI6IDIsXG5cdFZFQzM6IDMsXG5cdFZFQzQ6IDQsXG5cdE1BVDI6IDQsXG5cdE1BVDM6IDksXG5cdE1BVDQ6IDE2XG59O1xuXG5jb25zdCBzZW1hbnRpY0F0dHJpYnV0ZU1hcCA9IHtcblx0Tk9STUFMOiAnYU5vcm1hbCcsXG5cdFBPU0lUSU9OOiAnYVZlcnRleFBvc2l0aW9uJyxcblx0Ly8gJ1RBTkdFTlQnOiAnYVRhbmdlbnQnLFxuXHRURVhDT09SRF8wOiAnYVRleHR1cmVDb29yZCcsXG5cdFRFWENPT1JEXzE6ICdhVGV4dHVyZUNvb3JkMScsXG5cdFdFSUdIVFNfMDogJ2FXZWlnaHQnLFxuXHRKT0lOVFNfMDogJ2FKb2ludCcsXG5cdENPTE9SOiAnYUNvbG9yJ1xufTtcblxubGV0IGJhc2U7XG5cbmNvbnN0IGxvYWQgPSAobVNvdXJjZSkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRpZigodHlwZW9mIG1Tb3VyY2UpID09PSAnc3RyaW5nJykge1xuXHRcdGJhc2UgPSBtU291cmNlLnN1YnN0cmluZygwLCBtU291cmNlLmxhc3RJbmRleE9mKCcvJykrMSk7XG5cdH0gZWxzZSB7XG5cdFx0YmFzZSA9ICcnO1xuXHR9XG5cblx0X2xvYWRHbHRmKG1Tb3VyY2UpXG5cdFx0LnRoZW4oX2xvYWRCaW4pXG5cdFx0LnRoZW4oX2dldEJ1ZmZlclZpZXdEYXRhKVxuXHRcdC50aGVuKF9sb2FkVGV4dHVyZXMpXG5cdFx0LnRoZW4oX3BhcnNlTWVzaClcblx0XHQudGhlbihfcGFyc2VOb2Rlcylcblx0XHQudGhlbigoZ2x0ZkluZm8pPT57XG5cdFx0XHRyZXNvbHZlKGdsdGZJbmZvKTtcblx0XHR9KVxuXHRcdC5jYXRjaChlID0+IHtcblx0XHRcdGNvbnNvbGUubG9nKCdFcnJvcjonLCBlKTtcblx0XHR9KTtcbn0pO1xuXG5cbmNvbnN0IF9wYXJzZU5vZGVzID0gKGdsdGYpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0Y29uc3QgeyBub2RlcyB9ID0gZ2x0ZjtcblxuXHRub2Rlcy5mb3JFYWNoKChub2RlSW5mbywgaSkgPT4ge1xuXHRcdGlmIChub2RlSW5mby5jYW1lcmEgIT0gbnVsbCAmJiB0aGlzLmluY2x1ZGVDYW1lcmEpIHtcblx0XHRcdC8vIHNldHVwIGNhbWVyYVxuXHRcdH0gZWxzZSBpZihub2RlSW5mby5tZXNoICE9IG51bGwpIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nKGksICdNZXNoIGluZGV4IDonLCBub2RlSW5mby5tZXNoKTtcblx0XHR9XG5cblx0fSk7XG5cdHJlc29sdmUoZ2x0Zik7XG59KTtcblxuY29uc3QgX3BhcnNlTWVzaCA9IChnbHRmKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdGNvbnN0IHsgbWVzaGVzIH0gPSBnbHRmO1xuXHRnbHRmLmdlb21ldHJpZXMgPSBbXTtcblx0Z2x0Zi5vdXRwdXQgPSB7XG5cdFx0bWVzaGVzOltdLFxuXHRcdHNjZW5lOnt9XG5cdH07XG5cblx0bWVzaGVzLmZvckVhY2goKG1lc2gsIGkpID0+IHtcblx0XHRjb25zdCB7IHByaW1pdGl2ZXMgfSA9IG1lc2g7XG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB7fTtcblxuXHRcdHByaW1pdGl2ZXMuZm9yRWFjaCgocHJpbWl0aXZlSW5mbywgaSkgPT4ge1xuXHRcdFx0Y29uc3Qgc2VtYW50aWNzID0gT2JqZWN0LmtleXMocHJpbWl0aXZlSW5mby5hdHRyaWJ1dGVzKTtcblxuXHRcdFx0c2VtYW50aWNzLmZvckVhY2goKHNlbWFudGljLCBpKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGFjY2Vzc29ySWR4ID0gcHJpbWl0aXZlSW5mby5hdHRyaWJ1dGVzW3NlbWFudGljXTtcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlSW5mbyA9IGdsdGYuYWNjZXNzb3JzW2FjY2Vzc29ySWR4XTtcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlTmFtZSA9IHNlbWFudGljQXR0cmlidXRlTWFwW3NlbWFudGljXTtcblx0XHRcdFx0aWYoIWF0dHJpYnV0ZU5hbWUpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc3Qgc2l6ZSA9IFNJWkVfTUFQW2F0dHJpYnV0ZUluZm8udHlwZV07XG5cdFx0XHRcdGxldCBhdHRyaWJ1dGVBcnJheSA9IF9nZXRBY2Nlc3NvckRhdGEoZ2x0ZiwgYWNjZXNzb3JJZHgpO1xuXHRcdFx0XHRpZiAoYXR0cmlidXRlQXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSkge1xuXHRcdFx0XHRcdGF0dHJpYnV0ZUFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShhdHRyaWJ1dGVBcnJheSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRnZW9tZXRyeVthdHRyaWJ1dGVOYW1lXSA9IHtcblx0XHRcdFx0XHR2YWx1ZTphdHRyaWJ1dGVBcnJheSxcblx0XHRcdFx0XHRzaXplLFxuXHRcdFx0XHR9O1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZygnYXR0cmlidXRlJywgYXR0cmlidXRlTmFtZSwgZ2VvbWV0cnlbYXR0cmlidXRlTmFtZV0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vXHRwYXJzZSBpbmRleFxuXHRcdFx0aWYgKHByaW1pdGl2ZUluZm8uaW5kaWNlcyAhPSBudWxsKSB7XG5cdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZUFycmF5ID0gX2dldEFjY2Vzc29yRGF0YShnbHRmLCBwcmltaXRpdmVJbmZvLmluZGljZXMsIHRydWUpO1xuXHRcdFx0XHRnZW9tZXRyeS5pbmRpY2VzID0ge1xuXHRcdFx0XHRcdHZhbHVlOmF0dHJpYnV0ZUFycmF5LFxuXHRcdFx0XHRcdHNpemU6MVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBtID0gbmV3IE1lc2goKTtcblxuXHRcdFx0Zm9yKGNvbnN0IHMgaW4gZ2VvbWV0cnkpIHtcblx0XHRcdFx0Y29uc3QgZGF0YSA9IGdlb21ldHJ5W3NdO1xuXHRcdFx0XHRpZihzICE9PSAnaW5kaWNlcycpIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhzLCBkYXRhKTtcblx0XHRcdFx0XHRtLmJ1ZmZlckZsYXR0ZW5EYXRhKGRhdGEudmFsdWUsIHMsIGRhdGEuc2l6ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coZGF0YS52YWx1ZSk7XG5cdFx0XHRcdFx0bS5idWZmZXJJbmRleChkYXRhLnZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Z2x0Zi5vdXRwdXQubWVzaGVzLnB1c2gobSk7XG5cdFx0XHRnbHRmLmdlb21ldHJpZXMucHVzaChnZW9tZXRyeSk7XG5cdFx0fSk7XG5cdH0pO1xuXG5cdHJlc29sdmUoZ2x0Zik7XG59KTtcblxuXG5jb25zdCBfZ2V0QnVmZmVyVmlld0RhdGEgPSAoZ2x0ZkluZm8pID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0Y29uc3QgeyBidWZmZXJWaWV3cywgYnVmZmVycyB9ID0gZ2x0ZkluZm87XG5cblx0YnVmZmVyVmlld3MuZm9yRWFjaCgoYnVmZmVyVmlld0luZm8sIGkpID0+IHtcblx0XHRjb25zdCBidWZmZXIgPSBidWZmZXJzW2J1ZmZlclZpZXdJbmZvLmJ1ZmZlcl0uZGF0YTtcblx0XHRidWZmZXJWaWV3SW5mby5kYXRhID0gYnVmZmVyLnNsaWNlKGJ1ZmZlclZpZXdJbmZvLmJ5dGVPZmZzZXQgfHwgMCwgKGJ1ZmZlclZpZXdJbmZvLmJ5dGVPZmZzZXQgfHwgMCkgKyAoYnVmZmVyVmlld0luZm8uYnl0ZUxlbmd0aCB8fCAwKSk7XG5cdH0pO1xuXHRyZXNvbHZlKGdsdGZJbmZvKTtcbn0pO1xuXG5jb25zdCBfbG9hZEdsdGYgPSAobVNvdXJjZSkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRpZigodHlwZW9mIG1Tb3VyY2UpICE9PSAnc3RyaW5nJykge1xuXHRcdHJlc29sdmUobVNvdXJjZSk7XG5cdH0gZWxzZSB7XG5cdFx0eGhyKG1Tb3VyY2UpLnRoZW4oKG8pPT57XG5cdFx0XHRyZXNvbHZlKEpTT04ucGFyc2UobykpO1xuXHRcdH0sIChlKT0+IHtcblx0XHRcdHJlamVjdChlKTtcblx0XHR9KTtcblx0fVxufSk7XG5cblxuY29uc3QgX2xvYWRCaW4gPSAoZ2x0ZkluZm8pID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XG5cdGlmKGdsdGZJbmZvLmJ1ZmZlcnMpIHtcblx0XHRsZXQgY291bnQgPSBnbHRmSW5mby5idWZmZXJzLmxlbmd0aDtcblxuXHRcdGdsdGZJbmZvLmJ1ZmZlcnMuZm9yRWFjaChidWZmZXIgPT4ge1xuXG5cdFx0XHRjb25zdCB1cmxCaW4gPSBgJHtiYXNlfSR7Z2x0ZkluZm8uYnVmZmVyc1swXS51cml9YDtcblx0XHRcdHhocih1cmxCaW4sIHRydWUpLnRoZW4oKG8pPT4ge1xuXHRcdFx0XHRidWZmZXIuZGF0YSA9IG87XG5cblx0XHRcdFx0Y291bnQgLS07XG5cdFx0XHRcdGlmKGNvdW50ID09PSAwKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShnbHRmSW5mbyk7XHRcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdH0sIGUgPT4ge1xuXHRcdFx0XHRyZWplY3QoZSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHRcblx0fSBlbHNlIHtcblx0XHRyZXNvbHZlKGdsdGZJbmZvKTtcdFxuXHR9XG5cdFxufSk7XG5cbmNvbnN0IF9sb2FkVGV4dHVyZXMgPSAoZ2x0ZkluZm8pID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0Y29uc29sZS5sb2coJ1RPRE8gOiBMb2FkaW5nIHRleHR1cmVzJyk7XG5cdHJlc29sdmUoZ2x0ZkluZm8pO1xufSk7XG5cbmNvbnN0IHBhcnNlID0gKG1HbHRmSW5mbywgbUJpbikgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRyZXNvbHZlKG1Tb3VyY2UpO1xufSk7XG5cblxuY29uc3QgX2dldEFjY2Vzc29yRGF0YSA9IChnbHRmLCBhY2Nlc3NvcklkeCwgaXNJbmRpY2VzID0gZmFsc2UpID0+IHtcblx0Y29uc3QgYWNjZXNzb3JJbmZvID0gZ2x0Zi5hY2Nlc3NvcnNbYWNjZXNzb3JJZHhdO1xuXHRjb25zdCBidWZmZXIgPSBnbHRmLmJ1ZmZlclZpZXdzW2FjY2Vzc29ySW5mby5idWZmZXJWaWV3XS5kYXRhO1xuXHRjb25zdCBieXRlT2Zmc2V0ID0gYWNjZXNzb3JJbmZvLmJ5dGVPZmZzZXQgfHwgMDtcblx0Y29uc3QgQXJyYXlDdG9yID0gQVJSQVlfQ1RPUl9NQVBbYWNjZXNzb3JJbmZvLmNvbXBvbmVudFR5cGVdIHx8IEZsb2F0MzJBcnJheTtcblx0bGV0IHNpemUgPSBTSVpFX01BUFthY2Nlc3NvckluZm8udHlwZV07XG5cdGlmIChzaXplID09IG51bGwgJiYgaXNJbmRpY2VzKSB7XG5cdFx0c2l6ZSA9IDE7XG5cdH1cblx0bGV0IGFyciA9IG5ldyBBcnJheUN0b3IoYnVmZmVyLCBieXRlT2Zmc2V0LCBzaXplICogYWNjZXNzb3JJbmZvLmNvdW50KTtcblx0Y29uc3QgcXVhbnRpemVFeHRlbnNpb24gPSBhY2Nlc3NvckluZm8uZXh0ZW5zaW9ucyAmJiBhY2Nlc3NvckluZm8uZXh0ZW5zaW9uc1snV0VCM0RfcXVhbnRpemVkX2F0dHJpYnV0ZXMnXTtcblx0aWYgKHF1YW50aXplRXh0ZW5zaW9uKSB7XG5cdFx0Y29uc3QgZGVjb2RlZEFyciA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSAqIGFjY2Vzc29ySW5mby5jb3VudCk7XG5cdFx0Y29uc3QgZGVjb2RlTWF0cml4ID0gcXVhbnRpemVFeHRlbnNpb24uZGVjb2RlTWF0cml4O1xuXHRcdGNvbnN0IGRlY29kZU9mZnNldCA9IG5ldyBBcnJheShzaXplKTtcblx0XHRjb25zdCBkZWNvZGVTY2FsZSA9IG5ldyBBcnJheShzaXplKTtcblx0XHRmb3IgKGxldCBrID0gMDsgayA8IHNpemU7IGsrKykge1xuXHRcdFx0ZGVjb2RlT2Zmc2V0W2tdID0gZGVjb2RlTWF0cml4W3NpemUgKiAoc2l6ZSArIDEpICsga107XG5cdFx0XHRkZWNvZGVTY2FsZVtrXSA9IGRlY29kZU1hdHJpeFtrICogKHNpemUgKyAxKSArIGtdO1xuXHRcdH1cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFjY2Vzc29ySW5mby5jb3VudDsgaSsrKSB7XG5cdFx0XHRmb3IgKGxldCBrID0gMDsgayA8IHNpemU7IGsrKykge1xuXHRcdFx0XHRkZWNvZGVkQXJyW2kgKiBzaXplICsga10gPSBhcnJbaSAqIHNpemUgKyBrXSAqIGRlY29kZVNjYWxlW2tdICsgZGVjb2RlT2Zmc2V0W2tdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGFyciA9IGRlY29kZWRBcnI7XG5cdH1cblxuXHQvLyBjb25zb2xlLmxvZyh7YnVmZmVyLCBieXRlT2Zmc2V0LCBBcnJheUN0b3IsIHNpemUsIGFycn0pO1xuXG5cdHJldHVybiBhcnI7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cdGxvYWQsXG5cdHBhcnNlXG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2xvYWRlcnMvR2x0ZkxvYWRlci5qcyIsIi8vIHhoci5qc1xuXG5jb25zdCBsb2FkID0gKG1QYXRoLCBpc0FycmF5QnVmZmVyKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdGNvbnN0IHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHRyZXEuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIChlKSA9PiB7XG5cdFx0cmVzb2x2ZShyZXEucmVzcG9uc2UpO1xuXHR9KTtcblxuXHRyZXEuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZSkgPT4ge1xuXHRcdHJlamVjdChlKTtcblx0fSk7XG5cblx0aWYoaXNBcnJheUJ1ZmZlcikge1xuXHRcdHJlcS5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXHR9XG5cblx0cmVxLm9wZW4oJ0dFVCcsIG1QYXRoKTtcblx0cmVxLnNlbmQoKTtcblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGxvYWQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvbG9hZGVycy94aHIuanMiLCIvLyBFZmZlY3RDb21wb3Nlci5qc1xuXG5pbXBvcnQgUGFzcyBmcm9tICcuL1Bhc3MnO1xuaW1wb3J0IEdMIGZyb20gJy4uL0dMVG9vbCc7XG5pbXBvcnQgR2VvbSBmcm9tICcuLi9HZW9tJztcbmltcG9ydCBGcmFtZUJ1ZmZlciBmcm9tICcuLi9GcmFtZUJ1ZmZlcic7XG5cbmNsYXNzIEVmZmVjdENvbXBvc2VyIHtcblx0Y29uc3RydWN0b3IobVdpZHRoLCBtSGVpZ2h0LCBtUGFybWFzID0ge30pIHtcblx0XHR0aGlzLl93aWR0aCA9IG1XaWR0aCB8fCBHTC53aWR0aDtcblx0XHR0aGlzLl9oZWlnaHQgPSBtSGVpZ2h0IHx8IEdMLmhlaWdodDtcblxuXHRcdHRoaXMuX3BhcmFtcyA9IHt9O1xuXHRcdHRoaXMuc2V0U2l6ZShtV2lkdGgsIG1IZWlnaHQpO1xuXHRcdHRoaXMuX21lc2ggPSBHZW9tLmJpZ1RyaWFuZ2xlKCk7XG5cdFx0dGhpcy5fcGFzc2VzID0gW107XG5cdFx0dGhpcy5fcmV0dXJuVGV4dHVyZTtcblx0fVxuXG5cblx0YWRkUGFzcyhwYXNzKSB7XG5cdFx0aWYocGFzcy5wYXNzZXMpIHtcblx0XHRcdHRoaXMuYWRkUGFzcyhwYXNzLnBhc3Nlcyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChwYXNzLmxlbmd0aCkge1xuXHRcdFx0Zm9yKGxldCBpID0gMDsgaSA8IHBhc3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fcGFzc2VzLnB1c2gocGFzc1tpXSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3Bhc3Nlcy5wdXNoKHBhc3MpO1xuXHRcdH1cblx0fVxuXG5cdHJlbmRlcihtU291cmNlKSB7XG5cdFx0bGV0IHNvdXJjZSA9IG1Tb3VyY2U7XG5cdFx0bGV0IGZib1RhcmdldDtcblxuXHRcdHRoaXMuX3Bhc3Nlcy5mb3JFYWNoKChwYXNzKSA9PiB7XG5cblx0XHRcdC8vXHRnZXQgdGFyZ2V0XG5cdFx0XHRpZihwYXNzLmhhc0Zibykge1xuXHRcdFx0XHRmYm9UYXJnZXQgPSBwYXNzLmZibztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZib1RhcmdldCA9IHRoaXMuX2Zib1RhcmdldDtcblx0XHRcdH1cblxuXHRcdFx0Ly9cdHJlbmRlclxuXHRcdFx0ZmJvVGFyZ2V0LmJpbmQoKTtcblx0XHRcdEdMLmNsZWFyKDAsIDAsIDAsIDApO1xuXHRcdFx0cGFzcy5yZW5kZXIoc291cmNlKTtcblx0XHRcdEdMLmRyYXcodGhpcy5fbWVzaCk7XG5cdFx0XHRmYm9UYXJnZXQudW5iaW5kKCk7XG5cblx0XHRcdC8vXHRyZXNldCBzb3VyY2Vcblx0XHRcdGlmKHBhc3MuaGFzRmJvKSB7XG5cdFx0XHRcdHNvdXJjZSA9IHBhc3MuZmJvLmdldFRleHR1cmUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3N3YXAoKTtcdFxuXHRcdFx0XHRzb3VyY2UgPSB0aGlzLl9mYm9DdXJyZW50LmdldFRleHR1cmUoKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuX3JldHVyblRleHR1cmUgPSBzb3VyY2U7XG5cblx0XHRyZXR1cm4gc291cmNlO1xuXHR9XG5cblxuXHRfc3dhcCgpIHtcblx0XHRjb25zdCB0bXAgPSB0aGlzLl9mYm9DdXJyZW50O1xuXHRcdHRoaXMuX2Zib0N1cnJlbnQgPSB0aGlzLl9mYm9UYXJnZXQ7XG5cdFx0dGhpcy5fZmJvVGFyZ2V0ID0gdG1wO1xuXG5cdFx0dGhpcy5fY3VycmVudCA9IHRoaXMuX2Zib0N1cnJlbnQ7XG5cdFx0dGhpcy5fdGFyZ2V0ID0gdGhpcy5fZmJvVGFyZ2V0O1xuXHR9XG5cblx0c2V0U2l6ZShtV2lkdGgsIG1IZWlnaHQpIHtcblx0XHR0aGlzLl93aWR0aCA9IG1XaWR0aDtcblx0XHR0aGlzLl9oZWlnaHQgPSBtSGVpZ2h0O1xuXHRcdHRoaXMuX2Zib0N1cnJlbnQgPSBuZXcgRnJhbWVCdWZmZXIodGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCwgdGhpcy5fcGFyYW1zKTtcblx0XHR0aGlzLl9mYm9UYXJnZXQgPSBuZXcgRnJhbWVCdWZmZXIodGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCwgdGhpcy5fcGFyYW1zKTtcblx0fVxuXG5cdGdldCBwYXNzZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Bhc3Nlcztcblx0fVxuXG5cdGdldFRleHR1cmUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JldHVyblRleHR1cmU7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRWZmZWN0Q29tcG9zZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvcG9zdC9FZmZlY3RDb21wb3Nlci5qcyIsIi8vIFBhc3NCbHVyLmpzXG5cbmltcG9ydCBQYXNzVkJsdXIgZnJvbSAnLi9QYXNzVkJsdXInO1xuaW1wb3J0IFBhc3NIQmx1ciBmcm9tICcuL1Bhc3NIQmx1cic7XG5pbXBvcnQgUGFzc01hY3JvIGZyb20gJy4vUGFzc01hY3JvJztcblxuY2xhc3MgUGFzc0JsdXIgZXh0ZW5kcyBQYXNzTWFjcm8ge1xuXHRjb25zdHJ1Y3RvcihtUXVhbGl0eSA9IDksIG1XaWR0aCwgbUhlaWdodCwgbVBhcmFtcykge1xuXHRcdHN1cGVyKCk7XG5cdFx0Y29uc3QgdkJsdXIgPSBuZXcgUGFzc1ZCbHVyKG1RdWFsaXR5LCBtV2lkdGgsIG1IZWlnaHQsIG1QYXJhbXMpO1xuXHRcdGNvbnN0IGhCbHVyID0gbmV3IFBhc3NIQmx1cihtUXVhbGl0eSwgbVdpZHRoLCBtSGVpZ2h0LCBtUGFyYW1zKTtcblxuXHRcdHRoaXMuYWRkUGFzcyh2Qmx1cik7XG5cdFx0dGhpcy5hZGRQYXNzKGhCbHVyKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBQYXNzQmx1cjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3Bvc3QvUGFzc0JsdXIuanMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gYmx1cjUuZnJhZ1xcbi8vIHNvdXJjZSAgOiBodHRwczovL2dpdGh1Yi5jb20vSmFtMy9nbHNsLWZhc3QtZ2F1c3NpYW4tYmx1clxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgQkxVUl81XFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcXG51bmlmb3JtIHZlYzIgdURpcmVjdGlvbjtcXG51bmlmb3JtIHZlYzIgdVJlc29sdXRpb247XFxuXFxudmVjNCBibHVyNShzYW1wbGVyMkQgaW1hZ2UsIHZlYzIgdXYsIHZlYzIgcmVzb2x1dGlvbiwgdmVjMiBkaXJlY3Rpb24pIHtcXG5cXHR2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xcblxcdHZlYzIgb2ZmMSA9IHZlYzIoMS4zMzMzMzMzMzMzMzMzMzMzKSAqIGRpcmVjdGlvbjtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2KSAqIDAuMjk0MTE3NjQ3MDU4ODIzNTQ7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diArIChvZmYxIC8gcmVzb2x1dGlvbikpICogMC4zNTI5NDExNzY0NzA1ODgyNjtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2IC0gKG9mZjEgLyByZXNvbHV0aW9uKSkgKiAwLjM1Mjk0MTE3NjQ3MDU4ODI2O1xcblxcdHJldHVybiBjb2xvcjsgXFxufVxcblxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IGJsdXI1KHRleHR1cmUsIHZUZXh0dXJlQ29vcmQsIHVSZXNvbHV0aW9uLCB1RGlyZWN0aW9uKTtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3NoYWRlcnMvYmx1cjUuZnJhZ1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gYmx1cjkuZnJhZ1xcbi8vIHNvdXJjZSAgOiBodHRwczovL2dpdGh1Yi5jb20vSmFtMy9nbHNsLWZhc3QtZ2F1c3NpYW4tYmx1clxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgQkxVUl85XFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcXG51bmlmb3JtIHZlYzIgdURpcmVjdGlvbjtcXG51bmlmb3JtIHZlYzIgdVJlc29sdXRpb247XFxuXFxudmVjNCBibHVyOShzYW1wbGVyMkQgaW1hZ2UsIHZlYzIgdXYsIHZlYzIgcmVzb2x1dGlvbiwgdmVjMiBkaXJlY3Rpb24pIHtcXG5cXHR2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xcblxcdHZlYzIgb2ZmMSA9IHZlYzIoMS4zODQ2MTUzODQ2KSAqIGRpcmVjdGlvbjtcXG5cXHR2ZWMyIG9mZjIgPSB2ZWMyKDMuMjMwNzY5MjMwOCkgKiBkaXJlY3Rpb247XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1dikgKiAwLjIyNzAyNzAyNzA7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diArIChvZmYxIC8gcmVzb2x1dGlvbikpICogMC4zMTYyMTYyMTYyO1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgLSAob2ZmMSAvIHJlc29sdXRpb24pKSAqIDAuMzE2MjE2MjE2MjtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2ICsgKG9mZjIgLyByZXNvbHV0aW9uKSkgKiAwLjA3MDI3MDI3MDM7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diAtIChvZmYyIC8gcmVzb2x1dGlvbikpICogMC4wNzAyNzAyNzAzO1xcblxcdHJldHVybiBjb2xvcjtcXG59XFxuXFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gYmx1cjkodGV4dHVyZSwgdlRleHR1cmVDb29yZCwgdVJlc29sdXRpb24sIHVEaXJlY3Rpb24pO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9ibHVyOS5mcmFnXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0gXCIvLyBibHVyMTMuZnJhZ1xcbi8vIHNvdXJjZSAgOiBodHRwczovL2dpdGh1Yi5jb20vSmFtMy9nbHNsLWZhc3QtZ2F1c3NpYW4tYmx1clxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgQkxVUl8xM1xcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmU7XFxudW5pZm9ybSB2ZWMyIHVEaXJlY3Rpb247XFxudW5pZm9ybSB2ZWMyIHVSZXNvbHV0aW9uO1xcblxcbnZlYzQgYmx1cjEzKHNhbXBsZXIyRCBpbWFnZSwgdmVjMiB1diwgdmVjMiByZXNvbHV0aW9uLCB2ZWMyIGRpcmVjdGlvbikge1xcblxcdHZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XFxuXFx0dmVjMiBvZmYxID0gdmVjMigxLjQxMTc2NDcwNTg4MjM1MykgKiBkaXJlY3Rpb247XFxuXFx0dmVjMiBvZmYyID0gdmVjMigzLjI5NDExNzY0NzA1ODgyMzQpICogZGlyZWN0aW9uO1xcblxcdHZlYzIgb2ZmMyA9IHZlYzIoNS4xNzY0NzA1ODgyMzUyOTQpICogZGlyZWN0aW9uO1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYpICogMC4xOTY0ODI1NTAxNTExNDA0O1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgKyAob2ZmMSAvIHJlc29sdXRpb24pKSAqIDAuMjk2OTA2OTY0NjcyODM0NDtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2IC0gKG9mZjEgLyByZXNvbHV0aW9uKSkgKiAwLjI5NjkwNjk2NDY3MjgzNDQ7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diArIChvZmYyIC8gcmVzb2x1dGlvbikpICogMC4wOTQ0NzAzOTc4NTA0NDczMjtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2IC0gKG9mZjIgLyByZXNvbHV0aW9uKSkgKiAwLjA5NDQ3MDM5Nzg1MDQ0NzMyO1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgKyAob2ZmMyAvIHJlc29sdXRpb24pKSAqIDAuMDEwMzgxMzYyNDAxMTQ4MDU3O1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgLSAob2ZmMyAvIHJlc29sdXRpb24pKSAqIDAuMDEwMzgxMzYyNDAxMTQ4MDU3O1xcblxcdHJldHVybiBjb2xvcjtcXG59XFxuXFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gYmx1cjEzKHRleHR1cmUsIHZUZXh0dXJlQ29vcmQsIHVSZXNvbHV0aW9uLCB1RGlyZWN0aW9uKTtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3NoYWRlcnMvYmx1cjEzLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gUGFzc0Z4YWEuanNcblxuaW1wb3J0IEdMIGZyb20gJy4uL0dMVG9vbCc7XG5pbXBvcnQgUGFzcyBmcm9tICcuL1Bhc3MnO1xuaW1wb3J0IGZzRnhhYSBmcm9tICcuLi9zaGFkZXJzL2Z4YWEuZnJhZyc7XG5cbmNsYXNzIFBhc3NGeGFhIGV4dGVuZHMgUGFzcyB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKGZzRnhhYSk7XG5cdFx0dGhpcy51bmlmb3JtKCd1UmVzb2x1dGlvbicsIFsxL0dMLndpZHRoLCAxL0dMLmhlaWdodF0pO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhc3NGeGFhO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3Bvc3QvUGFzc0Z4YWEuanMiLCIvLyBCYXRjaENvcHkuanNcblxuaW1wb3J0IEdlb20gZnJvbSAnLi4vR2VvbSc7XG5pbXBvcnQgR0xTaGFkZXIgZnJvbSAnLi4vR0xTaGFkZXInO1xuaW1wb3J0IEJhdGNoIGZyb20gJy4uL0JhdGNoJztcblxuY29uc3QgdnMgPSByZXF1aXJlKCcuLi9zaGFkZXJzL2JpZ1RyaWFuZ2xlLnZlcnQnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vc2hhZGVycy9jb3B5LmZyYWcnKTtcblxuY2xhc3MgQmF0Y2hDb3B5IGV4dGVuZHMgQmF0Y2gge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdGNvbnN0IG1lc2ggPSBHZW9tLmJpZ1RyaWFuZ2xlKCk7XG5cdFx0Y29uc3Qgc2hhZGVyID0gbmV3IEdMU2hhZGVyKHZzLCBmcyk7XG5cdFx0c3VwZXIobWVzaCwgc2hhZGVyKTtcblxuXHRcdHNoYWRlci5iaW5kKCk7XG5cdFx0c2hhZGVyLnVuaWZvcm0oJ3RleHR1cmUnLCAndW5pZm9ybTFpJywgMCk7XG5cdH1cblxuXG5cdGRyYXcodGV4dHVyZSkge1xuXHRcdHRoaXMuc2hhZGVyLmJpbmQoKTtcblx0XHR0ZXh0dXJlLmJpbmQoMCk7XG5cdFx0c3VwZXIuZHJhdygpO1xuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmF0Y2hDb3B5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hDb3B5LmpzIiwiLy8gQmF0Y2hBeGlzLmpzXG5cbmltcG9ydCBHTCBmcm9tICcuLi9HTFRvb2wnO1xuaW1wb3J0IE1lc2ggZnJvbSAnLi4vTWVzaCc7XG5pbXBvcnQgR0xTaGFkZXIgZnJvbSAnLi4vR0xTaGFkZXInO1xuaW1wb3J0IEJhdGNoIGZyb20gJy4uL0JhdGNoJztcblxuY29uc3QgdnMgPSByZXF1aXJlKCcuLi9zaGFkZXJzL2F4aXMudmVydCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9zaGFkZXJzL2F4aXMuZnJhZycpO1xuXG5cbmNsYXNzIEJhdGNoQXhpcyBleHRlbmRzIEJhdGNoIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRjb25zdCBwb3NpdGlvbnMgPSBbXTtcblx0XHRjb25zdCBjb2xvcnMgPSBbXTtcblx0XHRjb25zdCBpbmRpY2VzID0gWzAsIDEsIDIsIDMsIDQsIDVdO1xuXHRcdGNvbnN0IHIgPSA5OTk5O1xuXG5cdFx0cG9zaXRpb25zLnB1c2goWy1yLCAgMCwgIDBdKTtcblx0XHRwb3NpdGlvbnMucHVzaChbciwgIDAsICAwXSk7XG5cdFx0cG9zaXRpb25zLnB1c2goWzAsIC1yLCAgMF0pO1xuXHRcdHBvc2l0aW9ucy5wdXNoKFswLCAgciwgIDBdKTtcblx0XHRwb3NpdGlvbnMucHVzaChbMCwgIDAsIC1yXSk7XG5cdFx0cG9zaXRpb25zLnB1c2goWzAsICAwLCAgcl0pO1xuXG5cblx0XHRjb2xvcnMucHVzaChbMSwgMCwgMF0pO1xuXHRcdGNvbG9ycy5wdXNoKFsxLCAwLCAwXSk7XG5cdFx0Y29sb3JzLnB1c2goWzAsIDEsIDBdKTtcblx0XHRjb2xvcnMucHVzaChbMCwgMSwgMF0pO1xuXHRcdGNvbG9ycy5wdXNoKFswLCAwLCAxXSk7XG5cdFx0Y29sb3JzLnB1c2goWzAsIDAsIDFdKTtcblxuXHRcdGNvbnN0IG1lc2ggPSBuZXcgTWVzaChHTC5MSU5FUyk7XG5cdFx0bWVzaC5idWZmZXJWZXJ0ZXgocG9zaXRpb25zKTtcblx0XHRtZXNoLmJ1ZmZlckluZGV4KGluZGljZXMpO1xuXHRcdG1lc2guYnVmZmVyRGF0YShjb2xvcnMsICdhQ29sb3InLCAzKTtcblxuXHRcdGNvbnN0IHNoYWRlciA9IG5ldyBHTFNoYWRlcih2cywgZnMpO1xuXG5cdFx0c3VwZXIobWVzaCwgc2hhZGVyKTtcblxuXHR9XG5cblxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IEJhdGNoQXhpcztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL0JhdGNoQXhpcy5qcyIsIm1vZHVsZS5leHBvcnRzID0gXCIvLyBheGlzLnZlcnRcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIEJBU0lDX1ZFUlRFWFxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbmF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMyBhQ29sb3I7XFxuYXR0cmlidXRlIHZlYzMgYU5vcm1hbDtcXG5cXG51bmlmb3JtIG1hdDQgdU1vZGVsTWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1Vmlld01hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVByb2plY3Rpb25NYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMzIHZDb2xvcjtcXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHVQcm9qZWN0aW9uTWF0cml4ICogdVZpZXdNYXRyaXggKiB1TW9kZWxNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKTtcXG4gICAgdkNvbG9yID0gYUNvbG9yO1xcbiAgICB2Tm9ybWFsID0gYU5vcm1hbDtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3NoYWRlcnMvYXhpcy52ZXJ0XG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0gXCIvLyBheGlzLmZyYWdcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIFNJTVBMRV9URVhUVVJFXFxuXFxucHJlY2lzaW9uIGxvd3AgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG52YXJ5aW5nIHZlYzMgdkNvbG9yO1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFx0Ly8gdmVjMyBjb2xvciA9IHZOb3JtYWw7XFxuXFx0dmVjMyBjb2xvciA9IHZDb2xvciArIHZOb3JtYWwgKiAwLjAwMDE7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIDEuMCk7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9zaGFkZXJzL2F4aXMuZnJhZ1xuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBCYXRjaEJhbGwuanNcblxuaW1wb3J0IEdlb20gZnJvbSAnLi4vR2VvbSc7XG5pbXBvcnQgR0xTaGFkZXIgZnJvbSAnLi4vR0xTaGFkZXInO1xuaW1wb3J0IEJhdGNoIGZyb20gJy4uL0JhdGNoJztcblxuY29uc3QgdnMgPSByZXF1aXJlKCcuLi9zaGFkZXJzL2dlbmVyYWwudmVydCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9zaGFkZXJzL3NpbXBsZUNvbG9yLmZyYWcnKTtcblxuY2xhc3MgQmF0Y2hCYWxsIGV4dGVuZHMgQmF0Y2gge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdGNvbnN0IG1lc2ggPSBHZW9tLnNwaGVyZSgxLCAyNCk7XG5cdFx0Y29uc3Qgc2hhZGVyID0gbmV3IEdMU2hhZGVyKHZzLCBmcyk7XG5cdFx0c3VwZXIobWVzaCwgc2hhZGVyKTtcblx0fVxuXG5cblx0ZHJhdyhwb3NpdGlvbiA9IFswLCAwLCAwXSwgc2NhbGUgPSBbMSwgMSwgMV0sIGNvbG9yID0gWzEsIDEsIDFdLCBvcGFjaXR5ID0gMSkge1xuXHRcdHRoaXMuc2hhZGVyLmJpbmQoKTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKCdwb3NpdGlvbicsICd1bmlmb3JtM2Z2JywgcG9zaXRpb24pO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oJ3NjYWxlJywgJ3VuaWZvcm0zZnYnLCBzY2FsZSk7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgnY29sb3InLCAndW5pZm9ybTNmdicsIGNvbG9yKTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKCdvcGFjaXR5JywgJ3VuaWZvcm0xZicsIG9wYWNpdHkpO1xuXHRcdHN1cGVyLmRyYXcoKTtcblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhdGNoQmFsbDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL0JhdGNoQmFsbC5qcyIsIi8vIEJhdGNoRG90c1BsYW5lLmpzXG5cbmltcG9ydCBHTCBmcm9tICcuLi9HTFRvb2wnO1xuaW1wb3J0IE1lc2ggZnJvbSAnLi4vTWVzaCc7XG5pbXBvcnQgR0xTaGFkZXIgZnJvbSAnLi4vR0xTaGFkZXInO1xuaW1wb3J0IEJhdGNoIGZyb20gJy4uL0JhdGNoJztcblxuY29uc3QgdnMgPSByZXF1aXJlKCcuLi9zaGFkZXJzL2RvdHNQbGFuZS52ZXJ0Jyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvc2ltcGxlQ29sb3IuZnJhZycpO1xuXG5jbGFzcyBCYXRjaERvdHNQbGFuZSBleHRlbmRzIEJhdGNoIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRjb25zdCBwb3NpdGlvbnMgPSBbXTtcblx0XHRjb25zdCBpbmRpY2VzICAgPSBbXTtcblx0XHRsZXQgaW5kZXggICAgICAgPSAwO1xuXHRcdGNvbnN0IHNpemUgICAgICA9IDEwMDtcblx0XHRsZXQgaSwgajtcblxuXHRcdGZvcihpID0gLXNpemU7IGkgPCBzaXplOyBpICs9IDEpIHtcblx0XHRcdGZvcihqID0gLXNpemU7IGogPCBzaXplOyBqICs9IDEpIHtcblx0XHRcdFx0cG9zaXRpb25zLnB1c2goW2ksIGosIDBdKTtcblx0XHRcdFx0aW5kaWNlcy5wdXNoKGluZGV4KTtcblx0XHRcdFx0aW5kZXgrKztcblxuXHRcdFx0XHRwb3NpdGlvbnMucHVzaChbaSwgMCwgal0pO1xuXHRcdFx0XHRpbmRpY2VzLnB1c2goaW5kZXgpO1xuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRjb25zdCBtZXNoICAgICA9IG5ldyBNZXNoKEdMLlBPSU5UUyk7XG5cdFx0bWVzaC5idWZmZXJWZXJ0ZXgocG9zaXRpb25zKTtcblx0XHRtZXNoLmJ1ZmZlckluZGV4KGluZGljZXMpO1xuXHRcdFxuXHRcdGNvbnN0IHNoYWRlciAgID0gbmV3IEdMU2hhZGVyKHZzLCBmcyk7XG5cdFx0XG5cdFx0c3VwZXIobWVzaCwgc2hhZGVyKTtcblx0XHRcblx0XHR0aGlzLmNvbG9yICAgPSBbMSwgMSwgMV07XG5cdFx0dGhpcy5vcGFjaXR5ID0gMC41O1xuXHR9XG5cblxuXHRkcmF3KCkge1xuXHRcdHRoaXMuc2hhZGVyLmJpbmQoKTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKCdjb2xvcicsICd1bmlmb3JtM2Z2JywgdGhpcy5jb2xvcik7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgnb3BhY2l0eScsICd1bmlmb3JtMWYnLCB0aGlzLm9wYWNpdHkpO1xuXHRcdC8vIEdMLmRyYXcodGhpcy5tZXNoKTtcblx0XHRzdXBlci5kcmF3KCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmF0Y2hEb3RzUGxhbmU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvaGVscGVycy9CYXRjaERvdHNQbGFuZS5qcyIsIm1vZHVsZS5leHBvcnRzID0gXCIvLyBiYXNpYy52ZXJ0XFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBET1RTX1BMQU5FX1ZFUlRFWFxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbmF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMyBhTm9ybWFsO1xcblxcbnVuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVWaWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHVQcm9qZWN0aW9uTWF0cml4ICogdVZpZXdNYXRyaXggKiB1TW9kZWxNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbiArIGFOb3JtYWwgKiAwLjAwMDAwMSwgMS4wKTtcXG4gICAgZ2xfUG9pbnRTaXplID0gMS4wO1xcbiAgICB2Tm9ybWFsID0gYU5vcm1hbDtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3NoYWRlcnMvZG90c1BsYW5lLnZlcnRcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gQmF0Y2hMaW5lLmpzXG5cblxuaW1wb3J0IEdMIGZyb20gJy4uL0dMVG9vbCc7XG5pbXBvcnQgTWVzaCBmcm9tICcuLi9NZXNoJztcbmltcG9ydCBHTFNoYWRlciBmcm9tICcuLi9HTFNoYWRlcic7XG5pbXBvcnQgQmF0Y2ggZnJvbSAnLi4vQmF0Y2gnO1xuXG5jb25zdCB2cyA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvYmFzaWMudmVydCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9zaGFkZXJzL3NpbXBsZUNvbG9yLmZyYWcnKTtcblxuXG5cbmNsYXNzIEJhdGNoQXhpcyBleHRlbmRzIEJhdGNoIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRjb25zdCBwb3NpdGlvbnMgPSBbXTtcblx0XHRjb25zdCBpbmRpY2VzID0gWzAsIDFdO1xuXHRcdGNvbnN0IGNvb3JkcyA9IFtbMCwgMF0sIFsxLCAxXV07XG5cdFx0cG9zaXRpb25zLnB1c2goWzAsICAwLCAgMF0pO1xuXHRcdHBvc2l0aW9ucy5wdXNoKFswLCAgMCwgIDBdKTtcblxuXHRcdGNvbnN0IG1lc2ggPSBuZXcgTWVzaChHTC5MSU5FUyk7XG5cdFx0bWVzaC5idWZmZXJWZXJ0ZXgocG9zaXRpb25zKTtcblx0XHRtZXNoLmJ1ZmZlclRleENvb3JkKGNvb3Jkcyk7XG5cdFx0bWVzaC5idWZmZXJJbmRleChpbmRpY2VzKTtcblxuXHRcdGNvbnN0IHNoYWRlciA9IG5ldyBHTFNoYWRlcih2cywgZnMpO1xuXG5cdFx0c3VwZXIobWVzaCwgc2hhZGVyKTtcblx0fVxuXG5cblx0ZHJhdyhtUG9zaXRpb25BLCBtUG9zaXRpb25CLCBjb2xvciA9IFsxLCAxLCAxXSwgb3BhY2l0eSA9IDEuMCkge1xuXHRcdHRoaXMuX21lc2guYnVmZmVyVmVydGV4KFttUG9zaXRpb25BLCBtUG9zaXRpb25CXSk7XG5cblx0XHR0aGlzLl9zaGFkZXIuYmluZCgpO1xuXHRcdHRoaXMuX3NoYWRlci51bmlmb3JtKCdjb2xvcicsICd2ZWMzJywgY29sb3IpO1xuXHRcdHRoaXMuX3NoYWRlci51bmlmb3JtKCdvcGFjaXR5JywgJ2Zsb2F0Jywgb3BhY2l0eSk7XG5cdFx0c3VwZXIuZHJhdygpO1xuXHR9XG5cblxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IEJhdGNoQXhpcztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL0JhdGNoTGluZS5qcyIsIi8vIEJhdGNoU2t5Ym94LmpzXG5cbmltcG9ydCBHZW9tIGZyb20gJy4uL0dlb20nO1xuaW1wb3J0IEdMU2hhZGVyIGZyb20gJy4uL0dMU2hhZGVyJztcbmltcG9ydCBCYXRjaCBmcm9tICcuLi9CYXRjaCc7XG5cbmNvbnN0IHZzID0gcmVxdWlyZSgnLi4vc2hhZGVycy9za3lib3gudmVydCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9zaGFkZXJzL3NreWJveC5mcmFnJyk7XG5cblxuY2xhc3MgQmF0Y2hTa3lib3ggZXh0ZW5kcyBCYXRjaCB7XG5cblx0Y29uc3RydWN0b3Ioc2l6ZSA9IDIwKSB7XG5cdFx0Y29uc3QgbWVzaCA9IEdlb20uc2t5Ym94KHNpemUpO1xuXHRcdGNvbnN0IHNoYWRlciA9IG5ldyBHTFNoYWRlcih2cywgZnMpO1xuXG5cdFx0c3VwZXIobWVzaCwgc2hhZGVyKTtcblx0fVxuXG5cdGRyYXcodGV4dHVyZSkge1xuXHRcdHRoaXMuc2hhZGVyLmJpbmQoKTtcblx0XHR0ZXh0dXJlLmJpbmQoMCk7XG5cdFx0c3VwZXIuZHJhdygpO1xuXHR9XG5cblxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IEJhdGNoU2t5Ym94O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hTa3lib3guanMiLCIvLyBCYXRjaFNreS5qc1xuXG5pbXBvcnQgR2VvbSBmcm9tICcuLi9HZW9tJztcbmltcG9ydCBHTFNoYWRlciBmcm9tICcuLi9HTFNoYWRlcic7XG5pbXBvcnQgQmF0Y2ggZnJvbSAnLi4vQmF0Y2gnO1xuXG5jb25zdCB2cyA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvc2t5LnZlcnQnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vc2hhZGVycy9jb3B5LmZyYWcnKTtcblxuXG5jbGFzcyBCYXRjaFNreSBleHRlbmRzIEJhdGNoIHtcblxuXHRjb25zdHJ1Y3RvcihzaXplID0gNTAsIHNlZyA9IDI0KSB7XG5cdFx0Y29uc3QgbWVzaCA9IEdlb20uc3BoZXJlKHNpemUsIHNlZywgdHJ1ZSk7XG5cdFx0Y29uc3Qgc2hhZGVyID0gbmV3IEdMU2hhZGVyKHZzLCBmcyk7XG5cblx0XHRzdXBlcihtZXNoLCBzaGFkZXIpO1xuXHR9XG5cblx0ZHJhdyh0ZXh0dXJlKSB7XG5cdFx0dGhpcy5zaGFkZXIuYmluZCgpO1xuXHRcdHRleHR1cmUuYmluZCgwKTtcblx0XHRzdXBlci5kcmF3KCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmF0Y2hTa3k7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvaGVscGVycy9CYXRjaFNreS5qcyIsIm1vZHVsZS5leHBvcnRzID0gXCIvLyBza3kudmVydFxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbmF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcbmF0dHJpYnV0ZSB2ZWMzIGFOb3JtYWw7XFxuXFxudW5pZm9ybSBtYXQ0IHVNb2RlbE1hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFx0bWF0NCBtYXRWaWV3ID0gdVZpZXdNYXRyaXg7XFxuXFx0bWF0Vmlld1szXVswXSA9IDAuMDtcXG5cXHRtYXRWaWV3WzNdWzFdID0gMC4wO1xcblxcdG1hdFZpZXdbM11bMl0gPSAwLjA7XFxuXFx0XFxuICAgIGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb25NYXRyaXggKiBtYXRWaWV3ICogdU1vZGVsTWF0cml4ICogdmVjNChhVmVydGV4UG9zaXRpb24sIDEuMCk7XFxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcbiAgICB2Tm9ybWFsID0gYU5vcm1hbDtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3NoYWRlcnMvc2t5LnZlcnRcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gQmF0Y2hGWEFBLmpzXG5pbXBvcnQgR0wgZnJvbSAnLi4vR0xUb29sJztcbmltcG9ydCBHZW9tIGZyb20gJy4uL0dlb20nO1xuaW1wb3J0IEdMU2hhZGVyIGZyb20gJy4uL0dMU2hhZGVyJztcbmltcG9ydCBCYXRjaCBmcm9tICcuLi9CYXRjaCc7XG5cbmNvbnN0IHZzID0gcmVxdWlyZSgnLi4vc2hhZGVycy9iaWdUcmlhbmdsZS52ZXJ0Jyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvZnhhYS5mcmFnJyk7XG5cbmNsYXNzIEJhdGNoRlhBQSBleHRlbmRzIEJhdGNoIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRjb25zdCBtZXNoID0gR2VvbS5iaWdUcmlhbmdsZSgpO1xuXHRcdGNvbnN0IHNoYWRlciA9IG5ldyBHTFNoYWRlcih2cywgZnMpO1xuXHRcdHN1cGVyKG1lc2gsIHNoYWRlcik7XG5cblx0XHRzaGFkZXIuYmluZCgpO1xuXHRcdHNoYWRlci51bmlmb3JtKCd0ZXh0dXJlJywgJ3VuaWZvcm0xaScsIDApO1xuXHR9XG5cblxuXHRkcmF3KHRleHR1cmUpIHtcblx0XHR0aGlzLnNoYWRlci5iaW5kKCk7XG5cdFx0dGV4dHVyZS5iaW5kKDApO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oJ3VSZXNvbHV0aW9uJywgJ3ZlYzInLCBbMS9HTC53aWR0aCwgMS9HTC5oZWlnaHRdKTtcblx0XHRzdXBlci5kcmF3KCk7XG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXRjaEZYQUE7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvaGVscGVycy9CYXRjaEZYQUEuanMiLCIvLyBTY2VuZS5qc1xuXG5pbXBvcnQgU2NoZWR1bGVyIGZyb20gJ3NjaGVkdWxpbmcnO1xuaW1wb3J0IEdMIGZyb20gJy4uL0dMVG9vbCc7XG5pbXBvcnQgQ2FtZXJhUGVyc3BlY3RpdmUgZnJvbSAnLi4vY2FtZXJhcy9DYW1lcmFQZXJzcGVjdGl2ZSc7XG5pbXBvcnQgQ2FtZXJhT3J0aG8gZnJvbSAnLi4vY2FtZXJhcy9DYW1lcmFPcnRobyc7XG5pbXBvcnQgT3JiaXRhbENvbnRyb2wgZnJvbSAnLi4vdXRpbHMvT3JiaXRhbENvbnRyb2wnO1xuXG5cbmNsYXNzIFNjZW5lIHtcblxuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuX2NoaWxkcmVuID0gW107XG5cdFx0dGhpcy5fbWF0cml4SWRlbnRpdHkgPSBtYXQ0LmNyZWF0ZSgpO1xuXHRcdEdMLmVuYWJsZUFscGhhQmxlbmRpbmcoKTtcblxuXHRcdHRoaXMuX2luaXQoKTtcblx0XHR0aGlzLl9pbml0VGV4dHVyZXMoKTtcblx0XHR0aGlzLl9pbml0Vmlld3MoKTtcblxuXHRcdHRoaXMuX2VmSW5kZXggPSBTY2hlZHVsZXIuYWRkRUYoKCk9PnRoaXMuX2xvb3AoKSk7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsICgpPT50aGlzLnJlc2l6ZSgpKTtcblx0fVxuXG5cblx0XG5cdC8vXHRQVUJMSUMgTUVUSE9EU1xuXG5cdHVwZGF0ZSgpIHtcblxuXHR9XG5cblx0cmVuZGVyKCkge1xuXG5cdH1cblxuXG5cdHN0b3AoKSB7XG5cdFx0aWYodGhpcy5fZWZJbmRleCA9PT0gLTEpIHtcdHJldHVybjsgfVxuXHRcdHRoaXMuX2VmSW5kZXggPSBTY2hlZHVsZXIucmVtb3ZlRUYodGhpcy5fZWZJbmRleCk7XG5cdH1cblxuXG5cdHN0YXJ0KCkge1xuXHRcdGlmKHRoaXMuX2VmSW5kZXggIT09IC0xKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSBcblxuXHRcdHRoaXMuX2VmSW5kZXggPSBTY2hlZHVsZXIuYWRkRUYoKCk9PnRoaXMuX2xvb3AoKSk7XG5cdH1cblxuXG5cdHJlc2l6ZSgpIHtcblx0XHRHTC5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuXHRcdHRoaXMuY2FtZXJhLnNldEFzcGVjdFJhdGlvKEdMLmFzcGVjdFJhdGlvKTtcblx0fVxuXG5cblx0YWRkQ2hpbGQobUNoaWxkKSB7XG5cdFx0dGhpcy5fY2hpbGRyZW4ucHVzaChtQ2hpbGQpO1xuXHR9XG5cblx0cmVtb3ZlQ2hpbGQobUNoaWxkKSB7XG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLl9jaGlsZHJlbi5pbmRleE9mKG1DaGlsZCk7XG5cdFx0aWYoaW5kZXggPT0gLTEpIHtcdGNvbnNvbGUud2FybignQ2hpbGQgbm8gZXhpc3QnKTsgcmV0dXJuO1x0fVxuXG5cdFx0dGhpcy5fY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcblx0fVxuXG5cblx0Ly9cdFBST1RFQ1RFRCBNRVRIT0RTIFRPIEJFIE9WRVJSSURFTiBCWSBDSElMRFJFTlxuXG5cdF9pbml0VGV4dHVyZXMoKSB7XG5cblx0fVxuXG5cblx0X2luaXRWaWV3cygpIHtcblxuXHR9XG5cblxuXHRfcmVuZGVyQ2hpbGRyZW4oKSB7XG5cdFx0bGV0IGNoaWxkO1xuXHRcdGZvcihsZXQgaT0wOyBpPHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuXHRcdFx0Y2hpbGQudG9SZW5kZXIoKTtcblx0XHR9XG5cblx0XHRHTC5yb3RhdGUodGhpcy5fbWF0cml4SWRlbnRpdHkpO1xuXHR9XG5cblx0Ly9cdFBSSVZBVEUgTUVUSE9EU1xuXG5cdF9pbml0KCkge1xuXHRcdHRoaXMuY2FtZXJhICAgICAgICAgICAgICAgICA9IG5ldyBDYW1lcmFQZXJzcGVjdGl2ZSgpO1xuXHRcdHRoaXMuY2FtZXJhLnNldFBlcnNwZWN0aXZlKDQ1ICogTWF0aC5QSSAvIDE4MCwgR0wuYXNwZWN0UmF0aW8sIDAuMSwgMTAwKTtcblx0XHR0aGlzLm9yYml0YWxDb250cm9sICAgICAgICAgID0gbmV3IE9yYml0YWxDb250cm9sKHRoaXMuY2FtZXJhLCB3aW5kb3csIDE1KTtcblx0XHR0aGlzLm9yYml0YWxDb250cm9sLnJhZGl1cy52YWx1ZSA9IDEwO1xuXHRcdFxuXHRcdHRoaXMuY2FtZXJhT3J0aG8gICAgICAgICAgICA9IG5ldyBDYW1lcmFPcnRobygpO1xuXHR9XG5cblx0X2xvb3AoKSB7XG5cblx0XHQvL1x0UkVTRVQgVklFV1BPUlRcblx0XHRHTC52aWV3cG9ydCgwLCAwLCBHTC53aWR0aCwgR0wuaGVpZ2h0KTtcblxuXHRcdC8vXHRSRVNFVCBDQU1FUkFcblx0XHRHTC5zZXRNYXRyaWNlcyh0aGlzLmNhbWVyYSk7XG5cblx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdHRoaXMuX3JlbmRlckNoaWxkcmVuKCk7XG5cdFx0dGhpcy5yZW5kZXIoKTtcblx0fVxuXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgU2NlbmU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvaGVscGVycy9TY2VuZS5qcyIsIi8vIFZpZXcuanNcblxuaW1wb3J0IEdMU2hhZGVyIGZyb20gJy4uL0dMU2hhZGVyJztcblxuY2xhc3MgVmlldyB7XG5cdGNvbnN0cnVjdG9yKG1TdHJWZXJ0ZXgsIG1TdHJGcmFnKSB7XG5cdFx0dGhpcy5zaGFkZXIgPSBuZXcgR0xTaGFkZXIobVN0clZlcnRleCwgbVN0ckZyYWcpO1xuXG5cdFx0dGhpcy5faW5pdCgpO1xuXHR9XG5cblxuXHQvL1x0UFJPVEVDVEVEIE1FVEhPRFNcblxuXHRfaW5pdCgpIHtcblxuXHR9XG5cblx0Ly8gXHRQVUJMSUMgTUVUSE9EU1xuXG5cdHJlbmRlcigpIHtcblxuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZpZXc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvaGVscGVycy9WaWV3LmpzIiwiLy8gVmlldzNELmpzXG5cbmltcG9ydCBPYmplY3QzRCBmcm9tICcuLi9vYmplY3RzL09iamVjdDNEJztcbmltcG9ydCBHTFNoYWRlciBmcm9tICcuLi9HTFNoYWRlcic7XG5pbXBvcnQgR0wgZnJvbSAnLi4vR0xUb29sJztcblxuY2xhc3MgVmlldzNEIGV4dGVuZHMgT2JqZWN0M0Qge1xuXHRjb25zdHJ1Y3RvcihtU3RyVmVydGV4LCBtU3RyRnJhZykge1xuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLl9jaGlsZHJlbiA9IFtdO1xuXHRcdHRoaXMuc2hhZGVyID0gbmV3IEdMU2hhZGVyKG1TdHJWZXJ0ZXgsIG1TdHJGcmFnKTtcblx0XHR0aGlzLl9pbml0KCk7XG5cdFx0dGhpcy5fbWF0cml4VGVtcCA9IG1hdDQuY3JlYXRlKCk7XG5cdH1cblxuXG5cdC8vXHRQUk9URUNURUQgTUVUSE9EU1xuXG5cdF9pbml0KCkge1xuXG5cdH1cblxuXHQvLyBcdFBVQkxJQyBNRVRIT0RTXG5cblx0YWRkQ2hpbGQobUNoaWxkKSB7XG5cdFx0dGhpcy5fY2hpbGRyZW4ucHVzaChtQ2hpbGQpO1xuXHR9XG5cblx0cmVtb3ZlQ2hpbGQobUNoaWxkKSB7XG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLl9jaGlsZHJlbi5pbmRleE9mKG1DaGlsZCk7XG5cdFx0aWYoaW5kZXggPT0gLTEpIHtcdGNvbnNvbGUud2FybignQ2hpbGQgbm8gZXhpc3QnKTsgcmV0dXJuO1x0fVxuXG5cdFx0dGhpcy5fY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcblx0fVxuXG5cblx0dG9SZW5kZXIobWF0cml4KSB7XG5cdFx0aWYobWF0cml4ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdG1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cdFx0fVxuXHRcdG1hdDQubXVsKHRoaXMuX21hdHJpeFRlbXAsIG1hdHJpeCwgdGhpcy5tYXRyaXgpO1xuXHRcdEdMLnJvdGF0ZSh0aGlzLl9tYXRyaXhUZW1wKTtcblx0XHR0aGlzLnJlbmRlcigpO1xuXG5cdFx0Zm9yKGxldCBpPTA7IGk8dGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG5cdFx0XHRjaGlsZC50b1JlbmRlcih0aGlzLm1hdHJpeCk7XG5cdFx0fVxuXHR9XG5cblx0cmVuZGVyKCkge1xuXG5cdH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBWaWV3M0Q7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvaGVscGVycy9WaWV3M0QuanMiLCIvLyBBc3NldHMuanNcblxuaW1wb3J0IGFzc2V0c1RvTG9hZCBmcm9tICcuL2Fzc2V0LWxpc3QnO1xuaW1wb3J0IGFsZnJpZCwgeyBHTFRleHR1cmUsIEdMQ3ViZVRleHR1cmUsIE1lc2gsIE9iakxvYWRlciB9IGZyb20gJ2FsZnJpZCc7XG5cbmNvbnN0IEFzc2V0cyA9IHt9O1xubGV0IF9hc3NldHMgPSBbXTtcblxuY29uc3QgZ2V0QXNzZXQgPSBmdW5jdGlvbihpZCkge1xuXHRyZXR1cm4gYXNzZXRzLmZpbmQoIChhKSA9PiBhLmlkID09PSBpZCkuZmlsZTtcbn1cblxuY29uc3QgZ2V0RXh0ZW5zaW9uID0gZnVuY3Rpb24obUZpbGUpIHtcblx0Y29uc3QgYXJ5ID0gbUZpbGUuc3BsaXQoJy4nKTtcblx0cmV0dXJuIGFyeVthcnkubGVuZ3RoIC0gMV07XG59XG5cbkFzc2V0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG5cdGxldCBoZHJDdWJlbWFwcyA9IHt9O1xuXHRfYXNzZXRzID0gYXNzZXRzVG9Mb2FkLm1hcCgobyk9PiB7XG5cdFx0Y29uc3QgZXh0ID0gZ2V0RXh0ZW5zaW9uKG8udXJsKTtcblx0XHRjb25zdCBmaWxlID0gZ2V0QXNzZXQoby5pZCk7XG5cdFx0bGV0IHRleHR1cmU7XG5cblx0XHRzd2l0Y2goZXh0KSB7XG5cdFx0XHRjYXNlICdqcGcnOlxuXHRcdFx0Y2FzZSAncG5nJzpcblx0XHRcdFx0dGV4dHVyZSA9IG5ldyBHTFRleHR1cmUoZmlsZSk7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0aWQ6by5pZCxcblx0XHRcdFx0XHRmaWxlOnRleHR1cmVcblx0XHRcdFx0fTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ2hkcic6XG5cdFx0XHRcdGxldCBjdWJlbWFwTmFtZSA9IG8uaWQuc3BsaXQoJ18nKVswXTtcblx0XHRcdFx0dGV4dHVyZSA9IGFsZnJpZC5IRFJMb2FkZXIucGFyc2UoZmlsZSk7XG5cblx0XHRcdFx0Y29uc3Qgb0Fzc2V0ID0ge1xuXHRcdFx0XHRcdGlkOm8uaWQsXG5cdFx0XHRcdFx0ZmlsZTp0ZXh0dXJlXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0aWYoIWhkckN1YmVtYXBzW2N1YmVtYXBOYW1lXSkge1xuXHRcdFx0XHRcdGhkckN1YmVtYXBzW2N1YmVtYXBOYW1lXSA9IFtdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aGRyQ3ViZW1hcHNbY3ViZW1hcE5hbWVdLnB1c2gob0Fzc2V0KTtcblx0XHRcdFx0cmV0dXJuIG9Bc3NldDtcblxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2Rkcyc6XG5cdFx0XHRcdHRleHR1cmUgPSBHTEN1YmVUZXh0dXJlLnBhcnNlRERTKGZpbGUpO1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGlkOm8uaWQsXG5cdFx0XHRcdFx0ZmlsZTp0ZXh0dXJlXG5cdFx0XHRcdH07XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdvYmonOlxuXHRcdFx0XHRjb25zdCBtZXNoID0gT2JqTG9hZGVyLnBhcnNlKGZpbGUpO1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGlkOm8uaWQsXG5cdFx0XHRcdFx0ZmlsZTptZXNoXG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdH0pO1xuXG5cdGZvcihsZXQgcyBpbiBoZHJDdWJlbWFwcykge1xuXHRcdGlmKGhkckN1YmVtYXBzW3NdLmxlbmd0aCA9PSA2KSB7XG5cdFx0XHRjb25zb2xlLmxvZygnR2VuZXJhdGUgQ3ViZW1hcCA6Jywgcyk7XG5cblx0XHRcdGNvbnN0IGFyeSA9IFtcblx0XHRcdFx0QXNzZXRzLmdldChgJHtzfV9wb3N4YCksXG5cdFx0XHRcdEFzc2V0cy5nZXQoYCR7c31fbmVneGApLFxuXHRcdFx0XHRBc3NldHMuZ2V0KGAke3N9X3Bvc3lgKSxcblx0XHRcdFx0QXNzZXRzLmdldChgJHtzfV9uZWd5YCksXG5cdFx0XHRcdEFzc2V0cy5nZXQoYCR7c31fcG9zemApLFxuXHRcdFx0XHRBc3NldHMuZ2V0KGAke3N9X25lZ3pgKVxuXHRcdFx0XTtcblxuXHRcdFx0Y29uc3QgdGV4dHVyZSA9IG5ldyBhbGZyaWQuR0xDdWJlVGV4dHVyZShhcnkpO1xuXHRcdFx0X2Fzc2V0cy5wdXNoKHtcblx0XHRcdFx0aWQ6cyxcblx0XHRcdFx0ZmlsZTp0ZXh0dXJlXG5cdFx0XHR9KVxuXHRcdH1cblx0fVxuXG5cdGlmKF9hc3NldHMubGVuZ3RoID4gMCkge1xuXHRcdGNvbnNvbGUuZGVidWcoJ0FTU0VUUzonKTtcblx0XHRjb25zb2xlLnRhYmxlKF9hc3NldHMpO1x0XG5cdH1cblx0XG59XG5cbkFzc2V0cy5nZXQgPSBmdW5jdGlvbihtSWQpIHtcblx0cmV0dXJuIF9hc3NldHMuZmluZCgoYSkgPT4ge1xuXHRcdHJldHVybiBhLmlkID09PSBtSWQ7XG5cdH0pLmZpbGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFzc2V0cztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvQXNzZXRzLmpzIiwiLy8gQ29uZmlnLmpzXG5cbmV4cG9ydCBkZWZhdWx0IHtcblx0Z2FtbWE6M1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9Db25maWcuanMiLCJcbmNvbnN0IGFzc2V0c1RvTG9hZCA9IFtcblx0e1wiaWRcIjpcImFsYmVkb1wiLFwidXJsXCI6XCJhc3NldHMvaW1nL2FsYmVkby5qcGdcIixcInR5cGVcIjpcImpwZ1wifSxcblx0e1wiaWRcIjpcImFvXCIsXCJ1cmxcIjpcImFzc2V0cy9pbWcvYW8uanBnXCIsXCJ0eXBlXCI6XCJqcGdcIn0sXG5cdHtcImlkXCI6XCJicmRmTFVUXCIsXCJ1cmxcIjpcImFzc2V0cy9pbWcvYnJkZkxVVC5wbmdcIixcInR5cGVcIjpcInBuZ1wifSxcblx0e1wiaWRcIjpcIm1ldGFsR2xvc3NcIixcInVybFwiOlwiYXNzZXRzL2ltZy9tZXRhbEdsb3NzLmpwZ1wiLFwidHlwZVwiOlwianBnXCJ9LFxuXHR7XCJpZFwiOlwibm9ybWFsXCIsXCJ1cmxcIjpcImFzc2V0cy9pbWcvbm9ybWFsLmpwZ1wiLFwidHlwZVwiOlwianBnXCJ9LFxuXHR7XCJpZFwiOlwic3R1ZGlvMTBfaXJyYWRpYW5jZVwiLFwidXJsXCI6XCJhc3NldHMvaW1nL3N0dWRpbzEwX2lycmFkaWFuY2UuZGRzXCIsXCJ0eXBlXCI6XCJiaW5hcnlcIn0sXG5cdHtcImlkXCI6XCJzdHVkaW8xMF9yYWRpYW5jZVwiLFwidXJsXCI6XCJhc3NldHMvaW1nL3N0dWRpbzEwX3JhZGlhbmNlLmRkc1wiLFwidHlwZVwiOlwiYmluYXJ5XCJ9LFxuXHR7XCJpZFwiOlwic3R1ZGlvMTFfaXJyYWRpYW5jZVwiLFwidXJsXCI6XCJhc3NldHMvaW1nL3N0dWRpbzExX2lycmFkaWFuY2UuZGRzXCIsXCJ0eXBlXCI6XCJiaW5hcnlcIn0sXG5cdHtcImlkXCI6XCJzdHVkaW8xMV9yYWRpYW5jZVwiLFwidXJsXCI6XCJhc3NldHMvaW1nL3N0dWRpbzExX3JhZGlhbmNlLmRkc1wiLFwidHlwZVwiOlwiYmluYXJ5XCJ9LFxuXHR7XCJpZFwiOlwic3R1ZGlvMTJfaXJyYWRpYW5jZVwiLFwidXJsXCI6XCJhc3NldHMvaW1nL3N0dWRpbzEyX2lycmFkaWFuY2UuZGRzXCIsXCJ0eXBlXCI6XCJiaW5hcnlcIn0sXG5cdHtcImlkXCI6XCJzdHVkaW8xMl9yYWRpYW5jZVwiLFwidXJsXCI6XCJhc3NldHMvaW1nL3N0dWRpbzEyX3JhZGlhbmNlLmRkc1wiLFwidHlwZVwiOlwiYmluYXJ5XCJ9LFxuXHR7XCJpZFwiOlwic3R1ZGlvMV9pcnJhZGlhbmNlXCIsXCJ1cmxcIjpcImFzc2V0cy9pbWcvc3R1ZGlvMV9pcnJhZGlhbmNlLmRkc1wiLFwidHlwZVwiOlwiYmluYXJ5XCJ9LFxuXHR7XCJpZFwiOlwic3R1ZGlvMV9yYWRpYW5jZVwiLFwidXJsXCI6XCJhc3NldHMvaW1nL3N0dWRpbzFfcmFkaWFuY2UuZGRzXCIsXCJ0eXBlXCI6XCJiaW5hcnlcIn0sXG5cdHtcImlkXCI6XCJzdHVkaW8yX2lycmFkaWFuY2VcIixcInVybFwiOlwiYXNzZXRzL2ltZy9zdHVkaW8yX2lycmFkaWFuY2UuZGRzXCIsXCJ0eXBlXCI6XCJiaW5hcnlcIn0sXG5cdHtcImlkXCI6XCJzdHVkaW8yX3JhZGlhbmNlXCIsXCJ1cmxcIjpcImFzc2V0cy9pbWcvc3R1ZGlvMl9yYWRpYW5jZS5kZHNcIixcInR5cGVcIjpcImJpbmFyeVwifSxcblx0e1wiaWRcIjpcInN0dWRpbzNfaXJyYWRpYW5jZVwiLFwidXJsXCI6XCJhc3NldHMvaW1nL3N0dWRpbzNfaXJyYWRpYW5jZS5kZHNcIixcInR5cGVcIjpcImJpbmFyeVwifSxcblx0e1wiaWRcIjpcInN0dWRpbzNfcmFkaWFuY2VcIixcInVybFwiOlwiYXNzZXRzL2ltZy9zdHVkaW8zX3JhZGlhbmNlLmRkc1wiLFwidHlwZVwiOlwiYmluYXJ5XCJ9LFxuXHR7XCJpZFwiOlwic3R1ZGlvNF9pcnJhZGlhbmNlXCIsXCJ1cmxcIjpcImFzc2V0cy9pbWcvc3R1ZGlvNF9pcnJhZGlhbmNlLmRkc1wiLFwidHlwZVwiOlwiYmluYXJ5XCJ9LFxuXHR7XCJpZFwiOlwic3R1ZGlvNF9yYWRpYW5jZVwiLFwidXJsXCI6XCJhc3NldHMvaW1nL3N0dWRpbzRfcmFkaWFuY2UuZGRzXCIsXCJ0eXBlXCI6XCJiaW5hcnlcIn0sXG5cdHtcImlkXCI6XCJzdHVkaW81X2lycmFkaWFuY2VcIixcInVybFwiOlwiYXNzZXRzL2ltZy9zdHVkaW81X2lycmFkaWFuY2UuZGRzXCIsXCJ0eXBlXCI6XCJiaW5hcnlcIn0sXG5cdHtcImlkXCI6XCJzdHVkaW81X3JhZGlhbmNlXCIsXCJ1cmxcIjpcImFzc2V0cy9pbWcvc3R1ZGlvNV9yYWRpYW5jZS5kZHNcIixcInR5cGVcIjpcImJpbmFyeVwifSxcblx0e1wiaWRcIjpcInN0dWRpbzZfaXJyYWRpYW5jZVwiLFwidXJsXCI6XCJhc3NldHMvaW1nL3N0dWRpbzZfaXJyYWRpYW5jZS5kZHNcIixcInR5cGVcIjpcImJpbmFyeVwifSxcblx0e1wiaWRcIjpcInN0dWRpbzZfcmFkaWFuY2VcIixcInVybFwiOlwiYXNzZXRzL2ltZy9zdHVkaW82X3JhZGlhbmNlLmRkc1wiLFwidHlwZVwiOlwiYmluYXJ5XCJ9LFxuXHR7XCJpZFwiOlwic3R1ZGlvN19pcnJhZGlhbmNlXCIsXCJ1cmxcIjpcImFzc2V0cy9pbWcvc3R1ZGlvN19pcnJhZGlhbmNlLmRkc1wiLFwidHlwZVwiOlwiYmluYXJ5XCJ9LFxuXHR7XCJpZFwiOlwic3R1ZGlvN19yYWRpYW5jZVwiLFwidXJsXCI6XCJhc3NldHMvaW1nL3N0dWRpbzdfcmFkaWFuY2UuZGRzXCIsXCJ0eXBlXCI6XCJiaW5hcnlcIn0sXG5cdHtcImlkXCI6XCJzdHVkaW84X2lycmFkaWFuY2VcIixcInVybFwiOlwiYXNzZXRzL2ltZy9zdHVkaW84X2lycmFkaWFuY2UuZGRzXCIsXCJ0eXBlXCI6XCJiaW5hcnlcIn0sXG5cdHtcImlkXCI6XCJzdHVkaW84X3JhZGlhbmNlXCIsXCJ1cmxcIjpcImFzc2V0cy9pbWcvc3R1ZGlvOF9yYWRpYW5jZS5kZHNcIixcInR5cGVcIjpcImJpbmFyeVwifSxcblx0e1wiaWRcIjpcInN0dWRpbzlfaXJyYWRpYW5jZVwiLFwidXJsXCI6XCJhc3NldHMvaW1nL3N0dWRpbzlfaXJyYWRpYW5jZS5kZHNcIixcInR5cGVcIjpcImJpbmFyeVwifSxcblx0e1wiaWRcIjpcInN0dWRpbzlfcmFkaWFuY2VcIixcInVybFwiOlwiYXNzZXRzL2ltZy9zdHVkaW85X3JhZGlhbmNlLmRkc1wiLFwidHlwZVwiOlwiYmluYXJ5XCJ9XG5dO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGFzc2V0c1RvTG9hZDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvYXNzZXQtbGlzdC5qcyIsIi8vIFNldHRpbmdzLmpzXG5cbmltcG9ydCBDb25maWcgZnJvbSAnLi9Db25maWcnO1xuaW1wb3J0IHVybCBmcm9tICdmYXN0LXVybC1wYXJzZXInO1xudXJsLnF1ZXJ5U3RyaW5nID0gcmVxdWlyZShcInF1ZXJ5c3RyaW5ncGFyc2VyXCIpO1xuXG5sZXQgZW5hYmxlZCA9IHRydWU7XG5cblxuY29uc3QgcmVsb2FkID0gKCkgPT4ge1xuXHRpZighZW5hYmxlZCkge1xuXHRcdHJldHVybjtcblx0fVxuXHR3aW5kb3cubG9jYXRpb24uaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4rd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgJz9jb25maWc9JyArIEpTT04uc3RyaW5naWZ5KENvbmZpZyk7XG59XG5cbmNvbnN0IHJlZnJlc2ggPSAoKSA9PiB7XG5cdGlmKCFlbmFibGVkKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSgnZXhwZXJpbWVudCcsICdUaXRsZScsIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4rd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgJz9jb25maWc9JyArIEpTT04uc3RyaW5naWZ5KENvbmZpZykpO1x0XG59XG5cblxubGV0IGRlbGF5SW5kZXggPSAtMTtcblxuY29uc3QgZGVsYXlSZWxvYWQgPSAoKSA9PiB7XG5cdGlmKCFlbmFibGVkKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdHdpbmRvdy5jbGVhclRpbWVvdXQoZGVsYXlJbmRleCk7XG5cblx0ZGVsYXlJbmRleCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpPT4ge1xuXHRcdHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gd2luZG93LmxvY2F0aW9uLm9yaWdpbit3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyAnP2NvbmZpZz0nICsgSlNPTi5zdHJpbmdpZnkoQ29uZmlnKTtcblx0fSwgNTAwKTtcbn1cblxuXG5jb25zdCBpbml0ID0gKG1FbmFibGVkPXRydWUpID0+IHtcblx0ZW5hYmxlZCA9IG1FbmFibGVkO1xuXHRjb25zdCBwYXJzZWQgPSB1cmwucGFyc2Uod2luZG93LmxvY2F0aW9uLnNlYXJjaCwgdHJ1ZSk7XG5cblx0aWYocGFyc2VkLnF1ZXJ5LmNvbmZpZykge1xuXHRcdGNvbnN0IG9Db25maWcgPSBKU09OLnBhcnNlKHBhcnNlZC5xdWVyeS5jb25maWcpO1xuXG5cdFx0Zm9yKGxldCBrZXkgaW4gb0NvbmZpZykge1xuXHRcdFx0Q29uZmlnW2tleV0gPSBvQ29uZmlnW2tleV07XG5cdFx0fVxuXHR9XG5cblx0Y29uc29sZS5sb2coJ0NvbmZpZyA6JywgQ29uZmlnKTtcblx0cmVmcmVzaCgpO1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IHtcblx0ZW5hYmxlZCxcblx0cmVsb2FkLFxuXHRyZWZyZXNoLFxuXHRkZWxheVJlbG9hZCxcblx0aW5pdFxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9TZXR0aW5ncy5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuZnVuY3Rpb24gRW1pdHRlcigpIHtcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnNldE1heExpc3RlbmVycygyMCk7XG59XG5cbkVtaXR0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcbkVtaXR0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRW1pdHRlcjtcblxuRW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICBpZiAodHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnModHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXNzZXRzLWxvYWRlci9zcmMvZW1pdHRlci5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtYnM6IDAsXG4gICAgc2VjczogMCxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKHJlcXVlc3QsIHN0YXJ0VGltZSwgdXJsLCBsb2cpIHtcbiAgICAgICAgdmFyIGxlbmd0aDtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSByZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpO1xuICAgICAgICBpZiAoaGVhZGVycykge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gaGVhZGVycy5tYXRjaCgvY29udGVudC1sZW5ndGg6IChcXGQrKS9pKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB2YXIgbGVuZ3RoID0gcmVxdWVzdC5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1MZW5ndGgnKTtcbiAgICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gcGFyc2VJbnQobGVuZ3RoLCAxMCk7XG4gICAgICAgICAgICB2YXIgbWJzID0gbGVuZ3RoIC8gMTAyNCAvIDEwMjQ7XG4gICAgICAgICAgICB2YXIgc2VjcyA9IChEYXRlLm5vdygpIC0gc3RhcnRUaW1lKSAvIDEwMDA7XG4gICAgICAgICAgICB0aGlzLnNlY3MgKz0gc2VjcztcbiAgICAgICAgICAgIHRoaXMubWJzICs9IG1icztcbiAgICAgICAgICAgIGlmIChsb2cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZyh1cmwsIG1icywgc2Vjcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZihsb2cpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybi5jYWxsKGNvbnNvbGUsICdDYW5cXCd0IGdldCBDb250ZW50LUxlbmd0aDonLCB1cmwpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBsb2c6IGZ1bmN0aW9uKHVybCwgbWJzLCBzZWNzKSB7XG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgIHZhciBmaWxlID0gJ0ZpbGUgbG9hZGVkOiAnICtcbiAgICAgICAgICAgICAgICB1cmwuc3Vic3RyKHVybC5sYXN0SW5kZXhPZignLycpICsgMSkgK1xuICAgICAgICAgICAgICAgICcgc2l6ZTonICsgbWJzLnRvRml4ZWQoMikgKyAnbWInICtcbiAgICAgICAgICAgICAgICAnIHRpbWU6JyArIHNlY3MudG9GaXhlZCgyKSArICdzJyArXG4gICAgICAgICAgICAgICAgJyBzcGVlZDonICsgKG1icyAvIHNlY3MpLnRvRml4ZWQoMikgKyAnbWJwcyc7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nLmNhbGwoY29uc29sZSwgZmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvdGFsID0gJ1RvdGFsIGxvYWRlZDogJyArIHRoaXMubWJzLnRvRml4ZWQoMikgKyAnbWInICtcbiAgICAgICAgICAgICcgdGltZTonICsgdGhpcy5zZWNzLnRvRml4ZWQoMikgKyAncycgK1xuICAgICAgICAgICAgJyBzcGVlZDonICsgdGhpcy5nZXRNYnBzKCkudG9GaXhlZCgyKSArICdtYnBzJztcbiAgICAgICAgY29uc29sZS5sb2cuY2FsbChjb25zb2xlLCB0b3RhbCk7XG4gICAgfSxcbiAgICBnZXRNYnBzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWJzIC8gdGhpcy5zZWNzO1xuICAgIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hc3NldHMtbG9hZGVyL3NyYy9zdGF0cy5qc1xuLy8gbW9kdWxlIGlkID0gMTAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vc2Nzcy9nbG9iYWwuc2Nzcyc7XG5pbXBvcnQgZGVidWdQb2x5ZmlsbCBmcm9tICcuL2RlYnVnL2RlYnVnUG9seWZpbGwnO1xuaW1wb3J0IGFsZnJpZCwgeyBHTCB9IGZyb20gJ2FsZnJpZCc7XG5pbXBvcnQgU2NlbmVBcHAgZnJvbSAnLi9TY2VuZUFwcCc7XG5pbXBvcnQgQXNzZXRzTG9hZGVyIGZyb20gJ2Fzc2V0cy1sb2FkZXInO1xuXG5pbXBvcnQgYXNzZXRzIGZyb20gJy4vYXNzZXQtbGlzdCc7XG5pbXBvcnQgQXNzZXRzIGZyb20gJy4vQXNzZXRzJztcblxuaWYoZG9jdW1lbnQuYm9keSkge1xuXHRfaW5pdCgpO1xufSBlbHNlIHtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBfaW5pdCk7XG59XG5cblxuZnVuY3Rpb24gX2luaXQoKSB7XG5cblx0Ly9cdExPQURJTkcgQVNTRVRTXG5cdGlmKGFzc2V0cy5sZW5ndGggPiAwKSB7XG5cdFx0ZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdpc0xvYWRpbmcnKTtcblxuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBBc3NldHNMb2FkZXIoe1xuXHRcdFx0YXNzZXRzOmFzc2V0c1xuXHRcdH0pXG5cdFx0Lm9uKCdlcnJvcicsIChlcnJvcik9Pntcblx0XHRcdGNvbnNvbGUubG9nKCdFcnJvciA6JywgZXJyb3IpO1xuXHRcdH0pXG5cdFx0Lm9uKCdwcm9ncmVzcycsIChwKSA9PiB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZygnUHJvZ3Jlc3MgOiAnLCBwKTtcblx0XHRcdGNvbnN0IGxvYWRlciA9IGRvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvcignLkxvYWRpbmctQmFyJyk7XG5cdFx0XHRpZihsb2FkZXIpIGxvYWRlci5zdHlsZS53aWR0aCA9IGAkeyhwICogMTAwKX0lYDtcblx0XHR9KVxuXHRcdC5vbignY29tcGxldGUnLCBfb25JbWFnZUxvYWRlZClcblx0XHQuc3RhcnQoKTtcblxuXHR9IGVsc2Uge1xuXHRcdF9pbml0M0QoKTtcblx0fVxufVxuXG5cbmZ1bmN0aW9uIF9vbkltYWdlTG9hZGVkKG8pIHtcblx0Ly9cdEFTU0VUU1xuXHRjb25zb2xlLmxvZygnSW1hZ2UgTG9hZGVkIDogJywgbyk7XG5cdHdpbmRvdy5hc3NldHMgPSBvO1xuXHRjb25zdCBsb2FkZXIgPSBkb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3IoJy5Mb2FkaW5nLUJhcicpO1xuXHRjb25zb2xlLmxvZygnTG9hZGVyIDonLCBsb2FkZXIpO1xuXHRsb2FkZXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XG5cblx0X2luaXQzRCgpO1xuXG5cdHNldFRpbWVvdXQoKCk9PiB7XG5cdFx0ZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdpc0xvYWRpbmcnKTtcblx0fSwgMjUwKTtcbn1cblxuXG5mdW5jdGlvbiBfaW5pdDNEKCkge1xuXHQvL1x0Q1JFQVRFIENBTlZBU1xuXHRjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0Y2FudmFzLmNsYXNzTmFtZSA9ICdNYWluLUNhbnZhcyc7XG5cdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcblxuXHQvL1x0SU5JVCAzRCBUT09MXG5cdEdMLmluaXQoY2FudmFzLCB7aWdub3JlV2ViZ2wyOnRydWV9KTtcblxuXHQvL1x0SU5JVCBBU1NFVFNcblx0QXNzZXRzLmluaXQoKTtcblxuXHQvL1x0Q1JFQVRFIFNDRU5FXG5cdGNvbnN0IHNjZW5lID0gbmV3IFNjZW5lQXBwKCk7XG5cblx0XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2FwcC5qcyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz91cmw9ZmFsc2UhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9nbG9iYWwuc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/dXJsPWZhbHNlIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vZ2xvYmFsLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3VybD1mYWxzZSEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL2dsb2JhbC5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zY3NzL2dsb2JhbC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAxMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24oc2VsZWN0b3IpIHtcblx0XHRpZiAodHlwZW9mIG1lbW9bc2VsZWN0b3JdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRtZW1vW3NlbGVjdG9yXSA9IGZuLmNhbGwodGhpcywgc2VsZWN0b3IpO1xuXHRcdH1cblxuXHRcdHJldHVybiBtZW1vW3NlbGVjdG9yXVxuXHR9O1xufSkoZnVuY3Rpb24gKHRhcmdldCkge1xuXHRyZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpXG59KTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24pIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG5cdGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0Jy4gTXVzdCBiZSAndG9wJyBvciAnYm90dG9tJy5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC8pL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBkZWJ1Z1BvbHlmaWxsLmpzXG5cbndpbmRvdy5ndWkgPSB7XG5cdGFkZDooKT0+e1xuXG5cdH1cbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2RlYnVnL2RlYnVnUG9seWZpbGwuanMiLCIvLyBTY2VuZUFwcC5qc1xuXG5pbXBvcnQgYWxmcmlkLCB7IFNjZW5lLCBHTCB9IGZyb20gJ2FsZnJpZCc7XG4vLyBpbXBvcnQgVmlld09iak1vZGVsIGZyb20gJy4vVmlld09iak1vZGVsJztcbmltcG9ydCBWaWV3TWljcm8gZnJvbSAnLi9WaWV3TWljcm8nO1xuaW1wb3J0IEFzc2V0cyBmcm9tICcuL0Fzc2V0cyc7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi9TZXR0aW5ncyc7XG5pbXBvcnQgQ29uZmlnIGZyb20gJy4vQ29uZmlnJztcblxuY2xhc3MgU2NlbmVBcHAgZXh0ZW5kcyBTY2VuZSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdFNldHRpbmdzLmluaXQoKTtcblxuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5yZXNpemUoKTtcblx0XHRHTC5lbmFibGVBbHBoYUJsZW5kaW5nKCk7XG5cdFx0dGhpcy5vcmJpdGFsQ29udHJvbC5yeC52YWx1ZSA9IHRoaXMub3JiaXRhbENvbnRyb2wucnkudmFsdWUgPSAwLjM7XG5cdFx0dGhpcy5vcmJpdGFsQ29udHJvbC5yYWRpdXMudmFsdWUgPSA1O1xuXHR9XG5cblx0X2luaXRUZXh0dXJlcygpIHtcblx0XHRjb25zb2xlLmxvZygnaW5pdCB0ZXh0dXJlcycpO1xuXHR9XG5cblxuXHRfaW5pdFZpZXdzKCkge1xuXHRcdGNvbnNvbGUubG9nKCdpbml0IHZpZXdzJyk7XG5cblx0XHR0aGlzLl9iQ29weSA9IG5ldyBhbGZyaWQuQmF0Y2hDb3B5KCk7XG5cdFx0dGhpcy5fYkF4aXMgPSBuZXcgYWxmcmlkLkJhdGNoQXhpcygpO1xuXHRcdHRoaXMuX2JEb3RzID0gbmV3IGFsZnJpZC5CYXRjaERvdHNQbGFuZSgpO1xuXHRcdHRoaXMuX2JTa3kgPSBuZXcgYWxmcmlkLkJhdGNoU2t5Ym94KCk7XG5cblx0XHQvLyB0aGlzLl92TW9kZWwgPSBuZXcgVmlld09iak1vZGVsKCk7XG5cblx0XHR0aGlzLl92TWljcm8gPSBuZXcgVmlld01pY3JvKCk7XG5cblx0XHR0aGlzLmVudiA9ICdzdHVkaW8xJztcblx0XHRcblx0XHRjb25zdCBlbnZzID0gW107XG5cdFx0Zm9yKGxldCBpPTE7IGk8PTEyOyBpKyspIHtcblx0XHRcdGVudnMucHVzaChgc3R1ZGlvJHtpfWApO1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZUVudk1hcCgpO1xuXG5cdFx0Z3VpLmFkZCh0aGlzLCAnZW52JywgZW52cykub25GaW5pc2hDaGFuZ2UoKCk9PnRoaXMuX3VwZGF0ZUVudk1hcCgpKTtcblx0fVxuXG5cblx0X3VwZGF0ZUVudk1hcCgpIHtcblx0XHR0aGlzLnRleHR1cmVJcnIgPSBBc3NldHMuZ2V0KGAke3RoaXMuZW52fV9pcnJhZGlhbmNlYCk7XG5cdFx0dGhpcy50ZXh0dXJlUmFkID0gQXNzZXRzLmdldChgJHt0aGlzLmVudn1fcmFkaWFuY2VgKTtcblx0fVxuXG5cblx0cmVuZGVyKCkge1xuXHRcdEdMLmNsZWFyKDAsIDAsIDAsIDApO1xuXG5cdFx0dGhpcy5fYlNreS5kcmF3KHRoaXMudGV4dHVyZVJhZCk7XG5cdFx0dGhpcy5fdk1pY3JvLnJlbmRlcih0aGlzLnRleHR1cmVJcnIsIHRoaXMudGV4dHVyZVJhZCk7XG5cdH1cblxuXG5cdHJlc2l6ZSgpIHtcblx0XHRjb25zdCB7IGlubmVyV2lkdGgsIGlubmVySGVpZ2h0LCBkZXZpY2VQaXhlbFJhdGlvIH0gPSB3aW5kb3c7XG5cdFx0R0wuc2V0U2l6ZShpbm5lcldpZHRoLCBpbm5lckhlaWdodCk7XG5cdFx0dGhpcy5jYW1lcmEuc2V0QXNwZWN0UmF0aW8oR0wuYXNwZWN0UmF0aW8pO1xuXHR9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgU2NlbmVBcHA7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL1NjZW5lQXBwLmpzIiwiLy8gVmlld01pY3JvLmpzXG5cbmltcG9ydCBhbGZyaWQsIHsgR0wsIEdMVEZMb2FkZXIgfSBmcm9tICdhbGZyaWQnO1xuaW1wb3J0IHZzIGZyb20gJ3NoYWRlcnMvZ2x0Zi52ZXJ0JztcbmltcG9ydCBmcyBmcm9tICdzaGFkZXJzL2dsdGYuZnJhZyc7XG5cbmltcG9ydCBBc3NldHMgZnJvbSAnLi9Bc3NldHMnO1xuaW1wb3J0IENvbmZpZyBmcm9tICcuL0NvbmZpZyc7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi9TZXR0aW5ncyc7XG5cbmNvbnN0IGRlZmluZXNUb1N0cmluZyA9IGZ1bmN0aW9uKGRlZmluZXMpIHtcblx0bGV0IG91dFN0ciA9ICcnO1xuXHRmb3IgKGNvbnN0IGRlZiBpbiBkZWZpbmVzKSB7XG5cdFx0aWYoZGVmaW5lc1tkZWZdKSB7XG5cdFx0XHRvdXRTdHIgKz0gJyNkZWZpbmUgJyArIGRlZiArICcgJyArIGRlZmluZXNbZGVmXSArICdcXG4nO1x0XG5cdFx0fVxuXHRcdFxuXHR9XG5cdHJldHVybiBvdXRTdHI7XG59O1xuXG5jbGFzcyBWaWV3TWljcm8gZXh0ZW5kcyBhbGZyaWQuVmlldyB7XG5cdFxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRjb25zdCBkZWZpbmVzID0ge1xuXHRcdFx0J1VTRV9JQkwnOiAxLFxuXHRcdFx0J0hBU19CQVNFQ09MT1JNQVAnOiAxLFxuXHRcdFx0J0hBU19OT1JNQUxNQVAnOiAxLFxuXHRcdFx0J0hBU19FTUlTU0lWRU1BUCc6IDAsXG5cdFx0XHQnSEFTX09DQ0xVU0lPTk1BUCc6IDEsXG5cdFx0XHQnSEFTX01FVEFMUk9VR0hORVNTTUFQJzogMSxcblx0XHR9O1xuXG5cdFx0Y29uc3QgZGVmaW5lU3RyID0gZGVmaW5lc1RvU3RyaW5nKGRlZmluZXMpO1xuXHRcdGNvbnN0IF92cyA9IGAke2RlZmluZVN0cn1cXG4ke3ZzfWA7XG5cdFx0Y29uc3QgX2ZzID0gYCR7ZGVmaW5lU3RyfVxcbiR7ZnN9YDtcblx0XHRzdXBlcihfdnMsIF9mcyk7XG5cdH1cblxuXG5cdF9pbml0KCkge1xuXHRcdC8vIGxvYWQgZ2x0ZiBmaWxlXG5cdFx0Y29uc3QgdXJsID0gJ2Fzc2V0cy9nbHRmL21pY3JvcGhvbmUuZ2x0Zic7XG5cblx0XHRHTFRGTG9hZGVyLmxvYWQodXJsKVxuXHRcdC50aGVuKChnbHRmSW5mbyk9PiB0aGlzLl9vbkxvYWRlZChnbHRmSW5mbykpXG5cdFx0LmNhdGNoKGUgPT4ge1xuXHRcdFx0Y29uc29sZS5sb2coJ0Vycm9yIGxvYWRpbmcgZ2x0ZjonLCBlKTtcblx0XHR9KTtcblxuXHRcdGd1aS5hZGQoQ29uZmlnLCAnZ2FtbWEnLCAxLCA1KS5vbkNoYW5nZShTZXR0aW5ncy5yZWZyZXNoKTtcblx0XHQvL1x0dGV4dHVyZXNcblxuXHRcdGNvbnN0IHRleHR1cmVCcmRmID0gQXNzZXRzLmdldCgnYnJkZkxVVCcpO1xuXHRcdGNvbnN0IHRleHR1cmVDb2xvciA9IEFzc2V0cy5nZXQoJ2FsYmVkbycpO1xuXHRcdGNvbnN0IHRleHR1cmVNZXRhbEdsb3NzID0gQXNzZXRzLmdldCgnbWV0YWxHbG9zcycpO1xuXHRcdGNvbnN0IHRleHR1cmVBTyA9IEFzc2V0cy5nZXQoJ2FvJyk7XG5cdFx0Y29uc3QgdGV4dHVyZU5vcm1hbCA9IEFzc2V0cy5nZXQoJ25vcm1hbCcpO1xuXHRcdC8vIHRleHR1cmVJcnIgPSBhbGZyaWQuR0xDdWJlVGV4dHVyZS5wYXJzZUREUyhBc3NldHMuZ2V0KCdwbGlnaHRfaXJyYWRpYW5jZScpO1xuXHRcdC8vIHRleHR1cmVSYWQgPSBhbGZyaWQuR0xDdWJlVGV4dHVyZS5wYXJzZUREUyhBc3NldHMuZ2V0KCdwbGlnaHRfcmFkaWFuY2UnKTtcblxuXG5cdFx0Ly9cdGJpbmRpbmdcblx0XHRjb25zdCB7IHNoYWRlciB9ID0gdGhpcztcblx0XHRzaGFkZXIuYmluZCgpO1xuXG5cdFx0c2hhZGVyLnVuaWZvcm0oJ3VBb01hcCcsICd1bmlmb3JtMWknLCAwKTtcblx0XHR0ZXh0dXJlQU8uYmluZCgwKTtcblxuXHRcdHNoYWRlci51bmlmb3JtKFwidUJSREZNYXBcIiwgXCJ1bmlmb3JtMWlcIiwgMSk7XG5cdFx0dGV4dHVyZUJyZGYuYmluZCgxKTtcblxuXHRcdHNoYWRlci51bmlmb3JtKFwidUNvbG9yTWFwXCIsIFwidW5pZm9ybTFpXCIsIDIpO1xuXHRcdHRleHR1cmVDb2xvci5iaW5kKDIpO1xuXG5cdFx0c2hhZGVyLnVuaWZvcm0oXCJ1Tm9ybWFsTWFwXCIsIFwidW5pZm9ybTFpXCIsIDMpO1xuXHRcdHRleHR1cmVOb3JtYWwuYmluZCgzKTtcblxuXHRcdHNoYWRlci51bmlmb3JtKFwidU1ldGFsbGljUm91Z2huZXNzTWFwXCIsIFwidW5pZm9ybTFpXCIsIDQpO1xuXHRcdHRleHR1cmVNZXRhbEdsb3NzLmJpbmQoNCk7XG5cblx0XHRzaGFkZXIudW5pZm9ybSgndVJhZGlhbmNlTWFwJywgJ3VuaWZvcm0xaScsIDUpO1xuXHRcdHNoYWRlci51bmlmb3JtKCd1SXJyYWRpYW5jZU1hcCcsICd1bmlmb3JtMWknLCA2KTtcblx0XHRcblx0XHRcblxuXHRcdGNvbnN0IGJhc2VDb2xvciA9IFsxLCAxLCAxXTtcblx0XHRjb25zdCByb3VnaG5lc3MgPSAxO1xuXHRcdGNvbnN0IG1ldGFsbGljID0gMTtcblxuXG5cdFx0c2hhZGVyLnVuaWZvcm0oJ3VCYXNlQ29sb3InLCAndW5pZm9ybTNmdicsIGJhc2VDb2xvcik7XG5cdFx0c2hhZGVyLnVuaWZvcm0oJ3VSb3VnaG5lc3MnLCAndW5pZm9ybTFmJywgcm91Z2huZXNzKTtcblx0XHRzaGFkZXIudW5pZm9ybSgndU1ldGFsbGljJywgJ3VuaWZvcm0xZicsIG1ldGFsbGljKTtcblx0XHRzaGFkZXIudW5pZm9ybShcInVOb3JtYWxTY2FsZVwiLCBcImZsb2F0XCIsIDEpO1xuXHRcdHNoYWRlci51bmlmb3JtKFwidUVtaXNzaXZlRmFjdG9yXCIsIFwidmVjM1wiLCBbMC41LCAwLjUsIDAuNV0pO1xuXG5cdFx0c2hhZGVyLnVuaWZvcm0oXCJ1TGlnaHREaXJlY3Rpb25cIiwgXCJ2ZWMzXCIsIFswLjUsIDAuNSwgMC41XSk7XG5cdFx0c2hhZGVyLnVuaWZvcm0oXCJ1TGlnaHRDb2xvclwiLCBcInZlYzNcIiwgWzAsIDAsIDBdKTtcblxuXHRcdHNoYWRlci51bmlmb3JtKFwidVNjYWxlRGlmZkJhc2VNUlwiLCBcInZlYzRcIiwgWzAsIDAsIDAsIDBdKTtcblx0XHRzaGFkZXIudW5pZm9ybShcInVTY2FsZUZHRFNwZWNcIiwgXCJ2ZWM0XCIsIFswLCAwLCAwLCAwXSk7XG5cdFx0c2hhZGVyLnVuaWZvcm0oXCJ1U2NhbGVJQkxBbWJpZW50XCIsIFwidmVjNFwiLCBbMSwgMSwgMSwgMV0pO1xuXG5cdFx0XG5cdFx0c2hhZGVyLnVuaWZvcm0oXCJ1T2NjbHVzaW9uU3RyZW5ndGhcIiwgXCJmbG9hdFwiLCAxKTtcblx0fVxuXG5cblx0X29uTG9hZGVkKGdsdGZJbmZvKSB7XG5cdFx0Y29uc29sZS5sb2coJ2xvYWRlZCA6JywgZ2x0ZkluZm8pO1xuXHRcdHRoaXMubWVzaCA9IGdsdGZJbmZvLm91dHB1dC5tZXNoZXM7XG5cdH1cblxuXG5cdHJlbmRlcih0ZXh0dXJlSXJyLCB0ZXh0dXJlUmFkKSB7XG5cdFx0aWYoIXRoaXMubWVzaCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLnNoYWRlci5iaW5kKCk7XG5cblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKFwidUdhbW1hXCIsIFwiZmxvYXRcIiwgQ29uZmlnLmdhbW1hKTtcblx0XHR0ZXh0dXJlUmFkLmJpbmQoNSk7XG5cdFx0dGV4dHVyZUlyci5iaW5kKDYpO1xuXG5cdFx0R0wuZHJhdyh0aGlzLm1lc2gpO1xuXHR9XG5cblxufVxuXG5leHBvcnQgZGVmYXVsdCBWaWV3TWljcm87XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL1ZpZXdNaWNyby5qcyIsIm1vZHVsZS5leHBvcnRzID0gXCIjZGVmaW5lIFNIQURFUl9OQU1FIGdsdGZfcGJyX3ZlcnRcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMyBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5hdHRyaWJ1dGUgdmVjMyBhTm9ybWFsO1xcblxcbnVuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVWaWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcXG51bmlmb3JtIG1hdDMgdU5vcm1hbE1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG52YXJ5aW5nIHZlYzMgdlBvc2l0aW9uO1xcblxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFx0dmVjNCBwb3NpdGlvbiA9IHVNb2RlbE1hdHJpeCAqIHZlYzQoYVZlcnRleFBvc2l0aW9uLCAxLjApO1xcblxcdHZQb3NpdGlvbiAgICAgPSBwb3NpdGlvbi54eXogLyBwb3NpdGlvbi53O1xcblxcdFxcblxcdHZOb3JtYWwgICAgICAgPSBub3JtYWxpemUodmVjMyh1TW9kZWxNYXRyaXggKiB2ZWM0KGFOb3JtYWwsIDAuMCkpKTtcXG5cXHQvLyB2Tm9ybWFsICAgICAgID0gdU5vcm1hbE1hdHJpeCAqIGFOb3JtYWw7XFxuXFx0dlRleHR1cmVDb29yZCA9IHZlYzIoYVRleHR1cmVDb29yZC54LCAxLjAgLSBhVGV4dHVyZUNvb3JkLnkpO1xcblxcdFxcblxcdGdsX1Bvc2l0aW9uICAgPSB1UHJvamVjdGlvbk1hdHJpeCAqIHVWaWV3TWF0cml4ICogcG9zaXRpb247XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc2hhZGVycy9nbHRmLnZlcnRcbi8vIG1vZHVsZSBpZCA9IDEwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI2RlZmluZSBTSEFERVJfTkFNRSBwYnJfZnJhZ1xcblxcbiNleHRlbnNpb24gR0xfRVhUX3NoYWRlcl90ZXh0dXJlX2xvZDogZW5hYmxlXFxuI2V4dGVuc2lvbiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgOiBlbmFibGVcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCBcXHR1QlJERk1hcDtcXG51bmlmb3JtIHNhbXBsZXJDdWJlIHVSYWRpYW5jZU1hcDtcXG51bmlmb3JtIHNhbXBsZXJDdWJlIHVJcnJhZGlhbmNlTWFwO1xcblxcbiNpZmRlZiBIQVNfQkFTRUNPTE9STUFQXFxudW5pZm9ybSBzYW1wbGVyMkQgdUNvbG9yTWFwO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBIQVNfT0NDTFVTSU9OTUFQXFxudW5pZm9ybSBzYW1wbGVyMkQgdUFvTWFwO1xcbnVuaWZvcm0gZmxvYXQgdU9jY2x1c2lvblN0cmVuZ3RoO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBIQVNfTk9STUFMTUFQXFxudW5pZm9ybSBzYW1wbGVyMkQgdU5vcm1hbE1hcDtcXG51bmlmb3JtIGZsb2F0IHVOb3JtYWxTY2FsZTtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgSEFTX0VNSVNTSVZFTUFQXFxudW5pZm9ybSBzYW1wbGVyMkQgdUVtaXNzaXZlTWFwO1xcbnVuaWZvcm0gdmVjMyB1RW1pc3NpdmVGYWN0b3I7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEhBU19NRVRBTFJPVUdITkVTU01BUFxcbnVuaWZvcm0gc2FtcGxlcjJEIHVNZXRhbGxpY1JvdWdobmVzc01hcDtcXG4jZW5kaWZcXG5cXG51bmlmb3JtIHZlYzMgdUxpZ2h0RGlyZWN0aW9uO1xcbnVuaWZvcm0gdmVjMyB1TGlnaHRDb2xvcjtcXG51bmlmb3JtIHZlYzMgdUNhbWVyYVBvcztcXG5cXG51bmlmb3JtIHZlYzQgdVNjYWxlRGlmZkJhc2VNUjtcXG51bmlmb3JtIHZlYzQgdVNjYWxlRkdEU3BlYztcXG51bmlmb3JtIHZlYzQgdVNjYWxlSUJMQW1iaWVudDtcXG5cXG51bmlmb3JtIHZlYzMgdUJhc2VDb2xvcjtcXG51bmlmb3JtIGZsb2F0IHVSb3VnaG5lc3M7XFxudW5pZm9ybSBmbG9hdCB1TWV0YWxsaWM7XFxudW5pZm9ybSBmbG9hdCB1R2FtbWE7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxudmFyeWluZyB2ZWMzIHZQb3NpdGlvbjtcXG5cXG4vL1xcdEZyb20gR0xURiBXZWJHTCBQQlIgOlxcbi8vXFx0aHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGLVdlYkdMLVBCUlxcblxcbi8vIEVuY2Fwc3VsYXRlIHRoZSB2YXJpb3VzIGlucHV0cyB1c2VkIGJ5IHRoZSB2YXJpb3VzIGZ1bmN0aW9ucyBpbiB0aGUgc2hhZGluZyBlcXVhdGlvblxcbi8vIFdlIHN0b3JlIHZhbHVlcyBpbiB0aGlzIHN0cnVjdCB0byBzaW1wbGlmeSB0aGUgaW50ZWdyYXRpb24gb2YgYWx0ZXJuYXRpdmUgaW1wbGVtZW50YXRpb25zXFxuLy8gb2YgdGhlIHNoYWRpbmcgdGVybXMsIG91dGxpbmVkIGluIHRoZSBSZWFkbWUuTUQgQXBwZW5kaXguXFxuc3RydWN0IFBCUkluZm9cXG57XFxuXFx0ZmxvYXQgTmRvdEw7ICAgICAgICAgICAgICAgICAgLy8gY29zIGFuZ2xlIGJldHdlZW4gbm9ybWFsIGFuZCBsaWdodCBkaXJlY3Rpb25cXG5cXHRmbG9hdCBOZG90VjsgICAgICAgICAgICAgICAgICAvLyBjb3MgYW5nbGUgYmV0d2VlbiBub3JtYWwgYW5kIHZpZXcgZGlyZWN0aW9uXFxuXFx0ZmxvYXQgTmRvdEg7ICAgICAgICAgICAgICAgICAgLy8gY29zIGFuZ2xlIGJldHdlZW4gbm9ybWFsIGFuZCBoYWxmIHZlY3RvclxcblxcdGZsb2F0IExkb3RIOyAgICAgICAgICAgICAgICAgIC8vIGNvcyBhbmdsZSBiZXR3ZWVuIGxpZ2h0IGRpcmVjdGlvbiBhbmQgaGFsZiB2ZWN0b3JcXG5cXHRmbG9hdCBWZG90SDsgICAgICAgICAgICAgICAgICAvLyBjb3MgYW5nbGUgYmV0d2VlbiB2aWV3IGRpcmVjdGlvbiBhbmQgaGFsZiB2ZWN0b3JcXG5cXHRmbG9hdCBwZXJjZXB0dWFsUm91Z2huZXNzOyAgICAvLyByb3VnaG5lc3MgdmFsdWUsIGFzIGF1dGhvcmVkIGJ5IHRoZSBtb2RlbCBjcmVhdG9yIChpbnB1dCB0byBzaGFkZXIpXFxuXFx0ZmxvYXQgbWV0YWxuZXNzOyAgICAgICAgICAgICAgLy8gbWV0YWxsaWMgdmFsdWUgYXQgdGhlIHN1cmZhY2VcXG5cXHR2ZWMzIHJlZmxlY3RhbmNlMDsgICAgICAgICAgICAvLyBmdWxsIHJlZmxlY3RhbmNlIGNvbG9yIChub3JtYWwgaW5jaWRlbmNlIGFuZ2xlKVxcblxcdHZlYzMgcmVmbGVjdGFuY2U5MDsgICAgICAgICAgIC8vIHJlZmxlY3RhbmNlIGNvbG9yIGF0IGdyYXppbmcgYW5nbGVcXG5cXHRmbG9hdCBhbHBoYVJvdWdobmVzczsgICAgICAgICAvLyByb3VnaG5lc3MgbWFwcGVkIHRvIGEgbW9yZSBsaW5lYXIgY2hhbmdlIGluIHRoZSByb3VnaG5lc3MgKHByb3Bvc2VkIGJ5IFsyXSlcXG5cXHR2ZWMzIGRpZmZ1c2VDb2xvcjsgICAgICAgICAgICAvLyBjb2xvciBjb250cmlidXRpb24gZnJvbSBkaWZmdXNlIGxpZ2h0aW5nXFxuXFx0dmVjMyBzcGVjdWxhckNvbG9yOyAgICAgICAgICAgLy8gY29sb3IgY29udHJpYnV0aW9uIGZyb20gc3BlY3VsYXIgbGlnaHRpbmdcXG59O1xcblxcblxcbmNvbnN0IGZsb2F0IE1fUEkgPSAzLjE0MTU5MjY1MzU4OTc5MztcXG5jb25zdCBmbG9hdCBjX01pblJvdWdobmVzcyA9IDAuMDQ7XFxuXFxuXFxudmVjNCBTUkdCdG9MSU5FQVIodmVjNCBzcmdiSW4pXFxue1xcblxcdCNpZmRlZiBNQU5VQUxfU1JHQlxcblxcdCNpZmRlZiBTUkdCX0ZBU1RfQVBQUk9YSU1BVElPTlxcblxcdHZlYzMgbGluT3V0ID0gcG93KHNyZ2JJbi54eXosdmVjMygyLjIpKTtcXG5cXHQjZWxzZSAvL1NSR0JfRkFTVF9BUFBST1hJTUFUSU9OXFxuXFx0dmVjMyBiTGVzcyA9IHN0ZXAodmVjMygwLjA0MDQ1KSxzcmdiSW4ueHl6KTtcXG5cXHR2ZWMzIGxpbk91dCA9IG1peCggc3JnYkluLnh5ei92ZWMzKDEyLjkyKSwgcG93KChzcmdiSW4ueHl6K3ZlYzMoMC4wNTUpKS92ZWMzKDEuMDU1KSx2ZWMzKDIuNCkpLCBiTGVzcyApO1xcblxcdCNlbmRpZiAvL1NSR0JfRkFTVF9BUFBST1hJTUFUSU9OXFxuXFx0cmV0dXJuIHZlYzQobGluT3V0LHNyZ2JJbi53KTs7XFxuXFx0I2Vsc2UgLy9NQU5VQUxfU1JHQlxcblxcdHJldHVybiBzcmdiSW47XFxuXFx0I2VuZGlmIC8vTUFOVUFMX1NSR0JcXG59XFxuXFxuXFxudmVjMyBnZXROb3JtYWwoKSB7XFxuXFx0dmVjMyBwb3NfZHggPSBkRmR4KHZQb3NpdGlvbik7XFxuXFx0dmVjMyBwb3NfZHkgPSBkRmR5KHZQb3NpdGlvbik7XFxuXFx0dmVjMyB0ZXhfZHggPSBkRmR4KHZlYzModlRleHR1cmVDb29yZCwgMC4wKSk7XFxuXFx0dmVjMyB0ZXhfZHkgPSBkRmR5KHZlYzModlRleHR1cmVDb29yZCwgMC4wKSk7XFxuXFx0dmVjMyB0ID0gKHRleF9keS50ICogcG9zX2R4IC0gdGV4X2R4LnQgKiBwb3NfZHkpIC8gKHRleF9keC5zICogdGV4X2R5LnQgLSB0ZXhfZHkucyAqIHRleF9keC50KTtcXG5cXG5cXHR2ZWMzIG5nID0gbm9ybWFsaXplKHZOb3JtYWwpO1xcblxcblxcdHQgPSBub3JtYWxpemUodCAtIG5nICogZG90KG5nLCB0KSk7XFxuXFx0dmVjMyBiID0gbm9ybWFsaXplKGNyb3NzKG5nLCB0KSk7XFxuXFx0bWF0MyB0Ym4gPSBtYXQzKHQsIGIsIG5nKTtcXG5cXG4jaWZkZWYgSEFTX05PUk1BTE1BUFxcblxcdHZlYzMgbiA9IHRleHR1cmUyRCh1Tm9ybWFsTWFwLCB2VGV4dHVyZUNvb3JkKS5yZ2I7XFxuXFx0biA9IG5vcm1hbGl6ZSh0Ym4gKiAoKDIuMCAqIG4gLSAxLjApICogdmVjMyh1Tm9ybWFsU2NhbGUsIHVOb3JtYWxTY2FsZSwgMS4wKSkpO1xcbiNlbHNlXFxuXFx0Ly8gVGhlIHRibiBtYXRyaXggaXMgbGluZWFybHkgaW50ZXJwb2xhdGVkLCBzbyB3ZSBuZWVkIHRvIHJlLW5vcm1hbGl6ZVxcblxcdHZlYzMgbiA9IG5vcm1hbGl6ZSh0Ym5bMl0ueHl6KTtcXG4jZW5kaWZcXG5cXG5cXHRyZXR1cm4gbjtcXG59XFxuXFxuXFxudmVjMyBnZXRJQkxDb250cmlidXRpb24oUEJSSW5mbyBwYnJJbnB1dHMsIHZlYzMgbiwgdmVjMyByZWZsZWN0aW9uKVxcbntcXG5cXHRmbG9hdCBtaXBDb3VudCA9IDguMDsgLy8gcmVzb2x1dGlvbiBvZiAxMjh4MTI4XFxuXFx0ZmxvYXQgbG9kID0gKHBicklucHV0cy5wZXJjZXB0dWFsUm91Z2huZXNzICogbWlwQ291bnQpO1xcblxcdC8vIHJldHJpZXZlIGEgc2NhbGUgYW5kIGJpYXMgdG8gRjAuIFNlZSBbMV0sIEZpZ3VyZSAzXFxuXFx0dmVjMyBicmRmID0gU1JHQnRvTElORUFSKHRleHR1cmUyRCh1QlJERk1hcCwgdmVjMihwYnJJbnB1dHMuTmRvdFYsIDEuMCAtIHBicklucHV0cy5wZXJjZXB0dWFsUm91Z2huZXNzKSkpLnJnYjtcXG5cXHR2ZWMzIGRpZmZ1c2VMaWdodCA9IFNSR0J0b0xJTkVBUih0ZXh0dXJlQ3ViZSh1SXJyYWRpYW5jZU1hcCwgbikpLnJnYjtcXG5cXG5cXHR2ZWMzIHNwZWN1bGFyTGlnaHQgPSBTUkdCdG9MSU5FQVIodGV4dHVyZUN1YmVMb2RFWFQodVJhZGlhbmNlTWFwLCByZWZsZWN0aW9uLCBsb2QpKS5yZ2I7XFxuXFxuXFx0dmVjMyBkaWZmdXNlID0gZGlmZnVzZUxpZ2h0ICogcGJySW5wdXRzLmRpZmZ1c2VDb2xvcjtcXG5cXHR2ZWMzIHNwZWN1bGFyID0gc3BlY3VsYXJMaWdodCAqIChwYnJJbnB1dHMuc3BlY3VsYXJDb2xvciAqIGJyZGYueCArIGJyZGYueSk7XFxuXFxuXFx0Ly8gRm9yIHByZXNlbnRhdGlvbiwgdGhpcyBhbGxvd3MgdXMgdG8gZGlzYWJsZSBJQkwgdGVybXNcXG5cXHRkaWZmdXNlICo9IHVTY2FsZUlCTEFtYmllbnQueDtcXG5cXHRzcGVjdWxhciAqPSB1U2NhbGVJQkxBbWJpZW50Lnk7XFxuXFxuXFx0cmV0dXJuIGRpZmZ1c2UgKyBzcGVjdWxhcjtcXG59XFxuXFxuXFxudmVjMyBkaWZmdXNlKFBCUkluZm8gcGJySW5wdXRzKVxcbntcXG5cXHRyZXR1cm4gcGJySW5wdXRzLmRpZmZ1c2VDb2xvciAvIE1fUEk7XFxufVxcblxcblxcbnZlYzMgc3BlY3VsYXJSZWZsZWN0aW9uKFBCUkluZm8gcGJySW5wdXRzKVxcbntcXG5cXHRyZXR1cm4gcGJySW5wdXRzLnJlZmxlY3RhbmNlMCArIChwYnJJbnB1dHMucmVmbGVjdGFuY2U5MCAtIHBicklucHV0cy5yZWZsZWN0YW5jZTApICogcG93KGNsYW1wKDEuMCAtIHBicklucHV0cy5WZG90SCwgMC4wLCAxLjApLCA1LjApO1xcbn1cXG5cXG5mbG9hdCBnZW9tZXRyaWNPY2NsdXNpb24oUEJSSW5mbyBwYnJJbnB1dHMpXFxue1xcblxcdGZsb2F0IE5kb3RMID0gcGJySW5wdXRzLk5kb3RMO1xcblxcdGZsb2F0IE5kb3RWID0gcGJySW5wdXRzLk5kb3RWO1xcblxcdGZsb2F0IHIgPSBwYnJJbnB1dHMuYWxwaGFSb3VnaG5lc3M7XFxuXFxuXFx0ZmxvYXQgYXR0ZW51YXRpb25MID0gMi4wICogTmRvdEwgLyAoTmRvdEwgKyBzcXJ0KHIgKiByICsgKDEuMCAtIHIgKiByKSAqIChOZG90TCAqIE5kb3RMKSkpO1xcblxcdGZsb2F0IGF0dGVudWF0aW9uViA9IDIuMCAqIE5kb3RWIC8gKE5kb3RWICsgc3FydChyICogciArICgxLjAgLSByICogcikgKiAoTmRvdFYgKiBOZG90VikpKTtcXG5cXHRyZXR1cm4gYXR0ZW51YXRpb25MICogYXR0ZW51YXRpb25WO1xcbn1cXG5cXG5cXG5mbG9hdCBtaWNyb2ZhY2V0RGlzdHJpYnV0aW9uKFBCUkluZm8gcGJySW5wdXRzKVxcbntcXG5cXHRmbG9hdCByb3VnaG5lc3NTcSA9IHBicklucHV0cy5hbHBoYVJvdWdobmVzcyAqIHBicklucHV0cy5hbHBoYVJvdWdobmVzcztcXG5cXHRmbG9hdCBmID0gKHBicklucHV0cy5OZG90SCAqIHJvdWdobmVzc1NxIC0gcGJySW5wdXRzLk5kb3RIKSAqIHBicklucHV0cy5OZG90SCArIDEuMDtcXG5cXHRyZXR1cm4gcm91Z2huZXNzU3EgLyAoTV9QSSAqIGYgKiBmKTtcXG59XFxuXFxudm9pZCBtYWluKCkge1xcblxcblxcdGZsb2F0IHBlcmNlcHR1YWxSb3VnaG5lc3MgICA9IHVSb3VnaG5lc3M7XFxuXFx0ZmxvYXQgbWV0YWxsaWMgICAgICAgICAgICAgID0gdU1ldGFsbGljO1xcbiNpZmRlZiBIQVNfTUVUQUxST1VHSE5FU1NNQVBcXG5cXHQvLyBSb3VnaG5lc3MgaXMgc3RvcmVkIGluIHRoZSAnZycgY2hhbm5lbCwgbWV0YWxsaWMgaXMgc3RvcmVkIGluIHRoZSAnYicgY2hhbm5lbC5cXG5cXHQvLyBUaGlzIGxheW91dCBpbnRlbnRpb25hbGx5IHJlc2VydmVzIHRoZSAncicgY2hhbm5lbCBmb3IgKG9wdGlvbmFsKSBvY2NsdXNpb24gbWFwIGRhdGFcXG5cXHR2ZWM0IG1yU2FtcGxlID0gdGV4dHVyZTJEKHVNZXRhbGxpY1JvdWdobmVzc01hcCwgdlRleHR1cmVDb29yZCk7XFxuXFx0cGVyY2VwdHVhbFJvdWdobmVzcyA9IG1yU2FtcGxlLmcgKiBwZXJjZXB0dWFsUm91Z2huZXNzO1xcblxcdG1ldGFsbGljID0gbXJTYW1wbGUuYiAqIG1ldGFsbGljO1xcbiNlbmRpZlxcblxcdHBlcmNlcHR1YWxSb3VnaG5lc3MgICAgICAgICA9IGNsYW1wKHBlcmNlcHR1YWxSb3VnaG5lc3MsIGNfTWluUm91Z2huZXNzLCAxLjApO1xcblxcdG1ldGFsbGljICAgICAgICAgICAgICAgICAgICA9IGNsYW1wKG1ldGFsbGljLCAwLjAsIDEuMCk7XFxuXFx0ZmxvYXQgYWxwaGFSb3VnaG5lc3MgICAgICAgID0gcGVyY2VwdHVhbFJvdWdobmVzcyAqIHBlcmNlcHR1YWxSb3VnaG5lc3M7XFxuXFxuI2lmZGVmIEhBU19CQVNFQ09MT1JNQVBcXHRcXG5cXHR2ZWM0IGJhc2VDb2xvciA9IFNSR0J0b0xJTkVBUih0ZXh0dXJlMkQodUNvbG9yTWFwLCB2VGV4dHVyZUNvb3JkKSk7XFxuI2Vsc2VcXG5cXHR2ZWM0IGJhc2VDb2xvciAgICAgICAgICAgICAgPSB2ZWM0KHVCYXNlQ29sb3IsIDEuMCk7XFxuI2VuZGlmXFx0XFxuXFx0XFxuXFx0dmVjMyBmMCAgICAgICAgICAgICAgICAgICAgID0gdmVjMygwLjA0KTtcXG5cXHR2ZWMzIGRpZmZ1c2VDb2xvciAgICAgICAgICAgPSBiYXNlQ29sb3IucmdiICogKHZlYzMoMS4wKSAtIGYwKTtcXG5cXHRkaWZmdXNlQ29sb3IgICAgICAgICAgICAgICAgKj0gMS4wIC0gbWV0YWxsaWM7XFxuXFx0dmVjMyBzcGVjdWxhckNvbG9yICAgICAgICAgID0gbWl4KGYwLCBiYXNlQ29sb3IucmdiLCBtZXRhbGxpYyk7XFxuXFx0XFxuXFx0Ly8gQ29tcHV0ZSByZWZsZWN0YW5jZS5cXG5cXHRmbG9hdCByZWZsZWN0YW5jZSAgICAgICAgICAgPSBtYXgobWF4KHNwZWN1bGFyQ29sb3Iuciwgc3BlY3VsYXJDb2xvci5nKSwgc3BlY3VsYXJDb2xvci5iKTtcXG5cXHRcXG5cXHQvLyBGb3IgdHlwaWNhbCBpbmNpZGVudCByZWZsZWN0YW5jZSByYW5nZSAoYmV0d2VlbiA0JSB0byAxMDAlKSBzZXQgdGhlIGdyYXppbmcgcmVmbGVjdGFuY2UgdG8gMTAwJSBmb3IgdHlwaWNhbCBmcmVzbmVsIGVmZmVjdC5cXG5cXHQvLyBGb3IgdmVyeSBsb3cgcmVmbGVjdGFuY2UgcmFuZ2Ugb24gaGlnaGx5IGRpZmZ1c2Ugb2JqZWN0cyAoYmVsb3cgNCUpLCBpbmNyZW1lbnRhbGx5IHJlZHVjZSBncmF6aW5nIHJlZmxlY2FuY2UgdG8gMCUuXFxuXFx0ZmxvYXQgcmVmbGVjdGFuY2U5MCAgICAgICAgID0gY2xhbXAocmVmbGVjdGFuY2UgKiAyNS4wLCAwLjAsIDEuMCk7XFxuXFx0dmVjMyBzcGVjdWxhckVudmlyb25tZW50UjAgID0gc3BlY3VsYXJDb2xvci5yZ2I7XFxuXFx0dmVjMyBzcGVjdWxhckVudmlyb25tZW50UjkwID0gdmVjMygxLjAsIDEuMCwgMS4wKSAqIHJlZmxlY3RhbmNlOTA7XFxuXFx0XFxuXFx0dmVjMyBuICAgICAgICAgICAgICAgICAgICAgID0gZ2V0Tm9ybWFsKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3JtYWwgYXQgc3VyZmFjZSBwb2ludFxcblxcdHZlYzMgdiAgICAgICAgICAgICAgICAgICAgICA9IG5vcm1hbGl6ZSh1Q2FtZXJhUG9zIC0gdlBvc2l0aW9uKTsgICAgICAgIC8vIFZlY3RvciBmcm9tIHN1cmZhY2UgcG9pbnQgdG8gY2FtZXJhXFxuXFx0dmVjMyBsICAgICAgICAgICAgICAgICAgICAgID0gbm9ybWFsaXplKHVMaWdodERpcmVjdGlvbik7ICAgICAgICAgICAgIC8vIFZlY3RvciBmcm9tIHN1cmZhY2UgcG9pbnQgdG8gbGlnaHRcXG5cXHR2ZWMzIGggICAgICAgICAgICAgICAgICAgICAgPSBub3JtYWxpemUobCt2KTsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbGYgdmVjdG9yIGJldHdlZW4gYm90aCBsIGFuZCB2XFxuXFx0dmVjMyByZWZsZWN0aW9uICAgICAgICAgICAgID0gLW5vcm1hbGl6ZShyZWZsZWN0KHYsIG4pKTtcXG5cXHRcXG5cXHRmbG9hdCBOZG90TCAgICAgICAgICAgICAgICAgPSBjbGFtcChkb3QobiwgbCksIDAuMDAxLCAxLjApO1xcblxcdGZsb2F0IE5kb3RWICAgICAgICAgICAgICAgICA9IGFicyhkb3QobiwgdikpICsgMC4wMDE7XFxuXFx0ZmxvYXQgTmRvdEggICAgICAgICAgICAgICAgID0gY2xhbXAoZG90KG4sIGgpLCAwLjAsIDEuMCk7XFxuXFx0ZmxvYXQgTGRvdEggICAgICAgICAgICAgICAgID0gY2xhbXAoZG90KGwsIGgpLCAwLjAsIDEuMCk7XFxuXFx0ZmxvYXQgVmRvdEggICAgICAgICAgICAgICAgID0gY2xhbXAoZG90KHYsIGgpLCAwLjAsIDEuMCk7XFxuXFxuXFx0UEJSSW5mbyBwYnJJbnB1dHMgPSBQQlJJbmZvKFxcblxcdFxcdE5kb3RMLFxcblxcdFxcdE5kb3RWLFxcblxcdFxcdE5kb3RILFxcblxcdFxcdExkb3RILFxcblxcdFxcdFZkb3RILFxcblxcdFxcdHBlcmNlcHR1YWxSb3VnaG5lc3MsXFxuXFx0XFx0bWV0YWxsaWMsXFxuXFx0XFx0c3BlY3VsYXJFbnZpcm9ubWVudFIwLFxcblxcdFxcdHNwZWN1bGFyRW52aXJvbm1lbnRSOTAsXFxuXFx0XFx0YWxwaGFSb3VnaG5lc3MsXFxuXFx0XFx0ZGlmZnVzZUNvbG9yLFxcblxcdFxcdHNwZWN1bGFyQ29sb3JcXG5cXHQpO1xcblxcblxcdC8vIENhbGN1bGF0ZSB0aGUgc2hhZGluZyB0ZXJtcyBmb3IgdGhlIG1pY3JvZmFjZXQgc3BlY3VsYXIgc2hhZGluZyBtb2RlbFxcblxcdHZlYzMgRiAgICAgICAgICAgICAgPSBzcGVjdWxhclJlZmxlY3Rpb24ocGJySW5wdXRzKTtcXG5cXHRmbG9hdCBHICAgICAgICAgICAgID0gZ2VvbWV0cmljT2NjbHVzaW9uKHBicklucHV0cyk7XFxuXFx0ZmxvYXQgRCAgICAgICAgICAgICA9IG1pY3JvZmFjZXREaXN0cmlidXRpb24ocGJySW5wdXRzKTtcXG5cXHRcXG5cXHQvLyBDYWxjdWxhdGlvbiBvZiBhbmFseXRpY2FsIGxpZ2h0aW5nIGNvbnRyaWJ1dGlvblxcblxcdHZlYzMgZGlmZnVzZUNvbnRyaWIgPSAoMS4wIC0gRikgKiBkaWZmdXNlKHBicklucHV0cyk7XFxuXFx0dmVjMyBzcGVjQ29udHJpYiAgICA9IEYgKiBHICogRCAvICg0LjAgKiBOZG90TCAqIE5kb3RWKTtcXG5cXHQvLyBPYnRhaW4gZmluYWwgaW50ZW5zaXR5IGFzIHJlZmxlY3RhbmNlIChCUkRGKSBzY2FsZWQgYnkgdGhlIGVuZXJneSBvZiB0aGUgbGlnaHQgKGNvc2luZSBsYXcpXFxuXFx0dmVjMyBjb2xvciAgICAgICAgICA9IE5kb3RMICogdUxpZ2h0Q29sb3IgKiAoZGlmZnVzZUNvbnRyaWIgKyBzcGVjQ29udHJpYik7XFxuXFx0XFxuI2lmZGVmIFVTRV9JQkxcXG5cXHRjb2xvciArPSBnZXRJQkxDb250cmlidXRpb24ocGJySW5wdXRzLCBuLCByZWZsZWN0aW9uKTtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgSEFTX09DQ0xVU0lPTk1BUFxcdFxcblxcdGZsb2F0IGFvICAgICAgICAgICAgPSB0ZXh0dXJlMkQodUFvTWFwLCB2VGV4dHVyZUNvb3JkKS5yO1xcblxcdGNvbG9yICAgICAgICAgICAgICAgPSBtaXgoY29sb3IsIGNvbG9yICogYW8sIHVPY2NsdXNpb25TdHJlbmd0aCk7XFxuI2VuZGlmXFx0XFxuXFxuI2lmZGVmIEhBU19FTUlTU0lWRU1BUFxcblxcdHZlYzMgZW1pc3NpdmUgPSBTUkdCdG9MSU5FQVIodGV4dHVyZTJEKHVFbWlzc2l2ZU1hcCwgdlRleHR1cmVDb29yZCkpLnJnYiAqIHVFbWlzc2l2ZUZhY3RvcjtcXG5cXHRjb2xvciArPSBlbWlzc2l2ZTtcXG4jZW5kaWZcXG5cXHRcXG5cXHQvLyBUaGlzIHNlY3Rpb24gdXNlcyBtaXggdG8gb3ZlcnJpZGUgZmluYWwgY29sb3IgZm9yIHJlZmVyZW5jZSBhcHAgdmlzdWFsaXphdGlvblxcblxcdC8vIG9mIHZhcmlvdXMgcGFyYW1ldGVycyBpbiB0aGUgbGlnaHRpbmcgZXF1YXRpb24uXFxuXFx0Y29sb3IgICAgICAgICAgICAgICA9IG1peChjb2xvciwgRiwgdVNjYWxlRkdEU3BlYy54KTtcXG5cXHRjb2xvciAgICAgICAgICAgICAgID0gbWl4KGNvbG9yLCB2ZWMzKEcpLCB1U2NhbGVGR0RTcGVjLnkpO1xcblxcdGNvbG9yICAgICAgICAgICAgICAgPSBtaXgoY29sb3IsIHZlYzMoRCksIHVTY2FsZUZHRFNwZWMueik7XFxuXFx0Y29sb3IgICAgICAgICAgICAgICA9IG1peChjb2xvciwgc3BlY0NvbnRyaWIsIHVTY2FsZUZHRFNwZWMudyk7XFxuXFx0XFxuXFx0Y29sb3IgICAgICAgICAgICAgICA9IG1peChjb2xvciwgZGlmZnVzZUNvbnRyaWIsIHVTY2FsZURpZmZCYXNlTVIueCk7XFxuXFx0Y29sb3IgICAgICAgICAgICAgICA9IG1peChjb2xvciwgYmFzZUNvbG9yLnJnYiwgdVNjYWxlRGlmZkJhc2VNUi55KTtcXG5cXHRjb2xvciAgICAgICAgICAgICAgID0gbWl4KGNvbG9yLCB2ZWMzKG1ldGFsbGljKSwgdVNjYWxlRGlmZkJhc2VNUi56KTtcXG5cXHRjb2xvciAgICAgICAgICAgICAgID0gbWl4KGNvbG9yLCB2ZWMzKHBlcmNlcHR1YWxSb3VnaG5lc3MpLCB1U2NhbGVEaWZmQmFzZU1SLncpO1xcblxcdFxcblxcdC8vIG91dHB1dCB0aGUgZnJhZ21lbnQgY29sb3JcXG5cXHRnbF9GcmFnQ29sb3IgICAgICAgID0gdmVjNChwb3coY29sb3IsdmVjMygxLjAvdUdhbW1hKSksIGJhc2VDb2xvci5hKTtcXG5cXHQvLyBnbF9GcmFnQ29sb3IgICAgICAgID0gdmVjNCh2VGV4dHVyZUNvb3JkLCAxLjAsIDEuMCk7XFxuXFx0Ly8gZ2xfRnJhZ0NvbG9yICAgICAgICA9IHZlYzQoZ2V0Tm9ybWFsKCksIDEuMCk7XFxuXFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc2hhZGVycy9nbHRmLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDExMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbi8qXG5Db3B5cmlnaHQgKGMpIDIwMTQgUGV0a2EgQW50b25vdlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuKi9cbmZ1bmN0aW9uIFVybCgpIHtcbiAgICAvL0ZvciBtb3JlIGVmZmljaWVudCBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBhbmQgbGF6aW5lc3MuXG4gICAgLy9UaGUgbm9uLXVuZGVyc2NvcmUgdmVyc2lvbnMgb2YgdGhlc2UgcHJvcGVydGllcyBhcmUgYWNjZXNzb3IgZnVuY3Rpb25zXG4gICAgLy9kZWZpbmVkIG9uIHRoZSBwcm90b3R5cGUuXG4gICAgdGhpcy5fcHJvdG9jb2wgPSBudWxsO1xuICAgIHRoaXMuX2hyZWYgPSBcIlwiO1xuICAgIHRoaXMuX3BvcnQgPSAtMTtcbiAgICB0aGlzLl9xdWVyeSA9IG51bGw7XG5cbiAgICB0aGlzLmF1dGggPSBudWxsO1xuICAgIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gICAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgICB0aGlzLmhhc2ggPSBudWxsO1xuICAgIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcblxuICAgIHRoaXMuX3ByZXBlbmRTbGFzaCA9IGZhbHNlO1xufVxuXG52YXIgcXVlcnlzdHJpbmcgPSByZXF1aXJlKFwicXVlcnlzdHJpbmdcIik7XG5cblVybC5xdWVyeVN0cmluZyA9IHF1ZXJ5c3RyaW5nO1xuXG5VcmwucHJvdG90eXBlLnBhcnNlID1cbmZ1bmN0aW9uIFVybCRwYXJzZShzdHIsIHBhcnNlUXVlcnlTdHJpbmcsIGhvc3REZW5vdGVzU2xhc2gsIGRpc2FibGVBdXRvRXNjYXBlQ2hhcnMpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArXG4gICAgICAgICAgICB0eXBlb2Ygc3RyKTtcbiAgICB9XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICB2YXIgZW5kID0gc3RyLmxlbmd0aCAtIDE7XG5cbiAgICAvL1RyaW0gbGVhZGluZyBhbmQgdHJhaWxpbmcgd3NcbiAgICB3aGlsZSAoc3RyLmNoYXJDb2RlQXQoc3RhcnQpIDw9IDB4MjAgLyonICcqLykgc3RhcnQrKztcbiAgICB3aGlsZSAoc3RyLmNoYXJDb2RlQXQoZW5kKSA8PSAweDIwIC8qJyAnKi8pIGVuZC0tO1xuXG4gICAgc3RhcnQgPSB0aGlzLl9wYXJzZVByb3RvY29sKHN0ciwgc3RhcnQsIGVuZCk7XG5cbiAgICAvL0phdmFzY3JpcHQgZG9lc24ndCBoYXZlIGhvc3RcbiAgICBpZiAodGhpcy5fcHJvdG9jb2wgIT09IFwiamF2YXNjcmlwdFwiKSB7XG4gICAgICAgIHN0YXJ0ID0gdGhpcy5fcGFyc2VIb3N0KHN0ciwgc3RhcnQsIGVuZCwgaG9zdERlbm90ZXNTbGFzaCk7XG4gICAgICAgIHZhciBwcm90byA9IHRoaXMuX3Byb3RvY29sO1xuICAgICAgICBpZiAoIXRoaXMuaG9zdG5hbWUgJiZcbiAgICAgICAgICAgICh0aGlzLnNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaFByb3RvY29sc1twcm90b10pKSkge1xuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPD0gZW5kKSB7XG4gICAgICAgIHZhciBjaCA9IHN0ci5jaGFyQ29kZUF0KHN0YXJ0KTtcblxuICAgICAgICBpZiAoY2ggPT09IDB4MkYgLyonLycqLyB8fCBjaCA9PT0gMHg1QyAvKidcXCcqLykge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VQYXRoKHN0ciwgc3RhcnQsIGVuZCwgZGlzYWJsZUF1dG9Fc2NhcGVDaGFycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09IDB4M0YgLyonPycqLykge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VRdWVyeShzdHIsIHN0YXJ0LCBlbmQsIGRpc2FibGVBdXRvRXNjYXBlQ2hhcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAweDIzIC8qJyMnKi8pIHtcbiAgICAgICAgICB0aGlzLl9wYXJzZUhhc2goc3RyLCBzdGFydCwgZW5kLCBkaXNhYmxlQXV0b0VzY2FwZUNoYXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9wcm90b2NvbCAhPT0gXCJqYXZhc2NyaXB0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlUGF0aChzdHIsIHN0YXJ0LCBlbmQsIGRpc2FibGVBdXRvRXNjYXBlQ2hhcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvL0ZvciBqYXZhc2NyaXB0IHRoZSBwYXRobmFtZSBpcyBqdXN0IHRoZSByZXN0IG9mIGl0XG4gICAgICAgICAgICB0aGlzLnBhdGhuYW1lID0gc3RyLnNsaWNlKHN0YXJ0LCBlbmQgKyAxICk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGlmICghdGhpcy5wYXRobmFtZSAmJiB0aGlzLmhvc3RuYW1lICYmXG4gICAgICAgIHRoaXMuX3NsYXNoUHJvdG9jb2xzW3RoaXMuX3Byb3RvY29sXSkge1xuICAgICAgICB0aGlzLnBhdGhuYW1lID0gXCIvXCI7XG4gICAgfVxuXG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoO1xuICAgICAgICBpZiAoc2VhcmNoID09IG51bGwpIHtcbiAgICAgICAgICAgIHNlYXJjaCA9IHRoaXMuc2VhcmNoID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VhcmNoLmNoYXJDb2RlQXQoMCkgPT09IDB4M0YgLyonPycqLykge1xuICAgICAgICAgICAgc2VhcmNoID0gc2VhcmNoLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vVGhpcyBjYWxscyBhIHNldHRlciBmdW5jdGlvbiwgdGhlcmUgaXMgbm8gLnF1ZXJ5IGRhdGEgcHJvcGVydHlcbiAgICAgICAgdGhpcy5xdWVyeSA9IFVybC5xdWVyeVN0cmluZy5wYXJzZShzZWFyY2gpO1xuICAgIH1cbn07XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIFVybCRyZXNvbHZlKHJlbGF0aXZlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdChVcmwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIFVybCRmb3JtYXQoKSB7XG4gICAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgXCJcIjtcblxuICAgIGlmIChhdXRoKSB7XG4gICAgICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCBcIjpcIik7XG4gICAgICAgIGF1dGggKz0gXCJAXCI7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCBcIlwiO1xuICAgIHZhciBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgXCJcIjtcbiAgICB2YXIgaGFzaCA9IHRoaXMuaGFzaCB8fCBcIlwiO1xuICAgIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCBcIlwiO1xuICAgIHZhciBxdWVyeSA9IFwiXCI7XG4gICAgdmFyIGhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCBcIlwiO1xuICAgIHZhciBwb3J0ID0gdGhpcy5wb3J0IHx8IFwiXCI7XG4gICAgdmFyIGhvc3QgPSBmYWxzZTtcbiAgICB2YXIgc2NoZW1lID0gXCJcIjtcblxuICAgIC8vQ2FjaGUgdGhlIHJlc3VsdCBvZiB0aGUgZ2V0dGVyIGZ1bmN0aW9uXG4gICAgdmFyIHEgPSB0aGlzLnF1ZXJ5O1xuICAgIGlmIChxICYmIHR5cGVvZiBxID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHF1ZXJ5ID0gVXJsLnF1ZXJ5U3RyaW5nLnN0cmluZ2lmeShxKTtcbiAgICB9XG5cbiAgICBpZiAoIXNlYXJjaCkge1xuICAgICAgICBzZWFyY2ggPSBxdWVyeSA/IFwiP1wiICsgcXVlcnkgOiBcIlwiO1xuICAgIH1cblxuICAgIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5jaGFyQ29kZUF0KHByb3RvY29sLmxlbmd0aCAtIDEpICE9PSAweDNBIC8qJzonKi8pXG4gICAgICAgIHByb3RvY29sICs9IFwiOlwiO1xuXG4gICAgaWYgKHRoaXMuaG9zdCkge1xuICAgICAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaG9zdG5hbWUpIHtcbiAgICAgICAgdmFyIGlwNiA9IGhvc3RuYW1lLmluZGV4T2YoXCI6XCIpID4gLTE7XG4gICAgICAgIGlmIChpcDYpIGhvc3RuYW1lID0gXCJbXCIgKyBob3N0bmFtZSArIFwiXVwiO1xuICAgICAgICBob3N0ID0gYXV0aCArIGhvc3RuYW1lICsgKHBvcnQgPyBcIjpcIiArIHBvcnQgOiBcIlwiKTtcbiAgICB9XG5cbiAgICB2YXIgc2xhc2hlcyA9IHRoaXMuc2xhc2hlcyB8fFxuICAgICAgICAoKCFwcm90b2NvbCB8fFxuICAgICAgICBzbGFzaFByb3RvY29sc1twcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKTtcblxuXG4gICAgaWYgKHByb3RvY29sKSBzY2hlbWUgPSBwcm90b2NvbCArIChzbGFzaGVzID8gXCIvL1wiIDogXCJcIik7XG4gICAgZWxzZSBpZiAoc2xhc2hlcykgc2NoZW1lID0gXCIvL1wiO1xuXG4gICAgaWYgKHNsYXNoZXMgJiYgcGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckNvZGVBdCgwKSAhPT0gMHgyRiAvKicvJyovKSB7XG4gICAgICAgIHBhdGhuYW1lID0gXCIvXCIgKyBwYXRobmFtZTtcbiAgICB9XG4gICAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckNvZGVBdCgwKSAhPT0gMHgzRiAvKic/JyovKVxuICAgICAgICBzZWFyY2ggPSBcIj9cIiArIHNlYXJjaDtcbiAgICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJDb2RlQXQoMCkgIT09IDB4MjMgLyonIycqLylcbiAgICAgICAgaGFzaCA9IFwiI1wiICsgaGFzaDtcblxuICAgIHBhdGhuYW1lID0gZXNjYXBlUGF0aE5hbWUocGF0aG5hbWUpO1xuICAgIHNlYXJjaCA9IGVzY2FwZVNlYXJjaChzZWFyY2gpO1xuXG4gICAgcmV0dXJuIHNjaGVtZSArIChob3N0ID09PSBmYWxzZSA/IFwiXCIgOiBob3N0KSArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uIFVybCRyZXNvbHZlT2JqZWN0KHJlbGF0aXZlKSB7XG4gICAgaWYgKHR5cGVvZiByZWxhdGl2ZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmVsYXRpdmUgPSBVcmwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcblxuICAgIHZhciByZXN1bHQgPSB0aGlzLl9jbG9uZSgpO1xuXG4gICAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gICAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gICAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gICAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZVwicyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgICBpZiAoIXJlbGF0aXZlLmhyZWYpIHtcbiAgICAgICAgcmVzdWx0Ll9ocmVmID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUuX3Byb3RvY29sKSB7XG4gICAgICAgIHJlbGF0aXZlLl9jb3B5UHJvcHNUbyhyZXN1bHQsIHRydWUpO1xuXG4gICAgICAgIGlmIChzbGFzaFByb3RvY29sc1tyZXN1bHQuX3Byb3RvY29sXSAmJlxuICAgICAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wYXRobmFtZSA9IFwiL1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5faHJlZiA9IFwiXCI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKHJlbGF0aXZlLl9wcm90b2NvbCAmJiByZWxhdGl2ZS5fcHJvdG9jb2wgIT09IHJlc3VsdC5fcHJvdG9jb2wpIHtcbiAgICAgICAgLy8gaWYgaXRcInMgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAgICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgICAgIC8vIGZpcnN0LCBpZiBpdFwicyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAgICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAgICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgICAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgICAgICAvLyBiZWNhdXNlIHRoYXRcInMga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICAgICAgaWYgKCFzbGFzaFByb3RvY29sc1tyZWxhdGl2ZS5fcHJvdG9jb2xdKSB7XG4gICAgICAgICAgICByZWxhdGl2ZS5fY29weVByb3BzVG8ocmVzdWx0LCBmYWxzZSk7XG4gICAgICAgICAgICByZXN1bHQuX2hyZWYgPSBcIlwiO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5fcHJvdG9jb2wgPSByZWxhdGl2ZS5fcHJvdG9jb2w7XG4gICAgICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiByZWxhdGl2ZS5fcHJvdG9jb2wgIT09IFwiamF2YXNjcmlwdFwiKSB7XG4gICAgICAgICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCBcIlwiKS5zcGxpdChcIi9cIik7XG4gICAgICAgICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICAgICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKHJlbFBhdGhbMF0gIT09IFwiXCIpIHJlbFBhdGgudW5zaGlmdChcIlwiKTtcbiAgICAgICAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdChcIlwiKTtcbiAgICAgICAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbihcIi9cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCBcIlwiO1xuICAgICAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIHJlc3VsdC5fcG9ydCA9IHJlbGF0aXZlLl9wb3J0O1xuICAgICAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgICAgIHJlc3VsdC5faHJlZiA9IFwiXCI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIGlzU291cmNlQWJzID1cbiAgICAgICAgKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckNvZGVBdCgwKSA9PT0gMHgyRiAvKicvJyovKTtcbiAgICB2YXIgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgICAocmVsYXRpdmUucGF0aG5hbWUgJiZcbiAgICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJDb2RlQXQoMCkgPT09IDB4MkYgLyonLycqLylcbiAgICAgICAgKTtcbiAgICB2YXIgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSk7XG5cbiAgICB2YXIgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnM7XG5cbiAgICB2YXIgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoXCIvXCIpIHx8IFtdO1xuICAgIHZhciByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoXCIvXCIpIHx8IFtdO1xuICAgIHZhciBwc3ljaG90aWMgPSByZXN1bHQuX3Byb3RvY29sICYmICFzbGFzaFByb3RvY29sc1tyZXN1bHQuX3Byb3RvY29sXTtcblxuICAgIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gICAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAgIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gICAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgICByZXN1bHQuaG9zdG5hbWUgPSBcIlwiO1xuICAgICAgICByZXN1bHQuX3BvcnQgPSAtMTtcbiAgICAgICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICAgICAgICBpZiAoc3JjUGF0aFswXSA9PT0gXCJcIikgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gXCJcIjtcbiAgICAgICAgaWYgKHJlbGF0aXZlLl9wcm90b2NvbCkge1xuICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgcmVsYXRpdmUuX3BvcnQgPSAtMTtcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09IFwiXCIpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICAgICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09IFwiXCIgfHwgc3JjUGF0aFswXSA9PT0gXCJcIik7XG4gICAgfVxuXG4gICAgaWYgKGlzUmVsQWJzKSB7XG4gICAgICAgIC8vIGl0XCJzIGFic29sdXRlLlxuICAgICAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgP1xuICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgICAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSA/XG4gICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICAgICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICAgICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICAgIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAgICAgLy8gaXRcInMgcmVsYXRpdmVcbiAgICAgICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgICAgICBzcmNQYXRoLnBvcCgpO1xuICAgICAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgfSBlbHNlIGlmIChyZWxhdGl2ZS5zZWFyY2gpIHtcbiAgICAgICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgICAgICAvLyBsaWtlIGhyZWY9XCI/Zm9vXCIuXG4gICAgICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgICAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICAgICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgICAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgICAgICAgIC8vdGhpcyBlc3BlY2lhbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAgICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KFwibWFpbHRvOmxvY2FsMUBkb21haW4xXCIsIFwibG9jYWwyQGRvbWFpbjJcIilcbiAgICAgICAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZihcIkBcIikgPiAwID9cbiAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdChcIkBcIikgOiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICAgICAgcmVzdWx0Ll9ocmVmID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAgICAgLy8gd2VcInZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgICAgIHJlc3VsdC5faHJlZiA9IFwiXCI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gICAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gICAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICAgIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCkgJiYgKGxhc3QgPT09IFwiLlwiIHx8IGxhc3QgPT09IFwiLi5cIikgfHxcbiAgICAgICAgbGFzdCA9PT0gXCJcIik7XG5cbiAgICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gICAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgICB2YXIgdXAgPSAwO1xuICAgIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgICAgIGlmIChsYXN0ID09PSBcIi5cIikge1xuICAgICAgICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gXCIuLlwiKSB7XG4gICAgICAgICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHVwKys7XG4gICAgICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgICAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgdXAtLTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICAgICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICAgICAgICBzcmNQYXRoLnVuc2hpZnQoXCIuLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09IFwiXCIgJiZcbiAgICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckNvZGVBdCgwKSAhPT0gMHgyRiAvKicvJyovKSkge1xuICAgICAgICBzcmNQYXRoLnVuc2hpZnQoXCJcIik7XG4gICAgfVxuXG4gICAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbihcIi9cIikuc3Vic3RyKC0xKSAhPT0gXCIvXCIpKSB7XG4gICAgICAgIHNyY1BhdGgucHVzaChcIlwiKTtcbiAgICB9XG5cbiAgICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09IFwiXCIgfHxcbiAgICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQ29kZUF0KDApID09PSAweDJGIC8qJy8nKi8pO1xuXG4gICAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/IFwiXCIgOlxuICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiBcIlwiO1xuICAgICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAgIC8vdGhpcyBlc3BlY2lhbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoXCJtYWlsdG86bG9jYWwxQGRvbWFpbjFcIiwgXCJsb2NhbDJAZG9tYWluMlwiKVxuICAgICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoXCJAXCIpID4gMCA/XG4gICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdChcIkBcIikgOiBmYWxzZTtcbiAgICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gICAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICAgICAgc3JjUGF0aC51bnNoaWZ0KFwiXCIpO1xuICAgIH1cblxuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGgubGVuZ3RoID09PSAwID8gbnVsbCA6IHNyY1BhdGguam9pbihcIi9cIik7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuX2hyZWYgPSBcIlwiO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKFwicHVueWNvZGVcIik7XG5VcmwucHJvdG90eXBlLl9ob3N0SWRuYSA9IGZ1bmN0aW9uIFVybCRfaG9zdElkbmEoaG9zdG5hbWUpIHtcbiAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgcmV0dXJuIHB1bnljb2RlLnRvQVNDSUkoaG9zdG5hbWUpO1xufTtcblxudmFyIGVzY2FwZVBhdGhOYW1lID0gVXJsLnByb3RvdHlwZS5fZXNjYXBlUGF0aE5hbWUgPVxuZnVuY3Rpb24gVXJsJF9lc2NhcGVQYXRoTmFtZShwYXRobmFtZSkge1xuICAgIGlmICghY29udGFpbnNDaGFyYWN0ZXIyKHBhdGhuYW1lLCAweDIzIC8qJyMnKi8sIDB4M0YgLyonPycqLykpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhuYW1lO1xuICAgIH1cbiAgICAvL0F2b2lkIGNsb3N1cmUgY3JlYXRpb24gdG8ga2VlcCB0aGlzIGlubGluYWJsZVxuICAgIHJldHVybiBfZXNjYXBlUGF0aChwYXRobmFtZSk7XG59O1xuXG52YXIgZXNjYXBlU2VhcmNoID0gVXJsLnByb3RvdHlwZS5fZXNjYXBlU2VhcmNoID1cbmZ1bmN0aW9uIFVybCRfZXNjYXBlU2VhcmNoKHNlYXJjaCkge1xuICAgIGlmICghY29udGFpbnNDaGFyYWN0ZXIyKHNlYXJjaCwgMHgyMyAvKicjJyovLCAtMSkpIHJldHVybiBzZWFyY2g7XG4gICAgLy9Bdm9pZCBjbG9zdXJlIGNyZWF0aW9uIHRvIGtlZXAgdGhpcyBpbmxpbmFibGVcbiAgICByZXR1cm4gX2VzY2FwZVNlYXJjaChzZWFyY2gpO1xufTtcblxuVXJsLnByb3RvdHlwZS5fcGFyc2VQcm90b2NvbCA9IGZ1bmN0aW9uIFVybCRfcGFyc2VQcm90b2NvbChzdHIsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgZG9Mb3dlckNhc2UgPSBmYWxzZTtcbiAgICB2YXIgcHJvdG9jb2xDaGFyYWN0ZXJzID0gdGhpcy5fcHJvdG9jb2xDaGFyYWN0ZXJzO1xuXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgKytpKSB7XG4gICAgICAgIHZhciBjaCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmIChjaCA9PT0gMHgzQSAvKic6JyovKSB7XG4gICAgICAgICAgICB2YXIgcHJvdG9jb2wgPSBzdHIuc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgICAgICAgaWYgKGRvTG93ZXJDYXNlKSBwcm90b2NvbCA9IHByb3RvY29sLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB0aGlzLl9wcm90b2NvbCA9IHByb3RvY29sO1xuICAgICAgICAgICAgcmV0dXJuIGkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb3RvY29sQ2hhcmFjdGVyc1tjaF0gPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChjaCA8IDB4NjEgLyonYScqLylcbiAgICAgICAgICAgICAgICBkb0xvd2VyQ2FzZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnQ7XG4gICAgICAgIH1cblxuICAgIH1cbiAgICByZXR1cm4gc3RhcnQ7XG59O1xuXG5VcmwucHJvdG90eXBlLl9wYXJzZUF1dGggPSBmdW5jdGlvbiBVcmwkX3BhcnNlQXV0aChzdHIsIHN0YXJ0LCBlbmQsIGRlY29kZSkge1xuICAgIHZhciBhdXRoID0gc3RyLnNsaWNlKHN0YXJ0LCBlbmQgKyAxKTtcbiAgICBpZiAoZGVjb2RlKSB7XG4gICAgICAgIGF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuICAgIHRoaXMuYXV0aCA9IGF1dGg7XG59O1xuXG5VcmwucHJvdG90eXBlLl9wYXJzZVBvcnQgPSBmdW5jdGlvbiBVcmwkX3BhcnNlUG9ydChzdHIsIHN0YXJ0LCBlbmQpIHtcbiAgICAvL0ludGVybmFsIGZvcm1hdCBpcyBpbnRlZ2VyIGZvciBtb3JlIGVmZmljaWVudCBwYXJzaW5nXG4gICAgLy9hbmQgZm9yIGVmZmljaWVudCB0cmltbWluZyBvZiBsZWFkaW5nIHplcm9zXG4gICAgdmFyIHBvcnQgPSAwO1xuICAgIC8vRGlzdGluZ3Vpc2ggYmV0d2VlbiA6MCBhbmQgOiAobm8gcG9ydCBudW1iZXIgYXQgYWxsKVxuICAgIHZhciBoYWRDaGFycyA9IGZhbHNlO1xuICAgIHZhciB2YWxpZFBvcnQgPSB0cnVlO1xuXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgKytpKSB7XG4gICAgICAgIHZhciBjaCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmICgweDMwIC8qJzAnKi8gPD0gY2ggJiYgY2ggPD0gMHgzOSAvKic5JyovKSB7XG4gICAgICAgICAgICBwb3J0ID0gKDEwICogcG9ydCkgKyAoY2ggLSAweDMwIC8qJzAnKi8pO1xuICAgICAgICAgICAgaGFkQ2hhcnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsaWRQb3J0ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY2ggPT09IDB4NUMvKidcXCcqLyB8fCBjaCA9PT0gMHgyRi8qJy8nKi8pIHtcbiAgICAgICAgICAgICAgICB2YWxpZFBvcnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgIH1cbiAgICBpZiAoKHBvcnQgPT09IDAgJiYgIWhhZENoYXJzKSB8fCAhdmFsaWRQb3J0KSB7XG4gICAgICAgIGlmICghdmFsaWRQb3J0KSB7XG4gICAgICAgICAgICB0aGlzLl9wb3J0ID0gLTI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdGhpcy5fcG9ydCA9IHBvcnQ7XG4gICAgcmV0dXJuIGkgLSBzdGFydDtcbn07XG5cblVybC5wcm90b3R5cGUuX3BhcnNlSG9zdCA9XG5mdW5jdGlvbiBVcmwkX3BhcnNlSG9zdChzdHIsIHN0YXJ0LCBlbmQsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gICAgdmFyIGhvc3RFbmRpbmdDaGFyYWN0ZXJzID0gdGhpcy5faG9zdEVuZGluZ0NoYXJhY3RlcnM7XG4gICAgdmFyIGZpcnN0ID0gc3RyLmNoYXJDb2RlQXQoc3RhcnQpO1xuICAgIHZhciBzZWNvbmQgPSBzdHIuY2hhckNvZGVBdChzdGFydCArIDEpO1xuICAgIGlmICgoZmlyc3QgPT09IDB4MkYgLyonLycqLyB8fCBmaXJzdCA9PT0gMHg1QyAvKidcXCcqLykgJiZcbiAgICAgICAgKHNlY29uZCA9PT0gMHgyRiAvKicvJyovIHx8IHNlY29uZCA9PT0gMHg1QyAvKidcXCcqLykpIHtcbiAgICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcblxuICAgICAgICAvL1RoZSBzdHJpbmcgc3RhcnRzIHdpdGggLy9cbiAgICAgICAgaWYgKHN0YXJ0ID09PSAwKSB7XG4gICAgICAgICAgICAvL1RoZSBzdHJpbmcgaXMganVzdCBcIi8vXCJcbiAgICAgICAgICAgIGlmIChlbmQgPCAyKSByZXR1cm4gc3RhcnQ7XG4gICAgICAgICAgICAvL0lmIHNsYXNoZXMgZG8gbm90IGRlbm90ZSBob3N0IGFuZCB0aGVyZSBpcyBubyBhdXRoLFxuICAgICAgICAgICAgLy90aGVyZSBpcyBubyBob3N0IHdoZW4gdGhlIHN0cmluZyBzdGFydHMgd2l0aCAvL1xuICAgICAgICAgICAgdmFyIGhhc0F1dGggPVxuICAgICAgICAgICAgICAgIGNvbnRhaW5zQ2hhcmFjdGVyKHN0ciwgMHg0MCAvKidAJyovLCAyLCBob3N0RW5kaW5nQ2hhcmFjdGVycyk7XG4gICAgICAgICAgICBpZiAoIWhhc0F1dGggJiYgIXNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9UaGVyZSBpcyBhIGhvc3QgdGhhdCBzdGFydHMgYWZ0ZXIgdGhlIC8vXG4gICAgICAgIHN0YXJ0ICs9IDI7XG4gICAgfVxuICAgIC8vSWYgdGhlcmUgaXMgbm8gc2xhc2hlcywgdGhlcmUgaXMgbm8gaG9zdG5hbWUgaWZcbiAgICAvLzEuIHRoZXJlIHdhcyBubyBwcm90b2NvbCBhdCBhbGxcbiAgICBlbHNlIGlmICghdGhpcy5fcHJvdG9jb2wgfHxcbiAgICAgICAgLy8yLiB0aGVyZSB3YXMgYSBwcm90b2NvbCB0aGF0IHJlcXVpcmVzIHNsYXNoZXNcbiAgICAgICAgLy9lLmcuIGluICdodHRwOmFzZCcgJ2FzZCcgaXMgbm90IGEgaG9zdG5hbWVcbiAgICAgICAgc2xhc2hQcm90b2NvbHNbdGhpcy5fcHJvdG9jb2xdXG4gICAgKSB7XG4gICAgICAgIHJldHVybiBzdGFydDtcbiAgICB9XG5cbiAgICB2YXIgZG9Mb3dlckNhc2UgPSBmYWxzZTtcbiAgICB2YXIgaWRuYSA9IGZhbHNlO1xuICAgIHZhciBob3N0TmFtZVN0YXJ0ID0gc3RhcnQ7XG4gICAgdmFyIGhvc3ROYW1lRW5kID0gZW5kO1xuICAgIHZhciBsYXN0Q2ggPSAtMTtcbiAgICB2YXIgcG9ydExlbmd0aCA9IDA7XG4gICAgdmFyIGNoYXJzQWZ0ZXJEb3QgPSAwO1xuICAgIHZhciBhdXRoTmVlZHNEZWNvZGluZyA9IGZhbHNlO1xuXG4gICAgdmFyIGogPSAtMTtcblxuICAgIC8vRmluZCB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIGFuIEAtc2lnbiB1bnRpbCBob3N0ZW5kaW5nIGNoYXJhY3RlciBpcyBtZXRcbiAgICAvL2Fsc28gbWFyayBpZiBkZWNvZGluZyBpcyBuZWVkZWQgZm9yIHRoZSBhdXRoIHBvcnRpb25cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgaWYgKGNoID09PSAweDQwIC8qJ0AnKi8pIHtcbiAgICAgICAgICAgIGogPSBpO1xuICAgICAgICB9XG4gICAgICAgIC8vVGhpcyBjaGVjayBpcyB2ZXJ5LCB2ZXJ5IGNoZWFwLiBVbm5lZWRlZCBkZWNvZGVVUklDb21wb25lbnQgaXMgdmVyeVxuICAgICAgICAvL3ZlcnkgZXhwZW5zaXZlXG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAweDI1IC8qJyUnKi8pIHtcbiAgICAgICAgICAgIGF1dGhOZWVkc0RlY29kaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChob3N0RW5kaW5nQ2hhcmFjdGVyc1tjaF0gPT09IDEpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9ALXNpZ24gd2FzIGZvdW5kIGF0IGluZGV4IGosIGV2ZXJ5dGhpbmcgdG8gdGhlIGxlZnQgZnJvbSBpdFxuICAgIC8vaXMgYXV0aCBwYXJ0XG4gICAgaWYgKGogPiAtMSkge1xuICAgICAgICB0aGlzLl9wYXJzZUF1dGgoc3RyLCBzdGFydCwgaiAtIDEsIGF1dGhOZWVkc0RlY29kaW5nKTtcbiAgICAgICAgLy9ob3N0bmFtZSBzdGFydHMgYWZ0ZXIgdGhlIGxhc3QgQC1zaWduXG4gICAgICAgIHN0YXJ0ID0gaG9zdE5hbWVTdGFydCA9IGogKyAxO1xuICAgIH1cblxuICAgIC8vSG9zdCBuYW1lIGlzIHN0YXJ0aW5nIHdpdGggYSBbXG4gICAgaWYgKHN0ci5jaGFyQ29kZUF0KHN0YXJ0KSA9PT0gMHg1QiAvKidbJyovKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydCArIDE7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjaCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICAgICAvL0Fzc3VtZSB2YWxpZCBJUDYgaXMgYmV0d2VlbiB0aGUgYnJhY2tldHNcbiAgICAgICAgICAgIGlmIChjaCA9PT0gMHg1RCAvKiddJyovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0ci5jaGFyQ29kZUF0KGkgKyAxKSA9PT0gMHgzQSAvKic6JyovKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcnRMZW5ndGggPSB0aGlzLl9wYXJzZVBvcnQoc3RyLCBpICsgMiwgZW5kKSArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBob3N0bmFtZSA9IHN0ci5zbGljZShzdGFydCArIDEsIGkpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IGhvc3RuYW1lO1xuICAgICAgICAgICAgICAgIHRoaXMuaG9zdCA9IHRoaXMuX3BvcnQgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgXCJbXCIgKyBob3N0bmFtZSArIFwiXTpcIiArIHRoaXMuX3BvcnQgOlxuICAgICAgICAgICAgICAgICAgICBcIltcIiArIGhvc3RuYW1lICsgXCJdXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRobmFtZSA9IFwiL1wiO1xuICAgICAgICAgICAgICAgIHJldHVybiBpICsgcG9ydExlbmd0aCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9FbXB0eSBob3N0bmFtZSwgWyBzdGFydHMgYSBwYXRoXG4gICAgICAgIHJldHVybiBzdGFydDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgaWYgKGNoYXJzQWZ0ZXJEb3QgPiA2Mikge1xuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdCA9IHN0ci5zbGljZShzdGFydCwgaSk7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2ggPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoY2ggPT09IDB4M0EgLyonOicqLykge1xuICAgICAgICAgICAgcG9ydExlbmd0aCA9IHRoaXMuX3BhcnNlUG9ydChzdHIsIGkgKyAxLCBlbmQpICsgMTtcbiAgICAgICAgICAgIGhvc3ROYW1lRW5kID0gaSAtIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA8IDB4NjEgLyonYScqLykge1xuICAgICAgICAgICAgaWYgKGNoID09PSAweDJFIC8qJy4nKi8pIHtcbiAgICAgICAgICAgICAgICAvL05vZGUuanMgaWdub3JlcyB0aGlzIGVycm9yXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICBpZiAobGFzdENoID09PSBET1QgfHwgbGFzdENoID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNoYXJzQWZ0ZXJEb3QgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKDB4NDEgLyonQScqLyA8PSBjaCAmJiBjaCA8PSAweDVBIC8qJ1onKi8pIHtcbiAgICAgICAgICAgICAgICBkb0xvd2VyQ2FzZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL1ZhbGlkIGNoYXJhY3RlcnMgb3RoZXIgdGhhbiBBU0NJSSBsZXR0ZXJzIC0sIF8sICssIDAtOVxuICAgICAgICAgICAgZWxzZSBpZiAoIShjaCA9PT0gMHgyRCAvKictJyovIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIGNoID09PSAweDVGIC8qJ18nKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgY2ggPT09IDB4MkIgLyonKycqLyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAoMHgzMCAvKicwJyovIDw9IGNoICYmIGNoIDw9IDB4MzkgLyonOScqLykpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhvc3RFbmRpbmdDaGFyYWN0ZXJzW2NoXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ub1ByZXBlbmRTbGFzaEhvc3RFbmRlcnNbY2hdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByZXBlbmRTbGFzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhvc3ROYW1lRW5kID0gaSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPj0gMHg3QiAvKid7JyovKSB7XG4gICAgICAgICAgICBpZiAoY2ggPD0gMHg3RSAvKid+JyovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX25vUHJlcGVuZFNsYXNoSG9zdEVuZGVyc1tjaF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJlcGVuZFNsYXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaG9zdE5hbWVFbmQgPSBpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkbmEgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RDaCA9IGNoO1xuICAgICAgICBjaGFyc0FmdGVyRG90Kys7XG4gICAgfVxuXG4gICAgLy9Ob2RlLmpzIGlnbm9yZXMgdGhpcyBlcnJvclxuICAgIC8qXG4gICAgaWYgKGxhc3RDaCA9PT0gRE9UKSB7XG4gICAgICAgIGhvc3ROYW1lRW5kLS07XG4gICAgfVxuICAgICovXG5cbiAgICBpZiAoaG9zdE5hbWVFbmQgKyAxICE9PSBzdGFydCAmJlxuICAgICAgICBob3N0TmFtZUVuZCAtIGhvc3ROYW1lU3RhcnQgPD0gMjU2KSB7XG4gICAgICAgIHZhciBob3N0bmFtZSA9IHN0ci5zbGljZShob3N0TmFtZVN0YXJ0LCBob3N0TmFtZUVuZCArIDEpO1xuICAgICAgICBpZiAoZG9Mb3dlckNhc2UpIGhvc3RuYW1lID0gaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGlkbmEpIGhvc3RuYW1lID0gdGhpcy5faG9zdElkbmEoaG9zdG5hbWUpO1xuICAgICAgICB0aGlzLmhvc3RuYW1lID0gaG9zdG5hbWU7XG4gICAgICAgIHRoaXMuaG9zdCA9IHRoaXMuX3BvcnQgPiAwID8gaG9zdG5hbWUgKyBcIjpcIiArIHRoaXMuX3BvcnQgOiBob3N0bmFtZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaG9zdE5hbWVFbmQgKyAxICsgcG9ydExlbmd0aDtcblxufTtcblxuVXJsLnByb3RvdHlwZS5fY29weVByb3BzVG8gPSBmdW5jdGlvbiBVcmwkX2NvcHlQcm9wc1RvKGlucHV0LCBub1Byb3RvY29sKSB7XG4gICAgaWYgKCFub1Byb3RvY29sKSB7XG4gICAgICAgIGlucHV0Ll9wcm90b2NvbCA9IHRoaXMuX3Byb3RvY29sO1xuICAgIH1cbiAgICBpbnB1dC5faHJlZiA9IHRoaXMuX2hyZWY7XG4gICAgaW5wdXQuX3BvcnQgPSB0aGlzLl9wb3J0O1xuICAgIGlucHV0Ll9wcmVwZW5kU2xhc2ggPSB0aGlzLl9wcmVwZW5kU2xhc2g7XG4gICAgaW5wdXQuYXV0aCA9IHRoaXMuYXV0aDtcbiAgICBpbnB1dC5zbGFzaGVzID0gdGhpcy5zbGFzaGVzO1xuICAgIGlucHV0Lmhvc3QgPSB0aGlzLmhvc3Q7XG4gICAgaW5wdXQuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lO1xuICAgIGlucHV0Lmhhc2ggPSB0aGlzLmhhc2g7XG4gICAgaW5wdXQuc2VhcmNoID0gdGhpcy5zZWFyY2g7XG4gICAgaW5wdXQucGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lO1xufTtcblxuVXJsLnByb3RvdHlwZS5fY2xvbmUgPSBmdW5jdGlvbiBVcmwkX2Nsb25lKCkge1xuICAgIHZhciByZXQgPSBuZXcgVXJsKCk7XG4gICAgcmV0Ll9wcm90b2NvbCA9IHRoaXMuX3Byb3RvY29sO1xuICAgIHJldC5faHJlZiA9IHRoaXMuX2hyZWY7XG4gICAgcmV0Ll9wb3J0ID0gdGhpcy5fcG9ydDtcbiAgICByZXQuX3ByZXBlbmRTbGFzaCA9IHRoaXMuX3ByZXBlbmRTbGFzaDtcbiAgICByZXQuYXV0aCA9IHRoaXMuYXV0aDtcbiAgICByZXQuc2xhc2hlcyA9IHRoaXMuc2xhc2hlcztcbiAgICByZXQuaG9zdCA9IHRoaXMuaG9zdDtcbiAgICByZXQuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lO1xuICAgIHJldC5oYXNoID0gdGhpcy5oYXNoO1xuICAgIHJldC5zZWFyY2ggPSB0aGlzLnNlYXJjaDtcbiAgICByZXQucGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5VcmwucHJvdG90eXBlLl9nZXRDb21wb25lbnRFc2NhcGVkID1cbmZ1bmN0aW9uIFVybCRfZ2V0Q29tcG9uZW50RXNjYXBlZChzdHIsIHN0YXJ0LCBlbmQsIGlzQWZ0ZXJRdWVyeSkge1xuICAgIHZhciBjdXIgPSBzdGFydDtcbiAgICB2YXIgaSA9IHN0YXJ0O1xuICAgIHZhciByZXQgPSBcIlwiO1xuICAgIHZhciBhdXRvRXNjYXBlTWFwID0gaXNBZnRlclF1ZXJ5ID9cbiAgICAgICAgdGhpcy5fYWZ0ZXJRdWVyeUF1dG9Fc2NhcGVNYXAgOiB0aGlzLl9hdXRvRXNjYXBlTWFwO1xuICAgIGZvciAoOyBpIDw9IGVuZDsgKytpKSB7XG4gICAgICAgIHZhciBjaCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgZXNjYXBlZCA9IGF1dG9Fc2NhcGVNYXBbY2hdO1xuXG4gICAgICAgIGlmIChlc2NhcGVkICE9PSBcIlwiICYmIGVzY2FwZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGN1ciA8IGkpIHJldCArPSBzdHIuc2xpY2UoY3VyLCBpKTtcbiAgICAgICAgICAgIHJldCArPSBlc2NhcGVkO1xuICAgICAgICAgICAgY3VyID0gaSArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGN1ciA8IGkgKyAxKSByZXQgKz0gc3RyLnNsaWNlKGN1ciwgaSk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblVybC5wcm90b3R5cGUuX3BhcnNlUGF0aCA9XG5mdW5jdGlvbiBVcmwkX3BhcnNlUGF0aChzdHIsIHN0YXJ0LCBlbmQsIGRpc2FibGVBdXRvRXNjYXBlQ2hhcnMpIHtcbiAgICB2YXIgcGF0aFN0YXJ0ID0gc3RhcnQ7XG4gICAgdmFyIHBhdGhFbmQgPSBlbmQ7XG4gICAgdmFyIGVzY2FwZSA9IGZhbHNlO1xuICAgIHZhciBhdXRvRXNjYXBlQ2hhcmFjdGVycyA9IHRoaXMuX2F1dG9Fc2NhcGVDaGFyYWN0ZXJzO1xuICAgIHZhciBwcmVQYXRoID0gdGhpcy5fcG9ydCA9PT0gLTIgPyBcIi86XCIgOiBcIlwiO1xuXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgKytpKSB7XG4gICAgICAgIHZhciBjaCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2ggPT09IDB4MjMgLyonIycqLykge1xuICAgICAgICAgIHRoaXMuX3BhcnNlSGFzaChzdHIsIGksIGVuZCwgZGlzYWJsZUF1dG9Fc2NhcGVDaGFycyk7XG4gICAgICAgICAgICBwYXRoRW5kID0gaSAtIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gMHgzRiAvKic/JyovKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZVF1ZXJ5KHN0ciwgaSwgZW5kLCBkaXNhYmxlQXV0b0VzY2FwZUNoYXJzKTtcbiAgICAgICAgICAgIHBhdGhFbmQgPSBpIC0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFkaXNhYmxlQXV0b0VzY2FwZUNoYXJzICYmICFlc2NhcGUgJiYgYXV0b0VzY2FwZUNoYXJhY3RlcnNbY2hdID09PSAxKSB7XG4gICAgICAgICAgICBlc2NhcGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhdGhTdGFydCA+IHBhdGhFbmQpIHtcbiAgICAgICAgdGhpcy5wYXRobmFtZSA9IHByZVBhdGggPT09IFwiXCIgPyBcIi9cIiA6IHByZVBhdGg7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGF0aDtcbiAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgIHBhdGggPSB0aGlzLl9nZXRDb21wb25lbnRFc2NhcGVkKHN0ciwgcGF0aFN0YXJ0LCBwYXRoRW5kLCBmYWxzZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwYXRoID0gc3RyLnNsaWNlKHBhdGhTdGFydCwgcGF0aEVuZCArIDEpO1xuICAgIH1cbiAgICB0aGlzLnBhdGhuYW1lID0gcHJlUGF0aCA9PT0gXCJcIlxuICAgICAgICA/ICh0aGlzLl9wcmVwZW5kU2xhc2ggPyBcIi9cIiArIHBhdGggOiBwYXRoKVxuICAgICAgICA6IHByZVBhdGggKyBwYXRoO1xufTtcblxuVXJsLnByb3RvdHlwZS5fcGFyc2VRdWVyeSA9IGZ1bmN0aW9uIFVybCRfcGFyc2VRdWVyeShzdHIsIHN0YXJ0LCBlbmQsIGRpc2FibGVBdXRvRXNjYXBlQ2hhcnMpIHtcbiAgICB2YXIgcXVlcnlTdGFydCA9IHN0YXJ0O1xuICAgIHZhciBxdWVyeUVuZCA9IGVuZDtcbiAgICB2YXIgZXNjYXBlID0gZmFsc2U7XG4gICAgdmFyIGF1dG9Fc2NhcGVDaGFyYWN0ZXJzID0gdGhpcy5fYXV0b0VzY2FwZUNoYXJhY3RlcnM7XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgaWYgKGNoID09PSAweDIzIC8qJyMnKi8pIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlSGFzaChzdHIsIGksIGVuZCwgZGlzYWJsZUF1dG9Fc2NhcGVDaGFycyk7XG4gICAgICAgICAgICBxdWVyeUVuZCA9IGkgLSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWRpc2FibGVBdXRvRXNjYXBlQ2hhcnMgJiYgIWVzY2FwZSAmJiBhdXRvRXNjYXBlQ2hhcmFjdGVyc1tjaF0gPT09IDEpIHtcbiAgICAgICAgICAgIGVzY2FwZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocXVlcnlTdGFydCA+IHF1ZXJ5RW5kKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gXCJcIjtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBxdWVyeTtcbiAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgIHF1ZXJ5ID0gdGhpcy5fZ2V0Q29tcG9uZW50RXNjYXBlZChzdHIsIHF1ZXJ5U3RhcnQsIHF1ZXJ5RW5kLCB0cnVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHF1ZXJ5ID0gc3RyLnNsaWNlKHF1ZXJ5U3RhcnQsIHF1ZXJ5RW5kICsgMSk7XG4gICAgfVxuICAgIHRoaXMuc2VhcmNoID0gcXVlcnk7XG59O1xuXG5VcmwucHJvdG90eXBlLl9wYXJzZUhhc2ggPSBmdW5jdGlvbiBVcmwkX3BhcnNlSGFzaChzdHIsIHN0YXJ0LCBlbmQsIGRpc2FibGVBdXRvRXNjYXBlQ2hhcnMpIHtcbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgICAgdGhpcy5oYXNoID0gXCJcIjtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaGFzaCA9IGRpc2FibGVBdXRvRXNjYXBlQ2hhcnMgP1xuICAgICAgICBzdHIuc2xpY2Uoc3RhcnQsIGVuZCArIDEpIDogdGhpcy5fZ2V0Q29tcG9uZW50RXNjYXBlZChzdHIsIHN0YXJ0LCBlbmQsIHRydWUpO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFVybC5wcm90b3R5cGUsIFwicG9ydFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BvcnQgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIChcIlwiICsgdGhpcy5fcG9ydCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcG9ydCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcG9ydCA9IHBhcnNlSW50KHYsIDEwKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVXJsLnByb3RvdHlwZSwgXCJxdWVyeVwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy5fcXVlcnk7XG4gICAgICAgIGlmIChxdWVyeSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoO1xuXG4gICAgICAgIGlmIChzZWFyY2gpIHtcbiAgICAgICAgICAgIGlmIChzZWFyY2guY2hhckNvZGVBdCgwKSA9PT0gMHgzRiAvKic/JyovKSB7XG4gICAgICAgICAgICAgICAgc2VhcmNoID0gc2VhcmNoLnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlYXJjaCAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXJ5ID0gc2VhcmNoO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWFyY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlYXJjaDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICB0aGlzLl9xdWVyeSA9IHY7XG4gICAgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShVcmwucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCBcIlwiO1xuICAgICAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8IFwiXCI7XG4gICAgICAgIGlmIChwIHx8IHMpIHtcbiAgICAgICAgICAgIHJldHVybiBwICsgcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHAgPT0gbnVsbCAmJiBzKSA/IChcIi9cIiArIHMpIDogbnVsbDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oKSB7fVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShVcmwucHJvdG90eXBlLCBcInByb3RvY29sXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcHJvdG8gPSB0aGlzLl9wcm90b2NvbDtcbiAgICAgICAgcmV0dXJuIHByb3RvID8gcHJvdG8gKyBcIjpcIiA6IHByb3RvO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdmFyIGVuZCA9IHYubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmICh2LmNoYXJDb2RlQXQoZW5kKSA9PT0gMHgzQSAvKic6JyovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvdG9jb2wgPSB2LnNsaWNlKDAsIGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm90b2NvbCA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm90b2NvbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFVybC5wcm90b3R5cGUsIFwiaHJlZlwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhyZWYgPSB0aGlzLl9ocmVmO1xuICAgICAgICBpZiAoIWhyZWYpIHtcbiAgICAgICAgICAgIGhyZWYgPSB0aGlzLl9ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHJlZjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICB0aGlzLl9ocmVmID0gdjtcbiAgICB9XG59KTtcblxuVXJsLnBhcnNlID0gZnVuY3Rpb24gVXJsJFBhcnNlKHN0ciwgcGFyc2VRdWVyeVN0cmluZywgaG9zdERlbm90ZXNTbGFzaCwgZGlzYWJsZUF1dG9Fc2NhcGVDaGFycykge1xuICAgIGlmIChzdHIgaW5zdGFuY2VvZiBVcmwpIHJldHVybiBzdHI7XG4gICAgdmFyIHJldCA9IG5ldyBVcmwoKTtcbiAgICByZXQucGFyc2Uoc3RyLCAhIXBhcnNlUXVlcnlTdHJpbmcsICEhaG9zdERlbm90ZXNTbGFzaCwgISFkaXNhYmxlQXV0b0VzY2FwZUNoYXJzKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuVXJsLmZvcm1hdCA9IGZ1bmN0aW9uIFVybCRGb3JtYXQob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgb2JqID0gVXJsLnBhcnNlKG9iaik7XG4gICAgfVxuICAgIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHtcbiAgICAgICAgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn07XG5cblVybC5yZXNvbHZlID0gZnVuY3Rpb24gVXJsJFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICAgIHJldHVybiBVcmwucGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59O1xuXG5VcmwucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uIFVybCRSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICAgIHJldHVybiBVcmwucGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59O1xuXG5mdW5jdGlvbiBfZXNjYXBlUGF0aChwYXRobmFtZSkge1xuICAgIHJldHVybiBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBfZXNjYXBlU2VhcmNoKHNlYXJjaCkge1xuICAgIHJldHVybiBzZWFyY2gucmVwbGFjZSgvIy9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgICB9KTtcbn1cblxuLy9TZWFyY2ggYGNoYXIxYCAoaW50ZWdlciBjb2RlIGZvciBhIGNoYXJhY3RlcikgaW4gYHN0cmluZ2Bcbi8vc3RhcnRpbmcgZnJvbSBgZnJvbUluZGV4YCBhbmQgZW5kaW5nIGF0IGBzdHJpbmcubGVuZ3RoIC0gMWBcbi8vb3Igd2hlbiBhIHN0b3AgY2hhcmFjdGVyIGlzIGZvdW5kXG5mdW5jdGlvbiBjb250YWluc0NoYXJhY3RlcihzdHJpbmcsIGNoYXIxLCBmcm9tSW5kZXgsIHN0b3BDaGFyYWN0ZXJUYWJsZSkge1xuICAgIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSBmcm9tSW5kZXg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgY2ggPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoY2ggPT09IGNoYXIxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdG9wQ2hhcmFjdGVyVGFibGVbY2hdID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vL1NlZSBpZiBgY2hhcjFgIG9yIGBjaGFyMmAgKGludGVnZXIgY29kZXMgZm9yIGNoYXJhY3RlcnMpXG4vL2lzIGNvbnRhaW5lZCBpbiBgc3RyaW5nYFxuZnVuY3Rpb24gY29udGFpbnNDaGFyYWN0ZXIyKHN0cmluZywgY2hhcjEsIGNoYXIyKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgY2ggPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNoID09PSBjaGFyMSB8fCBjaCA9PT0gY2hhcjIpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vTWFrZXMgYW4gYXJyYXkgb2YgMTI4IHVpbnQ4J3Mgd2hpY2ggcmVwcmVzZW50IGJvb2xlYW4gdmFsdWVzLlxuLy9TcGVjIGlzIGFuIGFycmF5IG9mIGFzY2lpIGNvZGUgcG9pbnRzIG9yIGFzY2lpIGNvZGUgcG9pbnQgcmFuZ2VzXG4vL3JhbmdlcyBhcmUgZXhwcmVzc2VkIGFzIFtzdGFydCwgZW5kXVxuXG4vL0NyZWF0ZSBhIHRhYmxlIHdpdGggdGhlIGNoYXJhY3RlcnMgMHgzMC0weDM5IChkZWNpbWFscyAnMCcgLSAnOScpIGFuZFxuLy8weDdBIChsb3dlcmNhc2VsZXR0ZXIgJ3onKSBhcyBgdHJ1ZWA6XG4vL1xuLy92YXIgYSA9IG1ha2VBc2NpaVRhYmxlKFtbMHgzMCwgMHgzOV0sIDB4N0FdKTtcbi8vYVsweDMwXTsgLy8xXG4vL2FbMHgxNV07IC8vMFxuLy9hWzB4MzVdOyAvLzFcbmZ1bmN0aW9uIG1ha2VBc2NpaVRhYmxlKHNwZWMpIHtcbiAgICB2YXIgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoMTI4KTtcbiAgICBzcGVjLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0W2l0ZW1dID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGl0ZW1bMF07XG4gICAgICAgICAgICB2YXIgZW5kID0gaXRlbVsxXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBzdGFydDsgaiA8PSBlbmQ7ICsraikge1xuICAgICAgICAgICAgICAgIHJldFtqXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXQ7XG59XG5cblxudmFyIGF1dG9Fc2NhcGUgPSBbXCI8XCIsIFwiPlwiLCBcIlxcXCJcIiwgXCJgXCIsIFwiIFwiLCBcIlxcclwiLCBcIlxcblwiLFxuICAgIFwiXFx0XCIsIFwie1wiLCBcIn1cIiwgXCJ8XCIsIFwiXFxcXFwiLCBcIl5cIiwgXCJgXCIsIFwiJ1wiXTtcblxudmFyIGF1dG9Fc2NhcGVNYXAgPSBuZXcgQXJyYXkoMTI4KTtcblxuXG5cbmZvciAodmFyIGkgPSAwLCBsZW4gPSBhdXRvRXNjYXBlTWFwLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgYXV0b0VzY2FwZU1hcFtpXSA9IFwiXCI7XG59XG5cbmZvciAodmFyIGkgPSAwLCBsZW4gPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIGMgPSBhdXRvRXNjYXBlW2ldO1xuICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYyk7XG4gICAgaWYgKGVzYyA9PT0gYykge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYyk7XG4gICAgfVxuICAgIGF1dG9Fc2NhcGVNYXBbYy5jaGFyQ29kZUF0KDApXSA9IGVzYztcbn1cbnZhciBhZnRlclF1ZXJ5QXV0b0VzY2FwZU1hcCA9IGF1dG9Fc2NhcGVNYXAuc2xpY2UoKTtcbmF1dG9Fc2NhcGVNYXBbMHg1QyAvKidcXCcqL10gPSBcIi9cIjtcblxudmFyIHNsYXNoUHJvdG9jb2xzID0gVXJsLnByb3RvdHlwZS5fc2xhc2hQcm90b2NvbHMgPSB7XG4gICAgaHR0cDogdHJ1ZSxcbiAgICBodHRwczogdHJ1ZSxcbiAgICBnb3BoZXI6IHRydWUsXG4gICAgZmlsZTogdHJ1ZSxcbiAgICBmdHA6IHRydWUsXG5cbiAgICBcImh0dHA6XCI6IHRydWUsXG4gICAgXCJodHRwczpcIjogdHJ1ZSxcbiAgICBcImdvcGhlcjpcIjogdHJ1ZSxcbiAgICBcImZpbGU6XCI6IHRydWUsXG4gICAgXCJmdHA6XCI6IHRydWVcbn07XG5cbi8vT3B0aW1pemUgYmFjayBmcm9tIG5vcm1hbGl6ZWQgb2JqZWN0IGNhdXNlZCBieSBub24taWRlbnRpZmllciBrZXlzXG5mdW5jdGlvbiBmKCl7fVxuZi5wcm90b3R5cGUgPSBzbGFzaFByb3RvY29scztcblxuVXJsLnByb3RvdHlwZS5fcHJvdG9jb2xDaGFyYWN0ZXJzID0gbWFrZUFzY2lpVGFibGUoW1xuICAgIFsweDYxIC8qJ2EnKi8sIDB4N0EgLyoneicqL10sXG4gICAgWzB4NDEgLyonQScqLywgMHg1QSAvKidaJyovXSxcbiAgICAweDJFIC8qJy4nKi8sIDB4MkIgLyonKycqLywgMHgyRCAvKictJyovXG5dKTtcblxuVXJsLnByb3RvdHlwZS5faG9zdEVuZGluZ0NoYXJhY3RlcnMgPSBtYWtlQXNjaWlUYWJsZShbXG4gICAgMHgyMyAvKicjJyovLCAweDNGIC8qJz8nKi8sIDB4MkYgLyonLycqLywgMHg1QyAvKidcXCcqL1xuXSk7XG5cblVybC5wcm90b3R5cGUuX2F1dG9Fc2NhcGVDaGFyYWN0ZXJzID0gbWFrZUFzY2lpVGFibGUoXG4gICAgYXV0b0VzY2FwZS5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gdi5jaGFyQ29kZUF0KDApO1xuICAgIH0pXG4pO1xuXG4vL0lmIHRoZXNlIGNoYXJhY3RlcnMgZW5kIGEgaG9zdCBuYW1lLCB0aGUgcGF0aCB3aWxsIG5vdCBiZSBwcmVwZW5kZWQgYSAvXG5VcmwucHJvdG90eXBlLl9ub1ByZXBlbmRTbGFzaEhvc3RFbmRlcnMgPSBtYWtlQXNjaWlUYWJsZShcbiAgICBbXG4gICAgICAgIFwiPFwiLCBcIj5cIiwgXCInXCIsIFwiYFwiLCBcIiBcIiwgXCJcXHJcIixcbiAgICAgICAgXCJcXG5cIiwgXCJcXHRcIiwgXCJ7XCIsIFwifVwiLCBcInxcIixcbiAgICAgICAgXCJeXCIsIFwiYFwiLCBcIlxcXCJcIiwgXCIlXCIsIFwiO1wiXG4gICAgXS5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gdi5jaGFyQ29kZUF0KDApO1xuICAgIH0pXG4pO1xuXG5VcmwucHJvdG90eXBlLl9hdXRvRXNjYXBlTWFwID0gYXV0b0VzY2FwZU1hcDtcblVybC5wcm90b3R5cGUuX2FmdGVyUXVlcnlBdXRvRXNjYXBlTWFwID0gYWZ0ZXJRdWVyeUF1dG9Fc2NhcGVNYXA7XG5cbm1vZHVsZS5leHBvcnRzID0gVXJsO1xuXG5VcmwucmVwbGFjZSA9IGZ1bmN0aW9uIFVybCRSZXBsYWNlKCkge1xuICAgIHJlcXVpcmUuY2FjaGUudXJsID0ge1xuICAgICAgICBleHBvcnRzOiBVcmxcbiAgICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Zhc3QtdXJsLXBhcnNlci9zcmMvdXJscGFyc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDExMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qc1xuLy8gbW9kdWxlIGlkID0gMTEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qc1xuLy8gbW9kdWxlIGlkID0gMTE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuNC4xJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykge1xuXHRcdFx0Ly8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzIFBldGthIEFudG9ub3ZcbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOjwvcD5cbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIFF1ZXJ5U3RyaW5nU2VyaWFsaXplciA9IHJlcXVpcmUoXCIuL3F1ZXJ5c3RyaW5nc2VyaWFsaXplci5qc1wiKTtcbm1vZHVsZS5leHBvcnRzID0gUXVlcnlTdHJpbmdQYXJzZXI7XG5cbnZhciBycGx1cyA9IC9cXCsvZztcbnZhciByaW50ID0gL15bMC05XSskLztcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbnZhciBoYXZlUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBRdWVyeVN0cmluZ1BhcnNlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5zU3BhcnNlID0gZmFsc2U7XG4gICAgdGhpcy5jYWNoZUtleSA9IFwiXCI7XG4gICAgdGhpcy5jYWNoZVZhbCA9IG51bGw7XG59XG5cblF1ZXJ5U3RyaW5nUGFyc2VyLm1heExlbmd0aCA9IDMyNzY4O1xuUXVlcnlTdHJpbmdQYXJzZXIubWF4RGVwdGggPSA0O1xuUXVlcnlTdHJpbmdQYXJzZXIubWF4S2V5cyA9IDI1NjtcblxuUXVlcnlTdHJpbmdQYXJzZXIucGFyc2UgPSBmdW5jdGlvbiBRdWVyeVN0cmluZ1BhcnNlciRQYXJzZShzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YXIgbWF4TGVuZ3RoID0gUXVlcnlTdHJpbmdQYXJzZXIubWF4TGVuZ3RoO1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJzdHIgaXMgdG9vIGxhcmdlIChcIiArXG4gICAgICAgICAgICAgICAgXCJRdWVyeVN0cmluZ1BhcnNlci5tYXhMZW5ndGg9XCIgKyBtYXhMZW5ndGggKyBcIilcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyc2VyID0gbmV3IFF1ZXJ5U3RyaW5nUGFyc2VyKCk7XG4gICAgICAgIHJldHVybiBwYXJzZXIucGFyc2VTdHJpbmcoc3RyLCBmYWxzZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0ciAhPT0gbnVsbCAmJiB0eXBlb2Ygc3RyID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciBwYXJzZXIgPSBuZXcgUXVlcnlTdHJpbmdQYXJzZXIoKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZU9iamVjdChzdHIpO1xuICAgIH1cbiAgICByZXR1cm4ge307XG59O1xuXG5RdWVyeVN0cmluZ1BhcnNlci5zdHJpbmdpZnkgPVxuZnVuY3Rpb24gUXVlcnlTdHJpbmdQYXJzZXIkU3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgdmFyIHNlcmlhbGl6ZXIgPSBuZXcgUXVlcnlTdHJpbmdTZXJpYWxpemVyKCk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZXIuc2VyaWFsaXplKHZhbHVlKTtcbn07XG5cblF1ZXJ5U3RyaW5nUGFyc2VyLnByb3RvdHlwZS5kZWNvZGUgPVxuZnVuY3Rpb24gUXVlcnlTdHJpbmdQYXJzZXIkZGVjb2RlKHN0ciwgc2hvdWxkRGVjb2RlLCBjb250YWluc1BsdXMpIHtcbiAgICBpZiAoc2hvdWxkRGVjb2RlID09PSBmYWxzZSkgcmV0dXJuIHN0cjtcbiAgICBpZiAoY29udGFpbnNQbHVzID09PSB0cnVlKSBzdHIgPSBzdHIucmVwbGFjZShycGx1cywgXCIgXCIpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG59O1xuXG5RdWVyeVN0cmluZ1BhcnNlci5wcm90b3R5cGUubWF5YmVBcnJheUluZGV4ID1cbmZ1bmN0aW9uIFF1ZXJ5U3RyaW5nUGFyc2VyJG1heWJlQXJyYXlJbmRleChzdHIsIGFycmF5TGVuZ3RoKSB7XG4gICAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYXJyYXlMZW5ndGg7XG4gICAgfVxuICAgIHZhciBjaCA9IHN0ci5jaGFyQ29kZUF0KDApO1xuXG4gICAgaWYgKGNoID09PSA0OCkge1xuICAgICAgICByZXR1cm4gbGVuID4gMSA/IC0xIDogMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoNDggPD0gY2ggJiYgY2ggPD0gNTcpIHtcbiAgICAgICAgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGNoIC0gNDg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmludC50ZXN0KHN0cikpIHtcbiAgICAgICAgICAgIHZhciB2ID0gcGFyc2VJbnQoc3RyLCAxMCk7XG4gICAgICAgICAgICBpZiAoMCA8IHYgJiYgdiA8PSAxMDczNzQxODIyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcblxuUXVlcnlTdHJpbmdQYXJzZXIucHJvdG90eXBlLmdldFNsb3QgPVxuZnVuY3Rpb24gUXVlcnlTdHJpbmdQYXJzZXIkZ2V0U2xvdChkaWN0aW9uYXJ5LCBwcmV2S2V5LCBjdXJLZXkpIHtcbiAgICB2YXIgc2xvdDtcbiAgICBpZiAoIShoYXZlUHJvcC5jYWxsKGRpY3Rpb25hcnksIHByZXZLZXkpKSkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLm1heWJlQXJyYXlJbmRleChjdXJLZXksIDApO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgc2xvdCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2xvdCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGRpY3Rpb25hcnlbcHJldktleV0gPSBzbG90O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2xvdCA9IGRpY3Rpb25hcnlbcHJldktleV07XG4gICAgfVxuICAgIHJldHVybiBzbG90O1xufTtcblxuUXVlcnlTdHJpbmdQYXJzZXIucHJvdG90eXBlLnBsYWNlTmVzdGVkVmFsdWUgPVxuZnVuY3Rpb24gUXVlcnlTdHJpbmdQYXJzZXIkcGxhY2VOZXN0ZWRWYWx1ZVxuKGRpY3Rpb25hcnksIGtleSwgdmFsdWUsIGksIHByZXZLZXksIGN1cktleSkge1xuICAgIHZhciBzbG90ID0gdGhpcy5nZXRTbG90KGRpY3Rpb25hcnksIHByZXZLZXksIGN1cktleSk7XG4gICAgdmFyIGluZGV4ID0gLTE7XG5cbiAgICBpZiAoaXNBcnJheShzbG90KSkge1xuICAgICAgICBpbmRleCA9IHRoaXMubWF5YmVBcnJheUluZGV4KGN1cktleSwgc2xvdC5sZW5ndGgpO1xuICAgIH1cblxuICAgIHZhciBsZW4gPSBrZXkubGVuZ3RoO1xuICAgIHZhciBkZXB0aCA9IDI7XG4gICAgdmFyIG1heERlcHRoID0gUXVlcnlTdHJpbmdQYXJzZXIubWF4RGVwdGg7XG4gICAgdmFyIHN0YXJ0ID0gLTE7XG4gICAgZm9yICg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgY2ggPSBrZXkuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNoID09PSA5MSkge1xuICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gOTMgJiZcbiAgICAgICAgICAgICAgICBzdGFydCA+IC0xKSB7XG4gICAgICAgICAgICBwcmV2S2V5ID0gY3VyS2V5O1xuICAgICAgICAgICAgY3VyS2V5ID0gc3RhcnQgPT09IGkgPyBcIlwiIDoga2V5LnN1YnN0cmluZyhzdGFydCwgaSk7XG4gICAgICAgICAgICBzdGFydCA9IC0xO1xuICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgIGlmIChkZXB0aCA+IG1heERlcHRoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJOZXN0aW5nIGRlcHRoIG9mIGtleXMgaXMgdG9vIGxhcmdlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCIoUXVlcnlTdHJpbmdQYXJzZXIubWF4RGVwdGg9XCIrbWF4RGVwdGgrXCIpXCIgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNsb3QgPSB0aGlzLmdldFNsb3Qoc2xvdCwgcHJldktleSwgY3VyS2V5KTtcblxuICAgICAgICAgICAgaW5kZXggPSBpc0FycmF5KHNsb3QpXG4gICAgICAgICAgICAgICAgPyB0aGlzLm1heWJlQXJyYXlJbmRleChjdXJLZXksIHNsb3QubGVuZ3RoKVxuICAgICAgICAgICAgICAgIDogLTE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihpbmRleCA+IC0xKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSBzbG90Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNsb3QucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5zU3BhcnNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzbG90W2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmluc2VydChzbG90LCBjdXJLZXksIHZhbHVlKTtcbiAgICB9XG59O1xuXG5RdWVyeVN0cmluZ1BhcnNlci5wcm90b3R5cGUuaW5zZXJ0ID1cbmZ1bmN0aW9uIFF1ZXJ5U3RyaW5nUGFyc2VyJGluc2VydChkaWN0aW9uYXJ5LCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIHJldCA9IG51bGw7XG4gICAgaWYgKGhhdmVQcm9wLmNhbGwoZGljdGlvbmFyeSwga2V5KSkge1xuICAgICAgICB2YXIgcHJldiA9IGRpY3Rpb25hcnlba2V5XTtcbiAgICAgICAgaWYoIGlzQXJyYXkocHJldikgKSB7XG4gICAgICAgICAgICBwcmV2LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgcmV0ID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9IFtwcmV2LCB2YWx1ZV07XG4gICAgICAgICAgICBkaWN0aW9uYXJ5W2tleV0gPSByZXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRpY3Rpb25hcnlba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuUXVlcnlTdHJpbmdQYXJzZXIucHJvdG90eXBlLnB1c2ggPVxuZnVuY3Rpb24gUXVlcnlTdHJpbmdQYXJzZXIkcHVzaChkaWN0aW9uYXJ5LCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIHJldCA9IG51bGw7XG4gICAgaWYgKGhhdmVQcm9wLmNhbGwoZGljdGlvbmFyeSwga2V5KSkge1xuICAgICAgICB2YXIgcHJldiA9IGRpY3Rpb25hcnlba2V5XTtcbiAgICAgICAgcHJldi5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmV0ID0gcHJldjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldCA9IFt2YWx1ZV07XG4gICAgICAgIGRpY3Rpb25hcnlba2V5XSA9IHJldDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblF1ZXJ5U3RyaW5nUGFyc2VyLnByb3RvdHlwZS5tYXliZVBsYWNlTmVzdGVkVmFsdWUgPVxuZnVuY3Rpb24gUXVlcnlTdHJpbmdQYXJzZXIkbWF5YmVQbGFjZU5lc3RlZFZhbHVlKGRpY3Rpb25hcnksIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgbGVuID0ga2V5Lmxlbmd0aDtcbiAgICBpZiAoa2V5LmNoYXJDb2RlQXQobGVuIC0gMSkgIT09IDkzKSB7XG4gICAgICAgIHRoaXMucGxhY2VWYWx1ZShkaWN0aW9uYXJ5LCBrZXksIHZhbHVlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHN0YXJ0ID0gLTE7XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGN1cktleTtcbiAgICB2YXIgcHJldktleTtcblxuICAgIGZvciAoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdmFyIGNoID0ga2V5LmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgaWYgKGNoID09PSA5MSkge1xuICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgIHByZXZLZXkgPSBrZXkuc2xpY2UoMCwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09IDkzKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wbGFjZVZhbHVlKGRpY3Rpb25hcnksIGtleSwgdmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJLZXkgPSBzdGFydCA9PT0gaSA/IFwiXCIgOiBrZXkuc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3VyS2V5ID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5wbGFjZVZhbHVlKGRpY3Rpb25hcnksIGtleSwgdmFsdWUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjdXJLZXkgPT09IFwiXCIgJiYgdmFsdWUgIT09IFwiXCIgJiYgaSA9PT0gbGVuKSB7XG4gICAgICAgIGlmIChrZXkgPT09IHRoaXMuY2FjaGVLZXkpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVWYWwucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlS2V5ID0ga2V5O1xuICAgICAgICAgICAgdGhpcy5jYWNoZVZhbCA9IHRoaXMucHVzaChkaWN0aW9uYXJ5LCBwcmV2S2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMucGxhY2VOZXN0ZWRWYWx1ZShkaWN0aW9uYXJ5LCBrZXksIHZhbHVlLCBpLCBwcmV2S2V5LCBjdXJLZXkpO1xuICAgIH1cbn07XG5cblF1ZXJ5U3RyaW5nUGFyc2VyLnByb3RvdHlwZS5wbGFjZVZhbHVlID1cbmZ1bmN0aW9uIFF1ZXJ5U3RyaW5nUGFyc2VyJHBsYWNlVmFsdWUoZGljdGlvbmFyeSwga2V5LCB2YWx1ZSwgcG9zc2libHlOZXN0ZWQpIHtcbiAgICBpZiAocG9zc2libHlOZXN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5tYXliZVBsYWNlTmVzdGVkVmFsdWUoZGljdGlvbmFyeSwga2V5LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gdGhpcy5jYWNoZUtleSkge1xuICAgICAgICB0aGlzLmNhY2hlVmFsLnB1c2godmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjYWNoZSA9IHRoaXMuaW5zZXJ0KGRpY3Rpb25hcnksIGtleSwgdmFsdWUpO1xuICAgIGlmIChjYWNoZSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNhY2hlS2V5ID0ga2V5O1xuICAgICAgICB0aGlzLmNhY2hlVmFsID0gY2FjaGU7XG4gICAgfVxufTtcblxuUXVlcnlTdHJpbmdQYXJzZXIucHJvdG90eXBlLmNvbXBhY3QgPVxuZnVuY3Rpb24gUXVlcnlTdHJpbmdQYXJzZXIkY29tcGFjdChvYmopIHtcbiAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBmb3IoIHZhciBpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47ICsraSApIHtcbiAgICAgICAgICAgIHJldC5wdXNoKG9ialtrZXlzW2ldXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIGZvciggdmFyIGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgKytpICkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBvYmpba2V5XSA9IHRoaXMuY29tcGFjdChvYmpba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxufTtcblxuUXVlcnlTdHJpbmdQYXJzZXIucHJvdG90eXBlLnBhcnNlT2JqZWN0ID1cbmZ1bmN0aW9uIFF1ZXJ5U3RyaW5nUGFyc2VyJHBhcnNlT2JqZWN0KG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGxlbi0tO1xuICAgIHZhciByZXQgPSBcIlwiO1xuICAgIHZhciBrZXk7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsZW47ICsraSApIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgcmV0ICs9IGtleSArIFwiPVwiICsgb2JqW2tleV0gKyBcIiZcIjtcbiAgICB9XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICByZXQgKz0ga2V5ICsgXCI9XCIgKyBvYmpba2V5XTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVN0cmluZyhyZXQsIHRydWUpO1xufTtcblxuUXVlcnlTdHJpbmdQYXJzZXIucHJvdG90eXBlLnBhcnNlU3RyaW5nID1cbmZ1bmN0aW9uIFF1ZXJ5U3RyaW5nUGFyc2VyJHBhcnNlU3RyaW5nKHN0ciwgbm9EZWNvZGUpIHtcbiAgICB2YXIgbWF4S2V5cyA9IFF1ZXJ5U3RyaW5nUGFyc2VyLm1heEtleXM7XG4gICAgdmFyIGtleXMgPSAwO1xuICAgIHZhciBkZWNvZGVLZXkgPSBmYWxzZTtcbiAgICB2YXIgZGVjb2RlVmFsdWUgPSBmYWxzZTtcbiAgICB2YXIgcG9zc2libHlOZXN0ZWQgPSBmYWxzZTtcbiAgICB2YXIgbGVuID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGRpY3Rpb25hcnkgPSB7fTtcbiAgICB2YXIga2V5U3RhcnQgPSAwO1xuICAgIHZhciBrZXlFbmQgPSAwO1xuICAgIHZhciB2YWx1ZVN0YXJ0ID0gMDtcbiAgICB2YXIgdmFsdWVFbmQgPSAwO1xuICAgIHZhciBsZWZ0ID0gMDtcbiAgICB2YXIgbGFzdEluZGV4ID0gbGVuIC0gMTtcbiAgICB2YXIgY29udGFpbnNQbHVzID0gZmFsc2U7XG5cblxuICAgIGZvciAoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgaWYgKGNoID09PSA5MSkge1xuICAgICAgICAgICAgbGVmdCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlZnQgPiAwICYmIGNoID09PSA5Mykge1xuICAgICAgICAgICAgcG9zc2libHlOZXN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgbGVmdC0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlZnQgPT09IDAgJiYgY2ggPT09IDYxKSB7XG4gICAgICAgICAgICB2YXIgaiA9IGkgKyAxO1xuXG4gICAgICAgICAgICBrZXlFbmQgPSBpIC0gMTtcbiAgICAgICAgICAgIHZhbHVlRW5kID0gdmFsdWVTdGFydCA9IGo7XG4gICAgICAgICAgICB2YXIga2V5ID0gc3RyLnNsaWNlKGtleVN0YXJ0LCBrZXlFbmQgKyAxKTtcbiAgICAgICAgICAgIGtleSA9IHRoaXMuZGVjb2RlKGtleSwgZGVjb2RlS2V5LCBjb250YWluc1BsdXMpO1xuICAgICAgICAgICAgZGVjb2RlS2V5ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGZvciAoOyBqIDwgbGVuOyArK2opIHtcbiAgICAgICAgICAgICAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KGopO1xuICAgICAgICAgICAgICAgIGlmICgoY2ggPT09IDQzIHx8IGNoID09PSAzNykgJiYgIW5vRGVjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gNDMpIGNvbnRhaW5zUGx1cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZVZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAzOCB8fCBqID09PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVFbmQgPSBqO1xuICAgICAgICAgICAgICAgICAgICBpID0gajtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDM4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUVuZC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc3RyLnNsaWNlKHZhbHVlU3RhcnQsIHZhbHVlRW5kICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5kZWNvZGUodmFsdWUsIGRlY29kZVZhbHVlLCBjb250YWluc1BsdXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGxhY2VWYWx1ZShkaWN0aW9uYXJ5LCBrZXksIHZhbHVlLCBwb3NzaWJseU5lc3RlZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGFpbnNQbHVzID0gZGVjb2RlVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcG9zc2libHlOZXN0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBrZXlTdGFydCA9IGogKyAxO1xuICAgICAgICAgICAgICAgICAgICBrZXlzKys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlzID4gbWF4S2V5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBbW91bnQgb2Yga2V5cyBpcyB0b28gbGFyZ2UgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKFF1ZXJ5U3RyaW5nUGFyc2VyLm1heEtleXM9XCIgKyBtYXhLZXlzICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoY2ggPT09IDQzIHx8IGNoID09PSAzNykgJiYgIW5vRGVjb2RlKSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09IDQzKSBjb250YWluc1BsdXMgPSB0cnVlO1xuICAgICAgICAgICAgZGVjb2RlS2V5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5U3RhcnQgIT09IGxlbikge1xuICAgICAgICB2YXIgdmFsdWUgPSBcIlwiO1xuICAgICAgICB2YXIga2V5ID0gc3RyLnNsaWNlKGtleVN0YXJ0LCBsZW4pO1xuICAgICAgICBrZXkgPSB0aGlzLmRlY29kZShrZXksIGRlY29kZUtleSwgY29udGFpbnNQbHVzKTtcbiAgICAgICAgdGhpcy5wbGFjZVZhbHVlKGRpY3Rpb25hcnksIGtleSwgdmFsdWUsIHBvc3NpYmx5TmVzdGVkKTtcbiAgICB9XG5cblxuICAgIGlmICh0aGlzLmNvbnRhaW5zU3BhcnNlKSB7XG4gICAgICAgIHRoaXMuY29tcGFjdChkaWN0aW9uYXJ5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGljdGlvbmFyeTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZ3BhcnNlci9qcy9xdWVyeXN0cmluZ3BhcnNlci5qc1xuLy8gbW9kdWxlIGlkID0gMTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzIFBldGthIEFudG9ub3ZcbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOjwvcD5cbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBRdWVyeVN0cmluZ1NlcmlhbGl6ZXI7XG52YXIgZW5jID0gZW5jb2RlVVJJQ29tcG9uZW50O1xudmFyIEFSUkFZID0gW107XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgb1Byb3RvID0gZ2V0UHJvdG8oe30pO1xuXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgcHJvdG8gPSBnZXRQcm90byhvYmopO1xuXG4gICAgcmV0dXJuIHByb3RvID09PSBvUHJvdG8gfHwgcHJvdG8gPT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIFF1ZXJ5U3RyaW5nU2VyaWFsaXplcigpIHtcblxufVxuXG5RdWVyeVN0cmluZ1NlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZSA9XG5mdW5jdGlvbiBRdWVyeVN0cmluZ1NlcmlhbGl6ZXIkc2VyaWFsaXplKG9iaikge1xuICAgIGlmIChvYmogPT09IG51bGwgfHxcbiAgICAgICAgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidGhlIG9iaiB0byBzdHJpbmdpZnkgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gICAgfVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGFycmF5ID0gQVJSQVk7XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIHZhciBjdXIgPSBvYmo7XG4gICAgdmFyIGtleVByZWZpeCA9IFwiXCI7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzID09PSBhcnJheSA/IGkgOiBrZXlzW2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSBjdXJba2V5XTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgc3RhY2sucHVzaChrZXlQcmVmaXgsIGN1ciwga2V5cywgbGVuLCBpKTtcblxuICAgICAgICAgICAgaWYgKGtleVByZWZpeCA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGtleVByZWZpeCA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGtleVByZWZpeCA9IGtleVByZWZpeCArIFwiW1wiICsgZW5jKGtleSkgKyBcIl1cIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAga2V5cyA9IGFycmF5O1xuICAgICAgICAgICAgICAgIGxlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpID0gLTE7XG4gICAgICAgICAgICBjdXIgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZWRLZXkgPSBrZXlQcmVmaXggPT09IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBlbmMoa2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGtleVByZWZpeCArIFwiW1wiICsgZW5jKGtleSkgKyBcIl1cIjtcbiAgICAgICAgICAgIHJldC5wdXNoKHNlcmlhbGl6ZWRLZXkgKyBcIj1cIiArIGVuYyh2YWx1ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoaSA9PT0gbGVuIC0gMSAmJiBzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBsZW4gPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGtleXMgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGN1ciA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAga2V5UHJlZml4ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0LmpvaW4oXCImXCIpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5ncGFyc2VyL2pzL3F1ZXJ5c3RyaW5nc2VyaWFsaXplci5qc1xuLy8gbW9kdWxlIGlkID0gMTE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2V0c0xvYWRlciA9IHJlcXVpcmUoJy4vZ3JvdXAnKTtcbmFzc2V0c0xvYWRlci5zdGF0cyA9IHJlcXVpcmUoJy4vc3RhdHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhc3NldHNMb2FkZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hc3NldHMtbG9hZGVyL3NyYy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCcuL2VtaXR0ZXIuanMnKTtcbnZhciBjcmVhdGVMb2FkZXIgPSByZXF1aXJlKCcuL2xvYWRlcicpO1xudmFyIGF1dG9JZCA9IDA7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlR3JvdXAoY29uZmlnKSB7XG4gICAgdmFyIGdyb3VwO1xuICAgIHZhciBtYXAgPSB7fTtcbiAgICB2YXIgYXNzZXRzID0gW107XG4gICAgdmFyIHF1ZXVlID0gW107XG4gICAgdmFyIG51bUxvYWRlZCA9IDA7XG4gICAgdmFyIG51bVRvdGFsID0gMDtcbiAgICB2YXIgbG9hZGVycyA9IHt9O1xuXG4gICAgdmFyIGFkZCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gY29uc29sZS5kZWJ1ZygnYWRkJywgb3B0aW9ucyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBvcHRpb25zLmZvckVhY2goYWRkKTtcbiAgICAgICAgICAgIHJldHVybiBncm91cDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNHcm91cCA9ICEhb3B0aW9ucy5hc3NldHMgJiYgQXJyYXkuaXNBcnJheShvcHRpb25zLmFzc2V0cyk7XG4gICAgICAgIC8vIGNvbnNvbGUuZGVidWcoJ2lzR3JvdXAnLCBpc0dyb3VwKTtcbiAgICAgICAgdmFyIGxvYWRlcjtcbiAgICAgICAgaWYgKGlzR3JvdXApIHtcbiAgICAgICAgICAgIGxvYWRlciA9IGNyZWF0ZUdyb3VwKGNvbmZpZ3VyZShvcHRpb25zLCBjb25maWcpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvYWRlciA9IGNyZWF0ZUxvYWRlcihjb25maWd1cmUob3B0aW9ucywgY29uZmlnKSk7XG4gICAgICAgIH1cbiAgICAgICAgbG9hZGVyLm9uY2UoJ2Rlc3Ryb3knLCBkZXN0cm95SGFuZGxlcik7XG4gICAgICAgIHF1ZXVlLnB1c2gobG9hZGVyKTtcbiAgICAgICAgbG9hZGVyc1tsb2FkZXIuaWRdID0gbG9hZGVyO1xuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfTtcblxuICAgIHZhciBnZXQgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3NldHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcFtpZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBtYXBbaWRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2FkZXJzW2lkXTtcbiAgICB9O1xuXG4gICAgdmFyIGZpbmQgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICBpZiAoZ2V0KGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldChpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZvdW5kID0gbnVsbDtcbiAgICAgICAgT2JqZWN0LmtleXMobG9hZGVycykuc29tZShmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGZvdW5kID0gbG9hZGVyc1trZXldLmZpbmQgJiYgbG9hZGVyc1trZXldLmZpbmQoaWQpO1xuICAgICAgICAgICAgcmV0dXJuICEhZm91bmQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfTtcblxuICAgIHZhciBnZXRFeHRlbnNpb24gPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgcmV0dXJuIHVybCAmJiB1cmwuc3BsaXQoJz8nKVswXS5zcGxpdCgnLicpLnBvcCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgfTtcblxuICAgIHZhciBjb25maWd1cmUgPSBmdW5jdGlvbihvcHRpb25zLCBkZWZhdWx0cykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgdXJsID0gb3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5pc1RvdWNoTG9ja2VkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaXNUb3VjaExvY2tlZCA9IGRlZmF1bHRzLmlzVG91Y2hMb2NrZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5ibG9iID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuYmxvYiA9IGRlZmF1bHRzLmJsb2I7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5iYXNlUGF0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zLmJhc2VQYXRoID0gZGVmYXVsdHMuYmFzZVBhdGg7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zLmlkID0gb3B0aW9ucy5pZCB8fCBvcHRpb25zLnVybCB8fCBTdHJpbmcoKythdXRvSWQpO1xuICAgICAgICBvcHRpb25zLnR5cGUgPSBvcHRpb25zLnR5cGUgfHwgZ2V0RXh0ZW5zaW9uKG9wdGlvbnMudXJsKTtcbiAgICAgICAgb3B0aW9ucy5jcm9zc09yaWdpbiA9IG9wdGlvbnMuY3Jvc3NPcmlnaW4gfHwgZGVmYXVsdHMuY3Jvc3NPcmlnaW47XG4gICAgICAgIG9wdGlvbnMud2ViQXVkaW9Db250ZXh0ID0gb3B0aW9ucy53ZWJBdWRpb0NvbnRleHQgfHwgZGVmYXVsdHMud2ViQXVkaW9Db250ZXh0O1xuICAgICAgICBvcHRpb25zLmxvZyA9IGRlZmF1bHRzLmxvZztcblxuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9O1xuXG4gICAgdmFyIHN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG51bVRvdGFsID0gcXVldWUubGVuZ3RoO1xuXG4gICAgICAgIHF1ZXVlLmZvckVhY2goZnVuY3Rpb24obG9hZGVyKSB7XG4gICAgICAgICAgICBsb2FkZXJcbiAgICAgICAgICAgICAgICAub24oJ3Byb2dyZXNzJywgcHJvZ3Jlc3NIYW5kbGVyKVxuICAgICAgICAgICAgICAgIC5vbmNlKCdjb21wbGV0ZScsIGNvbXBsZXRlSGFuZGxlcilcbiAgICAgICAgICAgICAgICAub25jZSgnZXJyb3InLCBlcnJvckhhbmRsZXIpXG4gICAgICAgICAgICAgICAgLnN0YXJ0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHF1ZXVlID0gW107XG5cbiAgICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH07XG5cbiAgICB2YXIgcHJvZ3Jlc3NIYW5kbGVyID0gZnVuY3Rpb24ocHJvZ3Jlc3MpIHtcbiAgICAgICAgdmFyIGxvYWRlZCA9IG51bUxvYWRlZCArIHByb2dyZXNzO1xuICAgICAgICBncm91cC5lbWl0KCdwcm9ncmVzcycsIGxvYWRlZCAvIG51bVRvdGFsKTtcbiAgICB9O1xuXG4gICAgdmFyIGNvbXBsZXRlSGFuZGxlciA9IGZ1bmN0aW9uKGFzc2V0LCBpZCwgdHlwZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhc3NldCkpIHtcbiAgICAgICAgICAgIGFzc2V0ID0geyBpZDogaWQsIGZpbGU6IGFzc2V0LCB0eXBlOiB0eXBlIH07XG4gICAgICAgIH1cbiAgICAgICAgbnVtTG9hZGVkKys7XG4gICAgICAgIGdyb3VwLmVtaXQoJ3Byb2dyZXNzJywgbnVtTG9hZGVkIC8gbnVtVG90YWwpO1xuICAgICAgICBtYXBbYXNzZXQuaWRdID0gYXNzZXQuZmlsZTtcbiAgICAgICAgYXNzZXRzLnB1c2goYXNzZXQpO1xuICAgICAgICBncm91cC5lbWl0KCdjaGlsZGNvbXBsZXRlJywgYXNzZXQpO1xuICAgICAgICBjaGVja0NvbXBsZXRlKCk7XG4gICAgfTtcblxuICAgIHZhciBlcnJvckhhbmRsZXIgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgbnVtVG90YWwtLTtcbiAgICAgICAgaWYgKGdyb3VwLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGdyb3VwLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja0NvbXBsZXRlKCk7XG4gICAgfTtcblxuICAgIHZhciBkZXN0cm95SGFuZGxlciA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIGxvYWRlcnNbaWRdID0gbnVsbDtcbiAgICAgICAgZGVsZXRlIGxvYWRlcnNbaWRdO1xuXG4gICAgICAgIG1hcFtpZF0gPSBudWxsO1xuICAgICAgICBkZWxldGUgbWFwW2lkXTtcblxuICAgICAgICBhc3NldHMuc29tZShmdW5jdGlvbihhc3NldCwgaSkge1xuICAgICAgICAgICAgaWYgKGFzc2V0LmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgIGFzc2V0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgY2hlY2tDb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobnVtTG9hZGVkID49IG51bVRvdGFsKSB7XG4gICAgICAgICAgICBncm91cC5lbWl0KCdjb21wbGV0ZScsIGFzc2V0cywgbWFwLCBjb25maWcuaWQsICdncm91cCcpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBkZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHF1ZXVlLnBvcCgpLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBncm91cC5vZmYoJ2Vycm9yJyk7XG4gICAgICAgIGdyb3VwLm9mZigncHJvZ3Jlc3MnKTtcbiAgICAgICAgZ3JvdXAub2ZmKCdjb21wbGV0ZScpO1xuICAgICAgICBhc3NldHMgPSBbXTtcbiAgICAgICAgbWFwID0ge307XG4gICAgICAgIGNvbmZpZy53ZWJBdWRpb0NvbnRleHQgPSBudWxsO1xuICAgICAgICBudW1Ub3RhbCA9IDA7XG4gICAgICAgIG51bUxvYWRlZCA9IDA7XG5cbiAgICAgICAgT2JqZWN0LmtleXMobG9hZGVycykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGxvYWRlcnNba2V5XS5kZXN0cm95KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBsb2FkZXJzID0ge307XG5cbiAgICAgICAgZ3JvdXAuZW1pdCgnZGVzdHJveScsIGdyb3VwLmlkKTtcblxuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfTtcblxuICAgIC8vIGVtaXRzOiBwcm9ncmVzcywgZXJyb3IsIGNvbXBsZXRlLCBkZXN0cm95XG5cbiAgICBncm91cCA9IE9iamVjdC5jcmVhdGUoRW1pdHRlci5wcm90b3R5cGUsIHtcbiAgICAgICAgX2V2ZW50czoge1xuICAgICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIGlkOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25maWcuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFkZDoge1xuICAgICAgICAgICAgdmFsdWU6IGFkZFxuICAgICAgICB9LFxuICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgdmFsdWU6IHN0YXJ0XG4gICAgICAgIH0sXG4gICAgICAgIGdldDoge1xuICAgICAgICAgICAgdmFsdWU6IGdldFxuICAgICAgICB9LFxuICAgICAgICBmaW5kOiB7XG4gICAgICAgICAgICB2YWx1ZTogZmluZFxuICAgICAgICB9LFxuICAgICAgICBnZXRMb2FkZXI6IHtcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZXJzW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbG9hZGVkOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1Mb2FkZWQgPj0gbnVtVG90YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZpbGU6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzc2V0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveToge1xuICAgICAgICAgICAgdmFsdWU6IGRlc3Ryb3lcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uZmlnID0gY29uZmlndXJlKGNvbmZpZyB8fCB7fSwge1xuICAgICAgICBiYXNlUGF0aDogJycsXG4gICAgICAgIGJsb2I6IGZhbHNlLFxuICAgICAgICB0b3VjaExvY2tlZDogZmFsc2UsXG4gICAgICAgIGNyb3NzT3JpZ2luOiBudWxsLFxuICAgICAgICB3ZWJBdWRpb0NvbnRleHQ6IG51bGwsXG4gICAgICAgIGxvZzogZmFsc2VcbiAgICB9KTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZy5hc3NldHMpKSB7XG4gICAgICAgIGFkZChjb25maWcuYXNzZXRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShncm91cCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXNzZXRzLWxvYWRlci9zcmMvZ3JvdXAuanNcbi8vIG1vZHVsZSBpZCA9IDEyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJy4vZW1pdHRlci5qcycpO1xudmFyIGJyb3dzZXJIYXNCbG9iID0gcmVxdWlyZSgnLi9icm93c2VyLWhhcy1ibG9iLmpzJyk7XG52YXIgc3RhdHMgPSByZXF1aXJlKCcuL3N0YXRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBpZCA9IG9wdGlvbnMuaWQ7XG4gICAgdmFyIGJhc2VQYXRoID0gb3B0aW9ucy5iYXNlUGF0aCB8fCAnJztcbiAgICB2YXIgdXJsID0gb3B0aW9ucy51cmw7XG4gICAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgdmFyIGNyb3NzT3JpZ2luID0gb3B0aW9ucy5jcm9zc09yaWdpbjtcbiAgICB2YXIgaXNUb3VjaExvY2tlZCA9IG9wdGlvbnMuaXNUb3VjaExvY2tlZDtcbiAgICB2YXIgYmxvYiA9IG9wdGlvbnMuYmxvYiAmJiBicm93c2VySGFzQmxvYjtcbiAgICB2YXIgd2ViQXVkaW9Db250ZXh0ID0gb3B0aW9ucy53ZWJBdWRpb0NvbnRleHQ7XG4gICAgdmFyIGxvZyA9IG9wdGlvbnMubG9nO1xuXG4gICAgdmFyIGxvYWRlcjtcbiAgICB2YXIgbG9hZEhhbmRsZXI7XG4gICAgdmFyIHJlcXVlc3Q7XG4gICAgdmFyIHN0YXJ0VGltZTtcbiAgICB2YXIgdGltZW91dDtcbiAgICB2YXIgZmlsZTtcblxuICAgIHZhciBzdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgICAgICAgICAgbG9hZEpTT04oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2pwZyc6XG4gICAgICAgICAgICBjYXNlICdwbmcnOlxuICAgICAgICAgICAgY2FzZSAnZ2lmJzpcbiAgICAgICAgICAgIGNhc2UgJ3dlYnAnOlxuICAgICAgICAgICAgICAgIGxvYWRJbWFnZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbXAzJzpcbiAgICAgICAgICAgIGNhc2UgJ29nZyc6XG4gICAgICAgICAgICBjYXNlICdvcHVzJzpcbiAgICAgICAgICAgIGNhc2UgJ3dhdic6XG4gICAgICAgICAgICBjYXNlICdtNGEnOlxuICAgICAgICAgICAgICAgIGxvYWRBdWRpbygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnb2d2JzpcbiAgICAgICAgICAgIGNhc2UgJ21wNCc6XG4gICAgICAgICAgICBjYXNlICd3ZWJtJzpcbiAgICAgICAgICAgIGNhc2UgJ2hscyc6XG4gICAgICAgICAgICAgICAgbG9hZFZpZGVvKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdiaW4nOlxuICAgICAgICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgICAgICAgICBsb2FkWEhSKCdhcnJheWJ1ZmZlcicpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndHh0JzpcbiAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgICAgIGxvYWRYSFIoJ3RleHQnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0Fzc2V0c0xvYWRlciBFUlJPUjogVW5rbm93biB0eXBlIGZvciBmaWxlIHdpdGggVVJMOiAnICsgYmFzZVBhdGggKyB1cmwgKyAnICgnICsgdHlwZSArICcpJztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZGlzcGF0Y2hDb21wbGV0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZmlsZSA9IHtpZDogaWQsIGZpbGU6IGRhdGEsIHR5cGU6IHR5cGV9O1xuICAgICAgICBsb2FkZXIuZW1pdCgncHJvZ3Jlc3MnLCAxKTtcbiAgICAgICAgbG9hZGVyLmVtaXQoJ2NvbXBsZXRlJywgZmlsZSwgaWQsIHR5cGUpO1xuICAgICAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICB9O1xuXG4gICAgdmFyIGxvYWRYSFIgPSBmdW5jdGlvbihyZXNwb25zZVR5cGUsIGN1c3RvbUxvYWRIYW5kbGVyKSB7XG4gICAgICAgIGxvYWRIYW5kbGVyID0gY3VzdG9tTG9hZEhhbmRsZXIgfHwgY29tcGxldGVIYW5kbGVyO1xuXG4gICAgICAgIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCBiYXNlUGF0aCArIHVybCwgdHJ1ZSk7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlO1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgcHJvZ3Jlc3NIYW5kbGVyKTtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgbG9hZEhhbmRsZXIpO1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgfTtcblxuICAgIHZhciBwcm9ncmVzc0hhbmRsZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgICAgICAgbG9hZGVyLmVtaXQoJ3Byb2dyZXNzJywgZXZlbnQubG9hZGVkIC8gZXZlbnQudG90YWwpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjb21wbGV0ZUhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHN1Y2Nlc3MoKSkge1xuICAgICAgICAgICAgZGlzcGF0Y2hDb21wbGV0ZShyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc3VjY2VzcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnc3VjY2VzcycsIHVybCwgcmVxdWVzdC5zdGF0dXMpO1xuICAgICAgICBpZiAocmVxdWVzdCAmJiByZXF1ZXN0LnN0YXR1cyA8IDQwMCkge1xuICAgICAgICAgICAgc3RhdHMudXBkYXRlKHJlcXVlc3QsIHN0YXJ0VGltZSwgdXJsLCBsb2cpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3JIYW5kbGVyKHJlcXVlc3QgJiYgcmVxdWVzdC5zdGF0dXNUZXh0KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvLyBqc29uXG5cbiAgICB2YXIgbG9hZEpTT04gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbG9hZFhIUignanNvbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3MoKSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwYXRjaENvbXBsZXRlKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gaW1hZ2VcblxuICAgIHZhciBsb2FkSW1hZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGJsb2IpIHtcbiAgICAgICAgICAgIGxvYWRJbWFnZUJsb2IoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvYWRJbWFnZUVsZW1lbnQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbG9hZEltYWdlRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXF1ZXN0ID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGlmIChjcm9zc09yaWdpbikge1xuICAgICAgICAgICAgcmVxdWVzdC5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvckhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZWxlbWVudExvYWRIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIHJlcXVlc3Quc3JjID0gYmFzZVBhdGggKyB1cmw7XG4gICAgfTtcblxuICAgIHZhciBlbGVtZW50TG9hZEhhbmRsZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICBpZiAoIWV2ZW50ICYmIChyZXF1ZXN0LmVycm9yIHx8ICFyZXF1ZXN0LnJlYWR5U3RhdGUpKSB7XG4gICAgICAgICAgICBlcnJvckhhbmRsZXIoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkaXNwYXRjaENvbXBsZXRlKHJlcXVlc3QpO1xuICAgIH07XG5cbiAgICB2YXIgbG9hZEltYWdlQmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBsb2FkWEhSKCdibG9iJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoc3VjY2VzcygpKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvckhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBpbWFnZUJsb2JIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zcmMgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBpbWFnZUJsb2JIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKHJlcXVlc3Quc3JjKTtcbiAgICAgICAgZGlzcGF0Y2hDb21wbGV0ZShyZXF1ZXN0KTtcbiAgICB9O1xuXG4gICAgLy8gYXVkaW9cblxuICAgIHZhciBsb2FkQXVkaW8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHdlYkF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgbG9hZEF1ZGlvQnVmZmVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2FkTWVkaWFFbGVtZW50KCdhdWRpbycpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHZpZGVvXG5cbiAgICB2YXIgbG9hZFZpZGVvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChibG9iKSB7XG4gICAgICAgICAgICBsb2FkWEhSKCdibG9iJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2FkTWVkaWFFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIGF1ZGlvIGJ1ZmZlclxuXG4gICAgdmFyIGxvYWRBdWRpb0J1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBsb2FkWEhSKCdhcnJheWJ1ZmZlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3MoKSkge1xuICAgICAgICAgICAgICAgIHdlYkF1ZGlvQ29udGV4dC5kZWNvZGVBdWRpb0RhdGEoXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaENvbXBsZXRlKGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlcihlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBtZWRpYSBlbGVtZW50XG5cbiAgICB2YXIgbG9hZE1lZGlhRWxlbWVudCA9IGZ1bmN0aW9uKHRhZ05hbWUpIHtcbiAgICAgICAgcmVxdWVzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG5cbiAgICAgICAgaWYgKCFpc1RvdWNoTG9ja2VkKSB7XG4gICAgICAgICAgICAvLyB0aW1lb3V0IGJlY2F1c2Ugc29tZXRpbWVzIGNhbnBsYXl0aHJvdWdoIGRvZXNuJ3QgZmlyZVxuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChlbGVtZW50TG9hZEhhbmRsZXIsIDIwMDApO1xuICAgICAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5dGhyb3VnaCcsIGVsZW1lbnRMb2FkSGFuZGxlciwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9ySGFuZGxlciwgZmFsc2UpO1xuICAgICAgICByZXF1ZXN0LnByZWxvYWQgPSAnYXV0byc7XG4gICAgICAgIHJlcXVlc3Quc3JjID0gYmFzZVBhdGggKyB1cmw7XG4gICAgICAgIHJlcXVlc3QubG9hZCgpO1xuXG4gICAgICAgIGlmIChpc1RvdWNoTG9ja2VkKSB7XG4gICAgICAgICAgICBkaXNwYXRjaENvbXBsZXRlKHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIGVycm9yXG5cbiAgICB2YXIgZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdlcnJvckhhbmRsZXInLCB1cmwsIGVycik7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG5cbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBlcnI7XG5cbiAgICAgICAgaWYgKHJlcXVlc3QgJiYgcmVxdWVzdC50YWdOYW1lICYmIHJlcXVlc3QuZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBFUlJPUl9TVEFURSA9IFsnJywgJ0FCT1JURUQnLCAnTkVUV09SSycsICdERUNPREUnLCAnU1JDX05PVF9TVVBQT1JURUQnXTtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSAnTWVkaWFFcnJvcjogJyArIEVSUk9SX1NUQVRFW3JlcXVlc3QuZXJyb3IuY29kZV0gKyAnICcgKyByZXF1ZXN0LnNyYztcbiAgICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0ICYmIHJlcXVlc3Quc3RhdHVzVGV4dCkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IHJlcXVlc3Quc3RhdHVzVGV4dDtcbiAgICAgICAgfSBlbHNlIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnIgJiYgZXJyLnR5cGUpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnIudHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvYWRlci5lbWl0KCdlcnJvcicsICdFcnJvciBsb2FkaW5nIFwiJyArIGJhc2VQYXRoICsgdXJsICsgJ1wiICcgKyBtZXNzYWdlKTtcblxuICAgICAgICBkZXN0cm95KCk7XG4gICAgfTtcblxuICAgIC8vIGNsZWFuIHVwXG5cbiAgICB2YXIgcmVtb3ZlTGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGxvYWRlci5vZmYoJ2Vycm9yJyk7XG4gICAgICAgIGxvYWRlci5vZmYoJ3Byb2dyZXNzJyk7XG4gICAgICAgIGxvYWRlci5vZmYoJ2NvbXBsZXRlJyk7XG5cbiAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBwcm9ncmVzc0hhbmRsZXIpO1xuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgbG9hZEhhbmRsZXIpO1xuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9ySGFuZGxlcik7XG4gICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBlbGVtZW50TG9hZEhhbmRsZXIpO1xuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKCdjYW5wbGF5dGhyb3VnaCcsIGVsZW1lbnRMb2FkSGFuZGxlcik7XG4gICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBpbWFnZUJsb2JIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcnMoKTtcblxuICAgICAgICBpZiAocmVxdWVzdCAmJiByZXF1ZXN0LmFib3J0ICYmIHJlcXVlc3QucmVhZHlTdGF0ZSA8IDQpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgICB3ZWJBdWRpb0NvbnRleHQgPSBudWxsO1xuICAgICAgICBmaWxlID0gbnVsbDtcblxuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXG4gICAgICAgIGxvYWRlci5lbWl0KCdkZXN0cm95JywgaWQpO1xuICAgIH07XG5cbiAgICAvLyBlbWl0czogcHJvZ3Jlc3MsIGVycm9yLCBjb21wbGV0ZVxuXG4gICAgbG9hZGVyID0gT2JqZWN0LmNyZWF0ZShFbWl0dGVyLnByb3RvdHlwZSwge1xuICAgICAgICBfZXZlbnRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSxcbiAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmlkXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICB2YWx1ZTogc3RhcnRcbiAgICAgICAgfSxcbiAgICAgICAgbG9hZGVkOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIWZpbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZpbGU6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRlc3Ryb3k6IHtcbiAgICAgICAgICAgIHZhbHVlOiBkZXN0cm95XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGxvYWRlcik7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXNzZXRzLWxvYWRlci9zcmMvbG9hZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gISFuZXcgQmxvYigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0oKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hc3NldHMtbG9hZGVyL3NyYy9icm93c2VyLWhhcy1ibG9iLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==