/******/ (function(modules) { // webpackBootstrap
/******/ 	function hotDisposeChunk(chunkId) {
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/ 	var parentHotUpdateCallback = window["webpackHotUpdate"];
/******/ 	window["webpackHotUpdate"] = 
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/ 	
/******/ 	function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.type = "text/javascript";
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		;
/******/ 		head.appendChild(script);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadManifest(requestTimeout) { // eslint-disable-line no-unused-vars
/******/ 		requestTimeout = requestTimeout || 10000;
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if(typeof XMLHttpRequest === "undefined")
/******/ 				return reject(new Error("No browser support"));
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = requestTimeout;
/******/ 				request.send(null);
/******/ 			} catch(err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if(request.readyState !== 4) return;
/******/ 				if(request.status === 0) {
/******/ 					// timeout
/******/ 					reject(new Error("Manifest request to " + requestPath + " timed out."));
/******/ 				} else if(request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if(request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch(e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}
/******/
/******/ 	
/******/ 	
/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "aac4bc7543dc713d4d51"; // eslint-disable-line no-unused-vars
/******/ 	var hotRequestTimeout = 10000;
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = []; // eslint-disable-line no-unused-vars
/******/ 	
/******/ 	function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var me = installedModules[moduleId];
/******/ 		if(!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if(me.hot.active) {
/******/ 				if(installedModules[request]) {
/******/ 					if(installedModules[request].parents.indexOf(moduleId) < 0)
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if(me.children.indexOf(request) < 0)
/******/ 					me.children.push(request);
/******/ 			} else {
/******/ 				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for(var name in __webpack_require__) {
/******/ 			if(Object.prototype.hasOwnProperty.call(__webpack_require__, name) && name !== "e") {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if(hotStatus === "ready")
/******/ 				hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/ 	
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if(hotStatus === "prepare") {
/******/ 					if(!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/ 	
/******/ 	function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/ 	
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfAccepted = true;
/******/ 				else if(typeof dep === "function")
/******/ 					hot._selfAccepted = dep;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else
/******/ 					hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfDeclined = true;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else
/******/ 					hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if(!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/ 	
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/ 	
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for(var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/ 	
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/ 	
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/ 	
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = (+id) + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/ 	
/******/ 	function hotCheck(apply) {
/******/ 		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
/******/ 			if(!update) {
/******/ 				hotSetStatus("idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/ 	
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			var chunkId = 1;
/******/ 			{ // eslint-disable-line no-lone-blocks
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/ 	
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		if(!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for(var moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if(!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if(!deferred) return;
/******/ 		if(hotApplyOnUpdate) {
/******/ 			// Wrap deferred object in Promise to mark it as a well-handled Promise to
/******/ 			// avoid triggering uncaught exception warning in Chrome.
/******/ 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
/******/ 			Promise.resolve().then(function() {
/******/ 				return hotApply(hotApplyOnUpdate);
/******/ 			}).then(
/******/ 				function(result) {
/******/ 					deferred.resolve(result);
/******/ 				},
/******/ 				function(err) {
/******/ 					deferred.reject(err);
/******/ 				}
/******/ 			);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for(var id in hotUpdate) {
/******/ 				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotApply(options) {
/******/ 		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/ 	
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/ 	
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/ 	
/******/ 			var queue = outdatedModules.slice().map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while(queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if(!module || module.hot._selfAccepted)
/******/ 					continue;
/******/ 				if(module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if(module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for(var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if(!parent) continue;
/******/ 					if(parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if(outdatedModules.indexOf(parentId) >= 0) continue;
/******/ 					if(parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if(!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 	
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/ 	
/******/ 		function addAllToSet(a, b) {
/******/ 			for(var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if(a.indexOf(item) < 0)
/******/ 					a.push(item);
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/ 	
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn("[HMR] unexpected require(" + result.moduleId + ") to disposed module");
/******/ 		};
/******/ 	
/******/ 		for(var id in hotUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				var result;
/******/ 				if(hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if(result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch(result.type) {
/******/ 					case "self-declined":
/******/ 						if(options.onDeclined)
/******/ 							options.onDeclined(result);
/******/ 						if(!options.ignoreDeclined)
/******/ 							abortError = new Error("Aborted because of self decline: " + result.moduleId + chainInfo);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if(options.onDeclined)
/******/ 							options.onDeclined(result);
/******/ 						if(!options.ignoreDeclined)
/******/ 							abortError = new Error("Aborted because of declined dependency: " + result.moduleId + " in " + result.parentId + chainInfo);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if(options.onUnaccepted)
/******/ 							options.onUnaccepted(result);
/******/ 						if(!options.ignoreUnaccepted)
/******/ 							abortError = new Error("Aborted because " + moduleId + " is not accepted" + chainInfo);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if(options.onAccepted)
/******/ 							options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if(options.onDisposed)
/******/ 							options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if(abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if(doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for(moduleId in result.outdatedDependencies) {
/******/ 						if(Object.prototype.hasOwnProperty.call(result.outdatedDependencies, moduleId)) {
/******/ 							if(!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(outdatedDependencies[moduleId], result.outdatedDependencies[moduleId]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if(doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for(i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/ 	
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if(hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/ 	
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while(queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if(!module) continue;
/******/ 	
/******/ 			var data = {};
/******/ 	
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for(j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/ 	
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/ 	
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/ 	
/******/ 			// when disposing there is no need to call dispose handler
/******/ 			delete outdatedDependencies[moduleId];
/******/ 	
/******/ 			// remove "parents" references from all children
/******/ 			for(j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if(!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if(idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for(moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				module = installedModules[moduleId];
/******/ 				if(module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for(j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if(idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/ 	
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/ 	
/******/ 		// insert new code
/******/ 		for(moduleId in appliedUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for(moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				module = installedModules[moduleId];
/******/ 				if(module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					var callbacks = [];
/******/ 					for(i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 						dependency = moduleOutdatedDependencies[i];
/******/ 						cb = module.hot._acceptedDependencies[dependency];
/******/ 						if(cb) {
/******/ 							if(callbacks.indexOf(cb) >= 0) continue;
/******/ 							callbacks.push(cb);
/******/ 						}
/******/ 					}
/******/ 					for(i = 0; i < callbacks.length; i++) {
/******/ 						cb = callbacks[i];
/******/ 						try {
/******/ 							cb(moduleOutdatedDependencies);
/******/ 						} catch(err) {
/******/ 							if(options.onErrored) {
/******/ 								options.onErrored({
/******/ 									type: "accept-errored",
/******/ 									moduleId: moduleId,
/******/ 									dependencyId: moduleOutdatedDependencies[i],
/******/ 									error: err
/******/ 								});
/******/ 							}
/******/ 							if(!options.ignoreErrored) {
/******/ 								if(!error)
/******/ 									error = err;
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Load self accepted modules
/******/ 		for(i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch(err) {
/******/ 				if(typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch(err2) {
/******/ 						if(options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								orginalError: err, // TODO remove in webpack 4
/******/ 								originalError: err
/******/ 							});
/******/ 						}
/******/ 						if(!options.ignoreErrored) {
/******/ 							if(!error)
/******/ 								error = err2;
/******/ 						}
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if(options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if(!options.ignoreErrored) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if(error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/ 	
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(124)(__webpack_require__.s = 124);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // GLTool.js

var _glMatrix = __webpack_require__(1);

var _getAndApplyExtension = __webpack_require__(49);

var _getAndApplyExtension2 = _interopRequireDefault(_getAndApplyExtension);

var _exposeAttributes = __webpack_require__(50);

var _exposeAttributes2 = _interopRequireDefault(_exposeAttributes);

var _getFloat = __webpack_require__(51);

var _getFloat2 = _interopRequireDefault(_getFloat);

var _getHalfFloat = __webpack_require__(52);

var _getHalfFloat2 = _interopRequireDefault(_getHalfFloat);

var _getAttribLoc = __webpack_require__(25);

var _getAttribLoc2 = _interopRequireDefault(_getAttribLoc);

var _ExtensionsList = __webpack_require__(53);

var _ExtensionsList2 = _interopRequireDefault(_ExtensionsList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;

var GLTool = function () {
	function GLTool() {
		_classCallCheck(this, GLTool);

		this.canvas;
		this._viewport = [0, 0, 0, 0];
		this._enabledVertexAttribute = [];
		this.identityMatrix = _glMatrix.mat4.create();
		this._normalMatrix = _glMatrix.mat3.create();
		this._inverseModelViewMatrix = _glMatrix.mat3.create();
		this._modelMatrix = _glMatrix.mat4.create();
		this._matrix = _glMatrix.mat4.create();
		this._matrixStacks = [];
		this._lastMesh = null;
		this._useWebGL2 = false;
		this._hasArrayInstance;
		this._extArrayInstance;
		this._hasCheckedExt = false;
		_glMatrix.mat4.identity(this.identityMatrix, this.identityMatrix);

		this.isMobile = false;
		if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
			this.isMobile = true;
		}
	}

	//	INITIALIZE

	_createClass(GLTool, [{
		key: 'init',
		value: function init(mCanvas) {
			var mParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


			if (mCanvas === null || mCanvas === undefined) {
				console.error('Canvas not exist');
				return;
			}

			if (this.canvas !== undefined && this.canvas !== null) {
				this.destroy();
			}

			this.canvas = mCanvas;
			this.setSize(window.innerWidth, window.innerHeight);

			mParameters.useWebgl2 = mParameters.useWebgl2 || false;

			var ctx = void 0;
			if (mParameters.useWebgl2) {
				ctx = this.canvas.getContext('experimental-webgl2', mParameters) || this.canvas.getContext('webgl2', mParameters);

				if (!ctx) {
					ctx = this.canvas.getContext('webgl', mParameters) || this.canvas.getContext('experimental-webgl', mParameters);
					this._useWebGL2 = false;
				} else {
					this._useWebGL2 = true;
				}
			} else {
				// ctx = this.canvas.getContext('experimental-webgl2', mParameters) || this.canvas.getContext('webgl2', mParameters);
				// if(ctx) {
				// 	this._useWebGL2 = true;
				// } else {
				// 	ctx = this.canvas.getContext('webgl', mParameters) || this.canvas.getContext('experimental-webgl', mParameters);
				// }

				ctx = this.canvas.getContext('webgl', mParameters) || this.canvas.getContext('experimental-webgl', mParameters);
				this._useWebGL2 = false;
			}

			console.log('Using WebGL 2 ?', this.webgl2);

			//	extensions
			this.initWithGL(ctx);
		}
	}, {
		key: 'initWithGL',
		value: function initWithGL(ctx) {
			if (!this.canvas) {
				this.canvas = ctx.canvas;
			}
			gl = this.gl = ctx;

			this.extensions = {};
			for (var i = 0; i < _ExtensionsList2.default.length; i++) {
				this.extensions[_ExtensionsList2.default[i]] = gl.getExtension(_ExtensionsList2.default[i]);
			}

			//	Copy gl Attributes
			(0, _exposeAttributes2.default)();
			(0, _getAndApplyExtension2.default)(gl, 'OES_vertex_array_object');
			(0, _getAndApplyExtension2.default)(gl, 'ANGLE_instanced_arrays');
			(0, _getAndApplyExtension2.default)(gl, 'WEBGL_draw_buffers');

			this.enable(this.DEPTH_TEST);
			this.enable(this.CULL_FACE);
			this.enable(this.BLEND);
			this.enableAlphaBlending();
		}

		//	PUBLIC METHODS

	}, {
		key: 'setViewport',
		value: function setViewport(x, y, w, h) {
			var hasChanged = false;
			if (x !== this._viewport[0]) {
				hasChanged = true;
			}
			if (y !== this._viewport[1]) {
				hasChanged = true;
			}
			if (w !== this._viewport[2]) {
				hasChanged = true;
			}
			if (h !== this._viewport[3]) {
				hasChanged = true;
			}

			if (hasChanged) {
				gl.viewport(x, y, w, h);
				this._viewport = [x, y, w, h];
			}
		}
	}, {
		key: 'scissor',
		value: function scissor(x, y, w, h) {
			gl.scissor(x, y, w, h);
		}
	}, {
		key: 'clear',
		value: function clear(r, g, b, a) {
			gl.clearColor(r, g, b, a);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		}
	}, {
		key: 'cullFace',
		value: function cullFace(mValue) {
			gl.cullFace(mValue);
		}
	}, {
		key: 'setMatrices',
		value: function setMatrices(mCamera) {
			this.camera = mCamera;
			this.rotate(this.identityMatrix);
		}
	}, {
		key: 'useShader',
		value: function useShader(mShader) {
			this.shader = mShader;
			this.shaderProgram = this.shader.shaderProgram;
		}
	}, {
		key: 'rotate',
		value: function rotate(mRotation) {
			_glMatrix.mat4.copy(this._modelMatrix, mRotation);
			_glMatrix.mat4.multiply(this._matrix, this.camera.matrix, this._modelMatrix);
			_glMatrix.mat3.fromMat4(this._normalMatrix, this._matrix);
			_glMatrix.mat3.invert(this._normalMatrix, this._normalMatrix);
			_glMatrix.mat3.transpose(this._normalMatrix, this._normalMatrix);

			_glMatrix.mat3.fromMat4(this._inverseModelViewMatrix, this._matrix);
			_glMatrix.mat3.invert(this._inverseModelViewMatrix, this._inverseModelViewMatrix);
		}
	}, {
		key: 'draw',
		value: function draw(mMesh, mDrawingType) {
			if (mMesh.length) {
				for (var i = 0; i < mMesh.length; i++) {
					this.draw(mMesh[i]);
				}
				return;
			}

			mMesh.bind(this.shaderProgram);

			//	DEFAULT UNIFORMS
			if (this.camera !== undefined) {
				this.shader.uniform('uProjectionMatrix', 'mat4', this.camera.projection);
				this.shader.uniform('uViewMatrix', 'mat4', this.camera.matrix);
			}

			this.shader.uniform('uModelMatrix', 'mat4', this._modelMatrix);
			this.shader.uniform('uNormalMatrix', 'mat3', this._normalMatrix);
			this.shader.uniform('uModelViewMatrixInverse', 'mat3', this._inverseModelViewMatrix);

			var drawType = mMesh.drawType;
			if (mDrawingType !== undefined) {
				drawType = mDrawingType;
			}

			if (mMesh.isInstanced) {
				//	DRAWING
				gl.drawElementsInstanced(mMesh.drawType, mMesh.iBuffer.numItems, gl.UNSIGNED_SHORT, 0, mMesh.numInstance);
			} else {
				if (drawType === gl.POINTS) {
					gl.drawArrays(drawType, 0, mMesh.vertexSize);
				} else {
					gl.drawElements(drawType, mMesh.iBuffer.numItems, gl.UNSIGNED_SHORT, 0);
				}
			}

			mMesh.unbind();
		}
	}, {
		key: 'drawTransformFeedback',
		value: function drawTransformFeedback(mTransformObject) {
			var meshSource = mTransformObject.meshSource,
			    meshDestination = mTransformObject.meshDestination,
			    numPoints = mTransformObject.numPoints,
			    transformFeedback = mTransformObject.transformFeedback;

			//	BIND SOURCE BUFFERS -> setupVertexAttr(sourceVAO)

			meshSource.bind(this.shaderProgram);
			meshDestination.generateBuffers(this.shaderProgram);

			//	BIND DESTINATION BUFFERS
			gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedback);

			meshDestination.attributes.forEach(function (attr, i) {
				gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, attr.buffer);
			});

			gl.enable(gl.RASTERIZER_DISCARD);

			gl.beginTransformFeedback(gl.POINTS);
			gl.drawArrays(gl.POINTS, 0, numPoints);
			gl.endTransformFeedback();

			//	reset state
			gl.disable(gl.RASTERIZER_DISCARD);
			gl.useProgram(null);
			gl.bindBuffer(gl.ARRAY_BUFFER, null);
			meshDestination.attributes.forEach(function (attr, i) {
				gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, null);
			});
			gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);

			meshSource.unbind();
		}
	}, {
		key: 'setSize',
		value: function setSize(mWidth, mHeight) {
			this._width = mWidth;
			this._height = mHeight;
			this.canvas.width = this._width;
			this.canvas.height = this._height;
			this._aspectRatio = this._width / this._height;

			if (gl) {
				this.viewport(0, 0, this._width, this._height);
			}
		}
	}, {
		key: 'showExtensions',
		value: function showExtensions() {
			console.log('Extensions : ', this.extensions);
			for (var ext in this.extensions) {
				if (this.extensions[ext]) {
					console.log(ext, ':', this.extensions[ext]);
				}
			}
		}
	}, {
		key: 'checkExtension',
		value: function checkExtension(mExtension) {
			return !!this.extensions[mExtension];
		}
	}, {
		key: 'getExtension',
		value: function getExtension(mExtension) {
			return this.extensions[mExtension];
		}

		//	BLEND MODES

	}, {
		key: 'enableAlphaBlending',
		value: function enableAlphaBlending() {
			gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
		}
	}, {
		key: 'enableAdditiveBlending',
		value: function enableAdditiveBlending() {
			gl.blendFunc(gl.ONE, gl.ONE);
		}

		//	matrices

	}, {
		key: 'pushMatrix',
		value: function pushMatrix() {
			var mtx = _glMatrix.mat4.clone(this._modelMatrix);
			this._matrixStacks.push(mtx);
		}
	}, {
		key: 'popMatrix',
		value: function popMatrix() {
			if (this._matrixStacks.length == 0) {
				return null;
			}
			var mtx = this._matrixStacks.pop();
			this.rotate(mtx);
		}

		//	GL NATIVE FUNCTIONS

	}, {
		key: 'enable',
		value: function enable(mParameter) {
			gl.enable(mParameter);
		}
	}, {
		key: 'disable',
		value: function disable(mParameter) {
			gl.disable(mParameter);
		}
	}, {
		key: 'viewport',
		value: function viewport(x, y, w, h) {
			this.setViewport(x, y, w, h);
		}

		//	GETTER AND SETTERS

	}, {
		key: 'destroy',


		//	DESTROY

		value: function destroy() {

			if (this.canvas.parentNode) {
				try {
					this.canvas.parentNode.removeChild(this.canvas);
				} catch (e) {
					console.log('Error : ', e);
				}
			}

			this.canvas = null;
		}
	}, {
		key: 'FLOAT',
		get: function get() {
			return (0, _getFloat2.default)();
		}
	}, {
		key: 'HALF_FLOAT',
		get: function get() {
			return (0, _getHalfFloat2.default)();
		}
	}, {
		key: 'width',
		get: function get() {
			return this._width;
		}
	}, {
		key: 'height',
		get: function get() {
			return this._height;
		}
	}, {
		key: 'aspectRatio',
		get: function get() {
			return this._aspectRatio;
		}
	}, {
		key: 'webgl2',
		get: function get() {
			return this._useWebGL2;
		}
	}]);

	return GLTool;
}();

var GL = new GLTool();

exports.default = GL;

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__gl_matrix_common__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__gl_matrix_mat2__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__gl_matrix_mat2d__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__gl_matrix_mat3__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__gl_matrix_mat4__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__gl_matrix_quat__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__gl_matrix_vec2__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__gl_matrix_vec3__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__gl_matrix_vec4__ = __webpack_require__(23);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "glMatrix", function() { return __WEBPACK_IMPORTED_MODULE_0__gl_matrix_common__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2", function() { return __WEBPACK_IMPORTED_MODULE_1__gl_matrix_mat2__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2d", function() { return __WEBPACK_IMPORTED_MODULE_2__gl_matrix_mat2d__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat3", function() { return __WEBPACK_IMPORTED_MODULE_3__gl_matrix_mat3__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat4", function() { return __WEBPACK_IMPORTED_MODULE_4__gl_matrix_mat4__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quat", function() { return __WEBPACK_IMPORTED_MODULE_5__gl_matrix_quat__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec2", function() { return __WEBPACK_IMPORTED_MODULE_6__gl_matrix_vec2__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec3", function() { return __WEBPACK_IMPORTED_MODULE_7__gl_matrix_vec3__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec4", function() { return __WEBPACK_IMPORTED_MODULE_8__gl_matrix_vec4__; });
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.4.0
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */
// END HEADER













/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// GLShader.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var glslify = __webpack_require__(54);
var isSame = function isSame(array1, array2) {
	if (array1.length !== array2.length) {
		return false;
	}

	for (var i = 0; i < array1.length; i++) {
		if (array1[i] !== array2[i]) {
			return false;
		}
	}

	return true;
};

var addLineNumbers = function addLineNumbers(string) {
	var lines = string.split('\n');
	for (var i = 0; i < lines.length; i++) {
		lines[i] = i + 1 + ': ' + lines[i];
	}
	return lines.join('\n');
};

var cloneArray = function cloneArray(mArray) {
	if (mArray.slice) {
		return mArray.slice(0);
	} else {
		return new Float32Array(mArray);
	}
};

var gl = void 0;
var defaultVertexShader = __webpack_require__(11);
var defaultFragmentShader = __webpack_require__(55);

var uniformMapping = {
	float: 'uniform1f',
	vec2: 'uniform2fv',
	vec3: 'uniform3fv',
	vec4: 'uniform4fv',
	int: 'uniform1i',
	mat3: 'uniformMatrix3fv',
	mat4: 'uniformMatrix4fv'
};

var GLShader = function () {
	function GLShader() {
		var strVertexShader = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultVertexShader;
		var strFragmentShader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultFragmentShader;
		var mVaryings = arguments[2];

		_classCallCheck(this, GLShader);

		gl = _GLTool2.default.gl;
		this.parameters = [];
		this.uniformTextures = [];
		this._varyings = mVaryings;

		if (!strVertexShader) {
			strVertexShader = defaultVertexShader;
		}
		if (!strFragmentShader) {
			strFragmentShader = defaultVertexShader;
		}

		var vsShader = this._createShaderProgram(strVertexShader, true);
		var fsShader = this._createShaderProgram(strFragmentShader, false);
		this._attachShaderProgram(vsShader, fsShader);
	}

	_createClass(GLShader, [{
		key: 'bind',
		value: function bind() {

			if (_GLTool2.default.shader === this) {
				return;
			}
			gl.useProgram(this.shaderProgram);
			_GLTool2.default.useShader(this);
			this.uniformTextures = [];
		}
	}, {
		key: 'uniform',
		value: function uniform(mName, mType, mValue) {
			if ((typeof mName === 'undefined' ? 'undefined' : _typeof(mName)) === 'object') {
				this.uniformObject(mName);
				return;
			}
			/*
   if(!!mValue === undefined || mValue === null) {
   	console.warn('mValue Error:', mName);
   	return;
   }
   */
			var uniformType = uniformMapping[mType] || mType;

			var hasUniform = false;
			var oUniform = void 0;
			var parameterIndex = -1;

			for (var i = 0; i < this.parameters.length; i++) {
				oUniform = this.parameters[i];
				if (oUniform.name === mName) {
					hasUniform = true;
					parameterIndex = i;
					break;
				}
			}

			var isNumber = false;

			if (!hasUniform) {
				isNumber = uniformType === 'uniform1i' || uniformType === 'uniform1f';
				this.shaderProgram[mName] = gl.getUniformLocation(this.shaderProgram, mName);
				if (isNumber) {
					this.parameters.push({ name: mName, type: uniformType, value: mValue, uniformLoc: this.shaderProgram[mName], isNumber: isNumber });
				} else {
					this.parameters.push({ name: mName, type: uniformType, value: cloneArray(mValue), uniformLoc: this.shaderProgram[mName], isNumber: isNumber });
				}

				parameterIndex = this.parameters.length - 1;
			} else {
				this.shaderProgram[mName] = oUniform.uniformLoc;
				isNumber = oUniform.isNumber;
			}

			if (!this.parameters[parameterIndex].uniformLoc) {
				return;
			}

			if (uniformType.indexOf('Matrix') === -1) {
				if (!isNumber) {
					if (!isSame(this.parameters[parameterIndex].value, mValue) || !hasUniform) {
						gl[uniformType](this.shaderProgram[mName], mValue);
						this.parameters[parameterIndex].value = cloneArray(mValue);
					}
				} else {
					var needUpdate = this.parameters[parameterIndex].value !== mValue || !hasUniform;
					if (needUpdate) {
						gl[uniformType](this.shaderProgram[mName], mValue);
						this.parameters[parameterIndex].value = mValue;
					}
				}
			} else {
				if (!isSame(this.parameters[parameterIndex].value, mValue) || !hasUniform) {
					gl[uniformType](this.shaderProgram[mName], false, mValue);
					this.parameters[parameterIndex].value = cloneArray(mValue);
				}
			}
		}
	}, {
		key: 'uniformObject',
		value: function uniformObject(mUniformObj) {
			for (var uniformName in mUniformObj) {
				var uniformValue = mUniformObj[uniformName];
				var uniformType = GLShader.getUniformType(uniformValue);

				if (uniformValue.concat && uniformValue[0].concat) {
					var tmp = [];
					for (var i = 0; i < uniformValue.length; i++) {
						tmp = tmp.concat(uniformValue[i]);
					}
					uniformValue = tmp;
				}

				this.uniform(uniformName, uniformType, uniformValue);
			}
		}
	}, {
		key: '_createShaderProgram',
		value: function _createShaderProgram(mShaderStr, isVertexShader) {

			var shaderType = isVertexShader ? _GLTool2.default.VERTEX_SHADER : _GLTool2.default.FRAGMENT_SHADER;
			var shader = gl.createShader(shaderType);

			gl.shaderSource(shader, mShaderStr);
			gl.compileShader(shader);

			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				console.warn('Error in Shader : ', gl.getShaderInfoLog(shader));
				console.log(addLineNumbers(mShaderStr));
				return null;
			}

			return shader;
		}
	}, {
		key: '_attachShaderProgram',
		value: function _attachShaderProgram(mVertexShader, mFragmentShader) {

			this.shaderProgram = gl.createProgram();
			gl.attachShader(this.shaderProgram, mVertexShader);
			gl.attachShader(this.shaderProgram, mFragmentShader);

			gl.deleteShader(mVertexShader);
			gl.deleteShader(mFragmentShader);

			if (this._varyings) {
				console.log('Transform feedback setup : ', this._varyings);
				gl.transformFeedbackVaryings(this.shaderProgram, this._varyings, gl.SEPARATE_ATTRIBS);
			}

			gl.linkProgram(this.shaderProgram);
		}
	}]);

	return GLShader;
}();

GLShader.getUniformType = function (mValue) {
	var isArray = !!mValue.concat;

	var getArrayUniformType = function getArrayUniformType(mValue) {
		if (mValue.length === 9) {
			return 'uniformMatrix3fv';
		} else if (mValue.length === 16) {
			return 'uniformMatrix4fv';
		} else {
			return 'vec' + mValue.length;
		}
	};

	if (!isArray) {
		return 'float';
	} else {
		if (!mValue[0].concat) {
			return getArrayUniformType(mValue);
		} else {
			return getArrayUniformType(mValue[0]);
		}
	}
};

exports.default = GLShader;

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARRAY_TYPE", function() { return ARRAY_TYPE; });
/* harmony export (immutable) */ __webpack_exports__["setMatrixArrayType"] = setMatrixArrayType;
/* harmony export (immutable) */ __webpack_exports__["toRadian"] = toRadian;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

/**
 * Common utilities
 * @module glMatrix
 */

// Configuration Constants
const EPSILON = 0.000001;
/* harmony export (immutable) */ __webpack_exports__["EPSILON"] = EPSILON;

let ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
const RANDOM = Math.random;
/* harmony export (immutable) */ __webpack_exports__["RANDOM"] = RANDOM;


/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}

const degree = Math.PI / 180;

/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */
function toRadian(a) {
  return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
function equals(a, b) {
  return Math.abs(a - b) <= EPSILON*Math.max(1.0, Math.abs(a), Math.abs(b));
}


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _glMatrix = __webpack_require__(1);

var _getAttribLoc = __webpack_require__(25);

var _getAttribLoc2 = _interopRequireDefault(_getAttribLoc);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;
var STATIC_DRAW = 35044;

var getBuffer = function getBuffer(attr) {
	var buffer = void 0;

	if (attr.buffer !== undefined) {
		buffer = attr.buffer;
	} else {
		buffer = gl.createBuffer();
		attr.buffer = buffer;
	}

	return buffer;
};

var formBuffer = function formBuffer(mData, mNum) {
	var ary = [];

	for (var i = 0; i < mData.length; i += mNum) {
		var o = [];
		for (var j = 0; j < mNum; j++) {
			o.push(mData[i + j]);
		}

		ary.push(o);
	}

	return ary;
};

var Mesh = function () {
	function Mesh() {
		var mDrawingType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;
		var mUseVao = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

		_classCallCheck(this, Mesh);

		gl = _GLTool2.default.gl;
		this.drawType = mDrawingType;
		this._attributes = [];
		this._numInstance = -1;
		this._enabledVertexAttribute = [];

		this._indices = [];
		this._faces = [];
		this._bufferChanged = [];
		this._hasIndexBufferChanged = false;
		this._hasVAO = false;
		this._isInstanced = false;

		this._extVAO = !!_GLTool2.default.gl.createVertexArray;
		this._useVAO = !!this._extVAO && mUseVao;
		// this._useVAO = false;
	}

	_createClass(Mesh, [{
		key: 'bufferVertex',
		value: function bufferVertex(mArrayVertices) {
			var mDrawType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : STATIC_DRAW;


			this.bufferData(mArrayVertices, 'aVertexPosition', 3, mDrawType);

			if (this.normals.length < this.vertices.length) {
				this.bufferNormal(mArrayVertices, mDrawType);
			}

			return this;
		}
	}, {
		key: 'bufferTexCoord',
		value: function bufferTexCoord(mArrayTexCoords) {
			var mDrawType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : STATIC_DRAW;


			this.bufferData(mArrayTexCoords, 'aTextureCoord', 2, mDrawType);
			return this;
		}
	}, {
		key: 'bufferNormal',
		value: function bufferNormal(mNormals) {
			var mDrawType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : STATIC_DRAW;


			this.bufferData(mNormals, 'aNormal', 3, mDrawType);
			return this;
		}
	}, {
		key: 'bufferIndex',
		value: function bufferIndex(mArrayIndices) {
			var isDynamic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

			this._drawType = isDynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
			if (mArrayIndices instanceof Array) {
				this._indices = new Uint16Array(mArrayIndices);
			} else {
				this._indices = mArrayIndices;
			}

			this._numItems = this._indices.length;
			return this;
		}
	}, {
		key: 'bufferFlattenData',
		value: function bufferFlattenData(mData, mName, mItemSize) {
			var mDrawType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : STATIC_DRAW;
			var isInstanced = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;


			var data = formBuffer(mData, mItemSize);
			this.bufferData(data, mName, mItemSize, mDrawType = STATIC_DRAW, isInstanced = false);
			return this;
		}
	}, {
		key: 'bufferData',
		value: function bufferData(mData, mName, mItemSize) {
			var mDrawType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : STATIC_DRAW;
			var isInstanced = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

			var i = 0;
			var drawType = mDrawType;
			if (!drawType) debugger;

			var bufferData = [];
			if (!mItemSize) {
				mItemSize = mData[0].length;
			}
			this._isInstanced = isInstanced || this._isInstanced;

			//	flatten buffer data		
			for (i = 0; i < mData.length; i++) {
				for (var j = 0; j < mData[i].length; j++) {
					bufferData.push(mData[i][j]);
				}
			}
			var dataArray = new Float32Array(bufferData);
			var attribute = this.getAttribute(mName);

			if (attribute) {
				//	attribute existed, replace with new data
				attribute.itemSize = mItemSize;
				attribute.dataArray = dataArray;
				attribute.source = mData;
			} else {
				//	attribute not exist yet, create new attribute object
				this._attributes.push({ name: mName, source: mData, itemSize: mItemSize, drawType: drawType, dataArray: dataArray, isInstanced: isInstanced });
			}

			this._bufferChanged.push(mName);
			return this;
		}
	}, {
		key: 'bufferInstance',
		value: function bufferInstance(mData, mName) {
			if (!_GLTool2.default.gl.vertexAttribDivisor) {
				console.error('Extension : ANGLE_instanced_arrays is not supported with this device !');
				return;
			}

			var itemSize = mData[0].length;
			this._numInstance = mData.length;
			this.bufferData(mData, mName, itemSize, STATIC_DRAW, true);
		}
	}, {
		key: 'bind',
		value: function bind(mShaderProgram) {
			this.generateBuffers(mShaderProgram);

			if (this.hasVAO) {
				gl.bindVertexArray(this.vao);
			} else {
				this.attributes.forEach(function (attribute) {
					gl.bindBuffer(gl.ARRAY_BUFFER, attribute.buffer);
					var attrPosition = attribute.attrPosition;
					gl.vertexAttribPointer(attrPosition, attribute.itemSize, gl.FLOAT, false, 0, 0);

					if (attribute.isInstanced) {
						gl.vertexAttribDivisor(attrPosition, 1);
					}
				});

				//	BIND INDEX BUFFER
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.iBuffer);
			}
		}
	}, {
		key: 'generateBuffers',
		value: function generateBuffers(mShaderProgram) {
			var _this = this;

			if (this._bufferChanged.length == 0) {
				return;
			}

			if (this._useVAO) {
				//	IF SUPPORTED, CREATE VAO

				//	CREATE & BIND VAO
				if (!this._vao) {
					this._vao = gl.createVertexArray();
				}

				gl.bindVertexArray(this._vao);

				//	UPDATE BUFFERS
				this._attributes.forEach(function (attrObj) {

					if (_this._bufferChanged.indexOf(attrObj.name) !== -1) {
						var buffer = getBuffer(attrObj);
						gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
						gl.bufferData(gl.ARRAY_BUFFER, attrObj.dataArray, attrObj.drawType);

						var attrPosition = (0, _getAttribLoc2.default)(gl, mShaderProgram, attrObj.name);
						gl.enableVertexAttribArray(attrPosition);
						gl.vertexAttribPointer(attrPosition, attrObj.itemSize, gl.FLOAT, false, 0, 0);
						attrObj.attrPosition = attrPosition;

						if (attrObj.isInstanced) {
							gl.vertexAttribDivisor(attrPosition, 1);
						}
					}
				});

				//	check index buffer
				this._updateIndexBuffer();

				//	UNBIND VAO
				gl.bindVertexArray(null);

				this._hasVAO = true;
			} else {
				//	ELSE, USE TRADITIONAL METHOD

				this._attributes.forEach(function (attrObj) {
					//	SKIP IF BUFFER HASN'T CHANGED
					if (_this._bufferChanged.indexOf(attrObj.name) !== -1) {
						var buffer = getBuffer(attrObj);
						gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
						gl.bufferData(gl.ARRAY_BUFFER, attrObj.dataArray, attrObj.drawType);

						var attrPosition = (0, _getAttribLoc2.default)(gl, mShaderProgram, attrObj.name);
						gl.enableVertexAttribArray(attrPosition);
						gl.vertexAttribPointer(attrPosition, attrObj.itemSize, gl.FLOAT, false, 0, 0);
						attrObj.attrPosition = attrPosition;

						if (attrObj.isInstanced) {
							gl.vertexAttribDivisor(attrPosition, 1);
						}
					}
				});

				this._updateIndexBuffer();
			}

			this._hasIndexBufferChanged = false;
			this._bufferChanged = [];
		}
	}, {
		key: 'unbind',
		value: function unbind() {
			if (this._useVAO) {
				gl.bindVertexArray(null);
			}

			this._attributes.forEach(function (attribute) {
				if (attribute.isInstanced) {
					gl.vertexAttribDivisor(attribute.attrPosition, 0);
				}
			});
		}
	}, {
		key: '_updateIndexBuffer',
		value: function _updateIndexBuffer() {
			if (!this._hasIndexBufferChanged) {
				if (!this.iBuffer) {
					this.iBuffer = gl.createBuffer();
				}
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.iBuffer);
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indices, this._drawType);
				this.iBuffer.itemSize = 1;
				this.iBuffer.numItems = this._numItems;
			}
		}
	}, {
		key: 'computeNormals',
		value: function computeNormals() {
			var usingFaceNormals = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;


			this.generateFaces();

			if (usingFaceNormals) {
				this._computeFaceNormals();
			} else {
				this._computeVertexNormals();
			}
		}

		//	PRIVATE METHODS

	}, {
		key: '_computeFaceNormals',
		value: function _computeFaceNormals() {

			var faceIndex = void 0;
			var face = void 0;
			var normals = [];

			for (var i = 0; i < this._indices.length; i += 3) {
				faceIndex = i / 3;
				face = this._faces[faceIndex];
				var N = face.normal;

				normals[face.indices[0]] = N;
				normals[face.indices[1]] = N;
				normals[face.indices[2]] = N;
			}

			this.bufferNormal(normals);
		}
	}, {
		key: '_computeVertexNormals',
		value: function _computeVertexNormals() {
			//	loop through all vertices
			var face = void 0;
			var sumNormal = _glMatrix.vec3.create();
			var normals = [];
			var vertices = this.vertices;


			for (var i = 0; i < vertices.length; i++) {

				_glMatrix.vec3.set(sumNormal, 0, 0, 0);

				for (var j = 0; j < this._faces.length; j++) {
					face = this._faces[j];

					//	if vertex exist in the face, add the normal to sum normal
					if (face.indices.indexOf(i) >= 0) {

						sumNormal[0] += face.normal[0];
						sumNormal[1] += face.normal[1];
						sumNormal[2] += face.normal[2];
					}
				}

				_glMatrix.vec3.normalize(sumNormal, sumNormal);
				normals.push([sumNormal[0], sumNormal[1], sumNormal[2]]);
			}

			this.bufferNormal(normals);
		}
	}, {
		key: 'generateFaces',
		value: function generateFaces() {
			var ia = void 0,
			    ib = void 0,
			    ic = void 0;
			var a = void 0,
			    b = void 0,
			    c = void 0;
			var vba = _glMatrix.vec3.create(),
			    vca = _glMatrix.vec3.create(),
			    vNormal = _glMatrix.vec3.create();
			var vertices = this.vertices;


			for (var i = 0; i < this._indices.length; i += 3) {

				ia = this._indices[i];
				ib = this._indices[i + 1];
				ic = this._indices[i + 2];

				a = vertices[ia];
				b = vertices[ib];
				c = vertices[ic];

				var face = {
					indices: [ia, ib, ic],
					vertices: [a, b, c]
				};

				this._faces.push(face);
			}
		}
	}, {
		key: 'getAttribute',
		value: function getAttribute(mName) {
			return this._attributes.find(function (a) {
				return a.name === mName;
			});
		}
	}, {
		key: 'getSource',
		value: function getSource(mName) {
			var attr = this.getAttribute(mName);
			return attr ? attr.source : [];
		}

		//	GETTER AND SETTERS

	}, {
		key: 'vertices',
		get: function get() {
			return this.getSource('aVertexPosition');
		}
	}, {
		key: 'normals',
		get: function get() {
			return this.getSource('aNormal');
		}
	}, {
		key: 'coords',
		get: function get() {
			return this.getSource('aTextureCoord');
		}
	}, {
		key: 'indices',
		get: function get() {
			return this._indices;
		}
	}, {
		key: 'vertexSize',
		get: function get() {
			return this.vertices.length;
		}
	}, {
		key: 'faces',
		get: function get() {
			return this._faces;
		}
	}, {
		key: 'attributes',
		get: function get() {
			return this._attributes;
		}
	}, {
		key: 'hasVAO',
		get: function get() {
			return this._hasVAO;
		}
	}, {
		key: 'vao',
		get: function get() {
			return this._vao;
		}
	}, {
		key: 'numInstance',
		get: function get() {
			return this._numInstance;
		}
	}, {
		key: 'isInstanced',
		get: function get() {
			return this._isInstanced;
		}
	}]);

	return Mesh;
}();

exports.default = Mesh;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Batch.js

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Batch = function () {
	function Batch(mMesh, mShader) {
		_classCallCheck(this, Batch);

		this._mesh = mMesh;
		this._shader = mShader;
	}

	//	PUBLIC METHODS

	_createClass(Batch, [{
		key: 'draw',
		value: function draw() {
			this._shader.bind();
			_GLTool2.default.draw(this.mesh);
		}

		//	GETTER AND SETTER

	}, {
		key: 'mesh',
		get: function get() {
			return this._mesh;
		}
	}, {
		key: 'shader',
		get: function get() {
			return this._shader;
		}
	}]);

	return Batch;
}();

exports.default = Batch;

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
// Scheduler.js


class Scheduler {

	constructor() {
		this._delayTasks = [];
		this._nextTasks = [];
		this._deferTasks = [];
		this._highTasks = [];
		this._usurpTask = [];
		this._enterframeTasks = [];
		this._idTable = 0;
		this.frameRate = 60;
		this._startTime = new Date().getTime();

		this._deltaTime = 0;

		this._loop();
	}


	//  PUBLIC METHODS

	addEF(func, params) {
		params = params || [];
		const id = this._idTable;
		this._enterframeTasks[id] = { func, params };
		this._idTable ++;
		return id;
	}

	removeEF(id) {
		if (this._enterframeTasks[id] !== undefined) {
			this._enterframeTasks[id] = null;
		}
		return -1;
	}

	delay(func, params, delay) {
		const time = new Date().getTime();
		const t = { func, params, delay, time };
		this._delayTasks.push(t);
	}

	defer(func, params) {
		const t = { func, params };
		this._deferTasks.push(t);
	}

	next(func, params) {
		const t = { func, params };
		this._nextTasks.push(t);
	}

	usurp(func, params) {
		const t = { func, params };
		this._usurpTask.push(t);
	}


	//  PRIVATE METHODS

	_process() {
		let i = 0;
		let task;
		let interval;
		let current;
		for (i = 0; i < this._enterframeTasks.length; i++) {
			task = this._enterframeTasks[i];
			if (task !== null && task !== undefined) {
				task.func(task.params);
			}
		}

		while (this._highTasks.length > 0) {
			task = this._highTasks.pop();
			task.func(task.params);
		}


		let startTime = new Date().getTime();
		this._deltaTime = (startTime - this._startTime)/1000;

		for (i = 0; i < this._delayTasks.length; i++) {
			task = this._delayTasks[i];
			if (startTime - task.time > task.delay) {
				task.func(task.params);
				this._delayTasks.splice(i, 1);
			}
		}

		startTime = new Date().getTime();
		this._deltaTime = (startTime - this._startTime)/1000;
		interval = 1000 / this.frameRate;
		while (this._deferTasks.length > 0) {
			task = this._deferTasks.shift();
			current = new Date().getTime();
			if (current - startTime < interval) {
				task.func(task.params);
			} else {
				this._deferTasks.unshift(task);
				break;
			}
		}


		startTime = new Date().getTime();
		this._deltaTime = (startTime - this._startTime)/1000;
		interval = 1000 / this.frameRate;
		while (this._usurpTask.length > 0) {
			task = this._usurpTask.shift();
			current = new Date().getTime();
			if (current - startTime < interval) {
				task.func(task.params);
			}
		}

		this._highTasks = this._highTasks.concat(this._nextTasks);
		this._nextTasks = [];
		this._usurpTask = [];
	}


	_loop() {
		this._process();
		window.requestAnimationFrame(() => this._loop());
	}

	get deltaTime() {
		return this._deltaTime;
	}
}

const scheduler = new Scheduler();

/* harmony default export */ __webpack_exports__["default"] = (scheduler);


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Geom.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Mesh = __webpack_require__(4);

var _Mesh2 = _interopRequireDefault(_Mesh);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Geom = {};
var meshTri = void 0;

Geom.plane = function plane(width, height, numSegments) {
	var axis = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'xy';
	var drawType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 4;

	var positions = [];
	var coords = [];
	var indices = [];
	var normals = [];

	var gapX = width / numSegments;
	var gapY = height / numSegments;
	var gapUV = 1 / numSegments;
	var sx = -width * 0.5;
	var sy = -height * 0.5;
	var index = 0;

	for (var i = 0; i < numSegments; i++) {
		for (var j = 0; j < numSegments; j++) {
			var tx = gapX * i + sx;
			var ty = gapY * j + sy;

			var u = i / numSegments;
			var v = j / numSegments;

			if (axis === 'xz') {
				positions.push([tx, 0, ty + gapY]);
				positions.push([tx + gapX, 0, ty + gapY]);
				positions.push([tx + gapX, 0, ty]);
				positions.push([tx, 0, ty]);

				coords.push([u, 1.0 - (v + gapUV)]);
				coords.push([u + gapUV, 1.0 - (v + gapUV)]);
				coords.push([u + gapUV, 1.0 - v]);
				coords.push([u, 1.0 - v]);

				normals.push([0, 1, 0]);
				normals.push([0, 1, 0]);
				normals.push([0, 1, 0]);
				normals.push([0, 1, 0]);
			} else if (axis === 'yz') {
				positions.push([0, ty, tx]);
				positions.push([0, ty, tx + gapX]);
				positions.push([0, ty + gapY, tx + gapX]);
				positions.push([0, ty + gapY, tx]);

				coords.push([u, v]);
				coords.push([u + gapUV, v]);
				coords.push([u + gapUV, v + gapUV]);
				coords.push([u, v + gapUV]);

				normals.push([1, 0, 0]);
				normals.push([1, 0, 0]);
				normals.push([1, 0, 0]);
				normals.push([1, 0, 0]);
			} else {
				positions.push([tx, ty, 0]);
				positions.push([tx + gapX, ty, 0]);
				positions.push([tx + gapX, ty + gapY, 0]);
				positions.push([tx, ty + gapY, 0]);

				coords.push([u, v]);
				coords.push([u + gapUV, v]);
				coords.push([u + gapUV, v + gapUV]);
				coords.push([u, v + gapUV]);

				normals.push([0, 0, 1]);
				normals.push([0, 0, 1]);
				normals.push([0, 0, 1]);
				normals.push([0, 0, 1]);
			}

			indices.push(index * 4 + 0);
			indices.push(index * 4 + 1);
			indices.push(index * 4 + 2);
			indices.push(index * 4 + 0);
			indices.push(index * 4 + 2);
			indices.push(index * 4 + 3);

			index++;
		}
	}

	var mesh = new _Mesh2.default(drawType);
	mesh.bufferVertex(positions);
	mesh.bufferTexCoord(coords);
	mesh.bufferIndex(indices);
	mesh.bufferNormal(normals);

	return mesh;
};

Geom.sphere = function sphere(size, numSegments) {
	var isInvert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	var drawType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 4;

	var positions = [];
	var coords = [];
	var indices = [];
	var normals = [];
	var gapUV = 1 / numSegments;
	var index = 0;

	function getPosition(i, j) {
		var isNormal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
		//	rx : -90 ~ 90 , ry : 0 ~ 360
		var rx = i / numSegments * Math.PI - Math.PI * 0.5;
		var ry = j / numSegments * Math.PI * 2;
		var r = isNormal ? 1 : size;
		var pos = [];
		pos[1] = Math.sin(rx) * r;
		var t = Math.cos(rx) * r;
		pos[0] = Math.cos(ry) * t;
		pos[2] = Math.sin(ry) * t;

		var precision = 10000;
		pos[0] = Math.floor(pos[0] * precision) / precision;
		pos[1] = Math.floor(pos[1] * precision) / precision;
		pos[2] = Math.floor(pos[2] * precision) / precision;

		return pos;
	};

	for (var i = 0; i < numSegments; i++) {
		for (var j = 0; j < numSegments; j++) {
			positions.push(getPosition(i, j));
			positions.push(getPosition(i + 1, j));
			positions.push(getPosition(i + 1, j + 1));
			positions.push(getPosition(i, j + 1));

			normals.push(getPosition(i, j, true));
			normals.push(getPosition(i + 1, j, true));
			normals.push(getPosition(i + 1, j + 1, true));
			normals.push(getPosition(i, j + 1, true));

			var u = j / numSegments;
			var v = i / numSegments;

			coords.push([1.0 - u, v]);
			coords.push([1.0 - u, v + gapUV]);
			coords.push([1.0 - u - gapUV, v + gapUV]);
			coords.push([1.0 - u - gapUV, v]);

			indices.push(index * 4 + 0);
			indices.push(index * 4 + 1);
			indices.push(index * 4 + 2);
			indices.push(index * 4 + 0);
			indices.push(index * 4 + 2);
			indices.push(index * 4 + 3);

			index++;
		}
	}

	if (isInvert) {
		indices.reverse();
	}

	var mesh = new _Mesh2.default(drawType);
	mesh.bufferVertex(positions);
	mesh.bufferTexCoord(coords);
	mesh.bufferIndex(indices);
	mesh.bufferNormal(normals);

	return mesh;
};

Geom.cube = function cube(w, h, d) {
	var drawType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 4;

	h = h || w;
	d = d || w;

	var x = w / 2;
	var y = h / 2;
	var z = d / 2;

	var positions = [];
	var coords = [];
	var indices = [];
	var normals = [];
	var count = 0;

	// BACK
	positions.push([-x, y, -z]);
	positions.push([x, y, -z]);
	positions.push([x, -y, -z]);
	positions.push([-x, -y, -z]);

	normals.push([0, 0, -1]);
	normals.push([0, 0, -1]);
	normals.push([0, 0, -1]);
	normals.push([0, 0, -1]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// RIGHT
	positions.push([x, y, -z]);
	positions.push([x, y, z]);
	positions.push([x, -y, z]);
	positions.push([x, -y, -z]);

	normals.push([1, 0, 0]);
	normals.push([1, 0, 0]);
	normals.push([1, 0, 0]);
	normals.push([1, 0, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// FRONT
	positions.push([x, y, z]);
	positions.push([-x, y, z]);
	positions.push([-x, -y, z]);
	positions.push([x, -y, z]);

	normals.push([0, 0, 1]);
	normals.push([0, 0, 1]);
	normals.push([0, 0, 1]);
	normals.push([0, 0, 1]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// LEFT
	positions.push([-x, y, z]);
	positions.push([-x, y, -z]);
	positions.push([-x, -y, -z]);
	positions.push([-x, -y, z]);

	normals.push([-1, 0, 0]);
	normals.push([-1, 0, 0]);
	normals.push([-1, 0, 0]);
	normals.push([-1, 0, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// TOP
	positions.push([x, y, -z]);
	positions.push([-x, y, -z]);
	positions.push([-x, y, z]);
	positions.push([x, y, z]);

	normals.push([0, 1, 0]);
	normals.push([0, 1, 0]);
	normals.push([0, 1, 0]);
	normals.push([0, 1, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// BOTTOM
	positions.push([x, -y, z]);
	positions.push([-x, -y, z]);
	positions.push([-x, -y, -z]);
	positions.push([x, -y, -z]);

	normals.push([0, -1, 0]);
	normals.push([0, -1, 0]);
	normals.push([0, -1, 0]);
	normals.push([0, -1, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	var mesh = new _Mesh2.default(drawType);
	mesh.bufferVertex(positions);
	mesh.bufferTexCoord(coords);
	mesh.bufferIndex(indices);
	mesh.bufferNormal(normals);

	return mesh;
};

Geom.skybox = function skybox(size) {
	var drawType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;

	var positions = [];
	var coords = [];
	var indices = [];
	var normals = [];
	var count = 0;

	// BACK
	positions.push([size, size, -size]);
	positions.push([-size, size, -size]);
	positions.push([-size, -size, -size]);
	positions.push([size, -size, -size]);

	normals.push([0, 0, -1]);
	normals.push([0, 0, -1]);
	normals.push([0, 0, -1]);
	normals.push([0, 0, -1]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// RIGHT
	positions.push([size, -size, -size]);
	positions.push([size, -size, size]);
	positions.push([size, size, size]);
	positions.push([size, size, -size]);

	normals.push([1, 0, 0]);
	normals.push([1, 0, 0]);
	normals.push([1, 0, 0]);
	normals.push([1, 0, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// FRONT
	positions.push([-size, size, size]);
	positions.push([size, size, size]);
	positions.push([size, -size, size]);
	positions.push([-size, -size, size]);

	normals.push([0, 0, 1]);
	normals.push([0, 0, 1]);
	normals.push([0, 0, 1]);
	normals.push([0, 0, 1]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// LEFT
	positions.push([-size, -size, size]);
	positions.push([-size, -size, -size]);
	positions.push([-size, size, -size]);
	positions.push([-size, size, size]);

	normals.push([-1, 0, 0]);
	normals.push([-1, 0, 0]);
	normals.push([-1, 0, 0]);
	normals.push([-1, 0, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// TOP
	positions.push([size, size, size]);
	positions.push([-size, size, size]);
	positions.push([-size, size, -size]);
	positions.push([size, size, -size]);

	normals.push([0, 1, 0]);
	normals.push([0, 1, 0]);
	normals.push([0, 1, 0]);
	normals.push([0, 1, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// BOTTOM
	positions.push([size, -size, -size]);
	positions.push([-size, -size, -size]);
	positions.push([-size, -size, size]);
	positions.push([size, -size, size]);

	normals.push([0, -1, 0]);
	normals.push([0, -1, 0]);
	normals.push([0, -1, 0]);
	normals.push([0, -1, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	var mesh = new _Mesh2.default(drawType);
	mesh.bufferVertex(positions);
	mesh.bufferTexCoord(coords);
	mesh.bufferIndex(indices);
	mesh.bufferNormal(normals);

	return mesh;
};

Geom.bigTriangle = function bigTriangle() {

	if (!meshTri) {
		var indices = [2, 1, 0];
		var positions = [[-1, -1], [-1, 4], [4, -1]];

		meshTri = new _Mesh2.default();
		meshTri.bufferData(positions, 'aPosition', 2);
		meshTri.bufferIndex(indices);
	}

	return meshTri;
};

exports.default = Geom;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// stolen there https://github.com/mattdesl/gl-constants thanks @mattdesl ^^
module.exports = {
	0: 'NONE',
	1: 'ONE',
	2: 'LINE_LOOP',
	3: 'LINE_STRIP',
	4: 'TRIANGLES',
	5: 'TRIANGLE_STRIP',
	6: 'TRIANGLE_FAN',
	256: 'DEPTH_BUFFER_BIT',
	512: 'NEVER',
	513: 'LESS',
	514: 'EQUAL',
	515: 'LEQUAL',
	516: 'GREATER',
	517: 'NOTEQUAL',
	518: 'GEQUAL',
	519: 'ALWAYS',
	768: 'SRC_COLOR',
	769: 'ONE_MINUS_SRC_COLOR',
	770: 'SRC_ALPHA',
	771: 'ONE_MINUS_SRC_ALPHA',
	772: 'DST_ALPHA',
	773: 'ONE_MINUS_DST_ALPHA',
	774: 'DST_COLOR',
	775: 'ONE_MINUS_DST_COLOR',
	776: 'SRC_ALPHA_SATURATE',
	1024: 'STENCIL_BUFFER_BIT',
	1028: 'FRONT',
	1029: 'BACK',
	1032: 'FRONT_AND_BACK',
	1280: 'INVALID_ENUM',
	1281: 'INVALID_VALUE',
	1282: 'INVALID_OPERATION',
	1285: 'OUT_OF_MEMORY',
	1286: 'INVALID_FRAMEBUFFER_OPERATION',
	2304: 'CW',
	2305: 'CCW',
	2849: 'LINE_WIDTH',
	2884: 'CULL_FACE',
	2885: 'CULL_FACE_MODE',
	2886: 'FRONT_FACE',
	2928: 'DEPTH_RANGE',
	2929: 'DEPTH_TEST',
	2930: 'DEPTH_WRITEMASK',
	2931: 'DEPTH_CLEAR_VALUE',
	2932: 'DEPTH_FUNC',
	2960: 'STENCIL_TEST',
	2961: 'STENCIL_CLEAR_VALUE',
	2962: 'STENCIL_FUNC',
	2963: 'STENCIL_VALUE_MASK',
	2964: 'STENCIL_FAIL',
	2965: 'STENCIL_PASS_DEPTH_FAIL',
	2966: 'STENCIL_PASS_DEPTH_PASS',
	2967: 'STENCIL_REF',
	2968: 'STENCIL_WRITEMASK',
	2978: 'VIEWPORT',
	3024: 'DITHER',
	3042: 'BLEND',
	3088: 'SCISSOR_BOX',
	3089: 'SCISSOR_TEST',
	3106: 'COLOR_CLEAR_VALUE',
	3107: 'COLOR_WRITEMASK',
	3317: 'UNPACK_ALIGNMENT',
	3333: 'PACK_ALIGNMENT',
	3379: 'MAX_TEXTURE_SIZE',
	3386: 'MAX_VIEWPORT_DIMS',
	3408: 'SUBPIXEL_BITS',
	3410: 'RED_BITS',
	3411: 'GREEN_BITS',
	3412: 'BLUE_BITS',
	3413: 'ALPHA_BITS',
	3414: 'DEPTH_BITS',
	3415: 'STENCIL_BITS',
	3553: 'TEXTURE_2D',
	4352: 'DONT_CARE',
	4353: 'FASTEST',
	4354: 'NICEST',
	5120: 'BYTE',
	5121: 'UNSIGNED_BYTE',
	5122: 'SHORT',
	5123: 'UNSIGNED_SHORT',
	5124: 'INT',
	5125: 'UNSIGNED_INT',
	5126: 'FLOAT',
	5386: 'INVERT',
	5890: 'TEXTURE',
	6401: 'STENCIL_INDEX',
	6402: 'DEPTH_COMPONENT',
	6403: 'RED',
	6406: 'ALPHA',
	6407: 'RGB',
	6408: 'RGBA',
	6409: 'LUMINANCE',
	6410: 'LUMINANCE_ALPHA',
	7680: 'KEEP',
	7681: 'REPLACE',
	7682: 'INCR',
	7683: 'DECR',
	7936: 'VENDOR',
	7937: 'RENDERER',
	7938: 'VERSION',
	9728: 'NEAREST',
	9729: 'LINEAR',
	9984: 'NEAREST_MIPMAP_NEAREST',
	9985: 'LINEAR_MIPMAP_NEAREST',
	9986: 'NEAREST_MIPMAP_LINEAR',
	9987: 'LINEAR_MIPMAP_LINEAR',
	10240: 'TEXTURE_MAG_FILTER',
	10241: 'TEXTURE_MIN_FILTER',
	10242: 'TEXTURE_WRAP_S',
	10243: 'TEXTURE_WRAP_T',
	10497: 'REPEAT',
	10752: 'POLYGON_OFFSET_UNITS',
	16384: 'COLOR_BUFFER_BIT',
	32769: 'CONSTANT_COLOR',
	32770: 'ONE_MINUS_CONSTANT_COLOR',
	32771: 'CONSTANT_ALPHA',
	32772: 'ONE_MINUS_CONSTANT_ALPHA',
	32773: 'BLEND_COLOR',
	32774: 'FUNC_ADD',
	32777: 'BLEND_EQUATION_RGB',
	32778: 'FUNC_SUBTRACT',
	32779: 'FUNC_REVERSE_SUBTRACT',
	32819: 'UNSIGNED_SHORT_4_4_4_4',
	32820: 'UNSIGNED_SHORT_5_5_5_1',
	32823: 'POLYGON_OFFSET_FILL',
	32824: 'POLYGON_OFFSET_FACTOR',
	32854: 'RGBA4',
	32855: 'RGB5_A1',
	32873: 'TEXTURE_BINDING_2D',
	32926: 'SAMPLE_ALPHA_TO_COVERAGE',
	32928: 'SAMPLE_COVERAGE',
	32936: 'SAMPLE_BUFFERS',
	32937: 'SAMPLES',
	32938: 'SAMPLE_COVERAGE_VALUE',
	32939: 'SAMPLE_COVERAGE_INVERT',
	32968: 'BLEND_DST_RGB',
	32969: 'BLEND_SRC_RGB',
	32970: 'BLEND_DST_ALPHA',
	32971: 'BLEND_SRC_ALPHA',
	33071: 'CLAMP_TO_EDGE',
	33170: 'GENERATE_MIPMAP_HINT',
	33189: 'DEPTH_COMPONENT16',
	33306: 'DEPTH_STENCIL_ATTACHMENT',
	33321: 'R8',
	33635: 'UNSIGNED_SHORT_5_6_5',
	33648: 'MIRRORED_REPEAT',
	33901: 'ALIASED_POINT_SIZE_RANGE',
	33902: 'ALIASED_LINE_WIDTH_RANGE',
	33984: 'TEXTURE0',
	33985: 'TEXTURE1',
	33986: 'TEXTURE2',
	33987: 'TEXTURE3',
	33988: 'TEXTURE4',
	33989: 'TEXTURE5',
	33990: 'TEXTURE6',
	33991: 'TEXTURE7',
	33992: 'TEXTURE8',
	33993: 'TEXTURE9',
	33994: 'TEXTURE10',
	33995: 'TEXTURE11',
	33996: 'TEXTURE12',
	33997: 'TEXTURE13',
	33998: 'TEXTURE14',
	33999: 'TEXTURE15',
	34000: 'TEXTURE16',
	34001: 'TEXTURE17',
	34002: 'TEXTURE18',
	34003: 'TEXTURE19',
	34004: 'TEXTURE20',
	34005: 'TEXTURE21',
	34006: 'TEXTURE22',
	34007: 'TEXTURE23',
	34008: 'TEXTURE24',
	34009: 'TEXTURE25',
	34010: 'TEXTURE26',
	34011: 'TEXTURE27',
	34012: 'TEXTURE28',
	34013: 'TEXTURE29',
	34014: 'TEXTURE30',
	34015: 'TEXTURE31',
	34016: 'ACTIVE_TEXTURE',
	34024: 'MAX_RENDERBUFFER_SIZE',
	34041: 'DEPTH_STENCIL',
	34055: 'INCR_WRAP',
	34056: 'DECR_WRAP',
	34067: 'TEXTURE_CUBE_MAP',
	34068: 'TEXTURE_BINDING_CUBE_MAP',
	34069: 'TEXTURE_CUBE_MAP_POSITIVE_X',
	34070: 'TEXTURE_CUBE_MAP_NEGATIVE_X',
	34071: 'TEXTURE_CUBE_MAP_POSITIVE_Y',
	34072: 'TEXTURE_CUBE_MAP_NEGATIVE_Y',
	34073: 'TEXTURE_CUBE_MAP_POSITIVE_Z',
	34074: 'TEXTURE_CUBE_MAP_NEGATIVE_Z',
	34076: 'MAX_CUBE_MAP_TEXTURE_SIZE',
	34338: 'VERTEX_ATTRIB_ARRAY_ENABLED',
	34339: 'VERTEX_ATTRIB_ARRAY_SIZE',
	34340: 'VERTEX_ATTRIB_ARRAY_STRIDE',
	34341: 'VERTEX_ATTRIB_ARRAY_TYPE',
	34342: 'CURRENT_VERTEX_ATTRIB',
	34373: 'VERTEX_ATTRIB_ARRAY_POINTER',
	34466: 'NUM_COMPRESSED_TEXTURE_FORMATS',
	34467: 'COMPRESSED_TEXTURE_FORMATS',
	34660: 'BUFFER_SIZE',
	34661: 'BUFFER_USAGE',
	34816: 'STENCIL_BACK_FUNC',
	34817: 'STENCIL_BACK_FAIL',
	34818: 'STENCIL_BACK_PASS_DEPTH_FAIL',
	34819: 'STENCIL_BACK_PASS_DEPTH_PASS',
	34877: 'BLEND_EQUATION_ALPHA',
	34921: 'MAX_VERTEX_ATTRIBS',
	34922: 'VERTEX_ATTRIB_ARRAY_NORMALIZED',
	34930: 'MAX_TEXTURE_IMAGE_UNITS',
	34962: 'ARRAY_BUFFER',
	34963: 'ELEMENT_ARRAY_BUFFER',
	34964: 'ARRAY_BUFFER_BINDING',
	34965: 'ELEMENT_ARRAY_BUFFER_BINDING',
	34975: 'VERTEX_ATTRIB_ARRAY_BUFFER_BINDING',
	35040: 'STREAM_DRAW',
	35044: 'STATIC_DRAW',
	35048: 'DYNAMIC_DRAW',
	35632: 'FRAGMENT_SHADER',
	35633: 'VERTEX_SHADER',
	35660: 'MAX_VERTEX_TEXTURE_IMAGE_UNITS',
	35661: 'MAX_COMBINED_TEXTURE_IMAGE_UNITS',
	35663: 'SHADER_TYPE',
	35664: 'FLOAT_VEC2',
	35665: 'FLOAT_VEC3',
	35666: 'FLOAT_VEC4',
	35667: 'INT_VEC2',
	35668: 'INT_VEC3',
	35669: 'INT_VEC4',
	35670: 'BOOL',
	35671: 'BOOL_VEC2',
	35672: 'BOOL_VEC3',
	35673: 'BOOL_VEC4',
	35674: 'FLOAT_MAT2',
	35675: 'FLOAT_MAT3',
	35676: 'FLOAT_MAT4',
	35678: 'SAMPLER_2D',
	35680: 'SAMPLER_CUBE',
	35712: 'DELETE_STATUS',
	35713: 'COMPILE_STATUS',
	35714: 'LINK_STATUS',
	35715: 'VALIDATE_STATUS',
	35716: 'INFO_LOG_LENGTH',
	35717: 'ATTACHED_SHADERS',
	35718: 'ACTIVE_UNIFORMS',
	35719: 'ACTIVE_UNIFORM_MAX_LENGTH',
	35720: 'SHADER_SOURCE_LENGTH',
	35721: 'ACTIVE_ATTRIBUTES',
	35722: 'ACTIVE_ATTRIBUTE_MAX_LENGTH',
	35724: 'SHADING_LANGUAGE_VERSION',
	35725: 'CURRENT_PROGRAM',
	36003: 'STENCIL_BACK_REF',
	36004: 'STENCIL_BACK_VALUE_MASK',
	36005: 'STENCIL_BACK_WRITEMASK',
	36006: 'FRAMEBUFFER_BINDING',
	36007: 'RENDERBUFFER_BINDING',
	36048: 'FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE',
	36049: 'FRAMEBUFFER_ATTACHMENT_OBJECT_NAME',
	36050: 'FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL',
	36051: 'FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE',
	36053: 'FRAMEBUFFER_COMPLETE',
	36054: 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT',
	36055: 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT',
	36057: 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS',
	36061: 'FRAMEBUFFER_UNSUPPORTED',
	36064: 'COLOR_ATTACHMENT0',
	36096: 'DEPTH_ATTACHMENT',
	36128: 'STENCIL_ATTACHMENT',
	36160: 'FRAMEBUFFER',
	36161: 'RENDERBUFFER',
	36162: 'RENDERBUFFER_WIDTH',
	36163: 'RENDERBUFFER_HEIGHT',
	36164: 'RENDERBUFFER_INTERNAL_FORMAT',
	36168: 'STENCIL_INDEX8',
	36176: 'RENDERBUFFER_RED_SIZE',
	36177: 'RENDERBUFFER_GREEN_SIZE',
	36178: 'RENDERBUFFER_BLUE_SIZE',
	36179: 'RENDERBUFFER_ALPHA_SIZE',
	36180: 'RENDERBUFFER_DEPTH_SIZE',
	36181: 'RENDERBUFFER_STENCIL_SIZE',
	36194: 'RGB565',
	36336: 'LOW_FLOAT',
	36337: 'MEDIUM_FLOAT',
	36338: 'HIGH_FLOAT',
	36339: 'LOW_INT',
	36340: 'MEDIUM_INT',
	36341: 'HIGH_INT',
	36346: 'SHADER_COMPILER',
	36347: 'MAX_VERTEX_UNIFORM_VECTORS',
	36348: 'MAX_VARYING_VECTORS',
	36349: 'MAX_FRAGMENT_UNIFORM_VECTORS',
	37440: 'UNPACK_FLIP_Y_WEBGL',
	37441: 'UNPACK_PREMULTIPLY_ALPHA_WEBGL',
	37442: 'CONTEXT_LOST_WEBGL',
	37443: 'UNPACK_COLORSPACE_CONVERSION_WEBGL',
	37444: 'BROWSER_DEFAULT_WEBGL'
};

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Pass.js

var _GLShader = __webpack_require__(2);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _FrameBuffer = __webpack_require__(12);

var _FrameBuffer2 = _interopRequireDefault(_FrameBuffer);

var _ShaderLibs = __webpack_require__(33);

var _ShaderLibs2 = _interopRequireDefault(_ShaderLibs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Pass = function () {
	function Pass(mSource) {
		var mWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
		var mHeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
		var mParams = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

		_classCallCheck(this, Pass);

		this.shader = new _GLShader2.default(_ShaderLibs2.default.bigTriangleVert, mSource);

		this._width = mWidth;
		this._height = mHeight;
		this._uniforms = {};
		this._hasOwnFbo = this._width > 0 && this._width > 0;
		this._uniforms = {};

		if (this._hasOwnFbo) {
			this._fbo = new _FrameBuffer2.default(this._width, this.height, mParmas);
		}
	}

	_createClass(Pass, [{
		key: 'uniform',
		value: function uniform(mName, mValue) {
			this._uniforms[mName] = mValue;
		}
	}, {
		key: 'render',
		value: function render(texture) {
			this.shader.bind();
			this.shader.uniform('texture', 'uniform1i', 0);
			texture.bind(0);

			this.shader.uniform(this._uniforms);
		}
	}, {
		key: 'width',
		get: function get() {
			return this._width;
		}
	}, {
		key: 'height',
		get: function get() {
			return this._height;
		}
	}, {
		key: 'fbo',
		get: function get() {
			return this._fbo;
		}
	}, {
		key: 'hasFbo',
		get: function get() {
			return this._hasOwnFbo;
		}
	}]);

	return Pass;
}();

exports.default = Pass;

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = "// simpleColor.frag\n\n#define SHADER_NAME SIMPLE_COLOR\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform vec3 color;\nuniform float opacity;\n\nvoid main(void) {\n    gl_FragColor = vec4(color, opacity);\n}"

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = "// basic.vert\n\n#define SHADER_NAME BASIC_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);\n    vTextureCoord = aTextureCoord;\n    vNormal = aNormal;\n}"

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // FrameBuffer.js

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _GLTexture = __webpack_require__(27);

var _GLTexture2 = _interopRequireDefault(_GLTexture);

var _WebglNumber = __webpack_require__(8);

var _WebglNumber2 = _interopRequireDefault(_WebglNumber);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;
var webglDepthTexture = void 0;
var hasCheckedMultiRenderSupport = false;
var extDrawBuffer = void 0;

var checkMultiRender = function checkMultiRender() {
	if (_GLTool2.default.webgl2) {
		return true;
	} else {
		extDrawBuffer = _GLTool2.default.getExtension('WEBGL_draw_buffers');
		return !!extDrawBuffer;
	}

	hasCheckedMultiRenderSupport = true;
};

var FrameBuffer = function () {
	function FrameBuffer(mWidth, mHeight) {
		var mParameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
		var mNumTargets = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

		_classCallCheck(this, FrameBuffer);

		gl = _GLTool2.default.gl;
		webglDepthTexture = _GLTool2.default.checkExtension('WEBGL_depth_texture');

		this.width = mWidth;
		this.height = mHeight;
		this._numTargets = mNumTargets;
		this._multipleTargets = mNumTargets > 1;
		this._parameters = mParameters;

		if (!hasCheckedMultiRenderSupport) {
			checkMultiRender();
		}

		if (this._multipleTargets) {
			this._checkMaxNumRenderTarget();
		}

		this._init();
	}

	_createClass(FrameBuffer, [{
		key: '_init',
		value: function _init() {
			this._initTextures();

			this.frameBuffer = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);

			if (_GLTool2.default.webgl2) {
				// this.renderBufferDepth = gl.createRenderbuffer();
				// gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBufferDepth);
				// gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.width, this.height);
				// gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.renderBufferDepth);

				var buffers = [];
				for (var i = 0; i < this._numTargets; i++) {
					gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, this._textures[i].texture, 0);
					buffers.push(gl['COLOR_ATTACHMENT' + i]);
				}

				gl.drawBuffers(buffers);

				gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.glDepthTexture.texture, 0);
			} else {
				for (var _i = 0; _i < this._numTargets; _i++) {
					gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + _i, gl.TEXTURE_2D, this._textures[_i].texture, 0);
				}

				if (this._multipleTargets) {
					var drawBuffers = [];
					for (var _i2 = 0; _i2 < this._numTargets; _i2++) {
						drawBuffers.push(extDrawBuffer['COLOR_ATTACHMENT' + _i2 + '_WEBGL']);
					}

					extDrawBuffer.drawBuffersWEBGL(drawBuffers);
				}

				if (webglDepthTexture) {
					gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.glDepthTexture.texture, 0);
				}
			}

			//	CHECKING FBO
			var FBOstatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
			if (FBOstatus != gl.FRAMEBUFFER_COMPLETE) {
				console.error('GL_FRAMEBUFFER_COMPLETE failed, CANNOT use Framebuffer', _WebglNumber2.default[FBOstatus]);
			}

			//	UNBIND

			gl.bindTexture(gl.TEXTURE_2D, null);
			gl.bindRenderbuffer(gl.RENDERBUFFER, null);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			//	CLEAR FRAMEBUFFER 

			this.clear();
		}
	}, {
		key: '_checkMaxNumRenderTarget',
		value: function _checkMaxNumRenderTarget() {
			var maxNumDrawBuffers = _GLTool2.default.gl.getParameter(extDrawBuffer.MAX_DRAW_BUFFERS_WEBGL);
			if (this._numTargets > maxNumDrawBuffers) {
				console.error('Over max number of draw buffers supported : ', maxNumDrawBuffers);
				this._numTargets = maxNumDrawBuffers;
			}
		}
	}, {
		key: '_initTextures',
		value: function _initTextures() {
			this._textures = [];
			for (var i = 0; i < this._numTargets; i++) {
				var glt = this._createTexture();
				this._textures.push(glt);
			}

			if (_GLTool2.default.webgl2) {
				this.glDepthTexture = this._createTexture(gl.DEPTH_COMPONENT16, gl.UNSIGNED_SHORT, gl.DEPTH_COMPONENT, true);
			} else {
				this.glDepthTexture = this._createTexture(gl.DEPTH_COMPONENT, gl.UNSIGNED_SHORT, gl.DEPTH_COMPONENT, { minFilter: _GLTool2.default.LINEAR });
			}
		}
	}, {
		key: '_createTexture',
		value: function _createTexture(mInternalformat, mTexelType, mFormat) {
			var mParameters = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

			var parameters = Object.assign({}, this._parameters);
			if (!mFormat) {
				mFormat = mInternalformat;
			}

			parameters.internalFormat = mInternalformat || gl.RGBA;
			parameters.format = mFormat;
			parameters.type = mTexelType || parameters.type || _GLTool2.default.UNSIGNED_BYTE;
			for (var s in mParameters) {
				parameters[s] = mParameters[s];
			}

			var texture = new _GLTexture2.default(null, parameters, this.width, this.height);
			return texture;
		}

		//	PUBLIC METHODS

	}, {
		key: 'bind',
		value: function bind() {
			var mAutoSetViewport = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			if (mAutoSetViewport) {
				_GLTool2.default.viewport(0, 0, this.width, this.height);
			}
			gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
		}
	}, {
		key: 'unbind',
		value: function unbind() {
			var mAutoSetViewport = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			if (mAutoSetViewport) {
				_GLTool2.default.viewport(0, 0, _GLTool2.default.width, _GLTool2.default.height);
			}
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			this._textures.forEach(function (texture) {
				texture.generateMipmap();
			});
		}
	}, {
		key: 'clear',
		value: function clear() {
			var r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
			var g = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
			var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
			var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

			this.bind();
			_GLTool2.default.clear(r, g, b, a);
			this.unbind();
		}

		//	TEXTURES

	}, {
		key: 'getTexture',
		value: function getTexture() {
			var mIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

			return this._textures[mIndex];
		}
	}, {
		key: 'getDepthTexture',
		value: function getDepthTexture() {
			return this.glDepthTexture;
		}

		//	TOUGHTS : Should I remove these from frame buffer ? 
		//	Shouldn't these be set individually to each texture ? 
		//	e.g. fbo.getTexture(0).minFilter = GL.NEAREST;
		//		 fbo.getTexture(1).minFilter = GL.LINEAR; ... etc ? 

		//	MIPMAP FILTER

	}, {
		key: 'showParameters',


		//	UTILS

		value: function showParameters() {
			this._textures[0].showParameters();
		}
	}, {
		key: 'minFilter',
		get: function get() {
			return this._textures[0].minFilter;
		},
		set: function set(mValue) {
			this._textures.forEach(function (texture) {
				texture.minFilter = mValue;
			});
		}
	}, {
		key: 'magFilter',
		get: function get() {
			return this._textures[0].magFilter;
		},
		set: function set(mValue) {
			this._textures.forEach(function (texture) {
				texture.magFilter = mValue;
			});
		}

		//	WRAPPING

	}, {
		key: 'wrapS',
		get: function get() {
			return this._textures[0].wrapS;
		},
		set: function set(mValue) {
			this._textures.forEach(function (texture) {
				texture.wrapS = mValue;
			});
		}
	}, {
		key: 'wrapT',
		get: function get() {
			return this._textures[0].wrapT;
		},
		set: function set(mValue) {
			this._textures.forEach(function (texture) {
				texture.wrapT = mValue;
			});
		}
	}, {
		key: 'numTargets',
		get: function get() {
			return this._numTargets;
		}
	}]);

	return FrameBuffer;
}();

exports.default = FrameBuffer;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // EaseNumber.js

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EaseNumber = function () {
	function EaseNumber(mValue) {
		var _this = this;

		var mEasing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;

		_classCallCheck(this, EaseNumber);

		this.easing = mEasing;
		this._value = mValue;
		this._targetValue = mValue;
		this._efIndex = _scheduling2.default.addEF(function () {
			return _this._update();
		});
	}

	_createClass(EaseNumber, [{
		key: '_update',
		value: function _update() {
			var MIN_DIFF = 0.0001;
			this._checkLimit();
			this._value += (this._targetValue - this._value) * this.easing;
			if (Math.abs(this._targetValue - this._value) < MIN_DIFF) {
				this._value = this._targetValue;
			}
		}
	}, {
		key: 'setTo',
		value: function setTo(mValue) {
			this._targetValue = this._value = mValue;
		}
	}, {
		key: 'add',
		value: function add(mAdd) {
			this._targetValue += mAdd;
		}
	}, {
		key: 'limit',
		value: function limit(mMin, mMax) {
			if (mMin > mMax) {
				this.limit(mMax, mMin);
				return;
			}

			this._min = mMin;
			this._max = mMax;

			this._checkLimit();
		}
	}, {
		key: '_checkLimit',
		value: function _checkLimit() {
			if (this._min !== undefined && this._targetValue < this._min) {
				this._targetValue = this._min;
			}

			if (this._max !== undefined && this._targetValue > this._max) {
				this._targetValue = this._max;
			}
		}
	}, {
		key: 'destroy',
		value: function destroy() {
			_scheduling2.default.removeEF(this._efIndex);
		}

		//	GETTERS / SETTERS

	}, {
		key: 'value',
		set: function set(mValue) {
			this._targetValue = mValue;
		},
		get: function get() {
			return this._value;
		}
	}, {
		key: 'targetValue',
		get: function get() {
			return this._targetValue;
		}
	}]);

	return EaseNumber;
}();

exports.default = EaseNumber;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Ray.js

var _glMatrix = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var a = _glMatrix.vec3.create();
var b = _glMatrix.vec3.create();
var c = _glMatrix.vec3.create();
var target = _glMatrix.vec3.create();
var edge1 = _glMatrix.vec3.create();
var edge2 = _glMatrix.vec3.create();
var normal = _glMatrix.vec3.create();
var diff = _glMatrix.vec3.create();

var Ray = function () {
	function Ray(mOrigin, mDirection) {
		_classCallCheck(this, Ray);

		this.origin = _glMatrix.vec3.clone(mOrigin);
		this.direction = _glMatrix.vec3.clone(mDirection);
	}

	_createClass(Ray, [{
		key: 'at',
		value: function at(t) {
			_glMatrix.vec3.copy(target, this.direction);
			_glMatrix.vec3.scale(target, target, t);
			_glMatrix.vec3.add(target, target, this.origin);

			return target;
		}
	}, {
		key: 'lookAt',
		value: function lookAt(mTarget) {
			_glMatrix.vec3.sub(this.direction, mTarget, this.origin);
			_glMatrix.vec3.normalize(this.origin, this.origin);
		}
	}, {
		key: 'closestPointToPoint',
		value: function closestPointToPoint(mPoint) {
			var result = _glMatrix.vec3.create();
			_glMatrix.vec3.sub(mPoint, this.origin);
			var directionDistance = _glMatrix.vec3.dot(result, this.direction);

			if (directionDistance < 0) {
				return _glMatrix.vec3.clone(this.origin);
			}

			_glMatrix.vec3.copy(result, this.direction);
			_glMatrix.vec3.scale(result, result, directionDistance);
			_glMatrix.vec3.add(result, result, this.origin);

			return result;
		}
	}, {
		key: 'distanceToPoint',
		value: function distanceToPoint(mPoint) {
			return Math.sqrt(this.distanceSqToPoint(mPoint));
		}
	}, {
		key: 'distanceSqToPoint',
		value: function distanceSqToPoint(mPoint) {
			var v1 = _glMatrix.vec3.create();

			_glMatrix.vec3.sub(v1, mPoint, this.origin);
			var directionDistance = _glMatrix.vec3.dot(v1, this.direction);

			if (directionDistance < 0) {
				return _glMatrix.vec3.squaredDistance(this.origin, mPoint);
			}

			_glMatrix.vec3.copy(v1, this.direction);
			_glMatrix.vec3.scale(v1, v1, directionDistance);
			_glMatrix.vec3.add(v1, v1, this.origin);
			return _glMatrix.vec3.squaredDistance(v1, mPoint);
		}
	}, {
		key: 'intersectsSphere',
		value: function intersectsSphere(mCenter, mRadius) {
			return this.distanceToPoint(mCenter) <= mRadius;
		}
	}, {
		key: 'intersectSphere',
		value: function intersectSphere(mCenter, mRadius) {
			var v1 = _glMatrix.vec3.create();
			_glMatrix.vec3.sub(v1, mCenter, this.origin);
			var tca = _glMatrix.vec3.dot(v1, this.direction);
			var d2 = _glMatrix.vec3.dot(v1, v1) - tca * tca;
			var radius2 = mRadius * mRadius;

			if (d2 > radius2) return null;

			var thc = Math.sqrt(radius2 - d2);

			var t0 = tca - thc;

			var t1 = tca + thc;

			if (t0 < 0 && t1 < 0) return null;

			if (t0 < 0) return this.at(t1);

			return this.at(t0);
		}
	}, {
		key: 'distanceToPlane',
		value: function distanceToPlane(mPlaneCenter, mNormal) {
			var denominator = _glMatrix.vec3.dot(mNormal, this.direction);

			if (denominator === 0) {}
		}
	}, {
		key: 'intersectTriangle',
		value: function intersectTriangle(mPA, mPB, mPC) {
			var backfaceCulling = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

			_glMatrix.vec3.copy(a, mPA);
			_glMatrix.vec3.copy(b, mPB);
			_glMatrix.vec3.copy(c, mPC);

			// const edge1 = vec3.create();
			// const edge2 = vec3.create();
			// const normal = vec3.create();
			// const diff = vec3.create();

			_glMatrix.vec3.sub(edge1, b, a);
			_glMatrix.vec3.sub(edge2, c, a);
			_glMatrix.vec3.cross(normal, edge1, edge2);

			var DdN = _glMatrix.vec3.dot(this.direction, normal);
			var sign = void 0;

			if (DdN > 0) {
				if (backfaceCulling) {
					return null;
				}
				sign = 1;
			} else if (DdN < 0) {
				sign = -1;
				DdN = -DdN;
			} else {
				return null;
			}

			_glMatrix.vec3.sub(diff, this.origin, a);

			_glMatrix.vec3.cross(edge2, diff, edge2);
			var DdQxE2 = sign * _glMatrix.vec3.dot(this.direction, edge2);
			if (DdQxE2 < 0) {
				return null;
			}

			_glMatrix.vec3.cross(edge1, edge1, diff);
			var DdE1xQ = sign * _glMatrix.vec3.dot(this.direction, edge1);
			if (DdE1xQ < 0) {
				return null;
			}

			if (DdQxE2 + DdE1xQ > DdN) {
				return null;
			}

			var Qdn = -sign * _glMatrix.vec3.dot(diff, normal);
			if (Qdn < 0) {
				return null;
			}

			return this.at(Qdn / DdN);
		}
	}]);

	return Ray;
}();

exports.default = Ray;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Camera.js

var _glMatrix = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Camera = function () {
	function Camera() {
		_classCallCheck(this, Camera);

		//	VIEW MATRIX
		this._matrix = _glMatrix.mat4.create();

		//	FOR TRANSFORM FROM ORIENTATION
		this._quat = _glMatrix.quat.create();
		this._orientation = _glMatrix.mat4.create();

		//	PROJECTION MATRIX
		this._projection = _glMatrix.mat4.create();

		//	POSITION OF CAMERA
		this.position = vec3.create();
	}

	_createClass(Camera, [{
		key: 'lookAt',
		value: function lookAt(aEye, aCenter) {
			var aUp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 1, 0];

			this._eye = vec3.clone(aEye);
			this._center = vec3.clone(aCenter);

			vec3.copy(this.position, aEye);
			_glMatrix.mat4.identity(this._matrix);
			_glMatrix.mat4.lookAt(this._matrix, aEye, aCenter, aUp);
		}
	}, {
		key: 'setFromOrientation',
		value: function setFromOrientation(x, y, z, w) {
			_glMatrix.quat.set(this._quat, x, y, z, w);
			_glMatrix.mat4.fromQuat(this._orientation, this._quat);
			_glMatrix.mat4.translate(this._matrix, this._orientation, this.positionOffset);
		}
	}, {
		key: 'setProjection',
		value: function setProjection(mProj) {
			this._projection = _glMatrix.mat4.clone(mProj);
		}
	}, {
		key: 'setView',
		value: function setView(mView) {
			this._matrix = _glMatrix.mat4.clone(mView);
		}
	}, {
		key: 'setFromViewProj',
		value: function setFromViewProj(mView, mProj) {
			this.setView(mView);
			this.setProjection(mProj);
		}

		//	GETTERS 

	}, {
		key: 'matrix',
		get: function get() {
			return this._matrix;
		}
	}, {
		key: 'viewMatrix',
		get: function get() {
			return this._matrix;
		}
	}, {
		key: 'projection',
		get: function get() {
			return this._projection;
		}
	}, {
		key: 'projectionMatrix',
		get: function get() {
			return this._projection;
		}
	}, {
		key: 'eye',
		get: function get() {
			return this._eye;
		}
	}, {
		key: 'center',
		get: function get() {
			return this._center;
		}
	}]);

	return Camera;
}();

exports.default = Camera;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Camera2 = __webpack_require__(15);

var _Camera3 = _interopRequireDefault(_Camera2);

var _Ray = __webpack_require__(14);

var _Ray2 = _interopRequireDefault(_Ray);

var _glMatrix = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // CameraPerspective.js

var mInverseViewProj = _glMatrix.mat4.create();
var cameraDir = _glMatrix.vec3.create();

var CameraPerspective = function (_Camera) {
	_inherits(CameraPerspective, _Camera);

	function CameraPerspective() {
		_classCallCheck(this, CameraPerspective);

		return _possibleConstructorReturn(this, (CameraPerspective.__proto__ || Object.getPrototypeOf(CameraPerspective)).apply(this, arguments));
	}

	_createClass(CameraPerspective, [{
		key: 'setPerspective',
		value: function setPerspective(mFov, mAspectRatio, mNear, mFar) {

			this._fov = mFov;
			this._near = mNear;
			this._far = mFar;
			this._aspectRatio = mAspectRatio;
			_glMatrix.mat4.perspective(this._projection, mFov, mAspectRatio, mNear, mFar);

			// this._frustumTop = this._near * Math.tan(this._fov * 0.5);
			// this._frustumButtom = -this._frustumTop;
			// this._frustumRight = this._frustumTop * this._aspectRatio;
			// this._frustumLeft = -this._frustumRight;
		}
	}, {
		key: 'setAspectRatio',
		value: function setAspectRatio(mAspectRatio) {
			this._aspectRatio = mAspectRatio;
			_glMatrix.mat4.perspective(this.projection, this._fov, mAspectRatio, this._near, this._far);
		}
	}, {
		key: 'generateRay',
		value: function generateRay(mScreenPosition, mRay) {
			var proj = this.projectionMatrix;
			var view = this.viewMatrix;

			_glMatrix.mat4.multiply(mInverseViewProj, proj, view);
			_glMatrix.mat4.invert(mInverseViewProj, mInverseViewProj);

			_glMatrix.vec3.transformMat4(cameraDir, mScreenPosition, mInverseViewProj);
			_glMatrix.vec3.sub(cameraDir, cameraDir, this.position);
			_glMatrix.vec3.normalize(cameraDir, cameraDir);

			if (!mRay) {
				mRay = new _Ray2.default(this.position, cameraDir);
			} else {
				mRay.origin = this.position;
				mRay.direction = cameraDir;
			}

			return mRay;
		}
	}]);

	return CameraPerspective;
}(_Camera3.default);

exports.default = CameraPerspective;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// BinaryLoader.js

var BinaryLoader = function () {
	function BinaryLoader() {
		var _this = this;

		var isArrayBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

		_classCallCheck(this, BinaryLoader);

		this._req = new XMLHttpRequest();
		this._req.addEventListener('load', function (e) {
			return _this._onLoaded(e);
		});
		this._req.addEventListener('progress', function (e) {
			return _this._onProgress(e);
		});
		if (isArrayBuffer) {
			this._req.responseType = 'arraybuffer';
		}
	}

	_createClass(BinaryLoader, [{
		key: 'load',
		value: function load(url, callback) {
			console.log('Loading : ', url);
			this._callback = callback;

			this._req.open('GET', url);
			this._req.send();
		}
	}, {
		key: '_onLoaded',
		value: function _onLoaded() {
			this._callback(this._req.response);
		}
	}, {
		key: '_onProgress',
		value: function _onProgress() /* e*/{
			// console.log('on Progress:', (e.loaded/e.total*100).toFixed(2));
		}
	}]);

	return BinaryLoader;
}();

exports.default = BinaryLoader;

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = "// bigTriangle.vert\n\n#define SHADER_NAME BIG_TRIANGLE_VERTEX\n\nprecision mediump float;\n#define GLSLIFY 1\nattribute vec2 aPosition;\nvarying vec2 vTextureCoord;\n\nvoid main(void) {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n    vTextureCoord = aPosition * .5 + .5;\n}"

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = "// copy.frag\n\n#define SHADER_NAME COPY_FRAGMENT\n\nprecision mediump float;\n#define GLSLIFY 1\n\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\n\nvoid main(void) {\n    gl_FragColor = texture2D(texture, vTextureCoord);\n}"

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.ShaderLibs = exports.View3D = exports.View = exports.Scene = exports.BatchFXAA = exports.BatchSky = exports.BatchSkybox = exports.BatchLine = exports.BatchDotsPlane = exports.BatchBall = exports.BatchAxis = exports.BatchCopy = exports.PassFxaa = exports.PassHBlur = exports.PassVBlur = exports.PassBlur = exports.PassMacro = exports.Pass = exports.EffectComposer = exports.ColladaParser = exports.GLTFLoader = exports.HDRLoader = exports.ObjLoader = exports.BinaryLoader = exports.Object3D = exports.Ray = exports.CameraCube = exports.CameraPerspective = exports.CameraOrtho = exports.Camera = exports.TouchDetector = exports.QuatRotation = exports.WebglNumber = exports.OrbitalControl = exports.TweenNumber = exports.EaseNumber = exports.EventDispatcher = exports.Scheduler = exports.TransformFeedbackObject = exports.MultisampleFrameBuffer = exports.CubeFrameBuffer = exports.FrameBuffer = exports.Batch = exports.Geom = exports.Mesh = exports.GLCubeTexture = exports.GLTextureOld = exports.GLTexture = exports.GLShader = exports.GL = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // alfrid.js

//	WEBGL 2


//	TOOLS


//	CAMERAS


//	MATH


//	OBJECT


//	LOADERS


//	POST EFFECT


//	HELPERS


var _glMatrix = __webpack_require__(1);

var GLM = _interopRequireWildcard(_glMatrix);

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _GLShader = __webpack_require__(2);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _GLTexture = __webpack_require__(26);

var _GLTexture2 = _interopRequireDefault(_GLTexture);

var _GLTexture3 = __webpack_require__(27);

var _GLTexture4 = _interopRequireDefault(_GLTexture3);

var _GLCubeTexture = __webpack_require__(28);

var _GLCubeTexture2 = _interopRequireDefault(_GLCubeTexture);

var _Mesh = __webpack_require__(4);

var _Mesh2 = _interopRequireDefault(_Mesh);

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _Batch = __webpack_require__(5);

var _Batch2 = _interopRequireDefault(_Batch);

var _FrameBuffer = __webpack_require__(12);

var _FrameBuffer2 = _interopRequireDefault(_FrameBuffer);

var _CubeFrameBuffer = __webpack_require__(58);

var _CubeFrameBuffer2 = _interopRequireDefault(_CubeFrameBuffer);

var _MultisampleFrameBuffer = __webpack_require__(59);

var _MultisampleFrameBuffer2 = _interopRequireDefault(_MultisampleFrameBuffer);

var _TransformFeedbackObject = __webpack_require__(60);

var _TransformFeedbackObject2 = _interopRequireDefault(_TransformFeedbackObject);

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

var _EventDispatcher = __webpack_require__(29);

var _EventDispatcher2 = _interopRequireDefault(_EventDispatcher);

var _EaseNumber = __webpack_require__(13);

var _EaseNumber2 = _interopRequireDefault(_EaseNumber);

var _TweenNumber = __webpack_require__(61);

var _TweenNumber2 = _interopRequireDefault(_TweenNumber);

var _OrbitalControl = __webpack_require__(30);

var _OrbitalControl2 = _interopRequireDefault(_OrbitalControl);

var _QuatRotation = __webpack_require__(62);

var _QuatRotation2 = _interopRequireDefault(_QuatRotation);

var _TouchDetector = __webpack_require__(63);

var _TouchDetector2 = _interopRequireDefault(_TouchDetector);

var _WebglNumber = __webpack_require__(8);

var _WebglNumber2 = _interopRequireDefault(_WebglNumber);

var _WebglConst = __webpack_require__(24);

var _WebglConst2 = _interopRequireDefault(_WebglConst);

var _Camera = __webpack_require__(15);

var _Camera2 = _interopRequireDefault(_Camera);

var _CameraOrtho = __webpack_require__(31);

var _CameraOrtho2 = _interopRequireDefault(_CameraOrtho);

var _CameraPerspective = __webpack_require__(16);

var _CameraPerspective2 = _interopRequireDefault(_CameraPerspective);

var _CameraCube = __webpack_require__(65);

var _CameraCube2 = _interopRequireDefault(_CameraCube);

var _Ray = __webpack_require__(14);

var _Ray2 = _interopRequireDefault(_Ray);

var _Object3D = __webpack_require__(32);

var _Object3D2 = _interopRequireDefault(_Object3D);

var _BinaryLoader = __webpack_require__(17);

var _BinaryLoader2 = _interopRequireDefault(_BinaryLoader);

var _ObjLoader = __webpack_require__(66);

var _ObjLoader2 = _interopRequireDefault(_ObjLoader);

var _HDRLoader = __webpack_require__(67);

var _HDRLoader2 = _interopRequireDefault(_HDRLoader);

var _ColladaParser = __webpack_require__(69);

var _ColladaParser2 = _interopRequireDefault(_ColladaParser);

var _GltfLoader = __webpack_require__(72);

var _GltfLoader2 = _interopRequireDefault(_GltfLoader);

var _EffectComposer = __webpack_require__(74);

var _EffectComposer2 = _interopRequireDefault(_EffectComposer);

var _Pass = __webpack_require__(9);

var _Pass2 = _interopRequireDefault(_Pass);

var _PassMacro = __webpack_require__(37);

var _PassMacro2 = _interopRequireDefault(_PassMacro);

var _PassBlur = __webpack_require__(75);

var _PassBlur2 = _interopRequireDefault(_PassBlur);

var _PassVBlur = __webpack_require__(38);

var _PassVBlur2 = _interopRequireDefault(_PassVBlur);

var _PassHBlur = __webpack_require__(40);

var _PassHBlur2 = _interopRequireDefault(_PassHBlur);

var _PassFxaa = __webpack_require__(79);

var _PassFxaa2 = _interopRequireDefault(_PassFxaa);

var _BatchCopy = __webpack_require__(80);

var _BatchCopy2 = _interopRequireDefault(_BatchCopy);

var _BatchAxis = __webpack_require__(81);

var _BatchAxis2 = _interopRequireDefault(_BatchAxis);

var _BatchBall = __webpack_require__(84);

var _BatchBall2 = _interopRequireDefault(_BatchBall);

var _BatchDotsPlane = __webpack_require__(85);

var _BatchDotsPlane2 = _interopRequireDefault(_BatchDotsPlane);

var _BatchLine = __webpack_require__(87);

var _BatchLine2 = _interopRequireDefault(_BatchLine);

var _BatchSkybox = __webpack_require__(88);

var _BatchSkybox2 = _interopRequireDefault(_BatchSkybox);

var _BatchSky = __webpack_require__(89);

var _BatchSky2 = _interopRequireDefault(_BatchSky);

var _BatchFXAA = __webpack_require__(91);

var _BatchFXAA2 = _interopRequireDefault(_BatchFXAA);

var _Scene = __webpack_require__(92);

var _Scene2 = _interopRequireDefault(_Scene);

var _View = __webpack_require__(93);

var _View2 = _interopRequireDefault(_View);

var _View3D = __webpack_require__(94);

var _View3D2 = _interopRequireDefault(_View3D);

var _ShaderLibs = __webpack_require__(33);

var _ShaderLibs2 = _interopRequireDefault(_ShaderLibs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var VERSION = '0.2.0';

var Alfrid = function () {
	function Alfrid() {
		_classCallCheck(this, Alfrid);

		this.glm = GLM;
		this.GL = _GLTool2.default;
		this.GLTool = _GLTool2.default;
		this.GLShader = _GLShader2.default;
		this.GLTexture = _GLTexture4.default;
		this.GLTextureOld = _GLTexture2.default;
		this.GLCubeTexture = _GLCubeTexture2.default;
		this.Mesh = _Mesh2.default;
		this.Geom = _Geom2.default;
		this.Batch = _Batch2.default;
		this.FrameBuffer = _FrameBuffer2.default;
		this.CubeFrameBuffer = _CubeFrameBuffer2.default;
		this.Scheduler = _scheduling2.default;
		this.EventDispatcher = _EventDispatcher2.default;
		this.EaseNumber = _EaseNumber2.default;
		this.TweenNumber = _TweenNumber2.default;
		this.Camera = _Camera2.default;
		this.CameraOrtho = _CameraOrtho2.default;
		this.CameraPerspective = _CameraPerspective2.default;
		this.Ray = _Ray2.default;
		this.CameraCube = _CameraCube2.default;
		this.OrbitalControl = _OrbitalControl2.default;
		this.QuatRotation = _QuatRotation2.default;
		this.BinaryLoader = _BinaryLoader2.default;
		this.ObjLoader = _ObjLoader2.default;
		this.ColladaParser = _ColladaParser2.default;
		this.HDRLoader = _HDRLoader2.default;
		this.GLTFLoader = _GltfLoader2.default;
		this.BatchCopy = _BatchCopy2.default;
		this.BatchAxis = _BatchAxis2.default;
		this.BatchBall = _BatchBall2.default;
		this.BatchBall = _BatchBall2.default;
		this.BatchLine = _BatchLine2.default;
		this.BatchSkybox = _BatchSkybox2.default;
		this.BatchSky = _BatchSky2.default;
		this.BatchFXAA = _BatchFXAA2.default;
		this.BatchDotsPlane = _BatchDotsPlane2.default;
		this.Scene = _Scene2.default;
		this.View = _View2.default;
		this.View3D = _View3D2.default;
		this.Object3D = _Object3D2.default;
		this.ShaderLibs = _ShaderLibs2.default;
		this.WebglNumber = _WebglNumber2.default;

		this.EffectComposer = _EffectComposer2.default;
		this.Pass = _Pass2.default;
		this.PassMacro = _PassMacro2.default;
		this.PassBlur = _PassBlur2.default;
		this.PassVBlur = _PassVBlur2.default;
		this.PassHBlur = _PassHBlur2.default;
		this.PassFxaa = _PassFxaa2.default;

		this.MultisampleFrameBuffer = _MultisampleFrameBuffer2.default;
		this.TransformFeedbackObject = _TransformFeedbackObject2.default;

		//	NOT SUPER SURE I'VE DONE THIS IS A GOOD WAY

		for (var s in GLM) {
			if (GLM[s]) {
				window[s] = GLM[s];
			}
		}
	}

	_createClass(Alfrid, [{
		key: 'log',
		value: function log() {
			if (navigator.userAgent.indexOf('Chrome') > -1) {
				console.log('%clib alfrid : VERSION ' + VERSION, 'background: #193441; color: #FCFFF5');
			} else {
				console.log('lib alfrid : VERSION ', VERSION);
			}
			console.log('%cClasses : ', 'color: #193441');

			for (var s in this) {
				if (this[s]) {
					console.log('%c - ' + s, 'color: #3E606F');
				}
			}
		}
	}]);

	return Alfrid;
}();

var al = new Alfrid();

exports.default = al;
exports.GL = _GLTool2.default;
exports.GLShader = _GLShader2.default;
exports.GLTexture = _GLTexture4.default;
exports.GLTextureOld = _GLTexture2.default;
exports.GLCubeTexture = _GLCubeTexture2.default;
exports.Mesh = _Mesh2.default;
exports.Geom = _Geom2.default;
exports.Batch = _Batch2.default;
exports.FrameBuffer = _FrameBuffer2.default;
exports.CubeFrameBuffer = _CubeFrameBuffer2.default;
exports.MultisampleFrameBuffer = _MultisampleFrameBuffer2.default;
exports.TransformFeedbackObject = _TransformFeedbackObject2.default;
exports.Scheduler = _scheduling2.default;
exports.EventDispatcher = _EventDispatcher2.default;
exports.EaseNumber = _EaseNumber2.default;
exports.TweenNumber = _TweenNumber2.default;
exports.OrbitalControl = _OrbitalControl2.default;
exports.WebglNumber = _WebglNumber2.default;
exports.QuatRotation = _QuatRotation2.default;
exports.TouchDetector = _TouchDetector2.default;
exports.Camera = _Camera2.default;
exports.CameraOrtho = _CameraOrtho2.default;
exports.CameraPerspective = _CameraPerspective2.default;
exports.CameraCube = _CameraCube2.default;
exports.Ray = _Ray2.default;
exports.Object3D = _Object3D2.default;
exports.BinaryLoader = _BinaryLoader2.default;
exports.ObjLoader = _ObjLoader2.default;
exports.HDRLoader = _HDRLoader2.default;
exports.GLTFLoader = _GltfLoader2.default;
exports.ColladaParser = _ColladaParser2.default;
exports.EffectComposer = _EffectComposer2.default;
exports.Pass = _Pass2.default;
exports.PassMacro = _PassMacro2.default;
exports.PassBlur = _PassBlur2.default;
exports.PassVBlur = _PassVBlur2.default;
exports.PassHBlur = _PassHBlur2.default;
exports.PassFxaa = _PassFxaa2.default;
exports.BatchCopy = _BatchCopy2.default;
exports.BatchAxis = _BatchAxis2.default;
exports.BatchBall = _BatchBall2.default;
exports.BatchDotsPlane = _BatchDotsPlane2.default;
exports.BatchLine = _BatchLine2.default;
exports.BatchSkybox = _BatchSkybox2.default;
exports.BatchSky = _BatchSky2.default;
exports.BatchFXAA = _BatchFXAA2.default;
exports.Scene = _Scene2.default;
exports.View = _View2.default;
exports.View3D = _View3D2.default;
exports.ShaderLibs = _ShaderLibs2.default;

/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["fromMat4"] = fromMat4;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["transpose"] = transpose;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["adjoint"] = adjoint;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["translate"] = translate;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["fromTranslation"] = fromTranslation;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["fromMat2d"] = fromMat2d;
/* harmony export (immutable) */ __webpack_exports__["fromQuat"] = fromQuat;
/* harmony export (immutable) */ __webpack_exports__["normalFromMat4"] = normalFromMat4;
/* harmony export (immutable) */ __webpack_exports__["projection"] = projection;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(3);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](9);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    let a01 = a[1], a02 = a[2], a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function invert(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  let b01 = a22 * a11 - a12 * a21;
  let b11 = -a22 * a10 + a12 * a20;
  let b21 = a21 * a10 - a11 * a20;

  // Calculate the determinant
  let det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function adjoint(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  out[0] = (a11 * a22 - a12 * a21);
  out[1] = (a02 * a21 - a01 * a22);
  out[2] = (a01 * a12 - a02 * a11);
  out[3] = (a12 * a20 - a10 * a22);
  out[4] = (a00 * a22 - a02 * a20);
  out[5] = (a02 * a10 - a00 * a12);
  out[6] = (a10 * a21 - a11 * a20);
  out[7] = (a01 * a20 - a00 * a21);
  out[8] = (a00 * a11 - a01 * a10);
  return out;
}

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function multiply(out, a, b) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  let b00 = b[0], b01 = b[1], b02 = b[2];
  let b10 = b[3], b11 = b[4], b12 = b[5];
  let b20 = b[6], b21 = b[7], b22 = b[8];

  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;

  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;

  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
function translate(out, a, v) {
  let a00 = a[0], a01 = a[1], a02 = a[2],
    a10 = a[3], a11 = a[4], a12 = a[5],
    a20 = a[6], a21 = a[7], a22 = a[8],
    x = v[0], y = v[1];

  out[0] = a00;
  out[1] = a01;
  out[2] = a02;

  out[3] = a10;
  out[4] = a11;
  out[5] = a12;

  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function rotate(out, a, rad) {
  let a00 = a[0], a01 = a[1], a02 = a[2],
    a10 = a[3], a11 = a[4], a12 = a[5],
    a20 = a[6], a21 = a[7], a22 = a[8],

    s = Math.sin(rad),
    c = Math.cos(rad);

  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;

  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;

  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
function scale(out, a, v) {
  let x = v[0], y = v[1];

  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];

  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];

  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function fromRotation(out, rad) {
  let s = Math.sin(rad), c = Math.cos(rad);

  out[0] = c;
  out[1] = s;
  out[2] = 0;

  out[3] = -s;
  out[4] = c;
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;

  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;

  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;

  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
function fromQuat(out, q) {
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let yx = y * x2;
  let yy = y * y2;
  let zx = z * x2;
  let zy = z * y2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;

  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;

  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;

  return out;
}

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
function normalFromMat4(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

  return out;
}

/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */
function projection(out, width, height) {
    out[0] = 2 / width;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = -2 / height;
    out[5] = 0;
    out[6] = -1;
    out[7] = 1;
    out[8] = 1;
    return out;
}

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
          a[3] + ', ' + a[4] + ', ' + a[5] + ', ' +
          a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
}

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}



/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  out[4] = a[4] + (b[4] * scale);
  out[5] = a[5] + (b[5] * scale);
  out[6] = a[6] + (b[6] * scale);
  out[7] = a[7] + (b[7] * scale);
  out[8] = a[8] + (b[8] * scale);
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] &&
         a[3] === b[3] && a[4] === b[4] && a[5] === b[5] &&
         a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
          Math.abs(a4 - b4) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
          Math.abs(a5 - b5) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
          Math.abs(a6 - b6) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
          Math.abs(a7 - b7) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
          Math.abs(a8 - b8) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a8), Math.abs(b8)));
}

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat3.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["length"] = length;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["divide"] = divide;
/* harmony export (immutable) */ __webpack_exports__["ceil"] = ceil;
/* harmony export (immutable) */ __webpack_exports__["floor"] = floor;
/* harmony export (immutable) */ __webpack_exports__["min"] = min;
/* harmony export (immutable) */ __webpack_exports__["max"] = max;
/* harmony export (immutable) */ __webpack_exports__["round"] = round;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["scaleAndAdd"] = scaleAndAdd;
/* harmony export (immutable) */ __webpack_exports__["distance"] = distance;
/* harmony export (immutable) */ __webpack_exports__["squaredDistance"] = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["negate"] = negate;
/* harmony export (immutable) */ __webpack_exports__["inverse"] = inverse;
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;
/* harmony export (immutable) */ __webpack_exports__["cross"] = cross;
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;
/* harmony export (immutable) */ __webpack_exports__["hermite"] = hermite;
/* harmony export (immutable) */ __webpack_exports__["bezier"] = bezier;
/* harmony export (immutable) */ __webpack_exports__["random"] = random;
/* harmony export (immutable) */ __webpack_exports__["transformMat4"] = transformMat4;
/* harmony export (immutable) */ __webpack_exports__["transformMat3"] = transformMat3;
/* harmony export (immutable) */ __webpack_exports__["transformQuat"] = transformQuat;
/* harmony export (immutable) */ __webpack_exports__["rotateX"] = rotateX;
/* harmony export (immutable) */ __webpack_exports__["rotateY"] = rotateY;
/* harmony export (immutable) */ __webpack_exports__["rotateZ"] = rotateZ;
/* harmony export (immutable) */ __webpack_exports__["angle"] = angle;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(3);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](3);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
function clone(a) {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  return Math.sqrt(x*x + y*y + z*z);
}

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
function fromValues(x, y, z) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  return out;
}

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  return Math.sqrt(x*x + y*y + z*z);
}

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  return x*x + y*y + z*z;
}

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  return x*x + y*y + z*z;
}

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
function normalize(out, a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let len = x*x + y*y + z*z;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  let ax = a[0], ay = a[1], az = a[2];
  let bx = b[0], by = b[1], bz = b[2];

  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function lerp(out, a, b, t) {
  let ax = a[0];
  let ay = a[1];
  let az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function hermite(out, a, b, c, d, t) {
  let factorTimes2 = t * t;
  let factor1 = factorTimes2 * (2 * t - 3) + 1;
  let factor2 = factorTimes2 * (t - 2) + t;
  let factor3 = factorTimes2 * (t - 1);
  let factor4 = factorTimes2 * (3 - 2 * t);

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function bezier(out, a, b, c, d, t) {
  let inverseFactor = 1 - t;
  let inverseFactorTimesTwo = inverseFactor * inverseFactor;
  let factorTimes2 = t * t;
  let factor1 = inverseFactorTimesTwo * inverseFactor;
  let factor2 = 3 * t * inverseFactorTimesTwo;
  let factor3 = 3 * factorTimes2 * inverseFactor;
  let factor4 = factorTimes2 * t;

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
function random(out, scale) {
  scale = scale || 1.0;

  let r = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]() * 2.0 * Math.PI;
  let z = (__WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]() * 2.0) - 1.0;
  let zScale = Math.sqrt(1.0-z*z) * scale;

  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
function transformMat4(out, a, m) {
  let x = a[0], y = a[1], z = a[2];
  let w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
function transformMat3(out, a, m) {
  let x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
function transformQuat(out, a, q) {
  // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

  let x = a[0], y = a[1], z = a[2];
  let qx = q[0], qy = q[1], qz = q[2], qw = q[3];

  // calculate quat * vec
  let ix = qw * x + qy * z - qz * y;
  let iy = qw * y + qz * x - qx * z;
  let iz = qw * z + qx * y - qy * x;
  let iw = -qx * x - qy * y - qz * z;

  // calculate result * inverse quat
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  return out;
}

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateX(out, a, b, c){
  let p = [], r=[];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0];
  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateY(out, a, b, c){
  let p = [], r=[];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  r[1] = p[1];
  r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateZ(out, a, b, c){
  let p = [], r=[];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  r[2] = p[2];

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
  let tempA = fromValues(a[0], a[1], a[2]);
  let tempB = fromValues(b[0], b[1], b[2]);

  normalize(tempA, tempA);
  normalize(tempB, tempB);

  let cosine = dot(tempA, tempB);

  if(cosine > 1.0) {
    return 0;
  }
  else if(cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2];
  let b0 = b[0], b1 = b[1], b2 = b[2];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)));
}

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;


/**
 * Alias for {@link vec3.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link vec3.divide}
 * @function
 */
const div = divide;
/* harmony export (immutable) */ __webpack_exports__["div"] = div;


/**
 * Alias for {@link vec3.distance}
 * @function
 */
const dist = distance;
/* harmony export (immutable) */ __webpack_exports__["dist"] = dist;


/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
const sqrDist = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["sqrDist"] = sqrDist;


/**
 * Alias for {@link vec3.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
const forEach = (function() {
  let vec = create();

  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if(!stride) {
      stride = 3;
    }

    if(!offset) {
      offset = 0;
    }

    if(count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for(i = offset; i < l; i += stride) {
      vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
      fn(vec, vec, arg);
      a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
    }

    return a;
  };
})();
/* harmony export (immutable) */ __webpack_exports__["forEach"] = forEach;



/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["divide"] = divide;
/* harmony export (immutable) */ __webpack_exports__["ceil"] = ceil;
/* harmony export (immutable) */ __webpack_exports__["floor"] = floor;
/* harmony export (immutable) */ __webpack_exports__["min"] = min;
/* harmony export (immutable) */ __webpack_exports__["max"] = max;
/* harmony export (immutable) */ __webpack_exports__["round"] = round;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["scaleAndAdd"] = scaleAndAdd;
/* harmony export (immutable) */ __webpack_exports__["distance"] = distance;
/* harmony export (immutable) */ __webpack_exports__["squaredDistance"] = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["length"] = length;
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["negate"] = negate;
/* harmony export (immutable) */ __webpack_exports__["inverse"] = inverse;
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;
/* harmony export (immutable) */ __webpack_exports__["random"] = random;
/* harmony export (immutable) */ __webpack_exports__["transformMat4"] = transformMat4;
/* harmony export (immutable) */ __webpack_exports__["transformQuat"] = transformQuat;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(3);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
function fromValues(x, y, z, w) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}

/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}

/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}

/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  return out;
}

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  let w = b[3] - a[3];
  return Math.sqrt(x*x + y*y + z*z + w*w);
}

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  let w = b[3] - a[3];
  return x*x + y*y + z*z + w*w;
}

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  return Math.sqrt(x*x + y*y + z*z + w*w);
}

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  return x*x + y*y + z*z + w*w;
}

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
function normalize(out, a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  let len = x*x + y*y + z*z + w*w;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    out[0] = x * len;
    out[1] = y * len;
    out[2] = z * len;
    out[3] = w * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
function lerp(out, a, b, t) {
  let ax = a[0];
  let ay = a[1];
  let az = a[2];
  let aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
function random(out, vectorScale) {
  vectorScale = vectorScale || 1.0;

  //TODO: This is a pretty awful way of doing this. Find something better.
  out[0] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  out[1] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  out[2] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  out[3] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  normalize(out, out);
  scale(out, out, vectorScale);
  return out;
}

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
function transformMat4(out, a, m) {
  let x = a[0], y = a[1], z = a[2], w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
function transformQuat(out, a, q) {
  let x = a[0], y = a[1], z = a[2];
  let qx = q[0], qy = q[1], qz = q[2], qw = q[3];

  // calculate quat * vec
  let ix = qw * x + qy * z - qz * y;
  let iy = qw * y + qz * x - qx * z;
  let iz = qw * z + qx * y - qy * x;
  let iw = -qx * x - qy * y - qz * z;

  // calculate result * inverse quat
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
}

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;


/**
 * Alias for {@link vec4.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link vec4.divide}
 * @function
 */
const div = divide;
/* harmony export (immutable) */ __webpack_exports__["div"] = div;


/**
 * Alias for {@link vec4.distance}
 * @function
 */
const dist = distance;
/* harmony export (immutable) */ __webpack_exports__["dist"] = dist;


/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
const sqrDist = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["sqrDist"] = sqrDist;


/**
 * Alias for {@link vec4.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
const forEach = (function() {
  let vec = create();

  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if(!stride) {
      stride = 4;
    }

    if(!offset) {
      offset = 0;
    }

    if(count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for(i = offset; i < l; i += stride) {
      vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
      fn(vec, vec, arg);
      a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
    }

    return a;
  };
})();
/* harmony export (immutable) */ __webpack_exports__["forEach"] = forEach;



/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// WebglConst.js

// stolen there https://github.com/mattdesl/gl-constants thanks @mattdesl ^^

module.exports = {
	ACTIVE_ATTRIBUTES: 35721,
	ACTIVE_ATTRIBUTE_MAX_LENGTH: 35722,
	ACTIVE_TEXTURE: 34016,
	ACTIVE_UNIFORMS: 35718,
	ACTIVE_UNIFORM_MAX_LENGTH: 35719,
	ALIASED_LINE_WIDTH_RANGE: 33902,
	ALIASED_POINT_SIZE_RANGE: 33901,
	ALPHA: 6406,
	ALPHA_BITS: 3413,
	ALWAYS: 519,
	ARRAY_BUFFER: 34962,
	ARRAY_BUFFER_BINDING: 34964,
	ATTACHED_SHADERS: 35717,
	BACK: 1029,
	BLEND: 3042,
	BLEND_COLOR: 32773,
	BLEND_DST_ALPHA: 32970,
	BLEND_DST_RGB: 32968,
	BLEND_EQUATION: 32777,
	BLEND_EQUATION_ALPHA: 34877,
	BLEND_EQUATION_RGB: 32777,
	BLEND_SRC_ALPHA: 32971,
	BLEND_SRC_RGB: 32969,
	BLUE_BITS: 3412,
	BOOL: 35670,
	BOOL_VEC2: 35671,
	BOOL_VEC3: 35672,
	BOOL_VEC4: 35673,
	BROWSER_DEFAULT_WEBGL: 37444,
	BUFFER_SIZE: 34660,
	BUFFER_USAGE: 34661,
	BYTE: 5120,
	CCW: 2305,
	CLAMP_TO_EDGE: 33071,
	COLOR_ATTACHMENT0: 36064,
	COLOR_BUFFER_BIT: 16384,
	COLOR_CLEAR_VALUE: 3106,
	COLOR_WRITEMASK: 3107,
	COMPILE_STATUS: 35713,
	COMPRESSED_TEXTURE_FORMATS: 34467,
	CONSTANT_ALPHA: 32771,
	CONSTANT_COLOR: 32769,
	CONTEXT_LOST_WEBGL: 37442,
	CULL_FACE: 2884,
	CULL_FACE_MODE: 2885,
	CURRENT_PROGRAM: 35725,
	CURRENT_VERTEX_ATTRIB: 34342,
	CW: 2304,
	DECR: 7683,
	DECR_WRAP: 34056,
	DELETE_STATUS: 35712,
	DEPTH_ATTACHMENT: 36096,
	DEPTH_BITS: 3414,
	DEPTH_BUFFER_BIT: 256,
	DEPTH_CLEAR_VALUE: 2931,
	DEPTH_COMPONENT: 6402,
	RED: 6403,
	DEPTH_COMPONENT16: 33189,
	DEPTH_FUNC: 2932,
	DEPTH_RANGE: 2928,
	DEPTH_STENCIL: 34041,
	DEPTH_STENCIL_ATTACHMENT: 33306,
	DEPTH_TEST: 2929,
	DEPTH_WRITEMASK: 2930,
	DITHER: 3024,
	DONT_CARE: 4352,
	DST_ALPHA: 772,
	DST_COLOR: 774,
	DYNAMIC_DRAW: 35048,
	ELEMENT_ARRAY_BUFFER: 34963,
	ELEMENT_ARRAY_BUFFER_BINDING: 34965,
	EQUAL: 514,
	FASTEST: 4353,
	FLOAT: 5126,
	FLOAT_MAT2: 35674,
	FLOAT_MAT3: 35675,
	FLOAT_MAT4: 35676,
	FLOAT_VEC2: 35664,
	FLOAT_VEC3: 35665,
	FLOAT_VEC4: 35666,
	FRAGMENT_SHADER: 35632,
	FRAMEBUFFER: 36160,
	FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 36049,
	FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 36048,
	FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 36051,
	FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 36050,
	FRAMEBUFFER_BINDING: 36006,
	FRAMEBUFFER_COMPLETE: 36053,
	FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 36054,
	FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 36057,
	FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 36055,
	FRAMEBUFFER_UNSUPPORTED: 36061,
	FRONT: 1028,
	FRONT_AND_BACK: 1032,
	FRONT_FACE: 2886,
	FUNC_ADD: 32774,
	FUNC_REVERSE_SUBTRACT: 32779,
	FUNC_SUBTRACT: 32778,
	GENERATE_MIPMAP_HINT: 33170,
	GEQUAL: 518,
	GREATER: 516,
	GREEN_BITS: 3411,
	HIGH_FLOAT: 36338,
	HIGH_INT: 36341,
	INCR: 7682,
	INCR_WRAP: 34055,
	INFO_LOG_LENGTH: 35716,
	INT: 5124,
	INT_VEC2: 35667,
	INT_VEC3: 35668,
	INT_VEC4: 35669,
	INVALID_ENUM: 1280,
	INVALID_FRAMEBUFFER_OPERATION: 1286,
	INVALID_OPERATION: 1282,
	INVALID_VALUE: 1281,
	INVERT: 5386,
	KEEP: 7680,
	LEQUAL: 515,
	LESS: 513,
	LINEAR: 9729,
	LINEAR_MIPMAP_LINEAR: 9987,
	LINEAR_MIPMAP_NEAREST: 9985,
	LINES: 1,
	LINE_LOOP: 2,
	LINE_STRIP: 3,
	LINE_WIDTH: 2849,
	LINK_STATUS: 35714,
	LOW_FLOAT: 36336,
	LOW_INT: 36339,
	LUMINANCE: 6409,
	LUMINANCE_ALPHA: 6410,
	MAX_COMBINED_TEXTURE_IMAGE_UNITS: 35661,
	MAX_CUBE_MAP_TEXTURE_SIZE: 34076,
	MAX_FRAGMENT_UNIFORM_VECTORS: 36349,
	MAX_RENDERBUFFER_SIZE: 34024,
	MAX_TEXTURE_IMAGE_UNITS: 34930,
	MAX_TEXTURE_SIZE: 3379,
	MAX_VARYING_VECTORS: 36348,
	MAX_VERTEX_ATTRIBS: 34921,
	MAX_VERTEX_TEXTURE_IMAGE_UNITS: 35660,
	MAX_VERTEX_UNIFORM_VECTORS: 36347,
	MAX_VIEWPORT_DIMS: 3386,
	MEDIUM_FLOAT: 36337,
	MEDIUM_INT: 36340,
	MIRRORED_REPEAT: 33648,
	NEAREST: 9728,
	NEAREST_MIPMAP_LINEAR: 9986,
	NEAREST_MIPMAP_NEAREST: 9984,
	NEVER: 512,
	NICEST: 4354,
	NONE: 0,
	NOTEQUAL: 517,
	NO_ERROR: 0,
	NUM_COMPRESSED_TEXTURE_FORMATS: 34466,
	ONE: 1,
	ONE_MINUS_CONSTANT_ALPHA: 32772,
	ONE_MINUS_CONSTANT_COLOR: 32770,
	ONE_MINUS_DST_ALPHA: 773,
	ONE_MINUS_DST_COLOR: 775,
	ONE_MINUS_SRC_ALPHA: 771,
	ONE_MINUS_SRC_COLOR: 769,
	OUT_OF_MEMORY: 1285,
	PACK_ALIGNMENT: 3333,
	POINTS: 0,
	POLYGON_OFFSET_FACTOR: 32824,
	POLYGON_OFFSET_FILL: 32823,
	POLYGON_OFFSET_UNITS: 10752,
	RED_BITS: 3410,
	RENDERBUFFER: 36161,
	RENDERBUFFER_ALPHA_SIZE: 36179,
	RENDERBUFFER_BINDING: 36007,
	RENDERBUFFER_BLUE_SIZE: 36178,
	RENDERBUFFER_DEPTH_SIZE: 36180,
	RENDERBUFFER_GREEN_SIZE: 36177,
	RENDERBUFFER_HEIGHT: 36163,
	RENDERBUFFER_INTERNAL_FORMAT: 36164,
	RENDERBUFFER_RED_SIZE: 36176,
	RENDERBUFFER_STENCIL_SIZE: 36181,
	RENDERBUFFER_WIDTH: 36162,
	RENDERER: 7937,
	REPEAT: 10497,
	REPLACE: 7681,
	RGB: 6407,
	RGB5_A1: 32855,
	RGB565: 36194,
	RGBA: 6408,
	RGBA4: 32854,
	SAMPLER_2D: 35678,
	SAMPLER_CUBE: 35680,
	SAMPLES: 32937,
	SAMPLE_ALPHA_TO_COVERAGE: 32926,
	SAMPLE_BUFFERS: 32936,
	SAMPLE_COVERAGE: 32928,
	SAMPLE_COVERAGE_INVERT: 32939,
	SAMPLE_COVERAGE_VALUE: 32938,
	SCISSOR_BOX: 3088,
	SCISSOR_TEST: 3089,
	SHADER_COMPILER: 36346,
	SHADER_SOURCE_LENGTH: 35720,
	SHADER_TYPE: 35663,
	SHADING_LANGUAGE_VERSION: 35724,
	SHORT: 5122,
	SRC_ALPHA: 770,
	SRC_ALPHA_SATURATE: 776,
	SRC_COLOR: 768,
	STATIC_DRAW: 35044,
	STENCIL_ATTACHMENT: 36128,
	STENCIL_BACK_FAIL: 34817,
	STENCIL_BACK_FUNC: 34816,
	STENCIL_BACK_PASS_DEPTH_FAIL: 34818,
	STENCIL_BACK_PASS_DEPTH_PASS: 34819,
	STENCIL_BACK_REF: 36003,
	STENCIL_BACK_VALUE_MASK: 36004,
	STENCIL_BACK_WRITEMASK: 36005,
	STENCIL_BITS: 3415,
	STENCIL_BUFFER_BIT: 1024,
	STENCIL_CLEAR_VALUE: 2961,
	STENCIL_FAIL: 2964,
	STENCIL_FUNC: 2962,
	STENCIL_INDEX: 6401,
	STENCIL_INDEX8: 36168,
	STENCIL_PASS_DEPTH_FAIL: 2965,
	STENCIL_PASS_DEPTH_PASS: 2966,
	STENCIL_REF: 2967,
	STENCIL_TEST: 2960,
	STENCIL_VALUE_MASK: 2963,
	STENCIL_WRITEMASK: 2968,
	STREAM_DRAW: 35040,
	SUBPIXEL_BITS: 3408,
	TEXTURE: 5890,
	TEXTURE0: 33984,
	TEXTURE1: 33985,
	TEXTURE2: 33986,
	TEXTURE3: 33987,
	TEXTURE4: 33988,
	TEXTURE5: 33989,
	TEXTURE6: 33990,
	TEXTURE7: 33991,
	TEXTURE8: 33992,
	TEXTURE9: 33993,
	TEXTURE10: 33994,
	TEXTURE11: 33995,
	TEXTURE12: 33996,
	TEXTURE13: 33997,
	TEXTURE14: 33998,
	TEXTURE15: 33999,
	TEXTURE16: 34000,
	TEXTURE17: 34001,
	TEXTURE18: 34002,
	TEXTURE19: 34003,
	TEXTURE20: 34004,
	TEXTURE21: 34005,
	TEXTURE22: 34006,
	TEXTURE23: 34007,
	TEXTURE24: 34008,
	TEXTURE25: 34009,
	TEXTURE26: 34010,
	TEXTURE27: 34011,
	TEXTURE28: 34012,
	TEXTURE29: 34013,
	TEXTURE30: 34014,
	TEXTURE31: 34015,
	TEXTURE_2D: 3553,
	TEXTURE_BINDING_2D: 32873,
	TEXTURE_BINDING_CUBE_MAP: 34068,
	TEXTURE_CUBE_MAP: 34067,
	TEXTURE_CUBE_MAP_NEGATIVE_X: 34070,
	TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072,
	TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074,
	TEXTURE_CUBE_MAP_POSITIVE_X: 34069,
	TEXTURE_CUBE_MAP_POSITIVE_Y: 34071,
	TEXTURE_CUBE_MAP_POSITIVE_Z: 34073,
	TEXTURE_MAG_FILTER: 10240,
	TEXTURE_MIN_FILTER: 10241,
	TEXTURE_WRAP_S: 10242,
	TEXTURE_WRAP_T: 10243,
	TRIANGLES: 4,
	TRIANGLE_FAN: 6,
	TRIANGLE_STRIP: 5,
	UNPACK_ALIGNMENT: 3317,
	UNPACK_COLORSPACE_CONVERSION_WEBGL: 37443,
	UNPACK_FLIP_Y_WEBGL: 37440,
	UNPACK_PREMULTIPLY_ALPHA_WEBGL: 37441,
	UNSIGNED_BYTE: 5121,
	UNSIGNED_INT: 5125,
	UNSIGNED_SHORT: 5123,
	UNSIGNED_SHORT_4_4_4_4: 32819,
	UNSIGNED_SHORT_5_5_5_1: 32820,
	UNSIGNED_SHORT_5_6_5: 33635,
	VALIDATE_STATUS: 35715,
	VENDOR: 7936,
	VERSION: 7938,
	VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 34975,
	VERTEX_ATTRIB_ARRAY_ENABLED: 34338,
	VERTEX_ATTRIB_ARRAY_NORMALIZED: 34922,
	VERTEX_ATTRIB_ARRAY_POINTER: 34373,
	VERTEX_ATTRIB_ARRAY_SIZE: 34339,
	VERTEX_ATTRIB_ARRAY_STRIDE: 34340,
	VERTEX_ATTRIB_ARRAY_TYPE: 34341,
	VERTEX_SHADER: 35633,
	VIEWPORT: 2978,
	ZERO: 0,
	R8: 33321
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function (gl, shaderProgram, name) {
	if (shaderProgram.cacheAttribLoc === undefined) {
		shaderProgram.cacheAttribLoc = {};
	}
	if (shaderProgram.cacheAttribLoc[name] === undefined) {
		shaderProgram.cacheAttribLoc[name] = gl.getAttribLocation(shaderProgram, name);
	}

	return shaderProgram.cacheAttribLoc[name];
};

; // getAttribLoc.js

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // GLTexture.js

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _WebglNumber = __webpack_require__(8);

var _WebglNumber2 = _interopRequireDefault(_WebglNumber);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function isPowerOfTwo(x) {
	return x !== 0 && !(x & x - 1);
};

function isSourcePowerOfTwo(obj) {
	var w = obj.width || obj.videoWidth;
	var h = obj.height || obj.videoHeight;

	if (!w || !h) {
		return false;
	}

	return isPowerOfTwo(w) && isPowerOfTwo(h);
};

var gl = void 0;

var GLTexture = function () {
	function GLTexture(mSource) {
		var isTexture = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
		var mParameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

		_classCallCheck(this, GLTexture);

		gl = _GLTool2.default.gl;

		if (isTexture) {
			this._texture = mSource;
		} else {
			this._mSource = mSource;
			this._texture = gl.createTexture();
			this._isVideo = mSource.tagName === 'VIDEO';
			this._premultiplyAlpha = true;
			this._magFilter = mParameters.magFilter || gl.LINEAR;
			this._minFilter = mParameters.minFilter || gl.NEAREST_MIPMAP_LINEAR;

			this._wrapS = mParameters.wrapS || gl.MIRRORED_REPEAT;
			this._wrapT = mParameters.wrapT || gl.MIRRORED_REPEAT;
			var width = mSource.width || mSource.videoWidth;

			if (width) {
				if (!isSourcePowerOfTwo(mSource)) {
					this._wrapS = this._wrapT = gl.CLAMP_TO_EDGE;
					if (this._minFilter === gl.NEAREST_MIPMAP_LINEAR) {
						this._minFilter = gl.LINEAR;
					}
				}
			} else {
				this._wrapS = this._wrapT = gl.CLAMP_TO_EDGE;
				if (this._minFilter === gl.NEAREST_MIPMAP_LINEAR) {
					this._minFilter = gl.LINEAR;
				}
			}

			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

			if (mSource.exposure) {
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, mSource.shape[0], mSource.shape[1], 0, gl.RGBA, gl.FLOAT, mSource.data);
			} else {
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, mSource);
				// gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
			}

			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this._magFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._minFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._wrapS);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._wrapT);

			// console.log('Texture Min :', WebglNumber[this._minFilter]);
			// console.log('Texture Mag :', WebglNumber[this._magFilter]);

			var ext = _GLTool2.default.getExtension('EXT_texture_filter_anisotropic');
			if (ext) {
				var max = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
				gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, max);
			}

			if (this._canGenerateMipmap()) {
				gl.generateMipmap(gl.TEXTURE_2D);
			}

			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}

	_createClass(GLTexture, [{
		key: 'generateMipmap',
		value: function generateMipmap() {
			if (!this._canGenerateMipmap()) {
				return;
			}
			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.generateMipmap(gl.TEXTURE_2D);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}

		//	MIPMAP FILTER

	}, {
		key: 'updateTexture',


		//	UPDATE TEXTURE

		value: function updateTexture(mSource) {
			if (mSource) {
				this._mSource = mSource;
			}
			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._mSource);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this._magFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._minFilter);
			if (this._canGenerateMipmap()) {
				gl.generateMipmap(gl.TEXTURE_2D);
			}

			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: 'bind',
		value: function bind(index) {
			if (index === undefined) {
				index = 0;
			}
			if (!_GLTool2.default.shader) {
				return;
			}

			gl.activeTexture(gl.TEXTURE0 + index);
			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			this._bindIndex = index;
		}
	}, {
		key: '_canGenerateMipmap',
		value: function _canGenerateMipmap() {
			return this._minFilter === gl.LINEAR_MIPMAP_NEAREST || this._minFilter === gl.NEAREST_MIPMAP_LINEAR || this._minFilter === gl.LINEAR_MIPMAP_LINEAR || this._minFilter === gl.NEAREST_MIPMAP_NEAREST;
		}

		//	GETTER

	}, {
		key: 'minFilter',
		set: function set(mValue) {
			if (mValue !== gl.LINEAR && mValue !== gl.NEAREST && mValue !== gl.NEAREST_MIPMAP_LINEAR && mValue !== gl.NEAREST_MIPMAP_LINEAR && mValue !== gl.LINEAR_MIPMAP_LINEAR && mValue !== gl.NEAREST_MIPMAP_NEAREST) {
				return this;
			}
			this._minFilter = mValue;
			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._minFilter);
			gl.bindTexture(gl.TEXTURE_2D, null);
		},
		get: function get() {
			return this._minFilter;
		}
	}, {
		key: 'magFilter',
		set: function set(mValue) {
			if (mValue !== gl.LINEAR && mValue !== gl.NEAREST) {
				return this;
			}
			this._magFilter = mValue;
			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this._magFilter);
			gl.bindTexture(gl.TEXTURE_2D, null);
		},
		get: function get() {
			return this._magFilter;
		}

		//	WRAP

	}, {
		key: 'wrapS',
		set: function set(mValue) {
			if (mValue !== gl.CLAMP_TO_EDGE && mValue !== gl.REPEAT && mValue !== gl.MIRRORED_REPEAT) {
				return this;
			}
			this._wrapS = mValue;
			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._wrapS);
			gl.bindTexture(gl.TEXTURE_2D, null);
		},
		get: function get() {
			return this._wrapS;
		}
	}, {
		key: 'wrapT',
		set: function set(mValue) {
			if (mValue !== gl.CLAMP_TO_EDGE && mValue !== gl.REPEAT && mValue !== gl.MIRRORED_REPEAT) {
				return this;
			}
			this._wrapT = mValue;
			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._wrapT);
			gl.bindTexture(gl.TEXTURE_2D, null);
		},
		get: function get() {
			return this._wrapT;
		}

		//	PREMULTIPLY ALPHA

	}, {
		key: 'premultiplyAlpha',
		set: function set(mValue) {
			this._premultiplyAlpha = mValue;
			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			console.log('premultiplyAlpha:', mValue);
			gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha);
			gl.bindTexture(gl.TEXTURE_2D, null);
		},
		get: function get() {
			return this._premultiplyAlpha;
		}
	}, {
		key: 'texture',
		get: function get() {
			return this._texture;
		}
	}]);

	return GLTexture;
}();

var _whiteTexture = void 0,
    _greyTexture = void 0,
    _blackTexture = void 0;

GLTexture.whiteTexture = function whiteTexture() {
	if (_whiteTexture === undefined) {
		var canvas = document.createElement('canvas');
		canvas.width = canvas.height = 4;
		var ctx = canvas.getContext('2d');
		ctx.fillStyle = '#fff';
		ctx.fillRect(0, 0, 4, 4);
		_whiteTexture = new GLTexture(canvas);
	}

	return _whiteTexture;
};

GLTexture.greyTexture = function greyTexture() {
	if (_greyTexture === undefined) {
		var canvas = document.createElement('canvas');
		canvas.width = canvas.height = 4;
		var ctx = canvas.getContext('2d');
		ctx.fillStyle = 'rgb(127, 127, 127)';
		ctx.fillRect(0, 0, 4, 4);
		_greyTexture = new GLTexture(canvas);
	}
	return _greyTexture;
};

GLTexture.blackTexture = function blackTexture() {
	if (_blackTexture === undefined) {
		var canvas = document.createElement('canvas');
		canvas.width = canvas.height = 4;
		var ctx = canvas.getContext('2d');
		ctx.fillStyle = 'rgb(127, 127, 127)';
		ctx.fillRect(0, 0, 4, 4);
		_blackTexture = new GLTexture(canvas);
	}
	return _blackTexture;
};

exports.default = GLTexture;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // GLTexture2.js

var _getTextureParameters = __webpack_require__(56);

var _getTextureParameters2 = _interopRequireDefault(_getTextureParameters);

var _WebglNumber = __webpack_require__(8);

var _WebglNumber2 = _interopRequireDefault(_WebglNumber);

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;

var GLTexture = function () {
	function GLTexture(mSource) {
		var mParam = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		var _this = this;

		var mWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
		var mHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

		_classCallCheck(this, GLTexture);

		gl = _GLTool2.default.gl;

		this._source = mSource;
		this._getDimension(mSource, mWidth, mHeight);
		this._sourceType = mParam.type || getSourceType(mSource);
		this._checkSource();
		this._texelType = this._getTexelType();
		this._isTextureReady = true;

		this._params = (0, _getTextureParameters2.default)(mParam, mSource, this._width, this._height);
		this._checkMipmap();
		this._checkWrapping();

		//	setup texture
		this._texture = gl.createTexture();

		if (this._sourceType === 'video') {
			this._isTextureReady = false;
			_scheduling2.default.addEF(function () {
				return _this._loop();
			});
		} else {
			this._uploadTexture();
		}
	}

	_createClass(GLTexture, [{
		key: '_loop',
		value: function _loop() {
			if (this._source.readyState == 4) {
				this._isTextureReady = true;
				this._uploadTexture();
			}
		}
	}, {
		key: '_uploadTexture',
		value: function _uploadTexture() {
			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

			if (this._isSourceHtmlElement()) {
				gl.texImage2D(gl.TEXTURE_2D, 0, this._params.internalFormat, this._params.format, this._texelType, this._source);
			} else {
				gl.texImage2D(gl.TEXTURE_2D, 0, this._params.internalFormat, this._width, this._height, 0, this._params.format, this._texelType, this._source);
			}

			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this._params.magFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._params.minFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._params.wrapS);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._params.wrapT);
			gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._params.premultiplyAlpha);

			if (this._params.anisotropy > 0) {
				var ext = _GLTool2.default.getExtension('EXT_texture_filter_anisotropic');
				if (ext) {
					var max = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
					var level = Math.min(max, this._params.anisotropy);
					gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, level);
				}
			}

			if (this._generateMipmap) {
				gl.generateMipmap(gl.TEXTURE_2D);
			}

			//	unbind texture
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: 'bind',
		value: function bind(index) {
			if (index === undefined) {
				index = 0;
			}
			if (!_GLTool2.default.shader) {
				return;
			}

			gl.activeTexture(gl.TEXTURE0 + index);
			if (this._isTextureReady) {
				gl.bindTexture(gl.TEXTURE_2D, this._texture);
			} else {
				gl.bindTexture(gl.TEXTURE_2D, GLTexture.blackTexture().texture);
			}

			this._bindIndex = index;
		}
	}, {
		key: 'updateTexture',
		value: function updateTexture(mSource) {
			this._source = mSource;
			this._checkSource();
			this._uploadTexture();
		}
	}, {
		key: 'generateMipmap',
		value: function generateMipmap() {
			if (!this._generateMipmap) {
				return;
			}
			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.generateMipmap(gl.TEXTURE_2D);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: 'showParameters',
		value: function showParameters() {
			console.log('Source type : ', _WebglNumber2.default[this._sourceType] || this._sourceType);
			console.log('Texel type:', _WebglNumber2.default[this.texelType]);
			console.log('Dimension :', this._width, this._height);
			for (var s in this._params) {
				console.log(s, _WebglNumber2.default[this._params[s]] || this._params[s]);
			}

			console.log('Mipmapping :', this._generateMipmap);
		}
	}, {
		key: '_getDimension',
		value: function _getDimension(mSource, mWidth, mHeight) {
			if (mSource) {
				//	for html image / video element
				this._width = mSource.width || mSource.videoWidth;
				this._height = mSource.height || mSource.videoWidth;

				//	for manual width / height settings
				this._width = this._width || mWidth;
				this._height = this._height || mHeight;

				//	auto detect ( data array) ? not sure is good idea ? 
				//	todo : check HDR 
				if (!this._width || !this._height) {
					this._width = this._height = Math.sqrt(mSource.length / 4);
					// console.log('Auto detect, data dimension : ', this._width, this._height);	
				}
			} else {
				this._width = mWidth;
				this._height = mHeight;
			}
		}
	}, {
		key: '_checkSource',
		value: function _checkSource() {
			if (!this._source) {
				return;
			}

			if (this._sourceType === _GLTool2.default.UNSIGNED_BYTE) {
				if (!(this._source instanceof Uint8Array)) {
					// console.log('Converting to Uint8Array');
					this._source = new Uint8Array(this._source);
				}
			} else if (this._sourceType === _GLTool2.default.FLOAT) {
				if (!(this._source instanceof Float32Array)) {
					// console.log('Converting to Float32Array');
					this._source = new Float32Array(this._source);
				}
			}
		}
	}, {
		key: '_getTexelType',
		value: function _getTexelType() {
			if (this._isSourceHtmlElement()) {
				return _GLTool2.default.UNSIGNED_BYTE;
			}

			//	bad code here, if the type is not on the webglNumber list, it doesn't work
			return _GLTool2.default[_WebglNumber2.default[this._sourceType]] || this._sourceType;
		}
	}, {
		key: '_checkMipmap',
		value: function _checkMipmap() {
			this._generateMipmap = this._params.mipmap;

			if (!(isPowerOfTwo(this._width) && isPowerOfTwo(this._height))) {
				this._generateMipmap = false;
			}

			var minFilter = _WebglNumber2.default[this._params.minFilter];
			if (minFilter.indexOf('MIPMAP') == -1) {
				this._generateMipmap = false;
			}
		}
	}, {
		key: '_checkWrapping',
		value: function _checkWrapping() {
			if (!this._generateMipmap) {
				this._params.wrapS = _GLTool2.default.CLAMP_TO_EDGE;
				this._params.wrapT = _GLTool2.default.CLAMP_TO_EDGE;
			}
		}
	}, {
		key: '_isSourceHtmlElement',
		value: function _isSourceHtmlElement() {
			return this._sourceType === 'image' || this._sourceType === 'video' || this._sourceType === 'canvas';
		}
	}, {
		key: 'minFilter',
		get: function get() {
			return this._params.minFilter;
		},
		set: function set(mValue) {
			this._params.minFilter = mValue;
			this._checkMipmap();

			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._params.minFilter);
			gl.bindTexture(gl.TEXTURE_2D, null);

			this.generateMipmap();
		}
	}, {
		key: 'magFilter',
		get: function get() {
			return this._params.minFilter;
		},
		set: function set(mValue) {
			this._params.magFilter = mValue;

			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this._params.magFilter);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: 'wrapS',
		get: function get() {
			return this._params.wrapS;
		},
		set: function set(mValue) {
			this._params.wrapS = mValue;
			this._checkWrapping();

			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._params.wrapS);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: 'wrapT',
		get: function get() {
			return this._params.wrapT;
		},
		set: function set(mValue) {
			this._params.wrapT = mValue;
			this._checkWrapping();

			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._params.wrapT);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: 'texelType',
		get: function get() {
			return this._texelType;
		}
	}, {
		key: 'width',
		get: function get() {
			return this._width;
		}
	}, {
		key: 'height',
		get: function get() {
			return this._height;
		}
	}, {
		key: 'texture',
		get: function get() {
			return this._texture;
		}
	}, {
		key: 'isTextureReady',
		get: function get() {
			return this._isTextureReady;
		}
	}]);

	return GLTexture;
}();

function isPowerOfTwo(x) {
	return x !== 0 && !(x & x - 1);
};

function getSourceType(mSource) {
	//	possible source type : Image / Video / Unit8Array / Float32Array
	//	this list must be flexible

	var type = _GLTool2.default.UNSIGNED_BYTE;

	if (mSource instanceof Array) {
		type = _GLTool2.default.UNSIGNED_BYTE;
	} else if (mSource instanceof Uint8Array) {
		type = _GLTool2.default.UNSIGNED_BYTE;
	} else if (mSource instanceof Float32Array) {
		type = _GLTool2.default.FLOAT;
	} else if (mSource instanceof HTMLImageElement) {
		type = 'image';
	} else if (mSource instanceof HTMLCanvasElement) {
		type = 'canvas';
	} else if (mSource instanceof HTMLVideoElement) {
		type = 'video';
	}
	return type;
}

var _whiteTexture = void 0,
    _greyTexture = void 0,
    _blackTexture = void 0;

GLTexture.whiteTexture = function whiteTexture() {
	if (_whiteTexture === undefined) {
		var canvas = document.createElement('canvas');
		canvas.width = canvas.height = 2;
		var ctx = canvas.getContext('2d');
		ctx.fillStyle = '#fff';
		ctx.fillRect(0, 0, 2, 2);
		_whiteTexture = new GLTexture(canvas);
	}

	return _whiteTexture;
};

GLTexture.greyTexture = function greyTexture() {
	if (_greyTexture === undefined) {
		var canvas = document.createElement('canvas');
		canvas.width = canvas.height = 2;
		var ctx = canvas.getContext('2d');
		ctx.fillStyle = 'rgb(127, 127, 127)';
		ctx.fillRect(0, 0, 2, 2);
		_greyTexture = new GLTexture(canvas);
	}
	return _greyTexture;
};

GLTexture.blackTexture = function blackTexture() {
	if (_blackTexture === undefined) {
		var canvas = document.createElement('canvas');
		canvas.width = canvas.height = 2;
		var ctx = canvas.getContext('2d');
		ctx.fillStyle = 'rgb(0, 0, 0)';
		ctx.fillRect(0, 0, 2, 2);
		_blackTexture = new GLTexture(canvas);
	}
	return _blackTexture;
};

exports.default = GLTexture;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// GLCubeTexture.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _parseDds = __webpack_require__(57);

var _parseDds2 = _interopRequireDefault(_parseDds);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;
var DDSD_MIPMAPCOUNT = 0x20000;
var OFF_MIPMAPCOUNT = 7;
var headerLengthInt = 31;

var GLCubeTexture = function () {
	function GLCubeTexture(mSource) {
		var mParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		var isCubeTexture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

		_classCallCheck(this, GLCubeTexture);

		gl = _GLTool2.default.gl;

		if (isCubeTexture) {
			this.texture = mSource;
			return;
		}

		var hasMipmaps = mSource.length > 6;
		if (mSource[0].mipmapCount) {
			hasMipmaps = mSource[0].mipmapCount > 1;
		}

		this.texture = gl.createTexture();
		this.magFilter = mParameters.magFilter || gl.LINEAR;
		this.minFilter = mParameters.minFilter || gl.LINEAR_MIPMAP_LINEAR;
		this.wrapS = mParameters.wrapS || gl.CLAMP_TO_EDGE;
		this.wrapT = mParameters.wrapT || gl.CLAMP_TO_EDGE;

		if (!hasMipmaps && this.minFilter == gl.LINEAR_MIPMAP_LINEAR) {
			this.minFilter = gl.LINEAR;
		}

		gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
		var targets = [gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];

		var numLevels = 1;
		var index = 0;
		numLevels = mSource.length / 6;
		this.numLevels = numLevels;

		if (hasMipmaps) {
			for (var j = 0; j < 6; j++) {
				for (var i = 0; i < numLevels; i++) {
					gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

					index = j * numLevels + i;
					if (mSource[index].shape) {
						gl.texImage2D(targets[j], i, gl.RGBA, mSource[index].shape[0], mSource[index].shape[1], 0, gl.RGBA, gl.FLOAT, mSource[index].data);
					} else {
						gl.texImage2D(targets[j], i, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, mSource[index]);
					}

					gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, this.wrapS);
					gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, this.wrapT);
					gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, this.magFilter);
					gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, this.minFilter);
				}
			}
		} else {
			var _index = 0;
			for (var _j = 0; _j < 6; _j++) {
				_index = _j * numLevels;
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
				if (mSource[_index].shape) {
					gl.texImage2D(targets[_j], 0, gl.RGBA, mSource[_index].shape[0], mSource[_index].shape[1], 0, gl.RGBA, gl.FLOAT, mSource[_index].data);
				} else {
					gl.texImage2D(targets[_j], 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, mSource[_index]);
				}
				gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, this.wrapS);
				gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, this.wrapT);
				gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, this.magFilter);
				gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, this.minFilter);
			}

			gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
		}

		gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
	}

	//	PUBLIC METHOD

	_createClass(GLCubeTexture, [{
		key: 'bind',
		value: function bind() {
			var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

			if (!_GLTool2.default.shader) {
				return;
			}

			gl.activeTexture(gl.TEXTURE0 + index);
			gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
			gl.uniform1i(_GLTool2.default.shader.uniformTextures[index], index);
			this._bindIndex = index;
		}
	}, {
		key: 'unbind',
		value: function unbind() {
			gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
		}
	}]);

	return GLCubeTexture;
}();

GLCubeTexture.parseDDS = function parseDDS(mArrayBuffer) {

	function clamp(value, min, max) {
		if (min > max) {
			return clamp(value, max, min);
		}

		if (value < min) return min;else if (value > max) return max;else return value;
	}

	//	CHECKING MIP MAP LEVELS
	var ddsInfos = (0, _parseDds2.default)(mArrayBuffer);
	var flags = ddsInfos.flags;

	var header = new Int32Array(mArrayBuffer, 0, headerLengthInt);
	var mipmapCount = 1;
	if (flags & DDSD_MIPMAPCOUNT) {
		mipmapCount = Math.max(1, header[OFF_MIPMAPCOUNT]);
	}
	var sources = ddsInfos.images.map(function (img) {
		var faceData = new Float32Array(mArrayBuffer.slice(img.offset, img.offset + img.length));
		return {
			data: faceData,
			shape: img.shape,
			mipmapCount: mipmapCount
		};
	});

	return new GLCubeTexture(sources);
};

exports.default = GLCubeTexture;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// EventDispatcher.js

var supportsCustomEvents = true;
try {
	var newTestCustomEvent = document.createEvent('CustomEvent');
	newTestCustomEvent = null;
} catch (e) {
	supportsCustomEvents = false;
}

var EventDispatcher = function () {
	function EventDispatcher() {
		_classCallCheck(this, EventDispatcher);

		this._eventListeners = {};
	}

	_createClass(EventDispatcher, [{
		key: 'addEventListener',
		value: function addEventListener(aEventType, aFunction) {

			if (this._eventListeners === null || this._eventListeners === undefined) {
				this._eventListeners = {};
			}

			if (!this._eventListeners[aEventType]) {
				this._eventListeners[aEventType] = [];
			}
			this._eventListeners[aEventType].push(aFunction);

			return this;
		}
	}, {
		key: 'on',
		value: function on(aEventType, aFunction) {
			return this.addEventListener(aEventType, aFunction);
		}
	}, {
		key: 'removeEventListener',
		value: function removeEventListener(aEventType, aFunction) {
			if (this._eventListeners === null || this._eventListeners === undefined) {
				this._eventListeners = {};
			}
			var currentArray = this._eventListeners[aEventType];

			if (typeof currentArray === 'undefined') {
				return this;
			}

			var currentArrayLength = currentArray.length;
			for (var i = 0; i < currentArrayLength; i++) {
				if (currentArray[i] === aFunction) {
					currentArray.splice(i, 1);
					i--;
					currentArrayLength--;
				}
			}
			return this;
		}
	}, {
		key: 'off',
		value: function off(aEventType, aFunction) {
			return this.removeEventListener(aEventType, aFunction);
		}
	}, {
		key: 'dispatchEvent',
		value: function dispatchEvent(aEvent) {
			if (this._eventListeners === null || this._eventListeners === undefined) {
				this._eventListeners = {};
			}
			var eventType = aEvent.type;

			try {
				if (aEvent.target === null) {
					aEvent.target = this;
				}
				aEvent.currentTarget = this;
			} catch (theError) {
				var newEvent = { type: eventType, detail: aEvent.detail, dispatcher: this };
				return this.dispatchEvent(newEvent);
			}

			var currentEventListeners = this._eventListeners[eventType];
			if (currentEventListeners !== null && currentEventListeners !== undefined) {
				var currentArray = this._copyArray(currentEventListeners);
				var currentArrayLength = currentArray.length;
				for (var i = 0; i < currentArrayLength; i++) {
					var currentFunction = currentArray[i];
					currentFunction.call(this, aEvent);
				}
			}
			return this;
		}
	}, {
		key: 'dispatchCustomEvent',
		value: function dispatchCustomEvent(aEventType, aDetail) {
			var newEvent = void 0;
			if (supportsCustomEvents) {
				newEvent = document.createEvent('CustomEvent');
				newEvent.dispatcher = this;
				newEvent.initCustomEvent(aEventType, false, false, aDetail);
			} else {
				newEvent = { type: aEventType, detail: aDetail, dispatcher: this };
			}
			return this.dispatchEvent(newEvent);
		}
	}, {
		key: 'trigger',
		value: function trigger(aEventType, aDetail) {
			return this.dispatchCustomEvent(aEventType, aDetail);
		}
	}, {
		key: '_destroy',
		value: function _destroy() {
			if (this._eventListeners !== null) {
				for (var objectName in this._eventListeners) {
					if (this._eventListeners.hasOwnProperty(objectName)) {
						var currentArray = this._eventListeners[objectName];
						var currentArrayLength = currentArray.length;
						for (var i = 0; i < currentArrayLength; i++) {
							currentArray[i] = null;
						}
						delete this._eventListeners[objectName];
					}
				}
				this._eventListeners = null;
			}
		}
	}, {
		key: '_copyArray',
		value: function _copyArray(aArray) {
			var currentArray = new Array(aArray.length);
			var currentArrayLength = currentArray.length;
			for (var i = 0; i < currentArrayLength; i++) {
				currentArray[i] = aArray[i];
			}
			return currentArray;
		}
	}]);

	return EventDispatcher;
}();

exports.default = EventDispatcher;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OrbitalControl.js


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _EaseNumber = __webpack_require__(13);

var _EaseNumber2 = _interopRequireDefault(_EaseNumber);

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

var _glMatrix = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var getMouse = function getMouse(mEvent, mTarget) {

	var o = mTarget || {};
	if (mEvent.touches) {
		o.x = mEvent.touches[0].pageX;
		o.y = mEvent.touches[0].pageY;
	} else {
		o.x = mEvent.clientX;
		o.y = mEvent.clientY;
	}

	return o;
};

var OrbitalControl = function () {
	function OrbitalControl(mTarget) {
		var _this = this;

		var mListenerTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;
		var mRadius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 500;

		_classCallCheck(this, OrbitalControl);

		this._target = mTarget;
		this._listenerTarget = mListenerTarget;
		this._mouse = {};
		this._preMouse = {};
		this.center = _glMatrix.vec3.create();
		this._up = _glMatrix.vec3.fromValues(0, 1, 0);
		this.radius = new _EaseNumber2.default(mRadius);
		this.position = _glMatrix.vec3.fromValues(0, 0, this.radius.value);
		this.positionOffset = _glMatrix.vec3.create();
		this._rx = new _EaseNumber2.default(0);
		this._rx.limit(-Math.PI / 2, Math.PI / 2);
		this._ry = new _EaseNumber2.default(0);
		this._preRX = 0;
		this._preRY = 0;

		this._isLockZoom = false;
		this._isLockRotation = false;
		this._isInvert = false;
		this.sensitivity = 1.0;

		this._wheelBind = function (e) {
			return _this._onWheel(e);
		};
		this._downBind = function (e) {
			return _this._onDown(e);
		};
		this._moveBind = function (e) {
			return _this._onMove(e);
		};
		this._upBind = function () {
			return _this._onUp();
		};

		this.connect();
		_scheduling2.default.addEF(function () {
			return _this._loop();
		});
	}

	_createClass(OrbitalControl, [{
		key: 'connect',
		value: function connect() {
			this.disconnect();

			this._listenerTarget.addEventListener('mousewheel', this._wheelBind);
			this._listenerTarget.addEventListener('DOMMouseScroll', this._wheelBind);

			this._listenerTarget.addEventListener('mousedown', this._downBind);
			this._listenerTarget.addEventListener('touchstart', this._downBind);
			this._listenerTarget.addEventListener('mousemove', this._moveBind);
			this._listenerTarget.addEventListener('touchmove', this._moveBind);
			window.addEventListener('touchend', this._upBind);
			window.addEventListener('mouseup', this._upBind);
		}
	}, {
		key: 'disconnect',
		value: function disconnect() {
			this._listenerTarget.removeEventListener('mousewheel', this._wheelBind);
			this._listenerTarget.removeEventListener('DOMMouseScroll', this._wheelBind);

			this._listenerTarget.removeEventListener('mousedown', this._downBind);
			this._listenerTarget.removeEventListener('touchstart', this._downBind);
			this._listenerTarget.removeEventListener('mousemove', this._moveBind);
			this._listenerTarget.removeEventListener('touchmove', this._moveBind);
			window.removeEventListener('touchend', this._upBind);
			window.removeEventListener('mouseup', this._upBind);
		}

		//	PUBLIC METHODS

	}, {
		key: 'lock',
		value: function lock() {
			var mValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			this._isLockZoom = mValue;
			this._isLockRotation = mValue;
			this._isMouseDown = false;
		}
	}, {
		key: 'lockZoom',
		value: function lockZoom() {
			var mValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			this._isLockZoom = mValue;
		}
	}, {
		key: 'lockRotation',
		value: function lockRotation() {
			var mValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			this._isLockRotation = mValue;
		}
	}, {
		key: 'inverseControl',
		value: function inverseControl() {
			var isInvert = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			this._isInvert = isInvert;
		}

		//	EVENT HANDLERES

	}, {
		key: '_onDown',
		value: function _onDown(mEvent) {
			if (this._isLockRotation) {
				return;
			}
			this._isMouseDown = true;
			getMouse(mEvent, this._mouse);
			getMouse(mEvent, this._preMouse);
			this._preRX = this._rx.targetValue;
			this._preRY = this._ry.targetValue;
		}
	}, {
		key: '_onMove',
		value: function _onMove(mEvent) {
			if (this._isLockRotation) {
				return;
			}
			getMouse(mEvent, this._mouse);
			if (mEvent.touches) {
				mEvent.preventDefault();
			}

			if (this._isMouseDown) {
				var diffX = -(this._mouse.x - this._preMouse.x);
				if (this._isInvert) {
					diffX *= -1;
				}
				this._ry.value = this._preRY - diffX * 0.01 * this.sensitivity;

				var diffY = -(this._mouse.y - this._preMouse.y);
				if (this._isInvert) {
					diffY *= -1;
				}
				this._rx.value = this._preRX - diffY * 0.01 * this.sensitivity;
			}
		}
	}, {
		key: '_onUp',
		value: function _onUp() {
			if (this._isLockRotation) {
				return;
			}
			this._isMouseDown = false;
		}
	}, {
		key: '_onWheel',
		value: function _onWheel(mEvent) {
			if (this._isLockZoom) {
				return;
			}
			var w = mEvent.wheelDelta;
			var d = mEvent.detail;
			var value = 0;
			if (d) {
				if (w) {
					value = w / d / 40 * d > 0 ? 1 : -1; // Opera
				} else {
					value = -d / 3; // Firefox;         TODO: do not /3 for OS X
				}
			} else {
				value = w / 120;
			}

			this.radius.add(-value * 2);
		}

		//	PRIVATE METHODS

	}, {
		key: '_loop',
		value: function _loop() {

			this._updatePosition();

			if (this._target) {
				this._updateCamera();
			}
		}
	}, {
		key: '_updatePosition',
		value: function _updatePosition() {
			this.position[1] = Math.sin(this._rx.value) * this.radius.value;
			var tr = Math.cos(this._rx.value) * this.radius.value;
			this.position[0] = Math.cos(this._ry.value + Math.PI * 0.5) * tr;
			this.position[2] = Math.sin(this._ry.value + Math.PI * 0.5) * tr;
			_glMatrix.vec3.add(this.position, this.position, this.positionOffset);
		}
	}, {
		key: '_updateCamera',
		value: function _updateCamera() {
			this._target.lookAt(this.position, this.center, this._up);
		}

		//	GETTER / SETTER


	}, {
		key: 'rx',
		get: function get() {
			return this._rx;
		}
	}, {
		key: 'ry',
		get: function get() {
			return this._ry;
		}
	}]);

	return OrbitalControl;
}();

exports.default = OrbitalControl;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Camera2 = __webpack_require__(15);

var _Camera3 = _interopRequireDefault(_Camera2);

var _glMatrix = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // CameraOrtho.js

var CameraOrtho = function (_Camera) {
	_inherits(CameraOrtho, _Camera);

	function CameraOrtho() {
		_classCallCheck(this, CameraOrtho);

		var _this = _possibleConstructorReturn(this, (CameraOrtho.__proto__ || Object.getPrototypeOf(CameraOrtho)).call(this));

		var eye = _glMatrix.vec3.clone([0, 0, 15]);
		var center = _glMatrix.vec3.create();
		var up = _glMatrix.vec3.clone([0, -1, 0]);
		_this.lookAt(eye, center, up);
		_this.ortho(1, -1, 1, -1);
		return _this;
	}

	_createClass(CameraOrtho, [{
		key: 'setBoundary',
		value: function setBoundary(left, right, top, bottom) {
			var near = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.1;
			var far = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 100;

			this.ortho(left, right, top, bottom, near, far);
		}
	}, {
		key: 'ortho',
		value: function ortho(left, right, top, bottom) {
			var near = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.1;
			var far = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 100;

			this.left = left;
			this.right = right;
			this.top = top;
			this.bottom = bottom;
			mat4.ortho(this._projection, left, right, top, bottom, near, far);
		}
	}]);

	return CameraOrtho;
}(_Camera3.default);

exports.default = CameraOrtho;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Object3D.js

var _glMatrix = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Object3D = function () {
	function Object3D() {
		_classCallCheck(this, Object3D);

		this._needUpdate = true;

		this._x = 0;
		this._y = 0;
		this._z = 0;

		this._sx = 1;
		this._sy = 1;
		this._sz = 1;

		this._rx = 0;
		this._ry = 0;
		this._rz = 0;

		this._position = _glMatrix.vec3.create();
		this._scale = _glMatrix.vec3.fromValues(1, 1, 1);
		this._rotation = _glMatrix.vec3.create();

		this._matrix = _glMatrix.mat4.create();
		this._matrixRotation = _glMatrix.mat4.create();
		this._matrixScale = _glMatrix.mat4.create();
		this._matrixTranslation = _glMatrix.mat4.create();
		this._matrixQuaternion = _glMatrix.mat4.create();
		this._quat = _glMatrix.quat.create();
	}

	_createClass(Object3D, [{
		key: '_update',
		value: function _update() {
			_glMatrix.vec3.set(this._scale, this._sx, this._sy, this._sz);
			_glMatrix.vec3.set(this._rotation, this._rx, this._ry, this._rz);
			_glMatrix.vec3.set(this._position, this._x, this._y, this._z);

			_glMatrix.mat4.identity(this._matrixTranslation, this._matrixTranslation);
			_glMatrix.mat4.identity(this._matrixScale, this._matrixScale);
			_glMatrix.mat4.identity(this._matrixRotation, this._matrixRotation);

			_glMatrix.mat4.rotateX(this._matrixRotation, this._matrixRotation, this._rx);
			_glMatrix.mat4.rotateY(this._matrixRotation, this._matrixRotation, this._ry);
			_glMatrix.mat4.rotateZ(this._matrixRotation, this._matrixRotation, this._rz);

			_glMatrix.mat4.fromQuat(this._matrixQuaternion, this._quat);
			_glMatrix.mat4.mul(this._matrixRotation, this._matrixQuaternion, this._matrixRotation);

			_glMatrix.mat4.scale(this._matrixScale, this._matrixScale, this._scale);
			_glMatrix.mat4.translate(this._matrixTranslation, this._matrixTranslation, this._position);

			_glMatrix.mat4.mul(this._matrix, this._matrixTranslation, this._matrixRotation);
			_glMatrix.mat4.mul(this._matrix, this._matrix, this._matrixScale);

			this._needUpdate = false;
		}
	}, {
		key: 'setRotationFromQuaternion',
		value: function setRotationFromQuaternion(mQuat) {
			_glMatrix.quat.copy(this._quat, mQuat);
			this._needUpdate = true;
		}
	}, {
		key: 'matrix',
		get: function get() {
			if (this._needUpdate) {
				this._update();
			}
			return this._matrix;
		}
	}, {
		key: 'x',
		get: function get() {
			return this._x;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._x = mValue;
		}
	}, {
		key: 'y',
		get: function get() {
			return this._y;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._y = mValue;
		}
	}, {
		key: 'z',
		get: function get() {
			return this._z;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._z = mValue;
		}
	}, {
		key: 'scaleX',
		get: function get() {
			return this._sx;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._sx = mValue;
		}
	}, {
		key: 'scaleY',
		get: function get() {
			return this._sy;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._sy = mValue;
		}
	}, {
		key: 'scaleZ',
		get: function get() {
			return this._sz;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._sz = mValue;
		}
	}, {
		key: 'rotationX',
		get: function get() {
			return this._rx;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._rx = mValue;
		}
	}, {
		key: 'rotationY',
		get: function get() {
			return this._ry;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._ry = mValue;
		}
	}, {
		key: 'rotationZ',
		get: function get() {
			return this._rz;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._rz = mValue;
		}
	}]);

	return Object3D;
}();

exports.default = Object3D;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// ShaderLbs.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _simpleColor = __webpack_require__(10);

var _simpleColor2 = _interopRequireDefault(_simpleColor);

var _bigTriangle = __webpack_require__(18);

var _bigTriangle2 = _interopRequireDefault(_bigTriangle);

var _general = __webpack_require__(34);

var _general2 = _interopRequireDefault(_general);

var _copy = __webpack_require__(19);

var _copy2 = _interopRequireDefault(_copy);

var _basic = __webpack_require__(11);

var _basic2 = _interopRequireDefault(_basic);

var _skybox = __webpack_require__(35);

var _skybox2 = _interopRequireDefault(_skybox);

var _skybox3 = __webpack_require__(36);

var _skybox4 = _interopRequireDefault(_skybox3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ShaderLibs = {
	simpleColorFrag: _simpleColor2.default,
	bigTriangleVert: _bigTriangle2.default,
	generalVert: _general2.default,
	copyFrag: _copy2.default,
	basicVert: _basic2.default,
	skyboxVert: _skybox2.default,
	skyboxFrag: _skybox4.default
};

exports.default = ShaderLibs;

/***/ }),
/* 34 */
/***/ (function(module, exports) {

module.exports = "// generalWithNormal.vert\n\n#define SHADER_NAME GENERAL_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\n\nuniform vec3 position;\nuniform vec3 scale;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\n\nvoid main(void) {\n\tvec3 pos      = aVertexPosition * scale;\n\tpos           += position;\n\tgl_Position   = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(pos, 1.0);\n\t\n\tvTextureCoord = aTextureCoord;\n\tvNormal       = normalize(uNormalMatrix * aNormal);\n}"

/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = "// basic.vert\n\n#define SHADER_NAME SKYBOX_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vVertex;\nvarying vec3 vNormal;\n\nvoid main(void) {\n\tmat4 matView = uViewMatrix;\n\tmatView[3][0] = 0.0;\n\tmatView[3][1] = 0.0;\n\tmatView[3][2] = 0.0;\n\t\n\tgl_Position = uProjectionMatrix * matView * uModelMatrix * vec4(aVertexPosition, 1.0);\n\tvTextureCoord = aTextureCoord;\n\t\n\tvVertex = aVertexPosition;\n\tvNormal = aNormal;\n}"

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = "// basic.frag\n\n#define SHADER_NAME SKYBOX_FRAGMENT\n\nprecision mediump float;\n#define GLSLIFY 1\nuniform samplerCube texture;\nvarying vec2 vTextureCoord;\nvarying vec3 vVertex;\n\nvoid main(void) {\n    gl_FragColor = textureCube(texture, vVertex);\n}"

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// PassMacro.js

var PassMacro = function () {
	function PassMacro() {
		_classCallCheck(this, PassMacro);

		this._passes = [];
	}

	_createClass(PassMacro, [{
		key: "addPass",
		value: function addPass(pass) {
			this._passes.push(pass);
		}
	}, {
		key: "passes",
		get: function get() {
			return this._passes;
		}
	}]);

	return PassMacro;
}();

exports.default = PassMacro;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _PassBlurBase2 = __webpack_require__(39);

var _PassBlurBase3 = _interopRequireDefault(_PassBlurBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // PassVBlur.js

var PassVBlur = function (_PassBlurBase) {
	_inherits(PassVBlur, _PassBlurBase);

	function PassVBlur() {
		var mQuality = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 9;
		var mWidth = arguments[1];
		var mHeight = arguments[2];
		var mParams = arguments[3];

		_classCallCheck(this, PassVBlur);

		return _possibleConstructorReturn(this, (PassVBlur.__proto__ || Object.getPrototypeOf(PassVBlur)).call(this, mQuality, [0, 1], mWidth, mHeight, mParams));
	}

	return PassVBlur;
}(_PassBlurBase3.default);

exports.default = PassVBlur;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Pass2 = __webpack_require__(9);

var _Pass3 = _interopRequireDefault(_Pass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // PassBlurBase.js

var fsBlur5 = __webpack_require__(76);
var fsBlur9 = __webpack_require__(77);
var fsBlur13 = __webpack_require__(78);

var PassBlurBase = function (_Pass) {
	_inherits(PassBlurBase, _Pass);

	function PassBlurBase() {
		var mQuality = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 9;
		var mDirection = arguments[1];
		var mWidth = arguments[2];
		var mHeight = arguments[3];
		var mParams = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

		_classCallCheck(this, PassBlurBase);

		var fs = void 0;
		switch (mQuality) {
			case 5:
			default:
				fs = fsBlur5;
				break;
			case 9:
				fs = fsBlur9;
				break;
			case 13:
				fs = fsBlur13;
				break;

		}

		var _this = _possibleConstructorReturn(this, (PassBlurBase.__proto__ || Object.getPrototypeOf(PassBlurBase)).call(this, fs, mWidth, mHeight, mParams));

		_this.uniform('uDirection', mDirection);
		_this.uniform('uResolution', [_GLTool2.default.width, _GLTool2.default.height]);
		return _this;
	}

	return PassBlurBase;
}(_Pass3.default);

exports.default = PassBlurBase;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _PassBlurBase2 = __webpack_require__(39);

var _PassBlurBase3 = _interopRequireDefault(_PassBlurBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // PassHBlur.js

var PassHBlur = function (_PassBlurBase) {
	_inherits(PassHBlur, _PassBlurBase);

	function PassHBlur() {
		var mQuality = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 9;
		var mWidth = arguments[1];
		var mHeight = arguments[2];
		var mParams = arguments[3];

		_classCallCheck(this, PassHBlur);

		return _possibleConstructorReturn(this, (PassHBlur.__proto__ || Object.getPrototypeOf(PassHBlur)).call(this, mQuality, [1, 0], mWidth, mHeight, mParams));
	}

	return PassHBlur;
}(_PassBlurBase3.default);

exports.default = PassHBlur;

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = "// fxaa.frag\n\n#define SHADER_NAME FXAA\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\nuniform vec2 uResolution;\n\n\nfloat FXAA_SUBPIX_SHIFT = 1.0/4.0;\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#define FXAA_SPAN_MAX     8.0\n\n\nvec4 applyFXAA(sampler2D tex) {\n    vec4 color;\n    vec2 fragCoord = gl_FragCoord.xy;\n    vec3 rgbNW = texture2D(tex, (fragCoord + vec2(-1.0, -1.0)) * uResolution).xyz;\n    vec3 rgbNE = texture2D(tex, (fragCoord + vec2(1.0, -1.0)) * uResolution).xyz;\n    vec3 rgbSW = texture2D(tex, (fragCoord + vec2(-1.0, 1.0)) * uResolution).xyz;\n    vec3 rgbSE = texture2D(tex, (fragCoord + vec2(1.0, 1.0)) * uResolution).xyz;\n    vec3 rgbM  = texture2D(tex, fragCoord  * uResolution).xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n              dir * rcpDirMin)) * uResolution;\n\n    vec3 rgbA = 0.5 * (\n        texture2D(tex, fragCoord * uResolution + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture2D(tex, fragCoord * uResolution + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture2D(tex, fragCoord * uResolution + dir * -0.5).xyz +\n        texture2D(tex, fragCoord * uResolution + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, 1.0);\n    else\n        color = vec4(rgbB, 1.0);\n    return color;\n}\n\nvoid main(void) {\n \tvec4 color = applyFXAA(texture);\n    gl_FragColor = color;\n}"

/***/ }),
/* 42 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 43 */,
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["transpose"] = transpose;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["adjoint"] = adjoint;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["LDU"] = LDU;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(3);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */
function fromValues(m00, m01, m10, m11) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */
function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    let a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function invert(out, a) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];

  // Calculate the determinant
  let det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] =  a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] =  a0 * det;

  return out;
}

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  let a0 = a[0];
  out[0] =  a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] =  a0;

  return out;
}

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function multiply(out, a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function rotate(out, a, rad) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  out[0] = a0 *  c + a2 * s;
  out[1] = a1 *  c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
function scale(out, a, v) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let v0 = v[0], v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function fromRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
}

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2]/a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}

/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  return out;
}

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat2.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["translate"] = translate;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["fromTranslation"] = fromTranslation;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(3);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 2x3 Matrix
 * @module mat2d
 *
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](6);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */
function fromValues(a, b, c, d, tx, ty) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}

/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */
function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
function invert(out, a) {
  let aa = a[0], ab = a[1], ac = a[2], ad = a[3];
  let atx = a[4], aty = a[5];

  let det = aa * ad - ab * ac;
  if(!det){
    return null;
  }
  det = 1.0 / det;

  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function multiply(out, a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}

/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
function rotate(out, a, rad) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  out[0] = a0 *  c + a2 * s;
  out[1] = a1 *  c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
function scale(out, a, v) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let v0 = v[0], v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
function translate(out, a, v) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let v0 = v[0], v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
function fromRotation(out, rad) {
  let s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
          a[3] + ', ' + a[4] + ', ' + a[5] + ')';
}

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}

/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}

/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  out[4] = a[4] + (b[4] * scale);
  out[5] = a[5] + (b[5] * scale);
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
          Math.abs(a4 - b4) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
          Math.abs(a5 - b5) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a5), Math.abs(b5)));
}

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat2d.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["transpose"] = transpose;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["adjoint"] = adjoint;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["translate"] = translate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["rotateX"] = rotateX;
/* harmony export (immutable) */ __webpack_exports__["rotateY"] = rotateY;
/* harmony export (immutable) */ __webpack_exports__["rotateZ"] = rotateZ;
/* harmony export (immutable) */ __webpack_exports__["fromTranslation"] = fromTranslation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromXRotation"] = fromXRotation;
/* harmony export (immutable) */ __webpack_exports__["fromYRotation"] = fromYRotation;
/* harmony export (immutable) */ __webpack_exports__["fromZRotation"] = fromZRotation;
/* harmony export (immutable) */ __webpack_exports__["fromRotationTranslation"] = fromRotationTranslation;
/* harmony export (immutable) */ __webpack_exports__["getTranslation"] = getTranslation;
/* harmony export (immutable) */ __webpack_exports__["getScaling"] = getScaling;
/* harmony export (immutable) */ __webpack_exports__["getRotation"] = getRotation;
/* harmony export (immutable) */ __webpack_exports__["fromRotationTranslationScale"] = fromRotationTranslationScale;
/* harmony export (immutable) */ __webpack_exports__["fromRotationTranslationScaleOrigin"] = fromRotationTranslationScaleOrigin;
/* harmony export (immutable) */ __webpack_exports__["fromQuat"] = fromQuat;
/* harmony export (immutable) */ __webpack_exports__["frustum"] = frustum;
/* harmony export (immutable) */ __webpack_exports__["perspective"] = perspective;
/* harmony export (immutable) */ __webpack_exports__["perspectiveFromFieldOfView"] = perspectiveFromFieldOfView;
/* harmony export (immutable) */ __webpack_exports__["ortho"] = ortho;
/* harmony export (immutable) */ __webpack_exports__["lookAt"] = lookAt;
/* harmony export (immutable) */ __webpack_exports__["targetTo"] = targetTo;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(3);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 4x4 Matrix
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](16);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */
function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}

/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */
function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}


/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    let a01 = a[1], a02 = a[2], a03 = a[3];
    let a12 = a[6], a13 = a[7];
    let a23 = a[11];

    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function invert(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

  return out;
}

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function adjoint(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
  out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
  out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
  out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
  out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
  out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
  return out;
}

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}

/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  // Cache only the current line of the second matrix
  let b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
  out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
  out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
  out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
  return out;
}

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
  let x = v[0], y = v[1], z = v[2];
  let a00, a01, a02, a03;
  let a10, a11, a12, a13;
  let a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
    out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
    out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}

/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function scale(out, a, v) {
  let x = v[0], y = v[1], z = v[2];

  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function rotate(out, a, rad, axis) {
  let x = axis[0], y = axis[1], z = axis[2];
  let len = Math.sqrt(x * x + y * y + z * z);
  let s, c, t;
  let a00, a01, a02, a03;
  let a10, a11, a12, a13;
  let a20, a21, a22, a23;
  let b00, b01, b02;
  let b10, b11, b12;
  let b20, b21, b22;

  if (Math.abs(len) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]) { return null; }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
  a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
  a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

  // Construct the elements of the rotation matrix
  b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
  b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
  b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

  // Perform rotation-specific matrix multiplication
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) { // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateX(out, a, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  let a10 = a[4];
  let a11 = a[5];
  let a12 = a[6];
  let a13 = a[7];
  let a20 = a[8];
  let a21 = a[9];
  let a22 = a[10];
  let a23 = a[11];

  if (a !== out) { // If the source and destination differ, copy the unchanged rows
    out[0]  = a[0];
    out[1]  = a[1];
    out[2]  = a[2];
    out[3]  = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateY(out, a, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  let a00 = a[0];
  let a01 = a[1];
  let a02 = a[2];
  let a03 = a[3];
  let a20 = a[8];
  let a21 = a[9];
  let a22 = a[10];
  let a23 = a[11];

  if (a !== out) { // If the source and destination differ, copy the unchanged rows
    out[4]  = a[4];
    out[5]  = a[5];
    out[6]  = a[6];
    out[7]  = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateZ(out, a, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  let a00 = a[0];
  let a01 = a[1];
  let a02 = a[2];
  let a03 = a[3];
  let a10 = a[4];
  let a11 = a[5];
  let a12 = a[6];
  let a13 = a[7];

  if (a !== out) { // If the source and destination differ, copy the unchanged last row
    out[8]  = a[8];
    out[9]  = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function fromRotation(out, rad, axis) {
  let x = axis[0], y = axis[1], z = axis[2];
  let len = Math.sqrt(x * x + y * y + z * z);
  let s, c, t;

  if (Math.abs(len) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]) { return null; }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  // Perform rotation-specific matrix multiplication
  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromXRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0]  = 1;
  out[1]  = 0;
  out[2]  = 0;
  out[3]  = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromYRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0]  = c;
  out[1]  = 0;
  out[2]  = -s;
  out[3]  = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromZRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0]  = c;
  out[1]  = s;
  out[2]  = 0;
  out[3]  = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromRotationTranslation(out, q, v) {
  // Quaternion math
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;

  return out;
}

/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];

  return out;
}

/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getScaling(out, mat) {
  let m11 = mat[0];
  let m12 = mat[1];
  let m13 = mat[2];
  let m21 = mat[4];
  let m22 = mat[5];
  let m23 = mat[6];
  let m31 = mat[8];
  let m32 = mat[9];
  let m33 = mat[10];

  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);

  return out;
}

/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */
function getRotation(out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  let trace = mat[0] + mat[5] + mat[10];
  let S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S;
    out[2] = (mat[1] - mat[4]) / S;
  } else if ((mat[0] > mat[5])&(mat[0] > mat[10])) {
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S;
    out[2] = (mat[8] + mat[2]) / S;
  } else if (mat[5] > mat[10]) {
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S;
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S;
  } else {
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;
  let sx = s[0];
  let sy = s[1];
  let sz = s[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;

  return out;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  let sx = s[0];
  let sy = s[1];
  let sz = s[2];

  let ox = o[0];
  let oy = o[1];
  let oz = o[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
  out[15] = 1;

  return out;
}

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
function fromQuat(out, q) {
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let yx = y * x2;
  let yy = y * y2;
  let zx = z * x2;
  let zy = z * y2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;

  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;

  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;

  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;

  return out;
}

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
function frustum(out, left, right, bottom, top, near, far) {
  let rl = 1 / (right - left);
  let tb = 1 / (top - bottom);
  let nf = 1 / (near - far);
  out[0] = (near * 2) * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = (near * 2) * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = (far * near * 2) * nf;
  out[15] = 0;
  return out;
}

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
  let f = 1.0 / Math.tan(fovy / 2);
  let nf = 1 / (near - far);
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = (2 * far * near) * nf;
  out[15] = 0;
  return out;
}

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspectiveFromFieldOfView(out, fov, near, far) {
  let upTan = Math.tan(fov.upDegrees * Math.PI/180.0);
  let downTan = Math.tan(fov.downDegrees * Math.PI/180.0);
  let leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0);
  let rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0);
  let xScale = 2.0 / (leftTan + rightTan);
  let yScale = 2.0 / (upTan + downTan);

  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = ((upTan - downTan) * yScale * 0.5);
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = (far * near) / (near - far);
  out[15] = 0.0;
  return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function ortho(out, left, right, bottom, top, near, far) {
  let lr = 1 / (left - right);
  let bt = 1 / (bottom - top);
  let nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
  let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  let eyex = eye[0];
  let eyey = eye[1];
  let eyez = eye[2];
  let upx = up[0];
  let upy = up[1];
  let upz = up[2];
  let centerx = center[0];
  let centery = center[1];
  let centerz = center[2];

  if (Math.abs(eyex - centerx) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"] &&
      Math.abs(eyey - centery) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"] &&
      Math.abs(eyez - centerz) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]) {
    return mat4.identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;

  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;

  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;

  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;

  return out;
}

/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function targetTo(out, eye, target, up) {
  let eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];

  let z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];

  let len = z0*z0 + z1*z1 + z2*z2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  let x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
          a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
          a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +
          a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
}

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
}

/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}

/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  out[4] = a[4] + (b[4] * scale);
  out[5] = a[5] + (b[5] * scale);
  out[6] = a[6] + (b[6] * scale);
  out[7] = a[7] + (b[7] * scale);
  out[8] = a[8] + (b[8] * scale);
  out[9] = a[9] + (b[9] * scale);
  out[10] = a[10] + (b[10] * scale);
  out[11] = a[11] + (b[11] * scale);
  out[12] = a[12] + (b[12] * scale);
  out[13] = a[13] + (b[13] * scale);
  out[14] = a[14] + (b[14] * scale);
  out[15] = a[15] + (b[15] * scale);
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] &&
         a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] &&
         a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] &&
         a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0  = a[0],  a1  = a[1],  a2  = a[2],  a3  = a[3];
  let a4  = a[4],  a5  = a[5],  a6  = a[6],  a7  = a[7];
  let a8  = a[8],  a9  = a[9],  a10 = a[10], a11 = a[11];
  let a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];

  let b0  = b[0],  b1  = b[1],  b2  = b[2],  b3  = b[3];
  let b4  = b[4],  b5  = b[5],  b6  = b[6],  b7  = b[7];
  let b8  = b[8],  b9  = b[9],  b10 = b[10], b11 = b[11];
  let b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];

  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
          Math.abs(a4 - b4) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
          Math.abs(a5 - b5) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
          Math.abs(a6 - b6) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
          Math.abs(a7 - b7) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
          Math.abs(a8 - b8) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&
          Math.abs(a9 - b9) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&
          Math.abs(a10 - b10) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&
          Math.abs(a11 - b11) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&
          Math.abs(a12 - b12) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&
          Math.abs(a13 - b13) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&
          Math.abs(a14 - b14) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&
          Math.abs(a15 - b15) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a15), Math.abs(b15)));
}

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat4.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["setAxisAngle"] = setAxisAngle;
/* harmony export (immutable) */ __webpack_exports__["getAxisAngle"] = getAxisAngle;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["rotateX"] = rotateX;
/* harmony export (immutable) */ __webpack_exports__["rotateY"] = rotateY;
/* harmony export (immutable) */ __webpack_exports__["rotateZ"] = rotateZ;
/* harmony export (immutable) */ __webpack_exports__["calculateW"] = calculateW;
/* harmony export (immutable) */ __webpack_exports__["slerp"] = slerp;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["conjugate"] = conjugate;
/* harmony export (immutable) */ __webpack_exports__["fromMat3"] = fromMat3;
/* harmony export (immutable) */ __webpack_exports__["fromEuler"] = fromEuler;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mat3__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__vec3__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__vec4__ = __webpack_require__(23);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */






/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  let s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}

/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */
function getAxisAngle(out_axis, q) {
  let rad = Math.acos(q[3]) * 2.0;
  let s = Math.sin(rad / 2.0);
  if (s != 0.0) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
function multiply(out, a, b) {
  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = b[0], by = b[1], bz = b[2], bw = b[3];

  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateX(out, a, rad) {
  rad *= 0.5;

  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = Math.sin(rad), bw = Math.cos(rad);

  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateY(out, a, rad) {
  rad *= 0.5;

  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let by = Math.sin(rad), bw = Math.cos(rad);

  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateZ(out, a, rad) {
  rad *= 0.5;

  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bz = Math.sin(rad), bw = Math.cos(rad);

  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
function calculateW(out, a) {
  let x = a[0], y = a[1], z = a[2];

  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = b[0], by = b[1], bz = b[2], bw = b[3];

  let omega, cosom, sinom, scale0, scale1;

  // calc cosine
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  // adjust signs (if necessary)
  if ( cosom < 0.0 ) {
    cosom = -cosom;
    bx = - bx;
    by = - by;
    bz = - bz;
    bw = - bw;
  }
  // calculate coefficients
  if ( (1.0 - cosom) > 0.000001 ) {
    // standard case (slerp)
    omega  = Math.acos(cosom);
    sinom  = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  }
  // calculate final values
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;

  return out;
}

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
function invert(out, a) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let dot = a0*a0 + a1*a1 + a2*a2 + a3*a3;
  let invDot = dot ? 1.0/dot : 0;

  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0*invDot;
  out[1] = -a1*invDot;
  out[2] = -a2*invDot;
  out[3] = a3*invDot;
  return out;
}

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  let fTrace = m[0] + m[4] + m[8];
  let fRoot;

  if ( fTrace > 0.0 ) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0);  // 2w
    out[3] = 0.5 * fRoot;
    fRoot = 0.5/fRoot;  // 1/(4w)
    out[0] = (m[5]-m[7])*fRoot;
    out[1] = (m[6]-m[2])*fRoot;
    out[2] = (m[1]-m[3])*fRoot;
  } else {
    // |w| <= 1/2
    let i = 0;
    if ( m[4] > m[0] )
      i = 1;
    if ( m[8] > m[i*3+i] )
      i = 2;
    let j = (i+1)%3;
    let k = (i+2)%3;

    fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
    out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
    out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
  }

  return out;
}

/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */
function fromEuler(out, x, y, z) {
    let halfToRad = 0.5 * Math.PI / 180.0;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;

    let sx = Math.sin(x);
    let cx = Math.cos(x);
    let sy = Math.sin(y);
    let cy = Math.cos(y);
    let sz = Math.sin(z);
    let cz = Math.cos(z);

    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;

    return out;
}

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
const clone = __WEBPACK_IMPORTED_MODULE_3__vec4__["clone"];
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;


/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
const fromValues = __WEBPACK_IMPORTED_MODULE_3__vec4__["fromValues"];
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;


/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
const copy = __WEBPACK_IMPORTED_MODULE_3__vec4__["copy"];
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;


/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
const set = __WEBPACK_IMPORTED_MODULE_3__vec4__["set"];
/* harmony export (immutable) */ __webpack_exports__["set"] = set;


/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
const add = __WEBPACK_IMPORTED_MODULE_3__vec4__["add"];
/* harmony export (immutable) */ __webpack_exports__["add"] = add;


/**
 * Alias for {@link quat.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
const scale = __WEBPACK_IMPORTED_MODULE_3__vec4__["scale"];
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;


/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
const dot = __WEBPACK_IMPORTED_MODULE_3__vec4__["dot"];
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;


/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
const lerp = __WEBPACK_IMPORTED_MODULE_3__vec4__["lerp"];
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;


/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 */
const length = __WEBPACK_IMPORTED_MODULE_3__vec4__["length"];
/* harmony export (immutable) */ __webpack_exports__["length"] = length;


/**
 * Alias for {@link quat.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
const squaredLength = __WEBPACK_IMPORTED_MODULE_3__vec4__["squaredLength"];
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;


/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
const normalize = __WEBPACK_IMPORTED_MODULE_3__vec4__["normalize"];
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;


/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
const exactEquals = __WEBPACK_IMPORTED_MODULE_3__vec4__["exactEquals"];
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;


/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
const equals = __WEBPACK_IMPORTED_MODULE_3__vec4__["equals"];
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;


/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
const rotationTo = (function() {
  let tmpvec3 = __WEBPACK_IMPORTED_MODULE_2__vec3__["create"]();
  let xUnitVec3 = __WEBPACK_IMPORTED_MODULE_2__vec3__["fromValues"](1,0,0);
  let yUnitVec3 = __WEBPACK_IMPORTED_MODULE_2__vec3__["fromValues"](0,1,0);

  return function(out, a, b) {
    let dot = __WEBPACK_IMPORTED_MODULE_2__vec3__["dot"](a, b);
    if (dot < -0.999999) {
      __WEBPACK_IMPORTED_MODULE_2__vec3__["cross"](tmpvec3, xUnitVec3, a);
      if (__WEBPACK_IMPORTED_MODULE_2__vec3__["len"](tmpvec3) < 0.000001)
        __WEBPACK_IMPORTED_MODULE_2__vec3__["cross"](tmpvec3, yUnitVec3, a);
      __WEBPACK_IMPORTED_MODULE_2__vec3__["normalize"](tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      __WEBPACK_IMPORTED_MODULE_2__vec3__["cross"](tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
})();
/* harmony export (immutable) */ __webpack_exports__["rotationTo"] = rotationTo;


/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 */
const sqlerp = (function () {
  let temp1 = create();
  let temp2 = create();

  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));

    return out;
  };
}());
/* harmony export (immutable) */ __webpack_exports__["sqlerp"] = sqlerp;


/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
const setAxes = (function() {
  let matr = __WEBPACK_IMPORTED_MODULE_1__mat3__["create"]();

  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];

    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];

    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];

    return normalize(out, fromMat3(out, matr));
  };
})();
/* harmony export (immutable) */ __webpack_exports__["setAxes"] = setAxes;



/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["divide"] = divide;
/* harmony export (immutable) */ __webpack_exports__["ceil"] = ceil;
/* harmony export (immutable) */ __webpack_exports__["floor"] = floor;
/* harmony export (immutable) */ __webpack_exports__["min"] = min;
/* harmony export (immutable) */ __webpack_exports__["max"] = max;
/* harmony export (immutable) */ __webpack_exports__["round"] = round;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["scaleAndAdd"] = scaleAndAdd;
/* harmony export (immutable) */ __webpack_exports__["distance"] = distance;
/* harmony export (immutable) */ __webpack_exports__["squaredDistance"] = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["length"] = length;
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["negate"] = negate;
/* harmony export (immutable) */ __webpack_exports__["inverse"] = inverse;
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;
/* harmony export (immutable) */ __webpack_exports__["cross"] = cross;
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;
/* harmony export (immutable) */ __webpack_exports__["random"] = random;
/* harmony export (immutable) */ __webpack_exports__["transformMat2"] = transformMat2;
/* harmony export (immutable) */ __webpack_exports__["transformMat2d"] = transformMat2d;
/* harmony export (immutable) */ __webpack_exports__["transformMat3"] = transformMat3;
/* harmony export (immutable) */ __webpack_exports__["transformMat4"] = transformMat4;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(3);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](2);
  out[0] = 0;
  out[1] = 0;
  return out;
}

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
function fromValues(x, y) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](2);
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
};

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
};

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
};

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
};

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
};

/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */
function round (out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return Math.sqrt(x*x + y*y);
};

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return x*x + y*y;
};

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  var x = a[0],
    y = a[1];
  return Math.sqrt(x*x + y*y);
};

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength (a) {
  var x = a[0],
    y = a[1];
  return x*x + y*y;
};

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
function normalize(out, a) {
  var x = a[0],
    y = a[1];
  var len = x*x + y*y;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
  }
  return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
function lerp(out, a, b, t) {
  var ax = a[0],
    ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
function random(out, scale) {
  scale = scale || 1.0;
  var r = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2d(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat3(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat4(out, a, m) {
  let x = a[0];
  let y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec2(' + a[0] + ', ' + a[1] + ')';
}

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1];
  let b0 = b[0], b1 = b[1];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)));
}

/**
 * Alias for {@link vec2.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Alias for {@link vec2.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;


/**
 * Alias for {@link vec2.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link vec2.divide}
 * @function
 */
const div = divide;
/* harmony export (immutable) */ __webpack_exports__["div"] = div;


/**
 * Alias for {@link vec2.distance}
 * @function
 */
const dist = distance;
/* harmony export (immutable) */ __webpack_exports__["dist"] = dist;


/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
const sqrDist = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["sqrDist"] = sqrDist;


/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
const forEach = (function() {
  let vec = create();

  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if(!stride) {
      stride = 2;
    }

    if(!offset) {
      offset = 0;
    }

    if(count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for(i = offset; i < l; i += stride) {
      vec[0] = a[i]; vec[1] = a[i+1];
      fn(vec, vec, arg);
      a[i] = vec[0]; a[i+1] = vec[1];
    }

    return a;
  };
})();
/* harmony export (immutable) */ __webpack_exports__["forEach"] = forEach;



/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = getAndApplyExtension;
// VertexArrayObject.js

function getAndApplyExtension(gl, name) {
	var ext = gl.getExtension(name);
	if (!ext) {
		return false;
	}
	var suffix = name.split('_')[0];
	var suffixRE = new RegExp(suffix + '$');

	for (var key in ext) {
		var val = ext[key];
		if (typeof val === 'function') {
			var unsuffixedKey = key.replace(suffixRE, '');
			if (key.substring) {
				gl[unsuffixedKey] = ext[key].bind(ext);
				// console.log('Replacing :', key, '=>', unsuffixedKey);
			}
		}
	}

	return true;
}

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _WebglConst = __webpack_require__(24);

var _WebglConst2 = _interopRequireDefault(_WebglConst);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// exposeAttributes.js

var exposeAttributes = function exposeAttributes() {
	// GL.VERTEX_SHADER         = GL.gl.VERTEX_SHADER;
	// GL.FRAGMENT_SHADER       = GL.gl.FRAGMENT_SHADER;
	// GL.COMPILE_STATUS        = GL.gl.COMPILE_STATUS;
	// GL.DEPTH_TEST            = GL.gl.DEPTH_TEST;
	// GL.CULL_FACE             = GL.gl.CULL_FACE;
	// GL.BLEND                 = GL.gl.BLEND;
	// GL.POINTS                = GL.gl.POINTS;
	// GL.LINES                 = GL.gl.LINES;
	// GL.TRIANGLES             = GL.gl.TRIANGLES;

	// GL.LINEAR                	= GL.gl.LINEAR;
	// GL.NEAREST               	= GL.gl.NEAREST;
	// GL.LINEAR_MIPMAP_NEAREST 	= GL.gl.LINEAR_MIPMAP_NEAREST;
	// GL.NEAREST_MIPMAP_LINEAR 	= GL.gl.NEAREST_MIPMAP_LINEAR;
	// GL.LINEAR_MIPMAP_LINEAR 	= GL.gl.LINEAR_MIPMAP_LINEAR;
	// GL.NEAREST_MIPMAP_NEAREST 	= GL.gl.NEAREST_MIPMAP_NEAREST;
	// GL.MIRRORED_REPEAT       	= GL.gl.MIRRORED_REPEAT;
	// GL.CLAMP_TO_EDGE         	= GL.gl.CLAMP_TO_EDGE;
	// GL.SCISSOR_TEST		   	 	= GL.gl.SCISSOR_TEST;
	// GL.UNSIGNED_BYTE		 	= GL.gl.UNSIGNED_BYTE;
	for (var s in _WebglConst2.default) {
		if (!_GLTool2.default[s]) {
			_GLTool2.default[s] = _WebglConst2.default[s];
		} else {
			console.log('already exist : ', s);
		}
	}
};

exports.default = exposeAttributes;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function () {
	if (!hasChecked) {
		_float = checkFloat();
	}

	return _float;
};

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hasChecked = false; // getFloat.js

var _float = void 0;

function checkFloat() {
	if (_GLTool2.default.webgl2) {
		return _GLTool2.default.gl.FLOAT;
	} else {
		var extFloat = _GLTool2.default.getExtension('OES_texture_float');
		if (extFloat) {
			return _GLTool2.default.gl.FLOAT;
		} else {
			console.warn('USING FLOAT BUT OES_texture_float NOT SUPPORTED');
			return _GLTool2.default.gl.UNSIGNED_BYTE;
		}
	}

	hasChecked = true;
};

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function () {
	if (!hasChecked) {
		halfFloat = checkHalfFloat();
	}

	return halfFloat;
};

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hasChecked = false; // getHalfFloat.js

var halfFloat = void 0;

function checkHalfFloat() {
	if (_GLTool2.default.webgl2) {
		return _GLTool2.default.gl.HALF_FLOAT;
	} else {
		var extHalfFloat = _GLTool2.default.getExtension('OES_texture_half_float');
		if (extHalfFloat) {
			return extHalfFloat.HALF_FLOAT_OES;
		} else {
			console.warn('USING HALF FLOAT BUT OES_texture_half_float NOT SUPPORTED');
			return _GLTool2.default.gl.UNSIGNED_BYTE;
		}
	}

	hasChecked = true;
};

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
// ExtensionsList.js

exports.default = ['EXT_shader_texture_lod', 'EXT_sRGB', 'EXT_frag_depth', 'OES_texture_float', 'OES_texture_half_float', 'OES_texture_float_linear', 'OES_texture_half_float_linear', 'OES_standard_derivatives', 'WEBGL_depth_texture', 'EXT_texture_filter_anisotropic', 'OES_vertex_array_object', 'ANGLE_instanced_arrays', 'WEBGL_draw_buffers'];

/***/ }),
/* 54 */
/***/ (function(module, exports) {

module.exports = function(strings) {
  if (typeof strings === 'string') strings = [strings]
  var exprs = [].slice.call(arguments,1)
  var parts = []
  for (var i = 0; i < strings.length-1; i++) {
    parts.push(strings[i], exprs[i] || '')
  }
  parts.push(strings[i])
  return parts.join('')
}


/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = "// basic.frag\n\n#define SHADER_NAME BASIC_FRAGMENT\n\nprecision lowp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform float time;\n// uniform sampler2D texture;\n\nvoid main(void) {\n    gl_FragColor = vec4(vTextureCoord, sin(time) * .5 + .5, 1.0);\n}"

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isPowerOfTwo(x) {
	return x !== 0 && !(x & x - 1);
} // getTextureParameters.js

;

var getTextureParameters = function getTextureParameters(mParams, mSource, mWidth, mHeight) {
	if (!mParams.minFilter) {
		var minFilter = _GLTool2.default.LINEAR;
		if (mWidth && mWidth) {
			if (isPowerOfTwo(mWidth) && isPowerOfTwo(mHeight)) {
				minFilter = _GLTool2.default.NEAREST_MIPMAP_LINEAR;
			}
		}

		mParams.minFilter = minFilter;
	}

	mParams.mipmap = mParams.mipmap || true;
	mParams.magFilter = mParams.magFilter || _GLTool2.default.LINEAR;
	mParams.wrapS = mParams.wrapS || _GLTool2.default.CLAMP_TO_EDGE;
	mParams.wrapT = mParams.wrapT || _GLTool2.default.CLAMP_TO_EDGE;
	mParams.internalFormat = mParams.internalFormat || _GLTool2.default.RGBA;
	mParams.format = mParams.format || _GLTool2.default.RGBA;
	mParams.premultiplyAlpha = mParams.premultiplyAlpha || false;
	mParams.level = mParams.level || 0;
	mParams.anisotropy = mParams.anisotropy || 0;
	return mParams;
};

exports.default = getTextureParameters;

/***/ }),
/* 57 */
/***/ (function(module, exports) {

// All values and structures referenced from:
// http://msdn.microsoft.com/en-us/library/bb943991.aspx/
//
// DX10 Cubemap support based on
// https://github.com/dariomanesku/cmft/issues/7#issuecomment-69516844
// https://msdn.microsoft.com/en-us/library/windows/desktop/bb943983(v=vs.85).aspx
// https://github.com/playcanvas/engine/blob/master/src/resources/resources_texture.js

var DDS_MAGIC = 0x20534444
var DDSD_MIPMAPCOUNT = 0x20000
var DDPF_FOURCC = 0x4

var FOURCC_DXT1 = fourCCToInt32('DXT1')
var FOURCC_DXT3 = fourCCToInt32('DXT3')
var FOURCC_DXT5 = fourCCToInt32('DXT5')
var FOURCC_DX10 = fourCCToInt32('DX10')
var FOURCC_FP32F = 116 // DXGI_FORMAT_R32G32B32A32_FLOAT

var DDSCAPS2_CUBEMAP = 0x200
var D3D10_RESOURCE_DIMENSION_TEXTURE2D = 3
var DXGI_FORMAT_R32G32B32A32_FLOAT = 2

// The header length in 32 bit ints
var headerLengthInt = 31

// Offsets into the header array
var off_magic = 0
var off_size = 1
var off_flags = 2
var off_height = 3
var off_width = 4
var off_mipmapCount = 7
var off_pfFlags = 20
var off_pfFourCC = 21
var off_caps2 = 28

module.exports = parseHeaders

function parseHeaders (arrayBuffer) {
  var header = new Int32Array(arrayBuffer, 0, headerLengthInt)

  if (header[off_magic] !== DDS_MAGIC) {
    throw new Error('Invalid magic number in DDS header')
  }

  if (!header[off_pfFlags] & DDPF_FOURCC) {
    throw new Error('Unsupported format, must contain a FourCC code')
  }

  var blockBytes
  var format
  var fourCC = header[off_pfFourCC]
  switch (fourCC) {
    case FOURCC_DXT1:
      blockBytes = 8
      format = 'dxt1'
      break
    case FOURCC_DXT3:
      blockBytes = 16
      format = 'dxt3'
      break
    case FOURCC_DXT5:
      blockBytes = 16
      format = 'dxt5'
      break
    case FOURCC_FP32F:
      format = 'rgba32f'
      break
    case FOURCC_DX10:
      var dx10Header = new Uint32Array(arrayBuffer.slice(128, 128 + 20))
      format = dx10Header[0]
      var resourceDimension = dx10Header[1]
      var miscFlag = dx10Header[2]
      var arraySize = dx10Header[3]
      var miscFlags2 = dx10Header[4]

      if (resourceDimension === D3D10_RESOURCE_DIMENSION_TEXTURE2D && format === DXGI_FORMAT_R32G32B32A32_FLOAT) {
        format = 'rgba32f'
      } else {
        throw new Error('Unsupported DX10 texture format ' + format)
      }
      break
    default:
      throw new Error('Unsupported FourCC code: ' + int32ToFourCC(fourCC))
  }

  var flags = header[off_flags]
  var mipmapCount = 1

  if (flags & DDSD_MIPMAPCOUNT) {
    mipmapCount = Math.max(1, header[off_mipmapCount])
  }

  var cubemap = false
  var caps2 = header[off_caps2]
  if (caps2 & DDSCAPS2_CUBEMAP) {
    cubemap = true
  }

  var width = header[off_width]
  var height = header[off_height]
  var dataOffset = header[off_size] + 4
  var texWidth = width
  var texHeight = height
  var images = []
  var dataLength

  if (fourCC === FOURCC_DX10) {
    dataOffset += 20
  }

  if (cubemap) {
    for (var f = 0; f < 6; f++) {
      if (format !== 'rgba32f') {
        throw new Error('Only RGBA32f cubemaps are supported')
      }
      var bpp = 4 * 32 / 8

      width = texWidth
      height = texHeight

      // cubemap should have all mipmap levels defined
      // Math.log2(width) + 1
      var requiredMipLevels = Math.log(width) / Math.log(2) + 1

      for (var i = 0; i < requiredMipLevels; i++) {
        dataLength = width * height * bpp
        images.push({
          offset: dataOffset,
          length: dataLength,
          shape: [ width, height ]
        })
        // Reuse data from the previous level if we are beyond mipmapCount
        // This is hack for CMFT not publishing full mipmap chain https://github.com/dariomanesku/cmft/issues/10
        if (i < mipmapCount) {
          dataOffset += dataLength
        }
        width = Math.floor(width / 2)
        height = Math.floor(height / 2)
      }
    }
  } else {
    for (var i = 0; i < mipmapCount; i++) {
      dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes

      images.push({
        offset: dataOffset,
        length: dataLength,
        shape: [ width, height ]
      })
      dataOffset += dataLength
      width = Math.floor(width / 2)
      height = Math.floor(height / 2)
    }
  }

  return {
    shape: [ texWidth, texHeight ],
    images: images,
    format: format,
    flags: flags,
    cubemap: cubemap
  }
}

function fourCCToInt32 (value) {
  return value.charCodeAt(0) +
    (value.charCodeAt(1) << 8) +
    (value.charCodeAt(2) << 16) +
    (value.charCodeAt(3) << 24)
}

function int32ToFourCC (value) {
  return String.fromCharCode(
    value & 0xff,
    (value >> 8) & 0xff,
    (value >> 16) & 0xff,
    (value >> 24) & 0xff
  )
}


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// CubeFrameBuffer.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _GLCubeTexture = __webpack_require__(28);

var _GLCubeTexture2 = _interopRequireDefault(_GLCubeTexture);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;

var CubeFrameBuffer = function () {
	function CubeFrameBuffer(size) {
		var mParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		_classCallCheck(this, CubeFrameBuffer);

		gl = _GLTool2.default.gl;
		this._size = size;
		this.magFilter = mParameters.magFilter || gl.LINEAR;
		this.minFilter = mParameters.minFilter || gl.LINEAR;
		this.wrapS = mParameters.wrapS || gl.CLAMP_TO_EDGE;
		this.wrapT = mParameters.wrapT || gl.CLAMP_TO_EDGE;

		this._init();
	}

	_createClass(CubeFrameBuffer, [{
		key: '_init',
		value: function _init() {
			this.texture = gl.createTexture();
			this.glTexture = new _GLCubeTexture2.default(this.texture, {}, true);

			gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
			gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, this.magFilter);
			gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, this.minFilter);
			gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, this.wrapS);
			gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, this.wrapT);

			var targets = [gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];

			for (var i = 0; i < targets.length; i++) {
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
				gl.texImage2D(targets[i], 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.FLOAT, null);
			}

			this._frameBuffers = [];
			for (var _i = 0; _i < targets.length; _i++) {
				var frameBuffer = gl.createFramebuffer();
				gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, targets[_i], this.texture, 0);

				var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
				if (status !== gl.FRAMEBUFFER_COMPLETE) {
					console.log('\'gl.checkFramebufferStatus() returned \'' + status);
				}

				this._frameBuffers.push(frameBuffer);
			}

			// gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			gl.bindRenderbuffer(gl.RENDERBUFFER, null);
			gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
		}
	}, {
		key: 'bind',
		value: function bind(mTargetIndex) {

			// if(Math.random() > .99) console.log('bind :', mTargetIndex, this._frameBuffers[mTargetIndex]);
			_GLTool2.default.viewport(0, 0, this.width, this.height);
			gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffers[mTargetIndex]);
		}
	}, {
		key: 'unbind',
		value: function unbind() {
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			_GLTool2.default.viewport(0, 0, _GLTool2.default.width, _GLTool2.default.height);
		}

		//	TEXTURES

	}, {
		key: 'getTexture',
		value: function getTexture() {
			return this.glTexture;
		}

		//	GETTERS AND SETTERS

	}, {
		key: 'width',
		get: function get() {
			return this._size;
		}
	}, {
		key: 'height',
		get: function get() {
			return this._size;
		}
	}]);

	return CubeFrameBuffer;
}();

exports.default = CubeFrameBuffer;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // MultisampleFrameBuffer.js

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _GLTexture = __webpack_require__(26);

var _GLTexture2 = _interopRequireDefault(_GLTexture);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;

function isPowerOfTwo(x) {
	return x !== 0 && !(x & x - 1);
};

var MultisampleFrameBuffer = function () {
	function MultisampleFrameBuffer(mWidth, mHeight) {
		var mParameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

		_classCallCheck(this, MultisampleFrameBuffer);

		gl = _GLTool2.default.gl;

		this.width = mWidth;
		this.height = mHeight;

		this.magFilter = mParameters.magFilter || gl.LINEAR;
		this.minFilter = mParameters.minFilter || gl.LINEAR;
		this.wrapS = mParameters.wrapS || gl.CLAMP_TO_EDGE;
		this.wrapT = mParameters.wrapT || gl.CLAMP_TO_EDGE;
		this.useDepth = mParameters.useDepth || true;
		this.useStencil = mParameters.useStencil || false;
		this.texelType = mParameters.type;
		this._numSample = mParameters.numSample || 8;

		if (!isPowerOfTwo(this.width) || !isPowerOfTwo(this.height)) {
			this.wrapS = this.wrapT = gl.CLAMP_TO_EDGE;

			if (this.minFilter === gl.LINEAR_MIPMAP_NEAREST) {
				this.minFilter = gl.LINEAR;
			}
		}

		this._init();
	}

	_createClass(MultisampleFrameBuffer, [{
		key: '_init',
		value: function _init() {
			var texelType = gl.UNSIGNED_BYTE;
			if (this.texelType) {
				texelType = this.texelType;
			}

			this.texelType = texelType;

			this.frameBuffer = gl.createFramebuffer();
			this.frameBufferColor = gl.createFramebuffer();
			this.renderBufferColor = gl.createRenderbuffer();
			this.renderBufferDepth = gl.createRenderbuffer();
			this.glTexture = this._createTexture();
			this.glDepthTexture = this._createTexture(gl.DEPTH_COMPONENT16, gl.UNSIGNED_SHORT, gl.DEPTH_COMPONENT, true);

			gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBufferColor);
			gl.renderbufferStorageMultisample(gl.RENDERBUFFER, this._numSample, gl.RGBA8, this.width, this.height);

			gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBufferDepth);
			gl.renderbufferStorageMultisample(gl.RENDERBUFFER, this._numSample, gl.DEPTH_COMPONENT16, this.width, this.height);

			gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
			gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, this.renderBufferColor);
			gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.renderBufferDepth);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBufferColor);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.glTexture.texture, 0);
			// gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.glDepthTexture.texture, 0);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			// gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBufferDepth);
			// gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.glDepthTexture.texture, 0);
			// gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		}
	}, {
		key: '_createTexture',
		value: function _createTexture(mInternalformat, mTexelType, mFormat) {
			var forceNearest = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

			if (mInternalformat === undefined) {
				mInternalformat = gl.RGBA;
			}
			if (mTexelType === undefined) {
				mTexelType = this.texelType;
			}
			if (!mFormat) {
				mFormat = mInternalformat;
			}

			var t = gl.createTexture();
			var glt = new _GLTexture2.default(t, true);
			var magFilter = forceNearest ? _GLTool2.default.NEAREST : this.magFilter;
			var minFilter = forceNearest ? _GLTool2.default.NEAREST : this.minFilter;

			gl.bindTexture(gl.TEXTURE_2D, t);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this.wrapS);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this.wrapT);
			gl.texImage2D(gl.TEXTURE_2D, 0, mInternalformat, this.width, this.height, 0, mFormat, mTexelType, null);
			gl.bindTexture(gl.TEXTURE_2D, null);

			return glt;
		}
	}, {
		key: 'bind',
		value: function bind() {
			var mAutoSetViewport = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			if (mAutoSetViewport) {
				_GLTool2.default.viewport(0, 0, this.width, this.height);
			}
			gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
		}
	}, {
		key: 'unbind',
		value: function unbind() {
			var mAutoSetViewport = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			if (mAutoSetViewport) {
				_GLTool2.default.viewport(0, 0, _GLTool2.default.width, _GLTool2.default.height);
			}

			var width = this.width,
			    height = this.height;


			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.frameBuffer);
			gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.frameBufferColor);
			gl.clearBufferfv(gl.COLOR, 0, [0.0, 0.0, 0.0, 0.0]);
			gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, gl.COLOR_BUFFER_BIT, _GLTool2.default.NEAREST);
			// gl.blitFramebuffer(
			// 	0, 0, width, height,
			// 	0, 0, width, height,
			// 	gl.COLOR_BUFFER_BIT|gl.DEPTH_STENCIL, GL.NEAREST
			// );

			// gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.frameBuffer);
			// gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.frameBufferDepth);
			// gl.clearBufferfi(gl.DEPTH_STENCIL, 0, 1.0, 0);
			// gl.blitFramebuffer(
			// 	0, 0, width, height,
			// 	0, 0, width, height,
			// 	gl.DEPTH_BUFFER_BIT, gl.NEAREST
			// );

			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		}
	}, {
		key: 'getTexture',
		value: function getTexture() {
			var mIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

			return this.glTexture;
		}
	}, {
		key: 'getDepthTexture',
		value: function getDepthTexture() {
			return this.glDepthTexture;
		}
	}]);

	return MultisampleFrameBuffer;
}();

exports.default = MultisampleFrameBuffer;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // TransformFeedbackObject.js

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _GLShader = __webpack_require__(2);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Mesh = __webpack_require__(4);

var _Mesh2 = _interopRequireDefault(_Mesh);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;

var TransformFeedbackObject = function () {
	function TransformFeedbackObject(strVertexShader, strFragmentShader) {
		_classCallCheck(this, TransformFeedbackObject);

		gl = _GLTool2.default.gl;
		this._vs = strVertexShader;
		this._fs = strFragmentShader;

		this._init();
	}

	_createClass(TransformFeedbackObject, [{
		key: '_init',
		value: function _init() {
			this._meshCurrent = new _Mesh2.default();
			this._meshTarget = new _Mesh2.default();
			this._numPoints = -1;

			this._varyings = [];
			this.transformFeedback = gl.createTransformFeedback();
		}
	}, {
		key: 'bufferData',
		value: function bufferData(mData, mName, mVaryingName) {
			var isTransformFeedback = !!mVaryingName;
			console.log('is Transform feedback ?', mName, isTransformFeedback);
			this._meshCurrent.bufferData(mData, mName, null, gl.STREAM_COPY, false);
			this._meshTarget.bufferData(mData, mName, null, gl.STREAM_COPY, false);

			if (isTransformFeedback) {
				this._varyings.push(mVaryingName);

				if (this._numPoints < 0) {
					this._numPoints = mData.length;
				}
			}
		}
	}, {
		key: 'bufferIndex',
		value: function bufferIndex(mArrayIndices) {
			this._meshCurrent.bufferIndex(mArrayIndices);
			this._meshTarget.bufferIndex(mArrayIndices);
		}
	}, {
		key: 'uniform',
		value: function uniform(mName, mType, mValue) {
			if (this.shader) {
				this.shader.uniform(mName, mType, mValue);
			}
		}
	}, {
		key: 'generate',
		value: function generate() {
			this.shader = new _GLShader2.default(this._vs, this._fs, this._varyings);
		}
	}, {
		key: 'render',
		value: function render() {
			if (!this.shader) {
				this.generate();
			}

			this.shader.bind();
			_GLTool2.default.drawTransformFeedback(this);

			this._swap();
		}
	}, {
		key: '_swap',
		value: function _swap() {
			var tmp = this._meshCurrent;
			this._meshCurrent = this._meshTarget;
			this._meshTarget = tmp;
		}
	}, {
		key: 'numPoints',
		get: function get() {
			return this._numPoints;
		}
	}, {
		key: 'meshCurrent',
		get: function get() {
			return this._meshCurrent;
		}
	}, {
		key: 'meshTarget',
		get: function get() {
			return this._meshTarget;
		}
	}, {
		key: 'meshSource',
		get: function get() {
			return this._meshCurrent;
		}
	}, {
		key: 'meshDestination',
		get: function get() {
			return this._meshTarget;
		}
	}]);

	return TransformFeedbackObject;
}();

exports.default = TransformFeedbackObject;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// TweenNumber.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Easing = {
	Linear: {
		None: function None(k) {
			return k;
		}
	},
	Quadratic: {
		In: function In(k) {
			return k * k;
		},
		Out: function Out(k) {
			return k * (2 - k);
		},
		InOut: function InOut(k) {
			if ((k *= 2) < 1) {
				return 0.5 * k * k;
			}
			return -0.5 * (--k * (k - 2) - 1);
		}
	},
	Cubic: {
		In: function In(k) {
			return k * k * k;
		},
		Out: function Out(k) {
			return --k * k * k + 1;
		},
		InOut: function InOut(k) {
			if ((k *= 2) < 1) {
				return 0.5 * k * k * k;
			}
			return 0.5 * ((k -= 2) * k * k + 2);
		}
	},
	Quartic: {
		In: function In(k) {
			return k * k * k * k;
		},
		Out: function Out(k) {
			return 1 - --k * k * k * k;
		},
		InOut: function InOut(k) {
			if ((k *= 2) < 1) {
				return 0.5 * k * k * k * k;
			}
			return -0.5 * ((k -= 2) * k * k * k - 2);
		}
	},
	Quintic: {
		In: function In(k) {
			return k * k * k * k * k;
		},
		Out: function Out(k) {
			return --k * k * k * k * k + 1;
		},
		InOut: function InOut(k) {
			if ((k *= 2) < 1) {
				return 0.5 * k * k * k * k * k;
			}
			return 0.5 * ((k -= 2) * k * k * k * k + 2);
		}
	},
	Sinusoidal: {
		In: function In(k) {
			return 1 - Math.cos(k * Math.PI / 2);
		},
		Out: function Out(k) {
			return Math.sin(k * Math.PI / 2);
		},
		InOut: function InOut(k) {
			return 0.5 * (1 - Math.cos(Math.PI * k));
		}
	},
	Exponential: {
		In: function In(k) {
			return k === 0 ? 0 : Math.pow(1024, k - 1);
		},
		Out: function Out(k) {
			return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
		},
		InOut: function InOut(k) {
			if (k === 0) {
				return 0;
			}
			if (k === 1) {
				return 1;
			}
			if ((k *= 2) < 1) {
				return 0.5 * Math.pow(1024, k - 1);
			}
			return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
		}
	},
	Circular: {
		In: function In(k) {
			return 1 - Math.sqrt(1 - k * k);
		},
		Out: function Out(k) {
			return Math.sqrt(1 - --k * k);
		},
		InOut: function InOut(k) {
			if ((k *= 2) < 1) {
				return -0.5 * (Math.sqrt(1 - k * k) - 1);
			}
			return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
		}
	},
	Elastic: {
		In: function In(k) {
			var s = void 0;
			var a = 0.1;
			var p = 0.4;
			if (k === 0) {
				return 0;
			}
			if (k === 1) {
				return 1;
			}
			if (!a || a < 1) {
				a = 1;
				s = p / 4;
			} else {
				s = p * Math.asin(1 / a) / (2 * Math.PI);
			}
			return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
		},
		Out: function Out(k) {
			var s = void 0;
			var a = 0.1;
			var p = 0.4;
			if (k === 0) {
				return 0;
			}
			if (k === 1) {
				return 1;
			}
			if (!a || a < 1) {
				a = 1;
				s = p / 4;
			} else {
				s = p * Math.asin(1 / a) / (2 * Math.PI);
			}
			return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
		},
		InOut: function InOut(k) {
			var s = void 0;
			var a = 0.1;
			var p = 0.4;
			if (k === 0) {
				return 0;
			}
			if (k === 1) {
				return 1;
			}
			if (!a || a < 1) {
				a = 1;
				s = p / 4;
			} else {
				s = p * Math.asin(1 / a) / (2 * Math.PI);
			}
			if ((k *= 2) < 1) {
				return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
			}
			return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
		}
	},
	Back: {
		In: function In(k) {
			var s = 1.70158;
			return k * k * ((s + 1) * k - s);
		},
		Out: function Out(k) {
			var s = 1.70158;
			return --k * k * ((s + 1) * k + s) + 1;
		},
		InOut: function InOut(k) {
			var s = 1.70158 * 1.525;
			if ((k *= 2) < 1) {
				return 0.5 * (k * k * ((s + 1) * k - s));
			}
			return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
		}
	},
	Bounce: {
		in: function _in(k) {
			return 1 - Easing.Bounce.out(1 - k);
		},
		out: function out(k) {
			if (k < 1 / 2.75) {
				return 7.5625 * k * k;
			} else if (k < 2 / 2.75) {
				return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
			} else if (k < 2.5 / 2.75) {
				return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
			} else {
				return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
			}
		},
		inOut: function inOut(k) {
			if (k < 0.5) {
				return Easing.Bounce.in(k * 2) * 0.5;
			}
			return Easing.Bounce.out(k * 2 - 1) * 0.5 + 0.5;
		}
	}
};

function getFunc(mEasing) {
	switch (mEasing) {
		default:
		case 'linear':
			return Easing.Linear.None;
		case 'expIn':
			return Easing.Exponential.In;
		case 'expOut':
			return Easing.Exponential.Out;
		case 'expInOut':
			return Easing.Exponential.InOut;

		case 'cubicIn':
			return Easing.Cubic.In;
		case 'cubicOut':
			return Easing.Cubic.Out;
		case 'cubicInOut':
			return Easing.Cubic.InOut;

		case 'quarticIn':
			return Easing.Quartic.In;
		case 'quarticOut':
			return Easing.Quartic.Out;
		case 'quarticInOut':
			return Easing.Quartic.InOut;

		case 'quinticIn':
			return Easing.Quintic.In;
		case 'quinticOut':
			return Easing.Quintic.Out;
		case 'quinticInOut':
			return Easing.Quintic.InOut;

		case 'sinusoidalIn':
			return Easing.Sinusoidal.In;
		case 'sinusoidalOut':
			return Easing.Sinusoidal.Out;
		case 'sinusoidalInOut':
			return Easing.Sinusoidal.InOut;

		case 'circularIn':
			return Easing.Circular.In;
		case 'circularOut':
			return Easing.Circular.Out;
		case 'circularInOut':
			return Easing.Circular.InOut;

		case 'elasticIn':
			return Easing.Elastic.In;
		case 'elasticOut':
			return Easing.Elastic.Out;
		case 'elasticInOut':
			return Easing.Elastic.InOut;

		case 'backIn':
			return Easing.Back.In;
		case 'backOut':
			return Easing.Back.Out;
		case 'backInOut':
			return Easing.Back.InOut;

		case 'bounceIn':
			return Easing.Bounce.in;
		case 'bounceOut':
			return Easing.Bounce.out;
		case 'bounceInOut':
			return Easing.Bounce.inOut;
	}
}

var TweenNumber = function () {
	function TweenNumber(mValue) {
		var _this = this;

		var mEasing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'expOut';
		var mSpeed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.01;

		_classCallCheck(this, TweenNumber);

		this._value = mValue;
		this._startValue = mValue;
		this._targetValue = mValue;
		this._counter = 1;
		this.speed = mSpeed;
		this.easing = mEasing;
		this._needUpdate = true;

		this._efIndex = _scheduling2.default.addEF(function () {
			return _this._update();
		});
	}

	_createClass(TweenNumber, [{
		key: '_update',
		value: function _update() {
			var newCounter = this._counter + this.speed;
			if (newCounter > 1) {
				newCounter = 1;
			}
			if (this._counter === newCounter) {
				this._needUpdate = false;
				return;
			}

			this._counter = newCounter;
			this._needUpdate = true;
		}
	}, {
		key: 'limit',
		value: function limit(mMin, mMax) {
			if (mMin > mMax) {
				this.limit(mMax, mMin);
				return;
			}

			this._min = mMin;
			this._max = mMax;

			this._checkLimit();
		}
	}, {
		key: 'setTo',
		value: function setTo(mValue) {
			this._value = mValue;
			this._targetValue = mValue;
			this._counter = 1;
		}
	}, {
		key: '_checkLimit',
		value: function _checkLimit() {
			if (this._min !== undefined && this._targetValue < this._min) {
				this._targetValue = this._min;
			}

			if (this._max !== undefined && this._targetValue > this._max) {
				this._targetValue = this._max;
			}
		}
	}, {
		key: 'destroy',
		value: function destroy() {
			_scheduling2.default.removeEF(this._efIndex);
		}

		//	GETTERS / SETTERS

	}, {
		key: 'value',
		set: function set(mValue) {
			this._startValue = this._value;
			this._targetValue = mValue;
			this._checkLimit();
			this._counter = 0;
		},
		get: function get() {
			if (this._needUpdate) {
				var f = getFunc(this.easing);
				var p = f(this._counter);
				this._value = this._startValue + p * (this._targetValue - this._startValue);
				this._needUpdate = false;
			}
			return this._value;
		}
	}, {
		key: 'targetValue',
		get: function get() {
			return this._targetValue;
		}
	}]);

	return TweenNumber;
}();

exports.default = TweenNumber;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// QuatRotation.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _glMatrix = __webpack_require__(1);

var _glMatrix2 = _interopRequireDefault(_glMatrix);

var _EaseNumber = __webpack_require__(13);

var _EaseNumber2 = _interopRequireDefault(_EaseNumber);

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var getMouse = function getMouse(mEvent, mTarget) {

	var o = mTarget || {};
	if (mEvent.touches) {
		o.x = mEvent.touches[0].pageX;
		o.y = mEvent.touches[0].pageY;
	} else {
		o.x = mEvent.clientX;
		o.y = mEvent.clientY;
	}

	return o;
};

var QuatRotation = function () {
	function QuatRotation(mTarget) {
		var _this = this;

		var mListenerTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;
		var mEasing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;

		_classCallCheck(this, QuatRotation);

		this._target = mTarget;
		this._listenerTarget = mListenerTarget;

		this.matrix = _glMatrix2.default.mat4.create();
		this.m = _glMatrix2.default.mat4.create();
		this._vZaxis = _glMatrix2.default.vec3.clone([0, 0, 0]);
		this._zAxis = _glMatrix2.default.vec3.clone([0, 0, 1]);
		this.preMouse = { x: 0, y: 0 };
		this.mouse = { x: 0, y: 0 };
		this._isMouseDown = false;
		this._rotation = _glMatrix2.default.quat.create();
		this.tempRotation = _glMatrix2.default.quat.create();
		this._rotateZMargin = 0;
		this._offset = 0.004;
		this._slerp = -1;
		this._isLocked = false;

		this._diffX = new _EaseNumber2.default(0, mEasing);
		this._diffY = new _EaseNumber2.default(0, mEasing);

		this._listenerTarget.addEventListener('mousedown', function (e) {
			return _this._onDown(e);
		});
		this._listenerTarget.addEventListener('touchstart', function (e) {
			return _this._onDown(e);
		});
		this._listenerTarget.addEventListener('mousemove', function (e) {
			return _this._onMove(e);
		});
		this._listenerTarget.addEventListener('touchmove', function (e) {
			return _this._onMove(e);
		});
		window.addEventListener('touchend', function () {
			return _this._onUp();
		});
		window.addEventListener('mouseup', function () {
			return _this._onUp();
		});

		_scheduling2.default.addEF(function () {
			return _this._loop();
		});
	}

	// 	PUBLIC METHODS

	_createClass(QuatRotation, [{
		key: 'inverseControl',
		value: function inverseControl() {
			var isInvert = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			this._isInvert = isInvert;
		}
	}, {
		key: 'lock',
		value: function lock() {
			var mValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			this._isLocked = mValue;
		}
	}, {
		key: 'setCameraPos',
		value: function setCameraPos(mQuat) {
			var speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;

			this.easing = speed;
			if (this._slerp > 0) {
				return;
			}

			var tempRotation = _glMatrix2.default.quat.clone(this._rotation);
			this._updateRotation(tempRotation);
			this._rotation = _glMatrix2.default.quat.clone(tempRotation);
			this._currDiffX = this.diffX = 0;
			this._currDiffY = this.diffY = 0;

			this._isMouseDown = false;
			this._isRotateZ = 0;

			this._targetQuat = _glMatrix2.default.quat.clone(mQuat);
			this._slerp = 1;
		}
	}, {
		key: 'resetQuat',
		value: function resetQuat() {
			this._rotation = _glMatrix2.default.quat.clone([0, 0, 1, 0]);
			this.tempRotation = _glMatrix2.default.quat.clone([0, 0, 0, 0]);
			this._targetQuat = undefined;
			this._slerp = -1;
		}

		//	EVENT HANDLER

	}, {
		key: '_onDown',
		value: function _onDown(mEvent) {
			if (this._isLocked) {
				return;
			}

			var mouse = getMouse(mEvent);
			var tempRotation = _glMatrix2.default.quat.clone(this._rotation);
			this._updateRotation(tempRotation);
			this._rotation = tempRotation;

			this._isMouseDown = true;
			this._isRotateZ = 0;
			this.preMouse = { x: mouse.x, y: mouse.y };

			if (mouse.y < this._rotateZMargin || mouse.y > window.innerHeight - this._rotateZMargin) {
				this._isRotateZ = 1;
			} else if (mouse.x < this._rotateZMargin || mouse.x > window.innerWidth - this._rotateZMargin) {
				this._isRotateZ = 2;
			}

			this._diffX.setTo(0);
			this._diffY.setTo(0);
		}
	}, {
		key: '_onMove',
		value: function _onMove(mEvent) {
			if (this._isLocked) {
				return;
			}
			getMouse(mEvent, this.mouse);
		}
	}, {
		key: '_onUp',
		value: function _onUp() {
			if (this._isLocked) {
				return;
			}
			this._isMouseDown = false;
		}

		//	PRIVATE METHODS

	}, {
		key: '_updateRotation',
		value: function _updateRotation(mTempRotation) {
			if (this._isMouseDown && !this._isLocked) {
				this._diffX.value = -(this.mouse.x - this.preMouse.x);
				this._diffY.value = this.mouse.y - this.preMouse.y;

				if (this._isInvert) {
					this._diffX.value = -this._diffX.targetValue;
					this._diffY.value = -this._diffY.targetValue;
				}
			}

			var angle = void 0,
			    _quat = void 0;

			if (this._isRotateZ > 0) {
				if (this._isRotateZ === 1) {
					angle = -this._diffX.value * this._offset;
					angle *= this.preMouse.y < this._rotateZMargin ? -1 : 1;
					_quat = _glMatrix2.default.quat.clone([0, 0, Math.sin(angle), Math.cos(angle)]);
					_glMatrix2.default.quat.multiply(_quat, mTempRotation, _quat);
				} else {
					angle = -this._diffY.value * this._offset;
					angle *= this.preMouse.x < this._rotateZMargin ? 1 : -1;
					_quat = _glMatrix2.default.quat.clone([0, 0, Math.sin(angle), Math.cos(angle)]);
					_glMatrix2.default.quat.multiply(_quat, mTempRotation, _quat);
				}
			} else {
				var v = _glMatrix2.default.vec3.clone([this._diffX.value, this._diffY.value, 0]);
				var axis = _glMatrix2.default.vec3.create();
				_glMatrix2.default.vec3.cross(axis, v, this._zAxis);
				_glMatrix2.default.vec3.normalize(axis, axis);
				angle = _glMatrix2.default.vec3.length(v) * this._offset;
				_quat = _glMatrix2.default.quat.clone([Math.sin(angle) * axis[0], Math.sin(angle) * axis[1], Math.sin(angle) * axis[2], Math.cos(angle)]);
				_glMatrix2.default.quat.multiply(mTempRotation, _quat, mTempRotation);
			}
		}
	}, {
		key: '_loop',
		value: function _loop() {
			_glMatrix2.default.mat4.identity(this.m);

			if (this._targetQuat === undefined) {
				_glMatrix2.default.quat.set(this.tempRotation, this._rotation[0], this._rotation[1], this._rotation[2], this._rotation[3]);
				this._updateRotation(this.tempRotation);
			} else {
				this._slerp += (0 - this._slerp) * 0.1;

				if (this._slerp < 0.0005) {
					_glMatrix2.default.quat.copy(this._rotation, this._targetQuat);
					_glMatrix2.default.quat.copy(this.tempRotation, this._targetQuat);
					this._targetQuat = undefined;
					this._diffX.setTo(0);
					this._diffY.setTo(0);
					this._slerp = -1;
				} else {
					_glMatrix2.default.quat.set(this.tempRotation, 0, 0, 0, 0);
					_glMatrix2.default.quat.slerp(this.tempRotation, this._targetQuat, this._rotation, this._slerp);
				}
			}

			_glMatrix2.default.vec3.transformQuat(this._vZaxis, this._vZaxis, this.tempRotation);

			_glMatrix2.default.mat4.fromQuat(this.matrix, this.tempRotation);
		}

		//	GETTER AND SETTER

	}, {
		key: 'easing',
		set: function set(mValue) {
			this._diffX.easing = mValue;
			this._diffY.easing = mValue;
		},
		get: function get() {
			return this._diffX.easing;
		}
	}]);

	return QuatRotation;
}();

exports.default = QuatRotation;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _EventDispatcher2 = __webpack_require__(29);

var _EventDispatcher3 = _interopRequireDefault(_EventDispatcher2);

var _Ray = __webpack_require__(14);

var _Ray2 = _interopRequireDefault(_Ray);

var _getMouse = __webpack_require__(64);

var _getMouse2 = _interopRequireDefault(_getMouse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // TouchDetector.js


function distance(a, b) {
	var dx = a.x - b.x;
	var dy = a.y - b.y;
	return Math.sqrt(dx * dx + dy * dy);
}

var TouchDetector = function (_EventDispatcher) {
	_inherits(TouchDetector, _EventDispatcher);

	function TouchDetector(mMesh, mCamera) {
		var mSkipMoveCheck = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
		var mListenerTarget = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : window;

		_classCallCheck(this, TouchDetector);

		var _this = _possibleConstructorReturn(this, (TouchDetector.__proto__ || Object.getPrototypeOf(TouchDetector)).call(this));

		_this._mesh = mMesh;
		_this._mesh.generateFaces();
		_this._camera = mCamera;
		_this.faceVertices = mMesh.faces.map(function (face) {
			return face.vertices;
		});
		_this.clickTolerance = 8;

		_this._ray = new _Ray2.default([0, 0, 0], [0, 0, -1]);
		_this._hit = vec3.fromValues(-999, -999, -999);
		_this._lastPos;
		_this._firstPos;
		_this.mtxModel = mat4.create();

		_this._listenerTarget = mListenerTarget;
		_this._skippingMove = mSkipMoveCheck;

		_this._onMoveBind = function (e) {
			return _this._onMove(e);
		};
		_this._onDownBind = function (e) {
			return _this._onDown(e);
		};
		_this._onUpBind = function () {
			return _this._onUp();
		};

		_this.connect();
		return _this;
	}

	_createClass(TouchDetector, [{
		key: 'connect',
		value: function connect() {
			this._listenerTarget.addEventListener('mousedown', this._onDownBind);
			this._listenerTarget.addEventListener('mousemove', this._onMoveBind);
			this._listenerTarget.addEventListener('mouseup', this._onUpBind);
		}
	}, {
		key: 'disconnect',
		value: function disconnect() {
			this._listenerTarget.removeEventListener('mousedown', this._onDownBind);
			this._listenerTarget.removeEventListener('mousemove', this._onMoveBind);
			this._listenerTarget.removeEventListener('mouseup', this._onUpBind);
		}
	}, {
		key: '_checkHit',
		value: function _checkHit() {
			var _this2 = this;

			var mType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'onHit';

			var camera = this._camera;
			if (!camera) {
				return;
			}

			var mx = this._lastPos.x / _GLTool2.default.width * 2.0 - 1.0;
			var my = -(this._lastPos.y / _GLTool2.default.height) * 2.0 + 1.0;

			camera.generateRay([mx, my, 0], this._ray);

			var hit = void 0;
			var v0 = vec3.create();
			var v1 = vec3.create();
			var v2 = vec3.create();
			var dist = 0;

			var getVector = function getVector(v, target) {
				vec3.transformMat4(target, v, _this2.mtxModel);
			};

			for (var i = 0; i < this.faceVertices.length; i++) {
				var vertices = this.faceVertices[i];
				getVector(vertices[0], v0);
				getVector(vertices[1], v1);
				getVector(vertices[2], v2);
				var t = this._ray.intersectTriangle(v0, v1, v2);

				if (t) {
					if (hit) {
						var distToCam = vec3.dist(t, camera.position);
						if (distToCam < dist) {
							hit = vec3.clone(t);
							dist = distToCam;
						}
					} else {
						hit = vec3.clone(t);
						dist = vec3.dist(hit, camera.position);
					}
				}
			}

			if (hit) {
				this._hit = vec3.clone(hit);
				this.dispatchCustomEvent(mType, { hit: hit });
			} else {
				this.dispatchCustomEvent('onUp');
			}
		}
	}, {
		key: '_onDown',
		value: function _onDown(e) {
			this._firstPos = (0, _getMouse2.default)(e);
			this._lastPos = (0, _getMouse2.default)(e);
			this._checkHit('onDown');
		}
	}, {
		key: '_onMove',
		value: function _onMove(e) {
			this._lastPos = (0, _getMouse2.default)(e);
			if (!this._skippingMove) {
				this._checkHit();
			}
		}
	}, {
		key: '_onUp',
		value: function _onUp() {
			var dist = distance(this._firstPos, this._lastPos);
			if (dist < this.clickTolerance) {
				this._checkHit();
			}
		}
	}]);

	return TouchDetector;
}(_EventDispatcher3.default);

exports.default = TouchDetector;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function (e) {
	var x = void 0,
	    y = void 0;

	if (e.touches) {
		x = e.touches[0].pageX;
		y = e.touches[0].pageY;
	} else {
		x = e.clientX;
		y = e.clientY;
	}

	return {
		x: x, y: y
	};
};

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// CameraCube.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CameraPerspective2 = __webpack_require__(16);

var _CameraPerspective3 = _interopRequireDefault(_CameraPerspective2);

var _glMatrix = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CAMERA_SETTINGS = [[_glMatrix.vec3.fromValues(0, 0, 0), _glMatrix.vec3.fromValues(1, 0, 0), _glMatrix.vec3.fromValues(0, -1, 0)], [_glMatrix.vec3.fromValues(0, 0, 0), _glMatrix.vec3.fromValues(-1, 0, 0), _glMatrix.vec3.fromValues(0, -1, 0)], [_glMatrix.vec3.fromValues(0, 0, 0), _glMatrix.vec3.fromValues(0, 1, 0), _glMatrix.vec3.fromValues(0, 0, 1)], [_glMatrix.vec3.fromValues(0, 0, 0), _glMatrix.vec3.fromValues(0, -1, 0), _glMatrix.vec3.fromValues(0, 0, -1)], [_glMatrix.vec3.fromValues(0, 0, 0), _glMatrix.vec3.fromValues(0, 0, 1), _glMatrix.vec3.fromValues(0, -1, 0)], [_glMatrix.vec3.fromValues(0, 0, 0), _glMatrix.vec3.fromValues(0, 0, -1), _glMatrix.vec3.fromValues(0, -1, 0)]];

var CameraCube = function (_CameraPerspective) {
	_inherits(CameraCube, _CameraPerspective);

	function CameraCube() {
		_classCallCheck(this, CameraCube);

		var _this = _possibleConstructorReturn(this, (CameraCube.__proto__ || Object.getPrototypeOf(CameraCube)).call(this));

		_this.setPerspective(Math.PI / 2, 1, 0.1, 1000);
		return _this;
	}

	_createClass(CameraCube, [{
		key: 'face',
		value: function face(mIndex) {
			var o = CAMERA_SETTINGS[mIndex];
			this.lookAt(o[0], o[1], o[2]);
		}
	}]);

	return CameraCube;
}(_CameraPerspective3.default);

exports.default = CameraCube;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// ObjLoader.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BinaryLoader2 = __webpack_require__(17);

var _BinaryLoader3 = _interopRequireDefault(_BinaryLoader2);

var _Mesh = __webpack_require__(4);

var _Mesh2 = _interopRequireDefault(_Mesh);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ObjLoader = function (_BinaryLoader) {
	_inherits(ObjLoader, _BinaryLoader);

	function ObjLoader() {
		_classCallCheck(this, ObjLoader);

		return _possibleConstructorReturn(this, (ObjLoader.__proto__ || Object.getPrototypeOf(ObjLoader)).apply(this, arguments));
	}

	_createClass(ObjLoader, [{
		key: 'load',
		value: function load(url, callback) {
			var drawType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;

			this._drawType = drawType;
			_get(ObjLoader.prototype.__proto__ || Object.getPrototypeOf(ObjLoader.prototype), 'load', this).call(this, url, callback);
		}
	}, {
		key: '_onLoaded',
		value: function _onLoaded() {
			this.parseObj(this._req.response);
		}
	}, {
		key: 'parseObj',
		value: function parseObj(objStr) {
			var lines = objStr.split('\n');

			var positions = [];
			var coords = [];
			var finalNormals = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
			var indices = [];
			var count = 0;
			var result = void 0;

			// v float float float
			var vertexPattern = /v( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/;

			// vn float float float
			var normalPattern = /vn( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/;

			// vt float float
			var uvPattern = /vt( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/;

			// f vertex vertex vertex ...
			var facePattern1 = /f( +-?\d+)( +-?\d+)( +-?\d+)( +-?\d+)?/;

			// f vertex/uv vertex/uv vertex/uv ...
			var facePattern2 = /f( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))?/;

			// f vertex/uv/normal vertex/uv/normal vertex/uv/normal ...
			var facePattern3 = /f( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))?/;

			// f vertex//normal vertex//normal vertex//normal ... 
			var facePattern4 = /f( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))?/;

			function parseVertexIndex(value) {
				var index = parseInt(value);
				return (index >= 0 ? index - 1 : index + vertices.length / 3) * 3;
			}

			function parseNormalIndex(value) {
				var index = parseInt(value);
				return (index >= 0 ? index - 1 : index + normals.length / 3) * 3;
			}

			function parseUVIndex(value) {
				var index = parseInt(value);
				return (index >= 0 ? index - 1 : index + uvs.length / 2) * 2;
			}

			function addVertex(a, b, c) {
				positions.push([vertices[a], vertices[a + 1], vertices[a + 2]]);
				positions.push([vertices[b], vertices[b + 1], vertices[b + 2]]);
				positions.push([vertices[c], vertices[c + 1], vertices[c + 2]]);

				indices.push(count * 3 + 0);
				indices.push(count * 3 + 1);
				indices.push(count * 3 + 2);

				count++;
			}

			function addUV(a, b, c) {
				coords.push([uvs[a], uvs[a + 1]]);
				coords.push([uvs[b], uvs[b + 1]]);
				coords.push([uvs[c], uvs[c + 1]]);
			}

			function addNormal(a, b, c) {
				finalNormals.push([normals[a], normals[a + 1], normals[a + 2]]);
				finalNormals.push([normals[b], normals[b + 1], normals[b + 2]]);
				finalNormals.push([normals[c], normals[c + 1], normals[c + 2]]);
			}

			function addFace(a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd) {
				var ia = parseVertexIndex(a);
				var ib = parseVertexIndex(b);
				var ic = parseVertexIndex(c);
				var id = void 0;

				if (d === undefined) {

					addVertex(ia, ib, ic);
				} else {

					id = parseVertexIndex(d);

					addVertex(ia, ib, id);
					addVertex(ib, ic, id);
				}

				if (ua !== undefined) {

					ia = parseUVIndex(ua);
					ib = parseUVIndex(ub);
					ic = parseUVIndex(uc);

					if (d === undefined) {

						addUV(ia, ib, ic);
					} else {

						id = parseUVIndex(ud);

						addUV(ia, ib, id);
						addUV(ib, ic, id);
					}
				}

				if (na !== undefined) {

					ia = parseNormalIndex(na);
					ib = parseNormalIndex(nb);
					ic = parseNormalIndex(nc);

					if (d === undefined) {

						addNormal(ia, ib, ic);
					} else {

						id = parseNormalIndex(nd);

						addNormal(ia, ib, id);
						addNormal(ib, ic, id);
					}
				}
			}

			for (var i = 0; i < lines.length; i++) {
				var line = lines[i];
				line = line.trim();

				if (line.length === 0 || line.charAt(0) === '#') {

					continue;
				} else if ((result = vertexPattern.exec(line)) !== null) {

					vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
				} else if ((result = normalPattern.exec(line)) !== null) {

					normals.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
				} else if ((result = uvPattern.exec(line)) !== null) {

					uvs.push(parseFloat(result[1]), parseFloat(result[2]));
				} else if ((result = facePattern1.exec(line)) !== null) {

					addFace(result[1], result[2], result[3], result[4]);
				} else if ((result = facePattern2.exec(line)) !== null) {

					addFace(result[2], result[5], result[8], result[11], result[3], result[6], result[9], result[12]);
				} else if ((result = facePattern3.exec(line)) !== null) {
					addFace(result[2], result[6], result[10], result[14], result[3], result[7], result[11], result[15], result[4], result[8], result[12], result[16]);
				} else if ((result = facePattern4.exec(line)) !== null) {
					addFace(result[2], result[5], result[8], result[11], undefined, undefined, undefined, undefined, result[3], result[6], result[9], result[12]);
				}
			}

			return this._generateMeshes({
				positions: positions,
				coords: coords,
				normals: finalNormals,
				indices: indices
			});
		}
	}, {
		key: '_generateMeshes',
		value: function _generateMeshes(o) {
			var maxNumVertices = 65535;
			var hasNormals = o.normals.length > 0;
			var hasUVs = o.coords.length > 0;
			var mesh = void 0;

			if (o.positions.length > maxNumVertices) {
				var meshes = [];
				var lastIndex = 0;

				var oCopy = {};
				oCopy.positions = o.positions.concat();
				oCopy.coords = o.coords.concat();
				oCopy.indices = o.indices.concat();
				oCopy.normals = o.normals.concat();

				while (o.indices.length > 0) {

					var sliceNum = Math.min(maxNumVertices, o.positions.length);
					var indices = o.indices.splice(0, sliceNum);
					var positions = [];
					var coords = [];
					var normals = [];
					var index = void 0,
					    tmpIndex = 0;

					for (var i = 0; i < indices.length; i++) {
						if (indices[i] > tmpIndex) {
							tmpIndex = indices[i];
						}

						index = indices[i];

						positions.push(oCopy.positions[index]);
						if (hasUVs) {
							coords.push(oCopy.coords[index]);
						}
						if (hasNormals) {
							normals.push(oCopy.normals[index]);
						}

						indices[i] -= lastIndex;
					}

					lastIndex = tmpIndex + 1;

					mesh = new _Mesh2.default(this._drawType);
					mesh.bufferVertex(positions);
					if (hasUVs) {
						mesh.bufferTexCoord(coords);
					}

					mesh.bufferIndex(indices);
					if (hasNormals) {
						mesh.bufferNormal(normals);
					}

					meshes.push(mesh);
				}

				if (this._callback) {
					this._callback(meshes, oCopy);
				}

				return meshes;
			} else {
				mesh = new _Mesh2.default(this._drawType);
				mesh.bufferVertex(o.positions);
				if (hasUVs) {
					mesh.bufferTexCoord(o.coords);
				}
				mesh.bufferIndex(o.indices);
				if (hasNormals) {
					mesh.bufferNormal(o.normals);
				}

				if (this._callback) {
					this._callback(mesh, o);
				}

				return mesh;
			}

			return null;
		}
	}]);

	return ObjLoader;
}(_BinaryLoader3.default);

ObjLoader.parse = function (objStr) {
	var loader = new ObjLoader();
	return loader.parseObj(objStr);
};

exports.default = ObjLoader;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// HDRLoader.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _BinaryLoader2 = __webpack_require__(17);

var _BinaryLoader3 = _interopRequireDefault(_BinaryLoader2);

var _HDRParser = __webpack_require__(68);

var _HDRParser2 = _interopRequireDefault(_HDRParser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var HDRLoader = function (_BinaryLoader) {
	_inherits(HDRLoader, _BinaryLoader);

	function HDRLoader() {
		_classCallCheck(this, HDRLoader);

		return _possibleConstructorReturn(this, (HDRLoader.__proto__ || Object.getPrototypeOf(HDRLoader)).call(this, true));
	}

	_createClass(HDRLoader, [{
		key: 'parse',
		value: function parse(mArrayBuffer) {
			return (0, _HDRParser2.default)(mArrayBuffer);
		}
	}, {
		key: '_onLoaded',
		value: function _onLoaded() {
			var o = this.parse(this._req.response);
			if (this._callback) {
				this._callback(o);
			}
		}
	}]);

	return HDRLoader;
}(_BinaryLoader3.default);

HDRLoader.parse = function (mArrayBuffer) {
	return (0, _HDRParser2.default)(mArrayBuffer);
};

exports.default = HDRLoader;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// HDRParser.js



// Code ported by Marcin Ignac (2014)
// Based on Java implementation from
// https://code.google.com/r/cys12345-research/source/browse/hdr/image_processor/RGBE.java?r=7d84e9fd866b24079dbe61fa0a966ce8365f5726

Object.defineProperty(exports, "__esModule", {
	value: true
});
var radiancePattern = '#\\?RADIANCE';
var commentPattern = '#.*';
// let gammaPattern = 'GAMMA=';
var exposurePattern = 'EXPOSURE=\\s*([0-9]*[.][0-9]*)';
var formatPattern = 'FORMAT=32-bit_rle_rgbe';
var widthHeightPattern = '-Y ([0-9]+) \\+X ([0-9]+)';

// http://croquetweak.blogspot.co.uk/2014/08/deconstructing-floats-frexp-and-ldexp.html
// function ldexp(mantissa, exponent) {
//     return exponent > 1023 ? mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023) : exponent < -1074 ? mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074) : mantissa * Math.pow(2, exponent);
// }

function readPixelsRawRLE(buffer, data, offset, fileOffset, scanlineWidth, numScanlines) {
	var rgbe = new Array(4);
	var scanlineBuffer = null;
	var ptr = void 0;
	var ptrEnd = void 0;
	var count = void 0;
	var buf = new Array(2);
	var bufferLength = buffer.length;

	function readBuf(buf) {
		var bytesRead = 0;
		do {
			buf[bytesRead++] = buffer[fileOffset];
		} while (++fileOffset < bufferLength && bytesRead < buf.length);
		return bytesRead;
	}

	function readBufOffset(buf, offset, length) {
		var bytesRead = 0;
		do {
			buf[offset + bytesRead++] = buffer[fileOffset];
		} while (++fileOffset < bufferLength && bytesRead < length);
		return bytesRead;
	}

	function readPixelsRaw(buffer, data, offset, numpixels) {
		var numExpected = 4 * numpixels;
		var numRead = readBufOffset(data, offset, numExpected);
		if (numRead < numExpected) {
			throw new Error('Error reading raw pixels: got ' + numRead + ' bytes, expected ' + numExpected);
		}
	}

	while (numScanlines > 0) {
		if (readBuf(rgbe) < rgbe.length) {
			throw new Error('Error reading bytes: expected ' + rgbe.length);
		}

		if (rgbe[0] !== 2 || rgbe[1] !== 2 || (rgbe[2] & 0x80) !== 0) {
			// this file is not run length encoded
			data[offset++] = rgbe[0];
			data[offset++] = rgbe[1];
			data[offset++] = rgbe[2];
			data[offset++] = rgbe[3];
			readPixelsRaw(buffer, data, offset, scanlineWidth * numScanlines - 1);
			return;
		}

		if (((rgbe[2] & 0xFF) << 8 | rgbe[3] & 0xFF) !== scanlineWidth) {
			throw new Error('Wrong scanline width ' + ((rgbe[2] & 0xFF) << 8 | rgbe[3] & 0xFF) + ', expected ' + scanlineWidth);
		}

		if (scanlineBuffer === null) {
			scanlineBuffer = new Array(4 * scanlineWidth);
		}

		ptr = 0;
		/* read each of the four channels for the scanline into the buffer */
		for (var i = 0; i < 4; i++) {
			ptrEnd = (i + 1) * scanlineWidth;
			while (ptr < ptrEnd) {
				if (readBuf(buf) < buf.length) {
					throw new Error('Error reading 2-byte buffer');
				}
				if ((buf[0] & 0xFF) > 128) {
					/* a run of the same value */
					count = (buf[0] & 0xFF) - 128;
					if (count === 0 || count > ptrEnd - ptr) {
						throw new Error('Bad scanline data');
					}
					while (count-- > 0) {
						scanlineBuffer[ptr++] = buf[1];
					}
				} else {
					/* a non-run */
					count = buf[0] & 0xFF;
					if (count === 0 || count > ptrEnd - ptr) {
						throw new Error('Bad scanline data');
					}
					scanlineBuffer[ptr++] = buf[1];
					if (--count > 0) {
						if (readBufOffset(scanlineBuffer, ptr, count) < count) {
							throw new Error('Error reading non-run data');
						}
						ptr += count;
					}
				}
			}
		}

		/* copy byte data to output */
		for (var _i = 0; _i < scanlineWidth; _i++) {
			data[offset + 0] = scanlineBuffer[_i];
			data[offset + 1] = scanlineBuffer[_i + scanlineWidth];
			data[offset + 2] = scanlineBuffer[_i + 2 * scanlineWidth];
			data[offset + 3] = scanlineBuffer[_i + 3 * scanlineWidth];
			offset += 4;
		}

		numScanlines--;
	}
}

// Returns data as floats and flipped along Y by default
function parseHdr(buffer) {
	if (buffer instanceof ArrayBuffer) {
		buffer = new Uint8Array(buffer);
	}

	var fileOffset = 0;
	var bufferLength = buffer.length;

	var NEW_LINE = 10;

	function readLine() {
		var buf = '';
		do {
			var b = buffer[fileOffset];
			if (b === NEW_LINE) {
				++fileOffset;
				break;
			}
			buf += String.fromCharCode(b);
		} while (++fileOffset < bufferLength);
		return buf;
	}

	var width = 0;
	var height = 0;
	var exposure = 1;
	var gamma = 1;
	var rle = false;

	for (var i = 0; i < 20; i++) {
		var line = readLine();
		var match = void 0;
		if (match = line.match(radiancePattern)) {} else if (match = line.match(formatPattern)) {
			rle = true;
		} else if (match = line.match(exposurePattern)) {
			exposure = Number(match[1]);
		} else if (match = line.match(commentPattern)) {} else if (match = line.match(widthHeightPattern)) {
			height = Number(match[1]);
			width = Number(match[2]);
			break;
		}
	}

	if (!rle) {
		throw new Error('File is not run length encoded!');
	}

	var data = new Uint8Array(width * height * 4);
	var scanlineWidth = width;
	var numScanlines = height;

	readPixelsRawRLE(buffer, data, 0, fileOffset, scanlineWidth, numScanlines);

	// TODO: Should be Float16
	var floatData = new Float32Array(width * height * 4);
	for (var offset = 0; offset < data.length; offset += 4) {
		var r = data[offset + 0] / 255;
		var g = data[offset + 1] / 255;
		var b = data[offset + 2] / 255;
		var e = data[offset + 3];
		var f = Math.pow(2.0, e - 128.0);

		r *= f;
		g *= f;
		b *= f;

		var floatOffset = offset;

		floatData[floatOffset + 0] = r;
		floatData[floatOffset + 1] = g;
		floatData[floatOffset + 2] = b;
		floatData[floatOffset + 3] = 1.0;
	}

	return {
		shape: [width, height],
		exposure: exposure,
		gamma: gamma,
		data: floatData
	};
}

exports.default = parseHdr;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _colladaParser = __webpack_require__(70);

var _colladaParser2 = _interopRequireDefault(_colladaParser);

var _Mesh = __webpack_require__(4);

var _Mesh2 = _interopRequireDefault(_Mesh);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// ColladaParser.js

var generateMesh = function generateMesh(meshes) {
	var caches = {};

	meshes.forEach(function (mesh) {
		var _mesh$mesh = mesh.mesh,
		    vertices = _mesh$mesh.vertices,
		    normals = _mesh$mesh.normals,
		    coords = _mesh$mesh.coords,
		    triangles = _mesh$mesh.triangles,
		    name = _mesh$mesh.name;

		if (!caches[name]) {
			var glMesh = new _Mesh2.default().bufferFlattenData(vertices, 'aVertexPosition', 3).bufferFlattenData(coords, 'aTextureCoord', 2).bufferFlattenData(normals, 'aNormal', 3).bufferIndex(triangles);

			caches[name] = glMesh;
		}

		mesh.glMesh = caches[name];
	});
};

var parse = function parse(mData) {
	var meshes = _colladaParser2.default.parse(mData);
	generateMesh(meshes);

	return meshes;
};

var load = function load(mPath, mCallback) {
	_colladaParser2.default.load(mPath, function (meshes) {
		generateMesh(meshes);
		mCallback(meshes);
	});
};

var ColladaParser = {
	parse: parse,
	load: load
};

exports.default = ColladaParser;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Collada = __webpack_require__(71);

var _Collada2 = _interopRequireDefault(_Collada);

var _glMatrix = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// ColladaParser.js

var parseData = function parseData(mData) {
	var materials = mData.materials,
	    meshes = mData.meshes;


	var finalMeshes = [];
	var meshObjs = [];
	var allMeshes = [];

	//	getting all meshes' buffers
	for (var s in meshes) {
		var oMesh = meshes[s];
		var vertices = oMesh.vertices,
		    normals = oMesh.normals,
		    coords = oMesh.coords,
		    triangles = oMesh.triangles;

		var buffers = {
			vertices: vertices, normals: normals, coords: coords, triangles: triangles
		};
		allMeshes.push({
			id: s,
			buffers: buffers
		});
	}

	function getMaterial(id) {
		var mat = void 0;
		for (var _s in materials) {
			if (_s === id) {
				mat = materials[_s];
			}
		}

		var oMaterial = {};
		if (mat.diffuse) {
			oMaterial.diffuseColor = mat.diffuse;
		}

		oMaterial.diffuseColor = mat.diffuse || [0, 0, 0];
		oMaterial.shininess = mat.shininess || 0;
		if (mat.textures) {
			if (mat.textures.diffuse) {
				oMaterial.diffuseMapID = mat.textures.diffuse.map_id;
			}

			if (mat.textures.normal) {
				oMaterial.normalMapID = mat.textures.normal.map_id;
			}
		}

		return oMaterial;
	}

	function walk(node, mtxParent) {
		var m = _glMatrix.mat4.create();
		if (node.model) {
			_glMatrix.mat4.multiply(m, mtxParent, node.model);
		} else {
			_glMatrix.mat4.copy(m, mtxParent);
		}

		if (node.children.length > 0) {
			node.children.forEach(function (child) {
				walk(child, m);
			});
		}

		if (node.mesh) {
			var _oMesh = {};
			_oMesh.modelMatrix = m;
			_oMesh.mesh = meshes[node.mesh];
			_oMesh.id = node.id;
			_oMesh.name = node.name;
			_oMesh.material = getMaterial(node.material);
			meshObjs.push(_oMesh);
		}
	}

	var mtx = _glMatrix.mat4.create();
	walk(mData.root, mtx);

	return meshObjs;
};

var parse = function parse(mFile) {
	var o = _Collada2.default.parse(mFile);
	return parseData(o);
};

var load = function load(mPath, mCallBack) {
	_Collada2.default.load(mPath, function (mData) {
		mCallBack(parseData(mData));
	});
};

var ColladaParser = {
	load: load,
	parse: parse
};

exports.default = ColladaParser;
module.exports = exports['default'];
//# sourceMappingURL=ColladaParser.js.map

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _glMatrix = __webpack_require__(1);

var isWorker = global.document === undefined; // Collada.js

var DEG2RAD = Math.PI * 2 / 360;

//global temporal variables
var temp_mat4 = null;
var temp_vec2 = null;
var temp_vec3 = null;
var temp_vec4 = null;
var temp_quat = null;

function request(url, callback) {
	var req = new XMLHttpRequest();
	req.onload = function () {
		var response = this.response;
		if (this.status != 200) return;
		if (callback) callback(this.response);
	};
	req.open("get", url, true);
	req.send();
}

var Collada = {

	libsPath: "./",
	workerPath: "./",
	no_flip: true,
	use_transferables: true, //for workers
	onerror: null,
	verbose: false,
	config: { forceParser: false },

	init: function init(config) {
		config = config || {};
		for (var i in config) {
			this[i] = config[i];
		}this.config = config;

		if (isWorker) {
			try {
				importScripts(this.libsPath + "gl-matrix-min.js", this.libsPath + "tinyxml.js");
			} catch (err) {
				Collada.throwException(Collada.LIBMISSING_ERROR);
			}
		}

		//init glMatrix
		temp_mat4 = _glMatrix.mat4.create();
		temp_vec2 = vec3.create();
		temp_vec3 = vec3.create();
		temp_vec4 = vec3.create();
		temp_quat = _glMatrix.quat.create();

		if (isWorker) console.log("Collada worker ready");
	},

	load: function load(url, callback) {
		request(url, function (data) {
			if (!data) callback(null);else callback(Collada.parse(data));
		});
	},

	_xmlroot: null,
	_nodes_by_id: null,
	_transferables: null,
	_controllers_found: null,
	_geometries_found: null,

	safeString: function safeString(str) {
		if (!str) return "";

		if (this.convertID) return this.convertID(str);

		return str.replace(/ /g, "_");
	},

	LIBMISSING_ERROR: "Libraries loading error, when using workers remember to pass the URL to the tinyxml.js in the options.libsPath",
	NOXMLPARSER_ERROR: "TinyXML not found, when using workers remember to pass the URL to the tinyxml.js in the options.libsPath (Workers do not allow to access the native XML DOMParser)",
	throwException: function throwException(msg) {
		if (isWorker) self.postMessage({ action: "exception", msg: msg });else if (Collada.onerror) Collada.onerror(msg);
		throw msg;
	},

	getFilename: function getFilename(filename) {
		var pos = filename.lastIndexOf("\\");
		if (pos != -1) filename = filename.substr(pos + 1);
		//strip unix slashes
		pos = filename.lastIndexOf("/");
		if (pos != -1) filename = filename.substr(pos + 1);
		return filename;
	},

	last_name: 0,

	generateName: function generateName(v) {
		v = v || "name_";
		var name = v + this.last_name;
		this.last_name++;
		return name;
	},

	parse: function parse(data, options, filename) {
		options = options || {};
		filename = filename || "_dae_" + Date.now() + ".dae";

		//console.log("Parsing collada");
		var flip = false;

		var xmlparser = null;
		var root = null;
		this._transferables = [];

		if (this.verbose) console.log(" - XML parsing...");

		if (global["DOMParser"] && !this.config.forceParser) {
			xmlparser = new DOMParser();
			root = xmlparser.parseFromString(data, "text/xml");
			if (this.verbose) console.log(" - XML parsed");
		} else //USING JS XML PARSER IMPLEMENTATION (much slower)
			{
				if (!global["DOMImplementation"]) return Collada.throwException(Collada.NOXMLPARSER_ERROR);
				//use tinyxmlparser
				try {
					xmlparser = new DOMImplementation();
				} catch (err) {
					return Collada.throwException(Collada.NOXMLPARSER_ERROR);
				}

				root = xmlparser.loadXML(data);
				if (this.verbose) console.log(" - XML parsed");

				//for every node...
				var by_ids = root._nodes_by_id = {};
				for (var i = 0, l = root.all.length; i < l; ++i) {
					var node = root.all[i];
					by_ids[node.id] = node;
					if (node.getAttribute("sid")) by_ids[node.getAttribute("sid")] = node;
				}

				if (!this.extra_functions) {
					this.extra_functions = true;
					//these methods are missing so here is a lousy implementation
					DOMDocument.prototype.querySelector = DOMElement.prototype.querySelector = function (selector) {
						var tags = selector.split(" ");
						var current_element = this;

						while (tags.length) {
							var current = tags.shift();
							var tokens = current.split("#");
							var tagname = tokens[0];
							var id = tokens[1];
							var elements = tagname ? current_element.getElementsByTagName(tagname) : current_element.childNodes;
							if (!id) //no id filter
								{
									if (tags.length == 0) return elements.item(0);
									current_element = elements.item(0);
									continue;
								}

							//has id? check for all to see if one matches the id
							for (var i = 0; i < elements.length; i++) {
								if (elements.item(i).getAttribute("id") == id) {
									if (tags.length == 0) return elements.item(i);
									current_element = elements.item(i);
									break;
								}
							}
						}
						return null;
					};

					DOMDocument.prototype.querySelectorAll = DOMElement.prototype.querySelectorAll = function (selector) {
						var tags = selector.split(" ");
						if (tags.length == 1) return this.getElementsByTagName(selector);

						var current_element = this;
						var result = [];

						inner(this, tags);

						function inner(root, tags) {
							if (!tags) return;

							var current = tags.shift();
							var elements = root.getElementsByTagName(current);
							if (tags.length == 0) {
								for (var i = 0; i < elements.length; i++) {
									result.push(elements.item(i));
								}return;
							}

							for (var i = 0; i < elements.length; i++) {
								inner(elements.item(i), tags.concat());
							}
						}

						var list = new DOMNodeList(this.documentElement);
						list._nodes = result;
						list.length = result.length;

						return list;
					};

					Object.defineProperty(DOMElement.prototype, "textContent", {
						get: function get() {
							var nodes = this.getChildNodes();
							return nodes.item(0).toString();
						},
						set: function set() {}
					});
				}
			}
		this._xmlroot = root;
		var xmlcollada = root.querySelector("COLLADA");
		if (xmlcollada) {
			this._current_DAE_version = xmlcollada.getAttribute("version");
			console.log("DAE Version:" + this._current_DAE_version);
		}

		//var xmlvisual_scene = root.querySelector("visual_scene");
		var xmlvisual_scene = root.getElementsByTagName("visual_scene").item(0);
		if (!xmlvisual_scene) throw "visual_scene XML node not found in DAE";

		//hack to avoid problems with bones with spaces in names
		this._nodes_by_id = {}; //clear
		this._controllers_found = {}; //we need to check what controllers had been found, in case we miss one at the end
		this._geometries_found = {};

		//Create a scene tree
		var scene = {
			object_type: "SceneTree",
			light: null,
			materials: {},
			meshes: {},
			resources: {}, //used to store animation tracks
			root: { children: [] },
			external_files: {} //store info about external files mentioned in this 
		};

		//scene metadata (like author, tool, up vector, dates, etc)
		var xmlasset = root.getElementsByTagName("asset")[0];
		if (xmlasset) scene.metadata = this.readAsset(xmlasset);

		//parse nodes tree to extract names and ierarchy only
		var xmlnodes = xmlvisual_scene.childNodes;
		for (var i = 0; i < xmlnodes.length; i++) {
			if (xmlnodes.item(i).localName != "node") continue;

			var node = this.readNodeTree(xmlnodes.item(i), scene, 0, flip);
			if (node) scene.root.children.push(node);
		}

		//parse nodes content (two steps so we have first all the scene tree info)
		for (var i = 0; i < xmlnodes.length; i++) {
			if (xmlnodes.item(i).localName != "node") continue;
			this.readNodeInfo(xmlnodes.item(i), scene, 0, flip);
		}

		//read remaining controllers (in some cases some controllers are not linked from the nodes or the geometries)
		this.readLibraryControllers(scene);

		//read animations
		var animations = this.readAnimations(root, scene);
		if (animations) {
			var animations_name = "#animations_" + filename.substr(0, filename.indexOf("."));
			scene.resources[animations_name] = animations;
			scene.root.animations = animations_name;
		}

		//read external files (images)
		scene.images = this.readImages(root);

		//clear memory
		this._nodes_by_id = {};
		this._controllers_found = {};
		this._geometries_found = {};
		this._xmlroot = null;

		//console.log(scene);
		return scene;
	},

	/* Collect node ids, in case there is bones (with spaces in name) I need to know the nodenames in advance */
	/*
 readAllNodeNames: function(xmlnode)
 {
 	var node_id = this.safeString( xmlnode.getAttribute("id") );
 	if(node_id)
 		this._nodes_by_id[node_id] = true; //node found
 	//nodes seem to have to possible ids, id and sid, I guess one is unique, the other user-defined
 	var node_sid = this.safeString( xmlnode.getAttribute("sid") );
 	if(node_sid)
 		this._nodes_by_id[node_sid] = true; //node found
 
 	for( var i = 0; i < xmlnode.childNodes.length; i++ )
 	{
 		var xmlchild = xmlnode.childNodes.item(i);
 			//children
 		if(xmlchild.localName != "node")
 			continue;
 		this.readAllNodeNames(xmlchild);
 	}
 },
 	*/

	readAsset: function readAsset(xmlasset) {
		var metadata = {};

		for (var i = 0; i < xmlasset.childNodes.length; i++) {
			var xmlchild = xmlasset.childNodes.item(i);
			if (xmlchild.nodeType != 1) //not tag
				continue;
			switch (xmlchild.localName) {
				case "contributor":
					var tool = xmlchild.querySelector("authoring_tool");
					if (tool) metadata["authoring_tool"] = tool.textContext;
					break;
				case "unit":
					metadata["unit"] = xmlchild.getAttribute("name");break;
				default:
					metadata[xmlchild.localName] = xmlchild.textContent;break;
			}
		}

		return metadata;
	},

	readNodeTree: function readNodeTree(xmlnode, scene, level, flip) {
		var node_id = this.safeString(xmlnode.getAttribute("id"));
		var node_sid = this.safeString(xmlnode.getAttribute("sid"));

		if (!node_id && !node_sid) return null;

		//here we create the node
		var node = {
			id: node_sid || node_id,
			children: [],
			_depth: level
		};

		var node_type = xmlnode.getAttribute("type");
		if (node_type) node.type = node_type;

		var node_name = xmlnode.getAttribute("name");
		if (node_name) node.name = node_name;
		this._nodes_by_id[node.id] = node;
		if (node_id) this._nodes_by_id[node_id] = node;
		if (node_sid) this._nodes_by_id[node_sid] = node;

		//transform
		node.model = this.readTransform(xmlnode, level, flip);

		//node elements
		for (var i = 0; i < xmlnode.childNodes.length; i++) {
			var xmlchild = xmlnode.childNodes.item(i);
			if (xmlchild.nodeType != 1) //not tag
				continue;

			//children
			if (xmlchild.localName == "node") {
				var child_node = this.readNodeTree(xmlchild, scene, level + 1, flip);
				if (child_node) node.children.push(child_node);
				continue;
			}
		}

		return node;
	},

	readNodeInfo: function readNodeInfo(xmlnode, scene, level, flip, parent) {
		var node_id = this.safeString(xmlnode.getAttribute("id"));
		var node_sid = this.safeString(xmlnode.getAttribute("sid"));

		/*
  if(!node_id && !node_sid)
  {
  	console.warn("Collada: node without id, creating a random one");
  	node_id = this.generateName("node_");
  	return null;
  }
  */

		var node;
		if (!node_id && !node_sid) {
			//if there is no id, then either all of this node's properties 
			//should be assigned directly to its parent node, or the node doesn't
			//have a parent node, in which case its a light or something. 
			//So we get the parent by its id, and if there is no parent, we return null
			if (parent) node = this._nodes_by_id[parent.id || parent.sid];else return null;
		} else node = this._nodes_by_id[node_id || node_sid];

		if (!node) {
			console.warn("Collada: Node not found by id: " + (node_id || node_sid));
			return null;
		}

		//node elements
		for (var i = 0; i < xmlnode.childNodes.length; i++) {
			var xmlchild = xmlnode.childNodes.item(i);
			if (xmlchild.nodeType != 1) //not tag
				continue;

			//children
			if (xmlchild.localName == "node") {
				//pass parent node in case child node is a 'dead' node (has no id or sid)
				this.readNodeInfo(xmlchild, scene, level + 1, flip, xmlnode);
				continue;
			}

			//geometry
			if (xmlchild.localName == "instance_geometry") {
				var url = xmlchild.getAttribute("url");
				var mesh_id = url.toString().substr(1);
				node.mesh = mesh_id;

				if (!scene.meshes[url]) {
					var mesh_data = this.readGeometry(url, flip);
					if (mesh_data) {
						mesh_data.name = mesh_id;
						scene.meshes[mesh_id] = mesh_data;
					}
				}

				//binded material
				var xmlmaterials = xmlchild.querySelectorAll("instance_material");
				if (xmlmaterials) {
					for (var iMat = 0; iMat < xmlmaterials.length; ++iMat) {
						var xmlmaterial = xmlmaterials.item(iMat);
						if (!xmlmaterial) {
							console.warn("instance_material not found: " + i);
							continue;
						}

						var matname = xmlmaterial.getAttribute("target").toString().substr(1);
						//matname = matname.replace(/ /g,"_"); //names cannot have spaces
						if (!scene.materials[matname]) {

							var material = this.readMaterial(matname);
							if (material) {
								material.id = matname;
								scene.materials[material.id] = material;
							}
						}
						if (iMat == 0) node.material = matname;else {
							if (!node.materials) node.materials = [];
							node.materials.push(matname);
						}
					}
				}
			}

			//this node has a controller: skinning, morph targets or even multimaterial are controllers
			//warning: I detected that some nodes could have a controller but they are not referenced here.  ??
			if (xmlchild.localName == "instance_controller") {
				var url = xmlchild.getAttribute("url");
				var xmlcontroller = this._xmlroot.querySelector("controller" + url);

				if (xmlcontroller) {

					var mesh_data = this.readController(xmlcontroller, flip, scene);

					//binded materials
					var xmlbind_material = xmlchild.querySelector("bind_material");
					if (xmlbind_material) {
						//removed readBindMaterials up here for consistency
						var xmltechniques = xmlbind_material.querySelectorAll("technique_common");
						for (var iTec = 0; iTec < xmltechniques.length; iTec++) {
							var xmltechnique = xmltechniques.item(iTec);
							var xmlinstance_materials = xmltechnique.querySelectorAll("instance_material");
							for (var iMat = 0; iMat < xmlinstance_materials.length; iMat++) {
								var xmlinstance_material = xmlinstance_materials.item(iMat);
								if (!xmlinstance_material) {
									console.warn("instance_material for controller not found: " + xmlinstance_material);
									continue;
								}
								var matname = xmlinstance_material.getAttribute("target").toString().substr(1);
								if (!scene.materials[matname]) {

									var material = this.readMaterial(matname);
									if (material) {
										material.id = matname;
										scene.materials[material.id] = material;
									}
								}
								if (iMat == 0) node.material = matname;else {
									if (!node.materials) node.materials = [];
									node.materials.push(matname);
								}
							}
						}
					}

					if (mesh_data) {
						var mesh = mesh_data;
						if (mesh_data.type == "morph") {
							mesh = mesh_data.mesh;
							node.morph_targets = mesh_data.morph_targets;
						}

						mesh.name = url.toString();
						node.mesh = url.toString();
						scene.meshes[url] = mesh;
					}
				}
			}

			//light
			if (xmlchild.localName == "instance_light") {
				var url = xmlchild.getAttribute("url");
				this.readLight(node, url);
			}

			//camera
			if (xmlchild.localName == "instance_camera") {
				var url = xmlchild.getAttribute("url");
				this.readCamera(node, url);
			}

			//other possible tags?
		}
	},

	//if you want to rename some material names
	material_translate_table: {
		/*
  transparency: "opacity",
  reflectivity: "reflection_factor",
  specular: "specular_factor",
  shininess: "specular_gloss",
  emission: "emissive",
  diffuse: "color"
  */
	},

	light_translate_table: {

		point: "omni",
		directional: "directional",
		spot: "spot"
	},

	camera_translate_table: {
		xfov: "fov",
		aspect_ratio: "aspect",
		znear: "near",
		zfar: "far"
	},

	//used when id have spaces (regular selector do not support spaces)
	querySelectorAndId: function querySelectorAndId(root, selector, id) {
		var nodes = root.querySelectorAll(selector);
		for (var i = 0; i < nodes.length; i++) {
			var attr_id = nodes.item(i).getAttribute("id");
			if (!attr_id) continue;
			attr_id = attr_id.toString();
			if (attr_id == id) return nodes.item(i);
		}
		return null;
	},

	//returns the first element that matches a tag name, if not tagname is specified then the first tag element
	getFirstChildElement: function getFirstChildElement(root, localName) {
		var c = root.childNodes;
		for (var i = 0; i < c.length; ++i) {
			var item = c.item(i);
			if (item.localName && !localName || localName && localName == item.localName) return item;
		}
		return null;
	},

	readMaterial: function readMaterial(url) {
		var xmlmaterial = this.querySelectorAndId(this._xmlroot, "library_materials material", url);

		if (!xmlmaterial) return null;

		//get effect name
		var xmleffect = xmlmaterial.querySelector("instance_effect");
		if (!xmleffect) return null;

		var effect_url = xmleffect.getAttribute("url").substr(1);

		//get effect
		var xmleffects = this.querySelectorAndId(this._xmlroot, "library_effects effect", effect_url);

		if (!xmleffects) return null;

		//get common
		var xmltechnique = xmleffects.querySelector("technique");
		if (!xmltechnique) return null;

		//get newparams and convert to js object
		var xmlnewparams = xmleffects.querySelectorAll("newparam");
		var newparams = {};
		for (var i = 0; i < xmlnewparams.length; i++) {

			var init_from = xmlnewparams[i].querySelector("init_from");
			var parent;
			if (init_from) parent = init_from.innerHTML;else {
				var source = xmlnewparams[i].querySelector("source");
				parent = source.innerHTML;
			}

			newparams[xmlnewparams[i].getAttribute("sid")] = {
				parent: parent
			};
		}

		var material = {};

		//read the images here because we need to access them to assign texture names
		var images = this.readImages(this._xmlroot);

		var xmlphong = xmltechnique.querySelector("phong");
		if (!xmlphong) xmlphong = xmltechnique.querySelector("blinn");
		if (!xmlphong) xmlphong = xmltechnique.querySelector("lambert");
		if (!xmlphong) return null;

		//for every tag of properties
		for (var i = 0; i < xmlphong.childNodes.length; ++i) {
			var xmlparam = xmlphong.childNodes.item(i);

			if (!xmlparam.localName) //text tag
				continue;

			//translate name
			var param_name = xmlparam.localName.toString();
			if (this.material_translate_table[param_name]) param_name = this.material_translate_table[param_name];

			//value
			var xmlparam_value = this.getFirstChildElement(xmlparam);
			if (!xmlparam_value) continue;

			if (xmlparam_value.localName.toString() == "color") {
				var value = this.readContentAsFloats(xmlparam_value);
				if (xmlparam.getAttribute("opaque") == "RGB_ZERO") material[param_name] = value.subarray(0, 4);else material[param_name] = value.subarray(0, 3);
				continue;
			} else if (xmlparam_value.localName.toString() == "float") {
				material[param_name] = this.readContentAsFloats(xmlparam_value)[0];
				continue;
			} else if (xmlparam_value.localName.toString() == "texture") {
				if (!material.textures) material.textures = {};
				var map_id = xmlparam_value.getAttribute("texture");
				if (!map_id) continue;

				// if map_id is not a filename, lets go and look for it.
				if (map_id.indexOf('.') === -1) {
					//check effect parents
					map_id = this.getParentParam(newparams, map_id);

					if (images[map_id]) map_id = images[map_id].path;
				}

				//now get the texture filename from images

				var map_info = { map_id: map_id };
				var uvs = xmlparam_value.getAttribute("texcoord");
				map_info.uvs = uvs;
				material.textures[param_name] = map_info;
			}
		}

		material.object_type = "Material";
		return material;
	},

	getParentParam: function getParentParam(newparams, param) {
		if (!newparams[param]) return param;

		if (newparams[param].parent) return this.getParentParam(newparams, newparams[param].parent);else return param;
	},

	readLight: function readLight(node, url) {
		var light = {};

		var xmlnode = null;

		if (url.length > 1) //weird cases with id == #
			xmlnode = this._xmlroot.querySelector("library_lights " + url);else {
			var xmlliblights = this._xmlroot.querySelector("library_lights");
			xmlnode = this.getFirstChildElement(xmlliblights, "light");
		}

		if (!xmlnode) return null;

		//pack
		var children = [];
		var xml = xmlnode.querySelector("technique_common");
		if (xml) for (var i = 0; i < xml.childNodes.length; i++) {
			if (xml.childNodes.item(i).nodeType == 1) //tag
				children.push(xml.childNodes.item(i));
		}var xmls = xmlnode.querySelectorAll("technique");
		for (var i = 0; i < xmls.length; i++) {
			var xml2 = xmls.item(i);
			for (var j = 0; j < xml2.childNodes.length; j++) {
				if (xml2.childNodes.item(j).nodeType == 1) //tag
					children.push(xml2.childNodes.item(j));
			}
		}

		//get
		for (var i = 0; i < children.length; i++) {
			var xml = children[i];
			switch (xml.localName) {
				case "point":
					light.type = this.light_translate_table[xml.localName];
					parse_params(light, xml);
					break;
				case "directional":
					light.type = this.light_translate_table[xml.localName];
					parse_params(light, xml);
					break;
				case "spot":
					light.type = this.light_translate_table[xml.localName];
					parse_params(light, xml);
					break;

				case "intensity":
					light.intensity = this.readContentAsFloats(xml)[0];
					break;
			}
		}

		function parse_params(light, xml) {
			for (var i = 0; i < xml.childNodes.length; i++) {
				var child = xml.childNodes.item(i);
				if (!child || child.nodeType != 1) //tag
					continue;

				switch (child.localName) {
					case "color":
						light.color = Collada.readContentAsFloats(child);break;
					case "falloff_angle":
						light.angle_end = Collada.readContentAsFloats(child)[0];
						light.angle = light.angle_end - 10;
						break;
				}
			}
		}

		if (node.model) {
			//light position is final column of model
			light.position = [node.model[12], node.model[13], node.model[14]];
			//light forward vector is reverse of third column of model
			var forward = [-node.model[8], -node.model[9], -node.model[10]];
			//so light target is position + forward
			light.target = [light.position[0] + forward[0], light.position[1] + forward[1], light.position[2] + forward[2]];
		} else {
			console.warn("Could not read light position for light: " + node.name + ". Setting defaults.");
			light.position = [0, 0, 0];
			light.target = [0, -1, 0];
		}

		node.light = light;
	},

	readCamera: function readCamera(node, url) {
		var camera = {};

		var xmlnode = this._xmlroot.querySelector("library_cameras " + url);
		if (!xmlnode) return null;

		//pack
		var children = [];
		var xml = xmlnode.querySelector("technique_common");
		if (xml) //grab all internal stuff
			for (var i = 0; i < xml.childNodes.length; i++) {
				if (xml.childNodes.item(i).nodeType == 1) //tag
					children.push(xml.childNodes.item(i));
			} //
		for (var i = 0; i < children.length; i++) {
			var tag = children[i];
			parse_params(camera, tag);
		}

		function parse_params(camera, xml) {
			for (var i = 0; i < xml.childNodes.length; i++) {
				var child = xml.childNodes.item(i);
				if (!child || child.nodeType != 1) //tag
					continue;
				var translated = Collada.camera_translate_table[child.localName] || child.localName;
				camera[translated] = parseFloat(child.textContent);
			}
		}

		//parse to convert yfov to standard (x) fov
		if (camera.yfov && !camera.fov) {
			if (camera.aspect) {
				camera.fov = camera.yfov * camera.aspect;
			} else console.warn("Could not convert camera yfov to xfov because aspect ratio not set");
		}

		node.camera = camera;
	},

	readTransform: function readTransform(xmlnode, level, flip) {
		//identity
		var matrix = _glMatrix.mat4.create();
		var temp = _glMatrix.mat4.create();
		var tmpq = _glMatrix.quat.create();

		var flip_fix = false;

		//search for the matrix
		for (var i = 0; i < xmlnode.childNodes.length; i++) {
			var xml = xmlnode.childNodes.item(i);
			if (!xml || xml.nodeType != 1) //tag
				continue;

			if (xml.localName == "matrix") {
				var matrix = this.readContentAsFloats(xml);
				//console.log("Nodename: " + xmlnode.getAttribute("id"));
				//console.log(matrix);
				this.transformMatrix(matrix, level == 0);
				//console.log(matrix);
				return matrix;
			}

			if (xml.localName == "translate") {
				var values = this.readContentAsFloats(xml);
				if (flip && level > 0) {
					var tmp = values[1];
					values[1] = values[2];
					values[2] = -tmp; //swap coords
				}

				_glMatrix.mat4.translate(matrix, matrix, values);
				continue;
			}

			//rotate
			if (xml.localName == "rotate") {
				var values = this.readContentAsFloats(xml);
				if (values.length == 4) //x,y,z, angle
					{
						var id = xml.getAttribute("sid");
						if (id == "jointOrientX") {
							values[3] += 90;
							flip_fix = true;
						}
						//rotateX & rotateY & rotateZ done below

						if (flip) {
							var tmp = values[1];
							values[1] = values[2];
							values[2] = -tmp; //swap coords
						}

						if (values[3] != 0.0) {
							_glMatrix.quat.setAxisAngle(tmpq, values.subarray(0, 3), values[3] * DEG2RAD);
							_glMatrix.mat4.fromQuat(temp, tmpq);
							_glMatrix.mat4.multiply(matrix, matrix, temp);
						}
					}
				continue;
			}

			//scale
			if (xml.localName == "scale") {
				var values = this.readContentAsFloats(xml);
				if (flip) {
					var tmp = values[1];
					values[1] = values[2];
					values[2] = -tmp; //swap coords
				}
				_glMatrix.mat4.scale(matrix, matrix, values);
			}
		}

		return matrix;
	},

	readTransform2: function readTransform2(xmlnode, level, flip) {
		//identity
		var matrix = _glMatrix.mat4.create();
		var rotation = _glMatrix.quat.create();
		var tmpmatrix = _glMatrix.mat4.create();
		var tmpq = _glMatrix.quat.create();
		var translate = vec3.create();
		var scale = vec3.fromValues(1, 1, 1);

		var flip_fix = false;

		//search for the matrix
		for (var i = 0; i < xmlnode.childNodes.length; i++) {
			var xml = xmlnode.childNodes.item(i);

			if (xml.localName == "matrix") {
				var matrix = this.readContentAsFloats(xml);
				//console.log("Nodename: " + xmlnode.getAttribute("id"));
				//console.log(matrix);
				this.transformMatrix(matrix, level == 0);
				//console.log(matrix);
				return matrix;
			}

			if (xml.localName == "translate") {
				var values = this.readContentAsFloats(xml);
				translate.set(values);
				continue;
			}

			//rotate
			if (xml.localName == "rotate") {
				var values = this.readContentAsFloats(xml);
				if (values.length == 4) //x,y,z, angle
					{
						var id = xml.getAttribute("sid");
						if (id == "jointOrientX") {
							values[3] += 90;
							flip_fix = true;
						}
						//rotateX & rotateY & rotateZ done below

						if (flip) {
							var tmp = values[1];
							values[1] = values[2];
							values[2] = -tmp; //swap coords
						}

						if (values[3] != 0.0) {
							_glMatrix.quat.setAxisAngle(tmpq, values.subarray(0, 3), values[3] * DEG2RAD);
							_glMatrix.quat.multiply(rotation, rotation, tmpq);
						}
					}
				continue;
			}

			//scale
			if (xml.localName == "scale") {
				var values = this.readContentAsFloats(xml);
				if (flip) {
					var tmp = values[1];
					values[1] = values[2];
					values[2] = -tmp; //swap coords
				}
				scale.set(values);
			}
		}

		if (flip && level > 0) {
			var tmp = translate[1];
			translate[1] = translate[2];
			translate[2] = -tmp; //swap coords
		}
		_glMatrix.mat4.translate(matrix, matrix, translate);

		_glMatrix.mat4.fromQuat(tmpmatrix, rotation);
		//mat4.rotateX(tmpmatrix, tmpmatrix, Math.PI * 0.5);
		_glMatrix.mat4.multiply(matrix, matrix, tmpmatrix);
		_glMatrix.mat4.scale(matrix, matrix, scale);

		return matrix;
	},

	//for help read this: https://www.khronos.org/collada/wiki/Using_accessors
	readGeometry: function readGeometry(id, flip, scene) {
		//already read, could happend if several controllers point to the same mesh
		if (this._geometries_found[id] !== undefined) return this._geometries_found[id];

		//var xmlgeometry = this._xmlroot.querySelector("geometry" + id);
		var xmlgeometry = this._xmlroot.getElementById(id.substr(1));
		if (!xmlgeometry) {
			console.warn("readGeometry: geometry not found: " + id);
			this._geometries_found[id] = null;
			return null;
		}

		//if the geometry has morph targets then instead of storing it in a geometry, it is in a controller
		if (xmlgeometry.localName == "controller") {
			var geometry = this.readController(xmlgeometry, flip, scene);
			this._geometries_found[id] = geometry;
			return geometry;
		}

		if (xmlgeometry.localName != "geometry") {
			console.warn("readGeometry: tag should be geometry, instead it was found: " + xmlgeometry.localName);
			this._geometries_found[id] = null;
			return null;
		}

		var xmlmesh = xmlgeometry.querySelector("mesh");
		if (!xmlmesh) {
			console.warn("readGeometry: mesh not found in geometry: " + id);
			this._geometries_found[id] = null;
			return null;
		}

		//get data sources
		var sources = {};
		var xmlsources = xmlmesh.querySelectorAll("source");
		for (var i = 0; i < xmlsources.length; i++) {
			var xmlsource = xmlsources.item(i);
			if (!xmlsource.querySelector) continue;
			var float_array = xmlsource.querySelector("float_array");
			if (!float_array) continue;
			var floats = this.readContentAsFloats(float_array);

			var xmlaccessor = xmlsource.querySelector("accessor");
			var stride = parseInt(xmlaccessor.getAttribute("stride"));

			sources[xmlsource.getAttribute("id")] = { stride: stride, data: floats };
		}

		//get streams
		var xmlvertices = xmlmesh.querySelector("vertices input");
		var vertices_source = sources[xmlvertices.getAttribute("source").substr(1)];
		sources[xmlmesh.querySelector("vertices").getAttribute("id")] = vertices_source;

		var mesh = null;
		var xmlpolygons = xmlmesh.querySelector("polygons");
		if (xmlpolygons) mesh = this.readTriangles(xmlpolygons, sources);

		if (!mesh) {
			var xmltriangles = xmlmesh.querySelectorAll("triangles");
			if (xmltriangles && xmltriangles.length) mesh = this.readTriangles(xmltriangles, sources);
		}

		if (!mesh) {
			//polylist = true;
			//var vcount = null;
			//var xmlvcount = xmlpolygons.querySelector("vcount");
			//var vcount = this.readContentAsUInt32( xmlvcount );
			var xmlpolylist = xmlmesh.querySelector("polylist");
			if (xmlpolylist) mesh = this.readPolylist(xmlpolylist, sources);
		}

		if (!mesh) {
			var xmllinestrip = xmlmesh.querySelector("linestrips");
			if (xmllinestrip) mesh = this.readLineStrip(sources, xmllinestrip);
		}

		if (!mesh) {
			console.log("no polygons or triangles in mesh: " + id);
			this._geometries_found[id] = null;
			return null;
		}

		//swap coords (X,Y,Z) -> (X,Z,-Y)
		if (flip && !this.no_flip) {
			var tmp = 0;
			var array = mesh.vertices;
			for (var i = 0, l = array.length; i < l; i += 3) {
				tmp = array[i + 1];
				array[i + 1] = array[i + 2];
				array[i + 2] = -tmp;
			}

			array = mesh.normals;
			for (var i = 0, l = array.length; i < l; i += 3) {
				tmp = array[i + 1];
				array[i + 1] = array[i + 2];
				array[i + 2] = -tmp;
			}
		}

		//transferables for worker
		if (isWorker && this.use_transferables) {
			for (var i in mesh) {
				var data = mesh[i];
				if (data && data.buffer && data.length > 100) {
					this._transferables.push(data.buffer);
				}
			}
		}

		//extra info
		mesh.filename = id;
		mesh.object_type = "Mesh";

		this._geometries_found[id] = mesh;
		return mesh;
	},

	readTriangles: function readTriangles(xmltriangles, sources) {
		var use_indices = false;

		var groups = [];
		var buffers = [];
		var last_index = 0;
		var facemap = {};
		var vertex_remap = []; //maps DAE vertex index to Mesh vertex index (because when meshes are triangulated indices are changed
		var indicesArray = [];
		var last_start = 0;
		var group_name = "";
		var material_name = "";

		//for every triangles set (warning, some times they are repeated...)
		for (var tris = 0; tris < xmltriangles.length; tris++) {
			var xml_shape_root = xmltriangles.item(tris);
			var triangles = xml_shape_root.localName == "triangles";

			material_name = xml_shape_root.getAttribute("material");

			//for each buffer (input) build the structure info
			if (tris == 0) buffers = this.readShapeInputs(xml_shape_root, sources);

			//assuming buffers are ordered by offset

			//iterate data
			var xmlps = xml_shape_root.querySelectorAll("p");
			var num_data_vertex = buffers.length; //one value per input buffer

			//for every polygon (could be one with all the indices, could be several, depends on the program)
			for (var i = 0; i < xmlps.length; i++) {
				var xmlp = xmlps.item(i);
				if (!xmlp || !xmlp.textContent) break;

				var data = xmlp.textContent.trim().split(" ");

				//used for triangulate polys
				var first_index = -1;
				var current_index = -1;
				var prev_index = -1;

				//discomment to force 16bits indices
				//if(use_indices && last_index >= 256*256)
				//	break;

				var num_values_per_vertex = 1;
				for (var b in buffers) {
					num_values_per_vertex = Math.max(num_values_per_vertex, buffers[b][4] + 1);
				} //for every pack of indices in the polygon (vertex, normal, uv, ... )
				var current_data_pos = 0;
				for (var k = 0, l = data.length; k < l; k += num_values_per_vertex) {
					var vertex_id = data.slice(k, k + num_values_per_vertex).join(" "); //generate unique id

					prev_index = current_index;
					if (facemap.hasOwnProperty(vertex_id)) //add to arrays, keep the index
						current_index = facemap[vertex_id];else {
						//for every data buffer associated to this vertex
						for (var j = 0; j < buffers.length; ++j) {
							var buffer = buffers[j];
							var array = buffer[1]; //array where we accumulate the final data as we extract if from sources
							var source = buffer[3]; //where to read the data from

							//compute the index inside the data source array
							//var index = parseInt(data[k + j]);
							var index = parseInt(data[k + buffer[4]]);
							//current_data_pos += buffer[4];

							//remember this index in case we need to remap
							if (j == 0) vertex_remap[array.length / buffer[2]] = index; //not sure if buffer[2], it should be number of floats per vertex (usually 3)
							//vertex_remap[ array.length / num_data_vertex ] = index;

							//compute the position inside the source buffer where the final data is located
							index *= buffer[2]; //this works in most DAEs (not all)
							//index = index * buffer[2] + buffer[4]; //stride(2) offset(4)
							//index += buffer[4]; //stride(2) offset(4)
							//extract every value of this element and store it in its final array (every x,y,z, etc)
							for (var x = 0; x < buffer[2]; ++x) {
								if (source[index + x] === undefined) throw "UNDEFINED!"; //DEBUG
								array.push(source[index + x]);
							}
						}

						current_index = last_index;
						last_index += 1;
						facemap[vertex_id] = current_index;
					}

					if (!triangles) //the xml element is not triangles? then split polygons in triangles
						{
							if (k == 0) first_index = current_index;
							//if(k > 2 * num_data_vertex) //not sure if use this or the next line, the next one works in some DAEs but not sure if it works in all
							if (k > 2) //triangulate polygons: ensure this works
								{
									indicesArray.push(first_index);
									indicesArray.push(prev_index);
								}
						}

					indicesArray.push(current_index);
				} //per vertex
			} //per polygon

			var group = {
				name: group_name || "group" + tris,
				start: last_start,
				length: indicesArray.length - last_start,
				material: material_name || ""
			};
			last_start = indicesArray.length;
			groups.push(group);
		} //per triangles group

		var mesh = {
			vertices: new Float32Array(buffers[0][1]),
			info: { groups: groups },
			_remap: new Uint32Array(vertex_remap)
		};

		this.transformMeshInfo(mesh, buffers, indicesArray);

		return mesh;
	},

	readPolylist: function readPolylist(xml_shape_root, sources) {
		var use_indices = false;

		var groups = [];
		var buffers = [];
		var last_index = 0;
		var facemap = {};
		var vertex_remap = [];
		var indicesArray = [];
		var last_start = 0;
		var group_name = "";
		var material_name = "";

		material_name = xml_shape_root.getAttribute("material");
		buffers = this.readShapeInputs(xml_shape_root, sources);

		var xmlvcount = xml_shape_root.querySelector("vcount");
		var vcount = this.readContentAsUInt32(xmlvcount);

		var xmlp = xml_shape_root.querySelector("p");
		var data = this.readContentAsUInt32(xmlp);

		var num_data_vertex = buffers.length;

		var pos = 0;
		for (var i = 0, l = vcount.length; i < l; ++i) {
			var num_vertices = vcount[i];

			var first_index = -1;
			var current_index = -1;
			var prev_index = -1;

			//iterate vertices of this polygon
			for (var k = 0; k < num_vertices; ++k) {
				var vertex_id = data.subarray(pos, pos + num_data_vertex).join(" ");

				prev_index = current_index;
				if (facemap.hasOwnProperty(vertex_id)) //add to arrays, keep the index
					current_index = facemap[vertex_id];else {
					for (var j = 0; j < buffers.length; ++j) {
						var buffer = buffers[j];
						var index = parseInt(data[pos + j]); //p
						var array = buffer[1]; //array with all the data
						var source = buffer[3]; //where to read the data from
						if (j == 0) vertex_remap[array.length / num_data_vertex] = index;
						index *= buffer[2]; //stride
						for (var x = 0; x < buffer[2]; ++x) {
							array.push(source[index + x]);
						}
					}

					current_index = last_index;
					last_index += 1;
					facemap[vertex_id] = current_index;
				}

				if (num_vertices > 3) //split polygons then
					{
						if (k == 0) first_index = current_index;
						//if(k > 2 * num_data_vertex) //not sure if use this or the next line, the next one works in some DAEs but not sure if it works in all
						if (k > 2) //triangulate polygons: tested, this works
							{
								indicesArray.push(first_index);
								indicesArray.push(prev_index);
							}
					}

				indicesArray.push(current_index);
				pos += num_data_vertex;
			} //per vertex
		} //per polygon

		var mesh = {
			vertices: new Float32Array(buffers[0][1]),
			info: {},
			_remap: new Uint32Array(vertex_remap)
		};

		this.transformMeshInfo(mesh, buffers, indicesArray);

		return mesh;
	},

	readShapeInputs: function readShapeInputs(xml_shape_root, sources) {
		var buffers = [];

		var xmlinputs = xml_shape_root.querySelectorAll("input");
		for (var i = 0; i < xmlinputs.length; i++) {
			var xmlinput = xmlinputs.item(i);
			if (!xmlinput.getAttribute) continue;
			var semantic = xmlinput.getAttribute("semantic").toUpperCase();
			var stream_source = sources[xmlinput.getAttribute("source").substr(1)];
			var offset = parseInt(xmlinput.getAttribute("offset"));
			var data_set = 0;
			if (xmlinput.getAttribute("set")) data_set = parseInt(xmlinput.getAttribute("set"));
			buffers.push([semantic, [], stream_source.stride, stream_source.data, offset, data_set]);
		}

		return buffers;
	},

	transformMeshInfo: function transformMeshInfo(mesh, buffers, indicesArray) {
		//rename buffers (DAE has other names)
		var translator = {
			"normal": "normals",
			"texcoord": "coords"
		};
		for (var i = 1; i < buffers.length; ++i) {
			var name = buffers[i][0].toLowerCase();
			var data = buffers[i][1];
			if (!data.length) continue;

			if (translator[name]) name = translator[name];
			if (mesh[name]) name = name + buffers[i][5];
			mesh[name] = new Float32Array(data); //are they always float32? I think so
		}

		if (indicesArray && indicesArray.length) {
			if (mesh.vertices.length > 256 * 256) mesh.triangles = new Uint32Array(indicesArray);else mesh.triangles = new Uint16Array(indicesArray);
		}

		return mesh;
	},

	readLineStrip: function readLineStrip(sources, xmllinestrip) {
		var use_indices = false;

		var buffers = [];
		var last_index = 0;
		var facemap = {};
		var vertex_remap = [];
		var indicesArray = [];
		var last_start = 0;
		var group_name = "";
		var material_name = "";

		var tris = 0; //used in case there are several strips

		//for each buffer (input) build the structure info
		var xmlinputs = xmllinestrip.querySelectorAll("input");
		if (tris == 0) //first iteration, create buffers
			for (var i = 0; i < xmlinputs.length; i++) {
				var xmlinput = xmlinputs.item(i);
				if (!xmlinput.getAttribute) continue;
				var semantic = xmlinput.getAttribute("semantic").toUpperCase();
				var stream_source = sources[xmlinput.getAttribute("source").substr(1)];
				var offset = parseInt(xmlinput.getAttribute("offset"));
				var data_set = 0;
				if (xmlinput.getAttribute("set")) data_set = parseInt(xmlinput.getAttribute("set"));

				buffers.push([semantic, [], stream_source.stride, stream_source.data, offset, data_set]);
			}
		//assuming buffers are ordered by offset

		//iterate data
		var xmlps = xmllinestrip.querySelectorAll("p");
		var num_data_vertex = buffers.length; //one value per input buffer

		//for every polygon (could be one with all the indices, could be several, depends on the program)
		for (var i = 0; i < xmlps.length; i++) {
			var xmlp = xmlps.item(i);
			if (!xmlp || !xmlp.textContent) break;

			var data = xmlp.textContent.trim().split(" ");

			//used for triangulate polys
			var first_index = -1;
			var current_index = -1;
			var prev_index = -1;

			//if(use_indices && last_index >= 256*256)
			//	break;

			//for every pack of indices in the polygon (vertex, normal, uv, ... )
			for (var k = 0, l = data.length; k < l; k += num_data_vertex) {
				var vertex_id = data.slice(k, k + num_data_vertex).join(" "); //generate unique id

				prev_index = current_index;
				if (facemap.hasOwnProperty(vertex_id)) //add to arrays, keep the index
					current_index = facemap[vertex_id];else {
					for (var j = 0; j < buffers.length; ++j) {
						var buffer = buffers[j];
						var index = parseInt(data[k + j]);
						var array = buffer[1]; //array with all the data
						var source = buffer[3]; //where to read the data from
						if (j == 0) vertex_remap[array.length / num_data_vertex] = index;
						index *= buffer[2]; //stride
						for (var x = 0; x < buffer[2]; ++x) {
							array.push(source[index + x]);
						}
					}

					current_index = last_index;
					last_index += 1;
					facemap[vertex_id] = current_index;
				}

				indicesArray.push(current_index);
			} //per vertex
		} //per polygon

		var mesh = {
			primitive: "line_strip",
			vertices: new Float32Array(buffers[0][1]),
			info: {}
		};

		return this.transformMeshInfo(mesh, buffers, indicesArray);
	},

	//like querySelector but allows spaces in names because COLLADA allows space in names
	findXMLNodeById: function findXMLNodeById(root, nodename, id) {
		//precomputed
		if (this._xmlroot._nodes_by_id) {
			var n = this._xmlroot._nodes_by_id[id];
			if (n && n.localName == nodename) return n;
		} else //for the native parser
			{
				var n = this._xmlroot.getElementById(id);
				if (n) return n;
			}

		//recursive: slow
		var childs = root.childNodes;
		for (var i = 0; i < childs.length; ++i) {
			var xmlnode = childs.item(i);
			if (xmlnode.nodeType != 1) //no tag
				continue;
			if (xmlnode.localName != nodename) continue;
			var node_id = xmlnode.getAttribute("id");
			if (node_id == id) return xmlnode;
		}
		return null;
	},

	readImages: function readImages(root) {
		var xmlimages = root.querySelector("library_images");
		if (!xmlimages) return null;

		var images = {};

		var xmlimages_childs = xmlimages.childNodes;
		for (var i = 0; i < xmlimages_childs.length; ++i) {
			var xmlimage = xmlimages_childs.item(i);
			if (xmlimage.nodeType != 1) //no tag
				continue;

			var xmlinitfrom = xmlimage.querySelector("init_from");
			if (!xmlinitfrom) continue;
			if (xmlinitfrom.textContent) {
				var filename = this.getFilename(xmlinitfrom.textContent);
				var id = xmlimage.getAttribute("id");
				images[id] = { filename: filename, map: id, name: xmlimage.getAttribute("name"), path: xmlinitfrom.textContent };
			}
		}

		return images;
	},

	readAnimations: function readAnimations(root, scene) {
		var xmlanimations = root.querySelector("library_animations");
		if (!xmlanimations) return null;

		var xmlanimation_childs = xmlanimations.childNodes;

		var animations = {
			object_type: "Animation",
			takes: {}
		};

		var default_take = { tracks: [] };
		var tracks = default_take.tracks;

		for (var i = 0; i < xmlanimation_childs.length; ++i) {
			var xmlanimation = xmlanimation_childs.item(i);
			if (xmlanimation.nodeType != 1 || xmlanimation.localName != "animation") //no tag
				continue;

			var anim_id = xmlanimation.getAttribute("id");
			if (!anim_id) //nested animation (DAE 1.5)
				{
					var xmlanimation2_childs = xmlanimation.querySelectorAll("animation");
					if (xmlanimation2_childs.length) {
						for (var j = 0; j < xmlanimation2_childs.length; ++j) {
							var xmlanimation2 = xmlanimation2_childs.item(j);
							this.readAnimation(xmlanimation2, tracks);
						}
					} else //source tracks?
						this.readAnimation(xmlanimation, tracks);
				} else //no nested (DAE 1.4)
				this.readAnimation(xmlanimation, tracks);
		}

		if (!tracks.length) return null; //empty animation

		//compute animation duration
		var max_time = 0;
		for (var i = 0; i < tracks.length; ++i) {
			if (max_time < tracks[i].duration) max_time = tracks[i].duration;
		}default_take.name = "default";
		default_take.duration = max_time;
		animations.takes[default_take.name] = default_take;
		return animations;
	},

	//animation xml
	readAnimation: function readAnimation(xmlanimation, result) {
		if (xmlanimation.localName != "animation") return null;

		//this could be missing when there are lots of anims packed in one <animation>
		var anim_id = xmlanimation.getAttribute("id");

		//channels are like animated properties
		var xmlchannel_list = xmlanimation.querySelectorAll("channel");
		if (!xmlchannel_list.length) return null;

		var tracks = result || [];

		for (var i = 0; i < xmlchannel_list.length; ++i) {
			var anim = this.readChannel(xmlchannel_list.item(i), xmlanimation);
			if (anim) tracks.push(anim);
		}

		return tracks;
	},

	readChannel: function readChannel(xmlchannel, xmlanimation) {
		if (xmlchannel.localName != "channel" || xmlanimation.localName != "animation") return null;

		var source = xmlchannel.getAttribute("source");
		var target = xmlchannel.getAttribute("target");

		//sampler, is in charge of the interpolation
		//var xmlsampler = xmlanimation.querySelector("sampler" + source);
		var xmlsampler = this.findXMLNodeById(xmlanimation, "sampler", source.substr(1));
		if (!xmlsampler) {
			console.error("Error DAE: Sampler not found in " + source);
			return null;
		}

		var inputs = {};
		var params = {};
		var sources = {};
		var xmlinputs = xmlsampler.querySelectorAll("input");

		var time_data = null;

		//iterate inputs: collada separates the keyframe info in independent streams, like time, interpolation method, value )
		for (var j = 0; j < xmlinputs.length; j++) {
			var xmlinput = xmlinputs.item(j);
			var source_name = xmlinput.getAttribute("source");

			//there are three 
			var semantic = xmlinput.getAttribute("semantic");

			//Search for source
			var xmlsource = this.findXMLNodeById(xmlanimation, "source", source_name.substr(1));
			if (!xmlsource) continue;

			var xmlparam = xmlsource.querySelector("param");
			if (!xmlparam) continue;

			var type = xmlparam.getAttribute("type");
			inputs[semantic] = { source: source_name, type: type };

			var data_array = null;

			if (type == "float" || type == "float4x4") {
				var xmlfloatarray = xmlsource.querySelector("float_array");
				var floats = this.readContentAsFloats(xmlfloatarray);
				sources[source_name] = floats;
				data_array = floats;
			} else //only floats and matrices are supported in animation
				continue;

			var param_name = xmlparam.getAttribute("name");
			if (param_name == "TIME") time_data = data_array;
			if (semantic == "OUTPUT") param_name = semantic;
			if (param_name) params[param_name] = type;else console.warn("Collada: <param> without name attribute in <animation>");
		}

		if (!time_data) {
			console.error("Error DAE: no TIME info found in <channel>: " + xmlchannel.getAttribute("source"));
			return null;
		}

		//construct animation
		var path = target.split("/");

		var anim = {};
		var nodename = path[0]; //safeString ?
		var node = this._nodes_by_id[nodename];
		var locator = node.id + "/" + path[1];
		//anim.nodename = this.safeString( path[0] ); //where it goes
		anim.name = path[1];
		anim.property = locator;
		var type = "number";
		var element_size = 1;
		var param_type = params["OUTPUT"];
		switch (param_type) {
			case "float":
				element_size = 1;break;
			case "float3x3":
				element_size = 9;type = "mat3";break;
			case "float4x4":
				element_size = 16;type = "mat4";break;
			default:
				break;
		}

		anim.type = type;
		anim.value_size = element_size;
		anim.duration = time_data[time_data.length - 1]; //last sample

		var value_data = sources[inputs["OUTPUT"].source];
		if (!value_data) return null;

		//Pack data ****************
		var num_samples = time_data.length;
		var sample_size = element_size + 1;
		var anim_data = new Float32Array(num_samples * sample_size);
		//for every sample
		for (var j = 0; j < time_data.length; ++j) {
			anim_data[j * sample_size] = time_data[j]; //set time
			var value = value_data.subarray(j * element_size, (j + 1) * element_size);
			if (param_type == "float4x4") {
				this.transformMatrix(value, node ? node._depth == 0 : 0);
				//mat4.transpose(value, value);
			}
			anim_data.set(value, j * sample_size + 1); //set data
		}

		if (isWorker && this.use_transferables) {
			var data = anim_data;
			if (data && data.buffer && data.length > 100) this._transferables.push(data.buffer);
		}

		anim.data = anim_data;
		return anim;
	},

	findNode: function findNode(root, id) {
		if (root.id == id) return root;
		if (root.children) for (var i in root.children) {
			var ret = this.findNode(root.children[i], id);
			if (ret) return ret;
		}
		return null;
	},

	//reads controllers and stores them in 
	readLibraryControllers: function readLibraryControllers(scene) {
		var xmllibrarycontrollers = this._xmlroot.querySelector("library_controllers");
		if (!xmllibrarycontrollers) return null;

		var xmllibrarycontrollers_childs = xmllibrarycontrollers.childNodes;

		for (var i = 0; i < xmllibrarycontrollers_childs.length; ++i) {
			var xmlcontroller = xmllibrarycontrollers_childs.item(i);
			if (xmlcontroller.nodeType != 1 || xmlcontroller.localName != "controller") //no tag
				continue;
			var id = xmlcontroller.getAttribute("id");
			//we have already processed this controller
			if (this._controllers_found[id]) continue;

			//read it (we wont use the returns, we will get it from this._controllers_found
			this.readController(xmlcontroller, null, scene);
		}
	},

	//used for skinning and morphing
	readController: function readController(xmlcontroller, flip, scene) {
		if (!xmlcontroller.localName == "controller") {
			console.warn("readController: not a controller: " + xmlcontroller.localName);
			return null;
		}

		var id = xmlcontroller.getAttribute("id");
		//use cached
		if (this._controllers_found[id]) return this._controllers_found[id];

		//AGUILA
		//TODO: does this work?
		// if (this._controllers_found[ id ])
		// 	return this._controllers_found[ id ];

		var use_indices = false;
		var mesh = null;
		var xmlskin = xmlcontroller.querySelector("skin");
		if (xmlskin) {
			mesh = this.readSkinController(xmlskin, flip, scene);
		}

		var xmlmorph = xmlcontroller.querySelector("morph");
		if (xmlmorph) mesh = this.readMorphController(xmlmorph, flip, scene, mesh);

		//cache and return
		if (this._controllers_found[id]) {
			id += "_1blah"; //??? this doesnt do anything
		} else this._controllers_found[id] = mesh;

		return mesh;
	},

	//read this to more info about DAE and skinning https://collada.org/mediawiki/index.php/Skinning
	readSkinController: function readSkinController(xmlskin, flip, scene) {
		//base geometry
		var id_geometry = xmlskin.getAttribute("source");

		var mesh = this.readGeometry(id_geometry, flip, scene);
		if (!mesh) return null;

		var sources = this.readSources(xmlskin, flip);
		if (!sources) return null;

		//matrix
		var bind_matrix = null;
		var xmlbindmatrix = xmlskin.querySelector("bind_shape_matrix");
		if (xmlbindmatrix) {
			bind_matrix = this.readContentAsFloats(xmlbindmatrix);
			this.transformMatrix(bind_matrix, true, true);
		} else bind_matrix = _glMatrix.mat4.create(); //identity

		//joints
		var joints = [];
		var xmljoints = xmlskin.querySelector("joints");
		if (xmljoints) {
			var joints_source = null; //which bones
			var inv_bind_source = null; //bind matrices
			var xmlinputs = xmljoints.querySelectorAll("input");
			for (var i = 0; i < xmlinputs.length; i++) {
				var xmlinput = xmlinputs[i];
				var sem = xmlinput.getAttribute("semantic").toUpperCase();
				var src = xmlinput.getAttribute("source");
				var source = sources[src.substr(1)];
				if (sem == "JOINT") joints_source = source;else if (sem == "INV_BIND_MATRIX") inv_bind_source = source;
			}

			//save bone names and inv matrix
			if (!inv_bind_source || !joints_source) {
				console.error("Error DAE: no joints or inv_bind sources found");
				return null;
			}

			for (var i in joints_source) {
				//get the inverse of the bind pose
				var inv_mat = inv_bind_source.subarray(i * 16, i * 16 + 16);
				var nodename = joints_source[i];
				var node = this._nodes_by_id[nodename];
				if (!node) {
					console.warn("Node " + nodename + " not found");
					continue;
				}
				this.transformMatrix(inv_mat, node._depth == 0, true);
				joints.push([nodename, inv_mat]);
			}
		}

		//weights
		var xmlvertexweights = xmlskin.querySelector("vertex_weights");
		if (xmlvertexweights) {

			//here we see the order 
			var weights_indexed_array = null;
			var xmlinputs = xmlvertexweights.querySelectorAll("input");
			for (var i = 0; i < xmlinputs.length; i++) {
				if (xmlinputs[i].getAttribute("semantic").toUpperCase() == "WEIGHT") weights_indexed_array = sources[xmlinputs.item(i).getAttribute("source").substr(1)];
			}

			if (!weights_indexed_array) throw "no weights found";

			var xmlvcount = xmlvertexweights.querySelector("vcount");
			var vcount = this.readContentAsUInt32(xmlvcount);

			var xmlv = xmlvertexweights.querySelector("v");
			var v = this.readContentAsUInt32(xmlv);

			var num_vertices = mesh.vertices.length / 3; //3 components per vertex
			var weights_array = new Float32Array(4 * num_vertices); //4 bones per vertex
			var bone_index_array = new Uint8Array(4 * num_vertices); //4 bones per vertex

			var pos = 0;
			var remap = mesh._remap;
			var max_bone = 0; //max bone affected

			for (var i = 0, l = vcount.length; i < l; ++i) {
				var num_bones = vcount[i]; //num bones influencing this vertex

				//find 4 with more influence
				//var v_tuplets = v.subarray(offset, offset + num_bones*2);

				var offset = pos;
				var b = bone_index_array.subarray(i * 4, i * 4 + 4);
				var w = weights_array.subarray(i * 4, i * 4 + 4);

				var sum = 0;
				for (var j = 0; j < num_bones && j < 4; ++j) {
					b[j] = v[offset + j * 2];
					if (b[j] > max_bone) max_bone = b[j];

					w[j] = weights_indexed_array[v[offset + j * 2 + 1]];
					sum += w[j];
				}

				//normalize weights
				if (num_bones > 4 && sum < 1.0) {
					var inv_sum = 1 / sum;
					for (var j = 0; j < 4; ++j) {
						w[j] *= inv_sum;
					}
				}

				pos += num_bones * 2;
			}

			//remap: because vertices order is now changed after parsing the mesh
			var final_weights = new Float32Array(4 * num_vertices); //4 bones per vertex
			var final_bone_indices = new Uint8Array(4 * num_vertices); //4 bones per vertex
			var used_joints = [];

			//for every vertex in the mesh, process bone indices and weights
			for (var i = 0; i < num_vertices; ++i) {
				var p = remap[i] * 4;
				var w = weights_array.subarray(p, p + 4);
				var b = bone_index_array.subarray(p, p + 4);

				//sort by weight so relevant ones goes first
				for (var k = 0; k < 3; ++k) {
					var max_pos = k;
					var max_value = w[k];
					for (var j = k + 1; j < 4; ++j) {
						if (w[j] <= max_value) continue;
						max_pos = j;
						max_value = w[j];
					}
					if (max_pos != k) {
						var tmp = w[k];
						w[k] = w[max_pos];
						w[max_pos] = tmp;
						tmp = b[k];
						b[k] = b[max_pos];
						b[max_pos] = tmp;
					}
				}

				//store
				final_weights.set(w, i * 4);
				final_bone_indices.set(b, i * 4);

				//mark bones used
				if (w[0]) used_joints[b[0]] = true;
				if (w[1]) used_joints[b[1]] = true;
				if (w[2]) used_joints[b[2]] = true;
				if (w[3]) used_joints[b[3]] = true;
			}

			if (max_bone >= joints.length) console.warn("Mesh uses higher bone index than bones found");

			//trim unused bones (collada could give you 100 bones for an object that only uses a fraction of them)
			if (1) {
				var new_bones = [];
				var bones_translation = {};
				for (var i = 0; i < used_joints.length; ++i) {
					if (used_joints[i]) {
						bones_translation[i] = new_bones.length;
						new_bones.push(joints[i]);
					}
				} //in case there are less bones in use...
				if (new_bones.length < joints.length) {
					//remap
					for (var i = 0; i < final_bone_indices.length; i++) {
						final_bone_indices[i] = bones_translation[final_bone_indices[i]];
					}joints = new_bones;
				}
				//console.log("Bones: ", joints.length, " used:", num_used_joints );
			}

			//console.log("Bones: ", joints.length, "Max bone: ", max_bone);

			mesh.weights = final_weights;
			mesh.bone_indices = final_bone_indices;
			mesh.bones = joints;
			mesh.bind_matrix = bind_matrix;

			//delete mesh["_remap"];
		}

		return mesh;
	},

	//NOT TESTED
	readMorphController: function readMorphController(xmlmorph, flip, scene, mesh) {
		var id_geometry = xmlmorph.getAttribute("source");
		var base_mesh = this.readGeometry(id_geometry, flip, scene);
		if (!base_mesh) return null;

		//read sources with blend shapes info (which ones, and the weight)
		var sources = this.readSources(xmlmorph, flip);

		var morphs = [];

		//targets
		var xmltargets = xmlmorph.querySelector("targets");
		if (!xmltargets) return null;

		var xmlinputs = xmltargets.querySelectorAll("input");
		var targets = null;
		var weights = null;

		for (var i = 0; i < xmlinputs.length; i++) {
			var xmlinput = xmlinputs.item(i);
			var semantic = xmlinput.getAttribute("semantic").toUpperCase();
			var data = sources[xmlinput.getAttribute("source").substr(1)];
			if (semantic == "MORPH_TARGET") targets = data;else if (semantic == "MORPH_WEIGHT") weights = data;
		}

		if (!targets || !weights) {
			console.warn("Morph controller without targets or weights. Skipping it.");
			return null;
		}

		//get targets
		for (var i in targets) {
			var id = "#" + targets[i];
			var geometry = this.readGeometry(id, flip, scene);
			scene.meshes[id] = geometry;
			morphs.push({ mesh: id, weight: weights[i] });
		}

		base_mesh.morph_targets = morphs;
		return base_mesh;
	},

	readBindMaterials: function readBindMaterials(xmlbind_material, mesh) {
		var materials = [];

		var xmltechniques = xmlbind_material.querySelectorAll("technique_common");
		for (var i = 0; i < xmltechniques.length; i++) {
			var xmltechnique = xmltechniques.item(i);
			var xmlinstance_materials = xmltechnique.querySelectorAll("instance_material");
			for (var j = 0; j < xmlinstance_materials.length; j++) {
				var xmlinstance_material = xmlinstance_materials.item(j);
				if (xmlinstance_material) materials.push(xmlinstance_material.getAttribute("symbol"));
			}
		}

		return materials;
	},

	readSources: function readSources(xmlnode, flip) {
		//for data sources
		var sources = {};
		var xmlsources = xmlnode.querySelectorAll("source");
		for (var i = 0; i < xmlsources.length; i++) {
			var xmlsource = xmlsources.item(i);
			if (!xmlsource.querySelector) //??
				continue;

			var float_array = xmlsource.querySelector("float_array");
			if (float_array) {
				var floats = this.readContentAsFloats(xmlsource);
				sources[xmlsource.getAttribute("id")] = floats;
				continue;
			}

			var name_array = xmlsource.querySelector("Name_array");
			if (name_array) {
				var names = this.readContentAsStringsArray(name_array);
				if (!names) continue;
				sources[xmlsource.getAttribute("id")] = names;
				continue;
			}

			var ref_array = xmlsource.querySelector("IDREF_array");
			if (ref_array) {
				var names = this.readContentAsStringsArray(ref_array);
				if (!names) continue;
				sources[xmlsource.getAttribute("id")] = names;
				continue;
			}
		}

		return sources;
	},

	readContentAsUInt32: function readContentAsUInt32(xmlnode) {
		if (!xmlnode) return null;
		var text = xmlnode.textContent;
		text = text.replace(/\n/gi, " "); //remove line breaks
		text = text.trim(); //remove empty spaces
		if (text.length == 0) return null;
		var numbers = text.split(" "); //create array
		var floats = new Uint32Array(numbers.length);
		for (var k = 0; k < numbers.length; k++) {
			floats[k] = parseInt(numbers[k]);
		}return floats;
	},

	readContentAsFloats: function readContentAsFloats(xmlnode) {
		if (!xmlnode) return null;
		var text = xmlnode.textContent;
		text = text.replace(/\n/gi, " "); //remove line breaks
		text = text.replace(/\s\s+/gi, " ");
		text = text.replace(/\t/gi, "");
		text = text.trim(); //remove empty spaces
		var numbers = text.split(" "); //create array
		var count = xmlnode.getAttribute("count");
		var length = count ? parseInt(count) : numbers.length;
		var floats = new Float32Array(length);
		for (var k = 0; k < numbers.length; k++) {
			floats[k] = parseFloat(numbers[k]);
		}return floats;
	},

	readContentAsStringsArray: function readContentAsStringsArray(xmlnode) {
		if (!xmlnode) return null;
		var text = xmlnode.textContent;
		text = text.replace(/\n/gi, " "); //remove line breaks
		text = text.replace(/\s\s/gi, " ");
		text = text.trim(); //remove empty spaces
		var words = text.split(" "); //create array
		for (var k = 0; k < words.length; k++) {
			words[k] = words[k].trim();
		}if (xmlnode.getAttribute("count") && parseInt(xmlnode.getAttribute("count")) != words.length) {
			var merged_words = [];
			var name = "";
			for (var i in words) {
				if (!name) name = words[i];else name += " " + words[i];
				if (!this._nodes_by_id[this.safeString(name)]) continue;
				merged_words.push(this.safeString(name));
				name = "";
			}

			var count = parseInt(xmlnode.getAttribute("count"));
			if (merged_words.length == count) return merged_words;

			console.error("Error: bone names have spaces, avoid using spaces in names");
			return null;
		}
		return words;
	},

	max3d_matrix_0: new Float32Array([0, -1, 0, 0, 0, 0, -1, 0, 1, 0, 0, -0, 0, 0, 0, 1]),
	//max3d_matrix_other: new Float32Array([0, -1, 0, 0, 0, 0, -1, 0, 1, 0, 0, -0, 0, 0, 0, 1]),

	transformMatrix: function transformMatrix(matrix, first_level, inverted) {
		_glMatrix.mat4.transpose(matrix, matrix);

		if (this.no_flip) return matrix;

		//WARNING: DO NOT CHANGE THIS FUNCTION, THE SKY WILL FALL
		if (first_level) {

			//flip row two and tree
			var temp = new Float32Array(matrix.subarray(4, 8)); //swap rows
			matrix.set(matrix.subarray(8, 12), 4);
			matrix.set(temp, 8);

			//reverse Z
			temp = matrix.subarray(8, 12);
			vec4.scale(temp, temp, -1);
		} else {
			var M = _glMatrix.mat4.create();
			var m = matrix;

			//if(inverted) mat4.invert(m,m);

			/* non trasposed
   M.set([m[0],m[8],-m[4]], 0);
   M.set([m[2],m[10],-m[6]], 4);
   M.set([-m[1],-m[9],m[5]], 8);
   M.set([m[3],m[11],-m[7]], 12);
   */

			M.set([m[0], m[2], -m[1]], 0);
			M.set([m[8], m[10], -m[9]], 4);
			M.set([-m[4], -m[6], m[5]], 8);
			M.set([m[12], m[14], -m[13]], 12);

			m.set(M);

			//if(inverted) mat4.invert(m,m);
		}
		return matrix;
	}
};

exports.default = Collada;
module.exports = exports['default'];
//# sourceMappingURL=Collada.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _xhr = __webpack_require__(73);

var _xhr2 = _interopRequireDefault(_xhr);

var _Mesh = __webpack_require__(4);

var _Mesh2 = _interopRequireDefault(_Mesh);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// GltfLoader.js

var ARRAY_CTOR_MAP = {
	5120: Int8Array,
	5121: Uint8Array,
	5122: Int16Array,
	5123: Uint16Array,
	5125: Uint32Array,
	5126: Float32Array
};

var SIZE_MAP = {
	SCALAR: 1,
	VEC2: 2,
	VEC3: 3,
	VEC4: 4,
	MAT2: 4,
	MAT3: 9,
	MAT4: 16
};

var semanticAttributeMap = {
	NORMAL: 'aNormal',
	POSITION: 'aVertexPosition',
	// 'TANGENT': 'aTangent',
	TEXCOORD_0: 'aTextureCoord',
	TEXCOORD_1: 'aTextureCoord1',
	WEIGHTS_0: 'aWeight',
	JOINTS_0: 'aJoint',
	COLOR: 'aColor'
};

var base = void 0;

var load = function load(mSource) {
	return new Promise(function (resolve, reject) {
		if (typeof mSource === 'string') {
			base = mSource.substring(0, mSource.lastIndexOf('/') + 1);
		} else {
			base = '';
		}

		_loadGltf(mSource).then(_loadBin).then(_getBufferViewData).then(_loadTextures).then(_parseMesh).then(_parseNodes).then(function (gltfInfo) {
			resolve(gltfInfo);
		}).catch(function (e) {
			console.log('Error:', e);
		});
	});
};

var _parseNodes = function _parseNodes(gltf) {
	return new Promise(function (resolve, reject) {
		var nodes = gltf.nodes;


		nodes.forEach(function (nodeInfo, i) {
			if (nodeInfo.camera != null && undefined.includeCamera) {
				// setup camera
			} else if (nodeInfo.mesh != null) {
				// console.log(i, 'Mesh index :', nodeInfo.mesh);
			}
		});
		resolve(gltf);
	});
};

var _parseMesh = function _parseMesh(gltf) {
	return new Promise(function (resolve, reject) {
		var meshes = gltf.meshes;

		gltf.geometries = [];
		gltf.output = {
			meshes: [],
			scene: {}
		};

		meshes.forEach(function (mesh, i) {
			var primitives = mesh.primitives;

			var geometry = {};

			primitives.forEach(function (primitiveInfo, i) {
				var semantics = Object.keys(primitiveInfo.attributes);

				semantics.forEach(function (semantic, i) {
					var accessorIdx = primitiveInfo.attributes[semantic];
					var attributeInfo = gltf.accessors[accessorIdx];
					var attributeName = semanticAttributeMap[semantic];
					if (!attributeName) {
						return;
					}
					var size = SIZE_MAP[attributeInfo.type];
					var attributeArray = _getAccessorData(gltf, accessorIdx);
					if (attributeArray instanceof Uint32Array) {
						attributeArray = new Float32Array(attributeArray);
					}

					geometry[attributeName] = {
						value: attributeArray,
						size: size
					};
					// console.log('attribute', attributeName, geometry[attributeName]);
				});

				//	parse index
				if (primitiveInfo.indices != null) {
					var attributeArray = _getAccessorData(gltf, primitiveInfo.indices, true);
					geometry.indices = {
						value: attributeArray,
						size: 1
					};
				}

				var m = new _Mesh2.default();

				for (var s in geometry) {
					var data = geometry[s];
					if (s !== 'indices') {
						// console.log(s, data);
						m.bufferFlattenData(data.value, s, data.size);
					} else {
						// console.log(data.value);
						m.bufferIndex(data.value);
					}
				}
				gltf.output.meshes.push(m);
				gltf.geometries.push(geometry);
			});
		});

		resolve(gltf);
	});
};

var _getBufferViewData = function _getBufferViewData(gltfInfo) {
	return new Promise(function (resolve, reject) {
		var bufferViews = gltfInfo.bufferViews,
		    buffers = gltfInfo.buffers;


		bufferViews.forEach(function (bufferViewInfo, i) {
			var buffer = buffers[bufferViewInfo.buffer].data;
			bufferViewInfo.data = buffer.slice(bufferViewInfo.byteOffset || 0, (bufferViewInfo.byteOffset || 0) + (bufferViewInfo.byteLength || 0));
		});
		resolve(gltfInfo);
	});
};

var _loadGltf = function _loadGltf(mSource) {
	return new Promise(function (resolve, reject) {
		if (typeof mSource !== 'string') {
			resolve(mSource);
		} else {
			(0, _xhr2.default)(mSource).then(function (o) {
				resolve(JSON.parse(o));
			}, function (e) {
				reject(e);
			});
		}
	});
};

var _loadBin = function _loadBin(gltfInfo) {
	return new Promise(function (resolve, reject) {

		if (gltfInfo.buffers) {
			var count = gltfInfo.buffers.length;

			gltfInfo.buffers.forEach(function (buffer) {

				var urlBin = '' + base + gltfInfo.buffers[0].uri;
				(0, _xhr2.default)(urlBin, true).then(function (o) {
					buffer.data = o;

					count--;
					if (count === 0) {
						resolve(gltfInfo);
					}
				}, function (e) {
					reject(e);
				});
			});
		} else {
			resolve(gltfInfo);
		}
	});
};

var _loadTextures = function _loadTextures(gltfInfo) {
	return new Promise(function (resolve, reject) {
		console.log('TODO : Loading textures');
		resolve(gltfInfo);
	});
};

var parse = function parse(mGltfInfo, mBin) {
	return new Promise(function (resolve, reject) {
		resolve(mSource);
	});
};

var _getAccessorData = function _getAccessorData(gltf, accessorIdx) {
	var isIndices = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	var accessorInfo = gltf.accessors[accessorIdx];
	var buffer = gltf.bufferViews[accessorInfo.bufferView].data;
	var byteOffset = accessorInfo.byteOffset || 0;
	var ArrayCtor = ARRAY_CTOR_MAP[accessorInfo.componentType] || Float32Array;
	var size = SIZE_MAP[accessorInfo.type];
	if (size == null && isIndices) {
		size = 1;
	}
	var arr = new ArrayCtor(buffer, byteOffset, size * accessorInfo.count);
	var quantizeExtension = accessorInfo.extensions && accessorInfo.extensions['WEB3D_quantized_attributes'];
	if (quantizeExtension) {
		var decodedArr = new Float32Array(size * accessorInfo.count);
		var decodeMatrix = quantizeExtension.decodeMatrix;
		var decodeOffset = new Array(size);
		var decodeScale = new Array(size);
		for (var k = 0; k < size; k++) {
			decodeOffset[k] = decodeMatrix[size * (size + 1) + k];
			decodeScale[k] = decodeMatrix[k * (size + 1) + k];
		}
		for (var i = 0; i < accessorInfo.count; i++) {
			for (var _k = 0; _k < size; _k++) {
				decodedArr[i * size + _k] = arr[i * size + _k] * decodeScale[_k] + decodeOffset[_k];
			}
		}

		arr = decodedArr;
	}

	// console.log({buffer, byteOffset, ArrayCtor, size, arr});

	return arr;
};

exports.default = {
	load: load,
	parse: parse
};

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
// xhr.js

var load = function load(mPath, isArrayBuffer) {
	return new Promise(function (resolve, reject) {
		var req = new XMLHttpRequest();
		req.addEventListener('load', function (e) {
			resolve(req.response);
		});

		req.addEventListener('error', function (e) {
			reject(e);
		});

		if (isArrayBuffer) {
			req.responseType = 'arraybuffer';
		}

		req.open('GET', mPath);
		req.send();
	});
};

exports.default = load;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // EffectComposer.js

var _Pass = __webpack_require__(9);

var _Pass2 = _interopRequireDefault(_Pass);

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _FrameBuffer = __webpack_require__(12);

var _FrameBuffer2 = _interopRequireDefault(_FrameBuffer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EffectComposer = function () {
	function EffectComposer(mWidth, mHeight) {
		var mParmas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

		_classCallCheck(this, EffectComposer);

		this._width = mWidth || _GLTool2.default.width;
		this._height = mHeight || _GLTool2.default.height;

		this._params = {};
		this.setSize(mWidth, mHeight);
		this._mesh = _Geom2.default.bigTriangle();
		this._passes = [];
		this._returnTexture;
	}

	_createClass(EffectComposer, [{
		key: 'addPass',
		value: function addPass(pass) {
			if (pass.passes) {
				this.addPass(pass.passes);
				return;
			}

			if (pass.length) {
				for (var i = 0; i < pass.length; i++) {
					this._passes.push(pass[i]);
				}
			} else {
				this._passes.push(pass);
			}
		}
	}, {
		key: 'render',
		value: function render(mSource) {
			var _this = this;

			var source = mSource;
			var fboTarget = void 0;

			this._passes.forEach(function (pass) {

				//	get target
				if (pass.hasFbo) {
					fboTarget = pass.fbo;
				} else {
					fboTarget = _this._fboTarget;
				}

				//	render
				fboTarget.bind();
				_GLTool2.default.clear(0, 0, 0, 0);
				pass.render(source);
				_GLTool2.default.draw(_this._mesh);
				fboTarget.unbind();

				//	reset source
				if (pass.hasFbo) {
					source = pass.fbo.getTexture();
				} else {
					_this._swap();
					source = _this._fboCurrent.getTexture();
				}
			});

			this._returnTexture = source;

			return source;
		}
	}, {
		key: '_swap',
		value: function _swap() {
			var tmp = this._fboCurrent;
			this._fboCurrent = this._fboTarget;
			this._fboTarget = tmp;

			this._current = this._fboCurrent;
			this._target = this._fboTarget;
		}
	}, {
		key: 'setSize',
		value: function setSize(mWidth, mHeight) {
			this._width = mWidth;
			this._height = mHeight;
			this._fboCurrent = new _FrameBuffer2.default(this._width, this._height, this._params);
			this._fboTarget = new _FrameBuffer2.default(this._width, this._height, this._params);
		}
	}, {
		key: 'getTexture',
		value: function getTexture() {
			return this._returnTexture;
		}
	}, {
		key: 'passes',
		get: function get() {
			return this._passes;
		}
	}]);

	return EffectComposer;
}();

exports.default = EffectComposer;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _PassVBlur = __webpack_require__(38);

var _PassVBlur2 = _interopRequireDefault(_PassVBlur);

var _PassHBlur = __webpack_require__(40);

var _PassHBlur2 = _interopRequireDefault(_PassHBlur);

var _PassMacro2 = __webpack_require__(37);

var _PassMacro3 = _interopRequireDefault(_PassMacro2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // PassBlur.js

var PassBlur = function (_PassMacro) {
	_inherits(PassBlur, _PassMacro);

	function PassBlur() {
		var mQuality = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 9;
		var mWidth = arguments[1];
		var mHeight = arguments[2];
		var mParams = arguments[3];

		_classCallCheck(this, PassBlur);

		var _this = _possibleConstructorReturn(this, (PassBlur.__proto__ || Object.getPrototypeOf(PassBlur)).call(this));

		var vBlur = new _PassVBlur2.default(mQuality, mWidth, mHeight, mParams);
		var hBlur = new _PassHBlur2.default(mQuality, mWidth, mHeight, mParams);

		_this.addPass(vBlur);
		_this.addPass(hBlur);
		return _this;
	}

	return PassBlur;
}(_PassMacro3.default);

exports.default = PassBlur;

/***/ }),
/* 76 */
/***/ (function(module, exports) {

module.exports = "// blur5.frag\n// source  : https://github.com/Jam3/glsl-fast-gaussian-blur\n\n#define SHADER_NAME BLUR_5\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\nuniform vec2 uDirection;\nuniform vec2 uResolution;\n\nvec4 blur5(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n\tvec4 color = vec4(0.0);\n\tvec2 off1 = vec2(1.3333333333333333) * direction;\n\tcolor += texture2D(image, uv) * 0.29411764705882354;\n\tcolor += texture2D(image, uv + (off1 / resolution)) * 0.35294117647058826;\n\tcolor += texture2D(image, uv - (off1 / resolution)) * 0.35294117647058826;\n\treturn color; \n}\n\n\nvoid main(void) {\n    gl_FragColor = blur5(texture, vTextureCoord, uResolution, uDirection);\n}"

/***/ }),
/* 77 */
/***/ (function(module, exports) {

module.exports = "// blur9.frag\n// source  : https://github.com/Jam3/glsl-fast-gaussian-blur\n\n#define SHADER_NAME BLUR_9\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\nuniform vec2 uDirection;\nuniform vec2 uResolution;\n\nvec4 blur9(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n\tvec4 color = vec4(0.0);\n\tvec2 off1 = vec2(1.3846153846) * direction;\n\tvec2 off2 = vec2(3.2307692308) * direction;\n\tcolor += texture2D(image, uv) * 0.2270270270;\n\tcolor += texture2D(image, uv + (off1 / resolution)) * 0.3162162162;\n\tcolor += texture2D(image, uv - (off1 / resolution)) * 0.3162162162;\n\tcolor += texture2D(image, uv + (off2 / resolution)) * 0.0702702703;\n\tcolor += texture2D(image, uv - (off2 / resolution)) * 0.0702702703;\n\treturn color;\n}\n\n\nvoid main(void) {\n    gl_FragColor = blur9(texture, vTextureCoord, uResolution, uDirection);\n}"

/***/ }),
/* 78 */
/***/ (function(module, exports) {

module.exports = "// blur13.frag\n// source  : https://github.com/Jam3/glsl-fast-gaussian-blur\n\n#define SHADER_NAME BLUR_13\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\nuniform vec2 uDirection;\nuniform vec2 uResolution;\n\nvec4 blur13(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n\tvec4 color = vec4(0.0);\n\tvec2 off1 = vec2(1.411764705882353) * direction;\n\tvec2 off2 = vec2(3.2941176470588234) * direction;\n\tvec2 off3 = vec2(5.176470588235294) * direction;\n\tcolor += texture2D(image, uv) * 0.1964825501511404;\n\tcolor += texture2D(image, uv + (off1 / resolution)) * 0.2969069646728344;\n\tcolor += texture2D(image, uv - (off1 / resolution)) * 0.2969069646728344;\n\tcolor += texture2D(image, uv + (off2 / resolution)) * 0.09447039785044732;\n\tcolor += texture2D(image, uv - (off2 / resolution)) * 0.09447039785044732;\n\tcolor += texture2D(image, uv + (off3 / resolution)) * 0.010381362401148057;\n\tcolor += texture2D(image, uv - (off3 / resolution)) * 0.010381362401148057;\n\treturn color;\n}\n\n\nvoid main(void) {\n    gl_FragColor = blur13(texture, vTextureCoord, uResolution, uDirection);\n}"

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Pass2 = __webpack_require__(9);

var _Pass3 = _interopRequireDefault(_Pass2);

var _fxaa = __webpack_require__(41);

var _fxaa2 = _interopRequireDefault(_fxaa);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // PassFxaa.js

var PassFxaa = function (_Pass) {
	_inherits(PassFxaa, _Pass);

	function PassFxaa() {
		_classCallCheck(this, PassFxaa);

		var _this = _possibleConstructorReturn(this, (PassFxaa.__proto__ || Object.getPrototypeOf(PassFxaa)).call(this, _fxaa2.default));

		_this.uniform('uResolution', [1 / _GLTool2.default.width, 1 / _GLTool2.default.height]);
		return _this;
	}

	return PassFxaa;
}(_Pass3.default);

exports.default = PassFxaa;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _GLShader = __webpack_require__(2);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchCopy.js

var vs = __webpack_require__(18);
var fs = __webpack_require__(19);

var BatchCopy = function (_Batch) {
	_inherits(BatchCopy, _Batch);

	function BatchCopy() {
		_classCallCheck(this, BatchCopy);

		var mesh = _Geom2.default.bigTriangle();
		var shader = new _GLShader2.default(vs, fs);

		var _this = _possibleConstructorReturn(this, (BatchCopy.__proto__ || Object.getPrototypeOf(BatchCopy)).call(this, mesh, shader));

		shader.bind();
		shader.uniform('texture', 'uniform1i', 0);
		return _this;
	}

	_createClass(BatchCopy, [{
		key: 'draw',
		value: function draw(texture) {
			this.shader.bind();
			texture.bind(0);
			_get(BatchCopy.prototype.__proto__ || Object.getPrototypeOf(BatchCopy.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchCopy;
}(_Batch3.default);

exports.default = BatchCopy;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Mesh = __webpack_require__(4);

var _Mesh2 = _interopRequireDefault(_Mesh);

var _GLShader = __webpack_require__(2);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchAxis.js

var vs = __webpack_require__(82);
var fs = __webpack_require__(83);

var BatchAxis = function (_Batch) {
	_inherits(BatchAxis, _Batch);

	function BatchAxis() {
		_classCallCheck(this, BatchAxis);

		var positions = [];
		var colors = [];
		var indices = [0, 1, 2, 3, 4, 5];
		var r = 9999;

		positions.push([-r, 0, 0]);
		positions.push([r, 0, 0]);
		positions.push([0, -r, 0]);
		positions.push([0, r, 0]);
		positions.push([0, 0, -r]);
		positions.push([0, 0, r]);

		colors.push([1, 0, 0]);
		colors.push([1, 0, 0]);
		colors.push([0, 1, 0]);
		colors.push([0, 1, 0]);
		colors.push([0, 0, 1]);
		colors.push([0, 0, 1]);

		var mesh = new _Mesh2.default(_GLTool2.default.LINES);
		mesh.bufferVertex(positions);
		mesh.bufferIndex(indices);
		mesh.bufferData(colors, 'aColor', 3);

		var shader = new _GLShader2.default(vs, fs);

		return _possibleConstructorReturn(this, (BatchAxis.__proto__ || Object.getPrototypeOf(BatchAxis)).call(this, mesh, shader));
	}

	return BatchAxis;
}(_Batch3.default);

exports.default = BatchAxis;

/***/ }),
/* 82 */
/***/ (function(module, exports) {

module.exports = "// axis.vert\n\n#define SHADER_NAME BASIC_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec3 aColor;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec3 vColor;\nvarying vec3 vNormal;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);\n    vColor = aColor;\n    vNormal = aNormal;\n}"

/***/ }),
/* 83 */
/***/ (function(module, exports) {

module.exports = "// axis.frag\n\n#define SHADER_NAME SIMPLE_TEXTURE\n\nprecision lowp float;\n#define GLSLIFY 1\nvarying vec3 vColor;\nvarying vec3 vNormal;\n\nvoid main(void) {\n\t// vec3 color = vNormal;\n\tvec3 color = vColor + vNormal * 0.0001;\n    gl_FragColor = vec4(color, 1.0);\n}"

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _GLShader = __webpack_require__(2);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchBall.js

var vs = __webpack_require__(34);
var fs = __webpack_require__(10);

var BatchBall = function (_Batch) {
	_inherits(BatchBall, _Batch);

	function BatchBall() {
		_classCallCheck(this, BatchBall);

		var mesh = _Geom2.default.sphere(1, 24);
		var shader = new _GLShader2.default(vs, fs);
		return _possibleConstructorReturn(this, (BatchBall.__proto__ || Object.getPrototypeOf(BatchBall)).call(this, mesh, shader));
	}

	_createClass(BatchBall, [{
		key: 'draw',
		value: function draw() {
			var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];
			var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [1, 1, 1];
			var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 1, 1];
			var opacity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

			this.shader.bind();
			this.shader.uniform('position', 'uniform3fv', position);
			this.shader.uniform('scale', 'uniform3fv', scale);
			this.shader.uniform('color', 'uniform3fv', color);
			this.shader.uniform('opacity', 'uniform1f', opacity);
			_get(BatchBall.prototype.__proto__ || Object.getPrototypeOf(BatchBall.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchBall;
}(_Batch3.default);

exports.default = BatchBall;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Mesh = __webpack_require__(4);

var _Mesh2 = _interopRequireDefault(_Mesh);

var _GLShader = __webpack_require__(2);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchDotsPlane.js

var vs = __webpack_require__(86);
var fs = __webpack_require__(10);

var BatchDotsPlane = function (_Batch) {
	_inherits(BatchDotsPlane, _Batch);

	function BatchDotsPlane() {
		_classCallCheck(this, BatchDotsPlane);

		var positions = [];
		var indices = [];
		var index = 0;
		var size = 100;
		var i = void 0,
		    j = void 0;

		for (i = -size; i < size; i += 1) {
			for (j = -size; j < size; j += 1) {
				positions.push([i, j, 0]);
				indices.push(index);
				index++;

				positions.push([i, 0, j]);
				indices.push(index);
				index++;
			}
		}

		var mesh = new _Mesh2.default(_GLTool2.default.POINTS);
		mesh.bufferVertex(positions);
		mesh.bufferIndex(indices);

		var shader = new _GLShader2.default(vs, fs);

		var _this = _possibleConstructorReturn(this, (BatchDotsPlane.__proto__ || Object.getPrototypeOf(BatchDotsPlane)).call(this, mesh, shader));

		_this.color = [1, 1, 1];
		_this.opacity = 0.5;
		return _this;
	}

	_createClass(BatchDotsPlane, [{
		key: 'draw',
		value: function draw() {
			this.shader.bind();
			this.shader.uniform('color', 'uniform3fv', this.color);
			this.shader.uniform('opacity', 'uniform1f', this.opacity);
			// GL.draw(this.mesh);
			_get(BatchDotsPlane.prototype.__proto__ || Object.getPrototypeOf(BatchDotsPlane.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchDotsPlane;
}(_Batch3.default);

exports.default = BatchDotsPlane;

/***/ }),
/* 86 */
/***/ (function(module, exports) {

module.exports = "// basic.vert\n\n#define SHADER_NAME DOTS_PLANE_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec3 vNormal;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition + aNormal * 0.000001, 1.0);\n    gl_PointSize = 1.0;\n    vNormal = aNormal;\n}"

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Mesh = __webpack_require__(4);

var _Mesh2 = _interopRequireDefault(_Mesh);

var _GLShader = __webpack_require__(2);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchLine.js


var vs = __webpack_require__(11);
var fs = __webpack_require__(10);

var BatchAxis = function (_Batch) {
	_inherits(BatchAxis, _Batch);

	function BatchAxis() {
		_classCallCheck(this, BatchAxis);

		var positions = [];
		var indices = [0, 1];
		var coords = [[0, 0], [1, 1]];
		positions.push([0, 0, 0]);
		positions.push([0, 0, 0]);

		var mesh = new _Mesh2.default(_GLTool2.default.LINES);
		mesh.bufferVertex(positions);
		mesh.bufferTexCoord(coords);
		mesh.bufferIndex(indices);

		var shader = new _GLShader2.default(vs, fs);

		return _possibleConstructorReturn(this, (BatchAxis.__proto__ || Object.getPrototypeOf(BatchAxis)).call(this, mesh, shader));
	}

	_createClass(BatchAxis, [{
		key: 'draw',
		value: function draw(mPositionA, mPositionB) {
			var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 1, 1];
			var opacity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1.0;

			this._mesh.bufferVertex([mPositionA, mPositionB]);

			this._shader.bind();
			this._shader.uniform('color', 'vec3', color);
			this._shader.uniform('opacity', 'float', opacity);
			_get(BatchAxis.prototype.__proto__ || Object.getPrototypeOf(BatchAxis.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchAxis;
}(_Batch3.default);

exports.default = BatchAxis;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _GLShader = __webpack_require__(2);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchSkybox.js

var vs = __webpack_require__(35);
var fs = __webpack_require__(36);

var BatchSkybox = function (_Batch) {
	_inherits(BatchSkybox, _Batch);

	function BatchSkybox() {
		var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 20;

		_classCallCheck(this, BatchSkybox);

		var mesh = _Geom2.default.skybox(size);
		var shader = new _GLShader2.default(vs, fs);

		return _possibleConstructorReturn(this, (BatchSkybox.__proto__ || Object.getPrototypeOf(BatchSkybox)).call(this, mesh, shader));
	}

	_createClass(BatchSkybox, [{
		key: 'draw',
		value: function draw(texture) {
			this.shader.bind();
			texture.bind(0);
			_get(BatchSkybox.prototype.__proto__ || Object.getPrototypeOf(BatchSkybox.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchSkybox;
}(_Batch3.default);

exports.default = BatchSkybox;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _GLShader = __webpack_require__(2);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchSky.js

var vs = __webpack_require__(90);
var fs = __webpack_require__(19);

var BatchSky = function (_Batch) {
	_inherits(BatchSky, _Batch);

	function BatchSky() {
		var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;
		var seg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 24;

		_classCallCheck(this, BatchSky);

		var mesh = _Geom2.default.sphere(size, seg, true);
		var shader = new _GLShader2.default(vs, fs);

		return _possibleConstructorReturn(this, (BatchSky.__proto__ || Object.getPrototypeOf(BatchSky)).call(this, mesh, shader));
	}

	_createClass(BatchSky, [{
		key: 'draw',
		value: function draw(texture) {
			this.shader.bind();
			texture.bind(0);
			_get(BatchSky.prototype.__proto__ || Object.getPrototypeOf(BatchSky.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchSky;
}(_Batch3.default);

exports.default = BatchSky;

/***/ }),
/* 90 */
/***/ (function(module, exports) {

module.exports = "// sky.vert\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\n\nvoid main(void) {\n\tmat4 matView = uViewMatrix;\n\tmatView[3][0] = 0.0;\n\tmatView[3][1] = 0.0;\n\tmatView[3][2] = 0.0;\n\t\n    gl_Position = uProjectionMatrix * matView * uModelMatrix * vec4(aVertexPosition, 1.0);\n    vTextureCoord = aTextureCoord;\n    vNormal = aNormal;\n}"

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _GLShader = __webpack_require__(2);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchFXAA.js


var vs = __webpack_require__(18);
var fs = __webpack_require__(41);

var BatchFXAA = function (_Batch) {
	_inherits(BatchFXAA, _Batch);

	function BatchFXAA() {
		_classCallCheck(this, BatchFXAA);

		var mesh = _Geom2.default.bigTriangle();
		var shader = new _GLShader2.default(vs, fs);

		var _this = _possibleConstructorReturn(this, (BatchFXAA.__proto__ || Object.getPrototypeOf(BatchFXAA)).call(this, mesh, shader));

		shader.bind();
		shader.uniform('texture', 'uniform1i', 0);
		return _this;
	}

	_createClass(BatchFXAA, [{
		key: 'draw',
		value: function draw(texture) {
			this.shader.bind();
			texture.bind(0);
			this.shader.uniform('uResolution', 'vec2', [1 / _GLTool2.default.width, 1 / _GLTool2.default.height]);
			_get(BatchFXAA.prototype.__proto__ || Object.getPrototypeOf(BatchFXAA.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchFXAA;
}(_Batch3.default);

exports.default = BatchFXAA;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Scene.js

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _CameraPerspective = __webpack_require__(16);

var _CameraPerspective2 = _interopRequireDefault(_CameraPerspective);

var _CameraOrtho = __webpack_require__(31);

var _CameraOrtho2 = _interopRequireDefault(_CameraOrtho);

var _OrbitalControl = __webpack_require__(30);

var _OrbitalControl2 = _interopRequireDefault(_OrbitalControl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Scene = function () {
	function Scene() {
		var _this = this;

		_classCallCheck(this, Scene);

		this._children = [];
		this._matrixIdentity = mat4.create();
		_GLTool2.default.enableAlphaBlending();

		this._init();
		this._initTextures();
		this._initViews();

		this._efIndex = _scheduling2.default.addEF(function () {
			return _this._loop();
		});
		window.addEventListener('resize', function () {
			return _this.resize();
		});
	}

	//	PUBLIC METHODS

	_createClass(Scene, [{
		key: 'update',
		value: function update() {}
	}, {
		key: 'render',
		value: function render() {}
	}, {
		key: 'stop',
		value: function stop() {
			if (this._efIndex === -1) {
				return;
			}
			this._efIndex = _scheduling2.default.removeEF(this._efIndex);
		}
	}, {
		key: 'start',
		value: function start() {
			var _this2 = this;

			if (this._efIndex !== -1) {
				return;
			}

			this._efIndex = _scheduling2.default.addEF(function () {
				return _this2._loop();
			});
		}
	}, {
		key: 'resize',
		value: function resize() {
			_GLTool2.default.setSize(window.innerWidth, window.innerHeight);
			this.camera.setAspectRatio(_GLTool2.default.aspectRatio);
		}
	}, {
		key: 'addChild',
		value: function addChild(mChild) {
			this._children.push(mChild);
		}
	}, {
		key: 'removeChild',
		value: function removeChild(mChild) {
			var index = this._children.indexOf(mChild);
			if (index == -1) {
				console.warn('Child no exist');return;
			}

			this._children.splice(index, 1);
		}

		//	PROTECTED METHODS TO BE OVERRIDEN BY CHILDREN

	}, {
		key: '_initTextures',
		value: function _initTextures() {}
	}, {
		key: '_initViews',
		value: function _initViews() {}
	}, {
		key: '_renderChildren',
		value: function _renderChildren() {
			var child = void 0;
			for (var i = 0; i < this._children.length; i++) {
				child = this._children[i];
				child.toRender();
			}

			_GLTool2.default.rotate(this._matrixIdentity);
		}

		//	PRIVATE METHODS

	}, {
		key: '_init',
		value: function _init() {
			this.camera = new _CameraPerspective2.default();
			this.camera.setPerspective(45 * Math.PI / 180, _GLTool2.default.aspectRatio, 0.1, 100);
			this.orbitalControl = new _OrbitalControl2.default(this.camera, window, 15);
			this.orbitalControl.radius.value = 10;

			this.cameraOrtho = new _CameraOrtho2.default();
		}
	}, {
		key: '_loop',
		value: function _loop() {

			//	RESET VIEWPORT
			_GLTool2.default.viewport(0, 0, _GLTool2.default.width, _GLTool2.default.height);

			//	RESET CAMERA
			_GLTool2.default.setMatrices(this.camera);

			this.update();
			this._renderChildren();
			this.render();
		}
	}]);

	return Scene;
}();

exports.default = Scene;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // View.js

var _GLShader = __webpack_require__(2);

var _GLShader2 = _interopRequireDefault(_GLShader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var View = function () {
	function View(mStrVertex, mStrFrag) {
		_classCallCheck(this, View);

		this.shader = new _GLShader2.default(mStrVertex, mStrFrag);

		this._init();
	}

	//	PROTECTED METHODS

	_createClass(View, [{
		key: '_init',
		value: function _init() {}

		// 	PUBLIC METHODS

	}, {
		key: 'render',
		value: function render() {}
	}]);

	return View;
}();

exports.default = View;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Object3D2 = __webpack_require__(32);

var _Object3D3 = _interopRequireDefault(_Object3D2);

var _GLShader = __webpack_require__(2);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // View3D.js

var View3D = function (_Object3D) {
	_inherits(View3D, _Object3D);

	function View3D(mStrVertex, mStrFrag) {
		_classCallCheck(this, View3D);

		var _this = _possibleConstructorReturn(this, (View3D.__proto__ || Object.getPrototypeOf(View3D)).call(this));

		_this._children = [];
		_this.shader = new _GLShader2.default(mStrVertex, mStrFrag);
		_this._init();
		_this._matrixTemp = mat4.create();
		return _this;
	}

	//	PROTECTED METHODS

	_createClass(View3D, [{
		key: '_init',
		value: function _init() {}

		// 	PUBLIC METHODS

	}, {
		key: 'addChild',
		value: function addChild(mChild) {
			this._children.push(mChild);
		}
	}, {
		key: 'removeChild',
		value: function removeChild(mChild) {
			var index = this._children.indexOf(mChild);
			if (index == -1) {
				console.warn('Child no exist');return;
			}

			this._children.splice(index, 1);
		}
	}, {
		key: 'toRender',
		value: function toRender(matrix) {
			if (matrix === undefined) {
				matrix = mat4.create();
			}
			mat4.mul(this._matrixTemp, matrix, this.matrix);
			_GLTool2.default.rotate(this._matrixTemp);
			this.render();

			for (var i = 0; i < this._children.length; i++) {
				var child = this._children[i];
				child.toRender(this.matrix);
			}
		}
	}, {
		key: 'render',
		value: function render() {}
	}]);

	return View3D;
}(_Object3D3.default);

exports.default = View3D;

/***/ }),
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _datGui = __webpack_require__(125);

var _datGui2 = _interopRequireDefault(_datGui);

var _stats = __webpack_require__(128);

var _stats2 = _interopRequireDefault(_stats);

var _alfrid = __webpack_require__(20);

var _alfrid2 = _interopRequireDefault(_alfrid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//	INIT DAT-GUI
window.gui = new _datGui2.default.GUI({ width: 300 }); // debug.js

var div = document.body.querySelector('.dg.ac');
div.style.zIndex = '999';

//	STATS
var stats = new _stats2.default();
document.body.appendChild(stats.domElement);
_alfrid2.default.Scheduler.addEF(function () {
  return stats.update();
});

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(126)
module.exports.color = __webpack_require__(127)

/***/ }),
/* 126 */
/***/ (function(module, exports) {

/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

/** @namespace */
var dat = module.exports = dat || {};

/** @namespace */
dat.gui = dat.gui || {};

/** @namespace */
dat.utils = dat.utils || {};

/** @namespace */
dat.controllers = dat.controllers || {};

/** @namespace */
dat.dom = dat.dom || {};

/** @namespace */
dat.color = dat.color || {};

dat.utils.css = (function () {
  return {
    load: function (url, doc) {
      doc = doc || document;
      var link = doc.createElement('link');
      link.type = 'text/css';
      link.rel = 'stylesheet';
      link.href = url;
      doc.getElementsByTagName('head')[0].appendChild(link);
    },
    inject: function(css, doc) {
      doc = doc || document;
      var injected = document.createElement('style');
      injected.type = 'text/css';
      injected.innerHTML = css;
      doc.getElementsByTagName('head')[0].appendChild(injected);
    }
  }
})();


dat.utils.common = (function () {
  
  var ARR_EACH = Array.prototype.forEach;
  var ARR_SLICE = Array.prototype.slice;

  /**
   * Band-aid methods for things that should be a lot easier in JavaScript.
   * Implementation and structure inspired by underscore.js
   * http://documentcloud.github.com/underscore/
   */

  return { 
    
    BREAK: {},
  
    extend: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (!this.isUndefined(obj[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
      
    },
    
    defaults: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (this.isUndefined(target[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
    
    },
    
    compose: function() {
      var toCall = ARR_SLICE.call(arguments);
            return function() {
              var args = ARR_SLICE.call(arguments);
              for (var i = toCall.length -1; i >= 0; i--) {
                args = [toCall[i].apply(this, args)];
              }
              return args[0];
            }
    },
    
    each: function(obj, itr, scope) {

      
      if (ARR_EACH && obj.forEach === ARR_EACH) { 
        
        obj.forEach(itr, scope);
        
      } else if (obj.length === obj.length + 0) { // Is number but not NaN
        
        for (var key = 0, l = obj.length; key < l; key++)
          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) 
            return;
            
      } else {

        for (var key in obj) 
          if (itr.call(scope, obj[key], key) === this.BREAK)
            return;
            
      }
            
    },
    
    defer: function(fnc) {
      setTimeout(fnc, 0);
    },
    
    toArray: function(obj) {
      if (obj.toArray) return obj.toArray();
      return ARR_SLICE.call(obj);
    },

    isUndefined: function(obj) {
      return obj === undefined;
    },
    
    isNull: function(obj) {
      return obj === null;
    },
    
    isNaN: function(obj) {
      return obj !== obj;
    },
    
    isArray: Array.isArray || function(obj) {
      return obj.constructor === Array;
    },
    
    isObject: function(obj) {
      return obj === Object(obj);
    },
    
    isNumber: function(obj) {
      return obj === obj+0;
    },
    
    isString: function(obj) {
      return obj === obj+'';
    },
    
    isBoolean: function(obj) {
      return obj === false || obj === true;
    },
    
    isFunction: function(obj) {
      return Object.prototype.toString.call(obj) === '[object Function]';
    }
  
  };
    
})();


dat.controllers.Controller = (function (common) {

  /**
   * @class An "abstract" class that represents a given property of an object.
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var Controller = function(object, property) {

    this.initialValue = object[property];

    /**
     * Those who extend this class will put their DOM elements in here.
     * @type {DOMElement}
     */
    this.domElement = document.createElement('div');

    /**
     * The object to manipulate
     * @type {Object}
     */
    this.object = object;

    /**
     * The name of the property to manipulate
     * @type {String}
     */
    this.property = property;

    /**
     * The function to be called on change.
     * @type {Function}
     * @ignore
     */
    this.__onChange = undefined;

    /**
     * The function to be called on finishing change.
     * @type {Function}
     * @ignore
     */
    this.__onFinishChange = undefined;

  };

  common.extend(

      Controller.prototype,

      /** @lends dat.controllers.Controller.prototype */
      {

        /**
         * Specify that a function fire every time someone changes the value with
         * this Controller.
         *
         * @param {Function} fnc This function will be called whenever the value
         * is modified via this Controller.
         * @returns {dat.controllers.Controller} this
         */
        onChange: function(fnc) {
          this.__onChange = fnc;
          return this;
        },

        /**
         * Specify that a function fire every time someone "finishes" changing
         * the value wih this Controller. Useful for values that change
         * incrementally like numbers or strings.
         *
         * @param {Function} fnc This function will be called whenever
         * someone "finishes" changing the value via this Controller.
         * @returns {dat.controllers.Controller} this
         */
        onFinishChange: function(fnc) {
          this.__onFinishChange = fnc;
          return this;
        },

        /**
         * Change the value of <code>object[property]</code>
         *
         * @param {Object} newValue The new value of <code>object[property]</code>
         */
        setValue: function(newValue) {
          this.object[this.property] = newValue;
          if (this.__onChange) {
            this.__onChange.call(this, newValue);
          }
          this.updateDisplay();
          return this;
        },

        /**
         * Gets the value of <code>object[property]</code>
         *
         * @returns {Object} The current value of <code>object[property]</code>
         */
        getValue: function() {
          return this.object[this.property];
        },

        /**
         * Refreshes the visual display of a Controller in order to keep sync
         * with the object's current value.
         * @returns {dat.controllers.Controller} this
         */
        updateDisplay: function() {
          return this;
        },

        /**
         * @returns {Boolean} true if the value has deviated from initialValue
         */
        isModified: function() {
          return this.initialValue !== this.getValue()
        }

      }

  );

  return Controller;


})(dat.utils.common);


dat.dom.dom = (function (common) {

  var EVENT_MAP = {
    'HTMLEvents': ['change'],
    'MouseEvents': ['click','mousemove','mousedown','mouseup', 'mouseover'],
    'KeyboardEvents': ['keydown']
  };

  var EVENT_MAP_INV = {};
  common.each(EVENT_MAP, function(v, k) {
    common.each(v, function(e) {
      EVENT_MAP_INV[e] = k;
    });
  });

  var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;

  function cssValueToPixels(val) {

    if (val === '0' || common.isUndefined(val)) return 0;

    var match = val.match(CSS_VALUE_PIXELS);

    if (!common.isNull(match)) {
      return parseFloat(match[1]);
    }

    // TODO ...ems? %?

    return 0;

  }

  /**
   * @namespace
   * @member dat.dom
   */
  var dom = {

    /**
     * 
     * @param elem
     * @param selectable
     */
    makeSelectable: function(elem, selectable) {

      if (elem === undefined || elem.style === undefined) return;

      elem.onselectstart = selectable ? function() {
        return false;
      } : function() {
      };

      elem.style.MozUserSelect = selectable ? 'auto' : 'none';
      elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
      elem.unselectable = selectable ? 'on' : 'off';

    },

    /**
     *
     * @param elem
     * @param horizontal
     * @param vertical
     */
    makeFullscreen: function(elem, horizontal, vertical) {

      if (common.isUndefined(horizontal)) horizontal = true;
      if (common.isUndefined(vertical)) vertical = true;

      elem.style.position = 'absolute';

      if (horizontal) {
        elem.style.left = 0;
        elem.style.right = 0;
      }
      if (vertical) {
        elem.style.top = 0;
        elem.style.bottom = 0;
      }

    },

    /**
     *
     * @param elem
     * @param eventType
     * @param params
     */
    fakeEvent: function(elem, eventType, params, aux) {
      params = params || {};
      var className = EVENT_MAP_INV[eventType];
      if (!className) {
        throw new Error('Event type ' + eventType + ' not supported.');
      }
      var evt = document.createEvent(className);
      switch (className) {
        case 'MouseEvents':
          var clientX = params.x || params.clientX || 0;
          var clientY = params.y || params.clientY || 0;
          evt.initMouseEvent(eventType, params.bubbles || false,
              params.cancelable || true, window, params.clickCount || 1,
              0, //screen X
              0, //screen Y
              clientX, //client X
              clientY, //client Y
              false, false, false, false, 0, null);
          break;
        case 'KeyboardEvents':
          var init = evt.initKeyboardEvent || evt.initKeyEvent; // webkit || moz
          common.defaults(params, {
            cancelable: true,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            keyCode: undefined,
            charCode: undefined
          });
          init(eventType, params.bubbles || false,
              params.cancelable, window,
              params.ctrlKey, params.altKey,
              params.shiftKey, params.metaKey,
              params.keyCode, params.charCode);
          break;
        default:
          evt.initEvent(eventType, params.bubbles || false,
              params.cancelable || true);
          break;
      }
      common.defaults(evt, aux);
      elem.dispatchEvent(evt);
    },

    /**
     *
     * @param elem
     * @param event
     * @param func
     * @param bool
     */
    bind: function(elem, event, func, bool) {
      bool = bool || false;
      if (elem.addEventListener)
        elem.addEventListener(event, func, bool);
      else if (elem.attachEvent)
        elem.attachEvent('on' + event, func);
      return dom;
    },

    /**
     *
     * @param elem
     * @param event
     * @param func
     * @param bool
     */
    unbind: function(elem, event, func, bool) {
      bool = bool || false;
      if (elem.removeEventListener)
        elem.removeEventListener(event, func, bool);
      else if (elem.detachEvent)
        elem.detachEvent('on' + event, func);
      return dom;
    },

    /**
     *
     * @param elem
     * @param className
     */
    addClass: function(elem, className) {
      if (elem.className === undefined) {
        elem.className = className;
      } else if (elem.className !== className) {
        var classes = elem.className.split(/ +/);
        if (classes.indexOf(className) == -1) {
          classes.push(className);
          elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
        }
      }
      return dom;
    },

    /**
     *
     * @param elem
     * @param className
     */
    removeClass: function(elem, className) {
      if (className) {
        if (elem.className === undefined) {
          // elem.className = className;
        } else if (elem.className === className) {
          elem.removeAttribute('class');
        } else {
          var classes = elem.className.split(/ +/);
          var index = classes.indexOf(className);
          if (index != -1) {
            classes.splice(index, 1);
            elem.className = classes.join(' ');
          }
        }
      } else {
        elem.className = undefined;
      }
      return dom;
    },

    hasClass: function(elem, className) {
      return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
    },

    /**
     *
     * @param elem
     */
    getWidth: function(elem) {

      var style = getComputedStyle(elem);

      return cssValueToPixels(style['border-left-width']) +
          cssValueToPixels(style['border-right-width']) +
          cssValueToPixels(style['padding-left']) +
          cssValueToPixels(style['padding-right']) +
          cssValueToPixels(style['width']);
    },

    /**
     *
     * @param elem
     */
    getHeight: function(elem) {

      var style = getComputedStyle(elem);

      return cssValueToPixels(style['border-top-width']) +
          cssValueToPixels(style['border-bottom-width']) +
          cssValueToPixels(style['padding-top']) +
          cssValueToPixels(style['padding-bottom']) +
          cssValueToPixels(style['height']);
    },

    /**
     *
     * @param elem
     */
    getOffset: function(elem) {
      var offset = {left: 0, top:0};
      if (elem.offsetParent) {
        do {
          offset.left += elem.offsetLeft;
          offset.top += elem.offsetTop;
        } while (elem = elem.offsetParent);
      }
      return offset;
    },

    // http://stackoverflow.com/posts/2684561/revisions
    /**
     * 
     * @param elem
     */
    isActive: function(elem) {
      return elem === document.activeElement && ( elem.type || elem.href );
    }

  };

  return dom;

})(dat.utils.common);


dat.controllers.OptionController = (function (Controller, dom, common) {

  /**
   * @class Provides a select input to alter the property of an object, using a
   * list of accepted values.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object|string[]} options A map of labels to acceptable values, or
   * a list of acceptable string values.
   *
   * @member dat.controllers
   */
  var OptionController = function(object, property, options) {

    OptionController.superclass.call(this, object, property);

    var _this = this;

    /**
     * The drop down menu
     * @ignore
     */
    this.__select = document.createElement('select');

    if (common.isArray(options)) {
      var map = {};
      common.each(options, function(element) {
        map[element] = element;
      });
      options = map;
    }

    common.each(options, function(value, key) {

      var opt = document.createElement('option');
      opt.innerHTML = key;
      opt.setAttribute('value', value);
      _this.__select.appendChild(opt);

    });

    // Acknowledge original value
    this.updateDisplay();

    dom.bind(this.__select, 'change', function() {
      var desiredValue = this.options[this.selectedIndex].value;
      _this.setValue(desiredValue);
    });

    this.domElement.appendChild(this.__select);

  };

  OptionController.superclass = Controller;

  common.extend(

      OptionController.prototype,
      Controller.prototype,

      {

        setValue: function(v) {
          var toReturn = OptionController.superclass.prototype.setValue.call(this, v);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          return toReturn;
        },

        updateDisplay: function() {
          this.__select.value = this.getValue();
          return OptionController.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  return OptionController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.controllers.NumberController = (function (Controller, common) {

  /**
   * @class Represents a given property of an object that is a number.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object} [params] Optional parameters
   * @param {Number} [params.min] Minimum allowed value
   * @param {Number} [params.max] Maximum allowed value
   * @param {Number} [params.step] Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberController = function(object, property, params) {

    NumberController.superclass.call(this, object, property);

    params = params || {};

    this.__min = params.min;
    this.__max = params.max;
    this.__step = params.step;

    if (common.isUndefined(this.__step)) {

      if (this.initialValue == 0) {
        this.__impliedStep = 1; // What are we, psychics?
      } else {
        // Hey Doug, check this out.
        this.__impliedStep = Math.pow(10, Math.floor(Math.log(this.initialValue)/Math.LN10))/10;
      }

    } else {

      this.__impliedStep = this.__step;

    }

    this.__precision = numDecimals(this.__impliedStep);


  };

  NumberController.superclass = Controller;

  common.extend(

      NumberController.prototype,
      Controller.prototype,

      /** @lends dat.controllers.NumberController.prototype */
      {

        setValue: function(v) {

          if (this.__min !== undefined && v < this.__min) {
            v = this.__min;
          } else if (this.__max !== undefined && v > this.__max) {
            v = this.__max;
          }

          if (this.__step !== undefined && v % this.__step != 0) {
            v = Math.round(v / this.__step) * this.__step;
          }

          return NumberController.superclass.prototype.setValue.call(this, v);

        },

        /**
         * Specify a minimum value for <code>object[property]</code>.
         *
         * @param {Number} minValue The minimum value for
         * <code>object[property]</code>
         * @returns {dat.controllers.NumberController} this
         */
        min: function(v) {
          this.__min = v;
          return this;
        },

        /**
         * Specify a maximum value for <code>object[property]</code>.
         *
         * @param {Number} maxValue The maximum value for
         * <code>object[property]</code>
         * @returns {dat.controllers.NumberController} this
         */
        max: function(v) {
          this.__max = v;
          return this;
        },

        /**
         * Specify a step value that dat.controllers.NumberController
         * increments by.
         *
         * @param {Number} stepValue The step value for
         * dat.controllers.NumberController
         * @default if minimum and maximum specified increment is 1% of the
         * difference otherwise stepValue is 1
         * @returns {dat.controllers.NumberController} this
         */
        step: function(v) {
          this.__step = v;
          return this;
        }

      }

  );

  function numDecimals(x) {
    x = x.toString();
    if (x.indexOf('.') > -1) {
      return x.length - x.indexOf('.') - 1;
    } else {
      return 0;
    }
  }

  return NumberController;

})(dat.controllers.Controller,
dat.utils.common);


dat.controllers.NumberControllerBox = (function (NumberController, dom, common) {

  /**
   * @class Represents a given property of an object that is a number and
   * provides an input element with which to manipulate it.
   *
   * @extends dat.controllers.Controller
   * @extends dat.controllers.NumberController
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object} [params] Optional parameters
   * @param {Number} [params.min] Minimum allowed value
   * @param {Number} [params.max] Maximum allowed value
   * @param {Number} [params.step] Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberControllerBox = function(object, property, params) {

    this.__truncationSuspended = false;

    NumberControllerBox.superclass.call(this, object, property, params);

    var _this = this;

    /**
     * {Number} Previous mouse y position
     * @ignore
     */
    var prev_y;

    this.__input = document.createElement('input');
    this.__input.setAttribute('type', 'text');

    // Makes it so manually specified values are not truncated.

    dom.bind(this.__input, 'change', onChange);
    dom.bind(this.__input, 'blur', onBlur);
    dom.bind(this.__input, 'mousedown', onMouseDown);
    dom.bind(this.__input, 'keydown', function(e) {

      // When pressing entire, you can be as precise as you want.
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true;
        this.blur();
        _this.__truncationSuspended = false;
      }

    });

    function onChange() {
      var attempted = parseFloat(_this.__input.value);
      if (!common.isNaN(attempted)) _this.setValue(attempted);
    }

    function onBlur() {
      onChange();
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    function onMouseDown(e) {
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      prev_y = e.clientY;
    }

    function onMouseDrag(e) {

      var diff = prev_y - e.clientY;
      _this.setValue(_this.getValue() + diff * _this.__impliedStep);

      prev_y = e.clientY;

    }

    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
    }

    this.updateDisplay();

    this.domElement.appendChild(this.__input);

  };

  NumberControllerBox.superclass = NumberController;

  common.extend(

      NumberControllerBox.prototype,
      NumberController.prototype,

      {

        updateDisplay: function() {

          this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
          return NumberControllerBox.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  function roundToDecimal(value, decimals) {
    var tenTo = Math.pow(10, decimals);
    return Math.round(value * tenTo) / tenTo;
  }

  return NumberControllerBox;

})(dat.controllers.NumberController,
dat.dom.dom,
dat.utils.common);


dat.controllers.NumberControllerSlider = (function (NumberController, dom, css, common, styleSheet) {

  /**
   * @class Represents a given property of an object that is a number, contains
   * a minimum and maximum, and provides a slider element with which to
   * manipulate it. It should be noted that the slider element is made up of
   * <code>&lt;div&gt;</code> tags, <strong>not</strong> the html5
   * <code>&lt;slider&gt;</code> element.
   *
   * @extends dat.controllers.Controller
   * @extends dat.controllers.NumberController
   * 
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Number} minValue Minimum allowed value
   * @param {Number} maxValue Maximum allowed value
   * @param {Number} stepValue Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberControllerSlider = function(object, property, min, max, step) {

    NumberControllerSlider.superclass.call(this, object, property, { min: min, max: max, step: step });

    var _this = this;

    this.__background = document.createElement('div');
    this.__foreground = document.createElement('div');
    


    dom.bind(this.__background, 'mousedown', onMouseDown);
    
    dom.addClass(this.__background, 'slider');
    dom.addClass(this.__foreground, 'slider-fg');

    function onMouseDown(e) {

      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);

      onMouseDrag(e);
    }

    function onMouseDrag(e) {

      e.preventDefault();

      var offset = dom.getOffset(_this.__background);
      var width = dom.getWidth(_this.__background);
      
      _this.setValue(
        map(e.clientX, offset.left, offset.left + width, _this.__min, _this.__max)
      );

      return false;

    }

    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    this.updateDisplay();

    this.__background.appendChild(this.__foreground);
    this.domElement.appendChild(this.__background);

  };

  NumberControllerSlider.superclass = NumberController;

  /**
   * Injects default stylesheet for slider elements.
   */
  NumberControllerSlider.useDefaultStyles = function() {
    css.inject(styleSheet);
  };

  common.extend(

      NumberControllerSlider.prototype,
      NumberController.prototype,

      {

        updateDisplay: function() {
          var pct = (this.getValue() - this.__min)/(this.__max - this.__min);
          this.__foreground.style.width = pct*100+'%';
          return NumberControllerSlider.superclass.prototype.updateDisplay.call(this);
        }

      }



  );

  function map(v, i1, i2, o1, o2) {
    return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
  }

  return NumberControllerSlider;
  
})(dat.controllers.NumberController,
dat.dom.dom,
dat.utils.css,
dat.utils.common,
".slider {\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\n  height: 1em;\n  border-radius: 1em;\n  background-color: #eee;\n  padding: 0 0.5em;\n  overflow: hidden;\n}\n\n.slider-fg {\n  padding: 1px 0 2px 0;\n  background-color: #aaa;\n  height: 1em;\n  margin-left: -0.5em;\n  padding-right: 0.5em;\n  border-radius: 1em 0 0 1em;\n}\n\n.slider-fg:after {\n  display: inline-block;\n  border-radius: 1em;\n  background-color: #fff;\n  border:  1px solid #aaa;\n  content: '';\n  float: right;\n  margin-right: -1em;\n  margin-top: -1px;\n  height: 0.9em;\n  width: 0.9em;\n}");


dat.controllers.FunctionController = (function (Controller, dom, common) {

  /**
   * @class Provides a GUI interface to fire a specified method, a property of an object.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var FunctionController = function(object, property, text) {

    FunctionController.superclass.call(this, object, property);

    var _this = this;

    this.__button = document.createElement('div');
    this.__button.innerHTML = text === undefined ? 'Fire' : text;
    dom.bind(this.__button, 'click', function(e) {
      e.preventDefault();
      _this.fire();
      return false;
    });

    dom.addClass(this.__button, 'button');

    this.domElement.appendChild(this.__button);


  };

  FunctionController.superclass = Controller;

  common.extend(

      FunctionController.prototype,
      Controller.prototype,
      {
        
        fire: function() {
          if (this.__onChange) {
            this.__onChange.call(this);
          }
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          this.getValue().call(this.object);
        }
      }

  );

  return FunctionController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.controllers.BooleanController = (function (Controller, dom, common) {

  /**
   * @class Provides a checkbox input to alter the boolean property of an object.
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var BooleanController = function(object, property) {

    BooleanController.superclass.call(this, object, property);

    var _this = this;
    this.__prev = this.getValue();

    this.__checkbox = document.createElement('input');
    this.__checkbox.setAttribute('type', 'checkbox');


    dom.bind(this.__checkbox, 'change', onChange, false);

    this.domElement.appendChild(this.__checkbox);

    // Match original value
    this.updateDisplay();

    function onChange() {
      _this.setValue(!_this.__prev);
    }

  };

  BooleanController.superclass = Controller;

  common.extend(

      BooleanController.prototype,
      Controller.prototype,

      {

        setValue: function(v) {
          var toReturn = BooleanController.superclass.prototype.setValue.call(this, v);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          this.__prev = this.getValue();
          return toReturn;
        },

        updateDisplay: function() {
          
          if (this.getValue() === true) {
            this.__checkbox.setAttribute('checked', 'checked');
            this.__checkbox.checked = true;    
          } else {
              this.__checkbox.checked = false;
          }

          return BooleanController.superclass.prototype.updateDisplay.call(this);

        }


      }

  );

  return BooleanController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.color.toString = (function (common) {

  return function(color) {

    if (color.a == 1 || common.isUndefined(color.a)) {

      var s = color.hex.toString(16);
      while (s.length < 6) {
        s = '0' + s;
      }

      return '#' + s;

    } else {

      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';

    }

  }

})(dat.utils.common);


dat.color.interpret = (function (toString, common) {

  var result, toReturn;

  var interpret = function() {

    toReturn = false;

    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];

    common.each(INTERPRETATIONS, function(family) {

      if (family.litmus(original)) {

        common.each(family.conversions, function(conversion, conversionName) {

          result = conversion.read(original);

          if (toReturn === false && result !== false) {
            toReturn = result;
            result.conversionName = conversionName;
            result.conversion = conversion;
            return common.BREAK;

          }

        });

        return common.BREAK;

      }

    });

    return toReturn;

  };

  var INTERPRETATIONS = [

    // Strings
    {

      litmus: common.isString,

      conversions: {

        THREE_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt(
                  '0x' +
                      test[1].toString() + test[1].toString() +
                      test[2].toString() + test[2].toString() +
                      test[3].toString() + test[3].toString())
            };

          },

          write: toString

        },

        SIX_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9]{6})$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt('0x' + test[1].toString())
            };

          },

          write: toString

        },

        CSS_RGB: {

          read: function(original) {

            var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3])
            };

          },

          write: toString

        },

        CSS_RGBA: {

          read: function(original) {

            var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3]),
              a: parseFloat(test[4])
            };

          },

          write: toString

        }

      }

    },

    // Numbers
    {

      litmus: common.isNumber,

      conversions: {

        HEX: {
          read: function(original) {
            return {
              space: 'HEX',
              hex: original,
              conversionName: 'HEX'
            }
          },

          write: function(color) {
            return color.hex;
          }
        }

      }

    },

    // Arrays
    {

      litmus: common.isArray,

      conversions: {

        RGB_ARRAY: {
          read: function(original) {
            if (original.length != 3) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b];
          }

        },

        RGBA_ARRAY: {
          read: function(original) {
            if (original.length != 4) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2],
              a: original[3]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b, color.a];
          }

        }

      }

    },

    // Objects
    {

      litmus: common.isObject,

      conversions: {

        RGBA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b) &&
                common.isNumber(original.a)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b,
              a: color.a
            }
          }
        },

        RGB_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b
            }
          }
        },

        HSVA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v) &&
                common.isNumber(original.a)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v,
              a: color.a
            }
          }
        },

        HSV_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v
            }
          }

        }

      }

    }


  ];

  return interpret;


})(dat.color.toString,
dat.utils.common);


dat.GUI = dat.gui.GUI = (function (css, saveDialogueContents, styleSheet, controllerFactory, Controller, BooleanController, FunctionController, NumberControllerBox, NumberControllerSlider, OptionController, ColorController, requestAnimationFrame, CenteredDiv, dom, common) {

  css.inject(styleSheet);

  /** Outer-most className for GUI's */
  var CSS_NAMESPACE = 'dg';

  var HIDE_KEY_CODE = 72;

  /** The only value shared between the JS and SCSS. Use caution. */
  var CLOSE_BUTTON_HEIGHT = 20;

  var DEFAULT_DEFAULT_PRESET_NAME = 'Default';

  var SUPPORTS_LOCAL_STORAGE = (function() {
    try {
      return 'localStorage' in window && window['localStorage'] !== null;
    } catch (e) {
      return false;
    }
  })();

  var SAVE_DIALOGUE;

  /** Have we yet to create an autoPlace GUI? */
  var auto_place_virgin = true;

  /** Fixed position div that auto place GUI's go inside */
  var auto_place_container;

  /** Are we hiding the GUI's ? */
  var hide = false;

  /** GUI's which should be hidden */
  var hideable_guis = [];

  /**
   * A lightweight controller library for JavaScript. It allows you to easily
   * manipulate variables and fire functions on the fly.
   * @class
   *
   * @member dat.gui
   *
   * @param {Object} [params]
   * @param {String} [params.name] The name of this GUI.
   * @param {Object} [params.load] JSON object representing the saved state of
   * this GUI.
   * @param {Boolean} [params.auto=true]
   * @param {dat.gui.GUI} [params.parent] The GUI I'm nested in.
   * @param {Boolean} [params.closed] If true, starts closed
   */
  var GUI = function(params) {

    var _this = this;

    /**
     * Outermost DOM Element
     * @type DOMElement
     */
    this.domElement = document.createElement('div');
    this.__ul = document.createElement('ul');
    this.domElement.appendChild(this.__ul);

    dom.addClass(this.domElement, CSS_NAMESPACE);

    /**
     * Nested GUI's by name
     * @ignore
     */
    this.__folders = {};

    this.__controllers = [];

    /**
     * List of objects I'm remembering for save, only used in top level GUI
     * @ignore
     */
    this.__rememberedObjects = [];

    /**
     * Maps the index of remembered objects to a map of controllers, only used
     * in top level GUI.
     *
     * @private
     * @ignore
     *
     * @example
     * [
     *  {
     *    propertyName: Controller,
     *    anotherPropertyName: Controller
     *  },
     *  {
     *    propertyName: Controller
     *  }
     * ]
     */
    this.__rememberedObjectIndecesToControllers = [];

    this.__listening = [];

    params = params || {};

    // Default parameters
    params = common.defaults(params, {
      autoPlace: true,
      width: GUI.DEFAULT_WIDTH
    });

    params = common.defaults(params, {
      resizable: params.autoPlace,
      hideable: params.autoPlace
    });


    if (!common.isUndefined(params.load)) {

      // Explicit preset
      if (params.preset) params.load.preset = params.preset;

    } else {

      params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };

    }

    if (common.isUndefined(params.parent) && params.hideable) {
      hideable_guis.push(this);
    }

    // Only root level GUI's are resizable.
    params.resizable = common.isUndefined(params.parent) && params.resizable;


    if (params.autoPlace && common.isUndefined(params.scrollable)) {
      params.scrollable = true;
    }
//    params.scrollable = common.isUndefined(params.parent) && params.scrollable === true;

    // Not part of params because I don't want people passing this in via
    // constructor. Should be a 'remembered' value.
    var use_local_storage =
        SUPPORTS_LOCAL_STORAGE &&
            localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';

    Object.defineProperties(this,

        /** @lends dat.gui.GUI.prototype */
        {

          /**
           * The parent <code>GUI</code>
           * @type dat.gui.GUI
           */
          parent: {
            get: function() {
              return params.parent;
            }
          },

          scrollable: {
            get: function() {
              return params.scrollable;
            }
          },

          /**
           * Handles <code>GUI</code>'s element placement for you
           * @type Boolean
           */
          autoPlace: {
            get: function() {
              return params.autoPlace;
            }
          },

          /**
           * The identifier for a set of saved values
           * @type String
           */
          preset: {

            get: function() {
              if (_this.parent) {
                return _this.getRoot().preset;
              } else {
                return params.load.preset;
              }
            },

            set: function(v) {
              if (_this.parent) {
                _this.getRoot().preset = v;
              } else {
                params.load.preset = v;
              }
              setPresetSelectIndex(this);
              _this.revert();
            }

          },

          /**
           * The width of <code>GUI</code> element
           * @type Number
           */
          width: {
            get: function() {
              return params.width;
            },
            set: function(v) {
              params.width = v;
              setWidth(_this, v);
            }
          },

          /**
           * The name of <code>GUI</code>. Used for folders. i.e
           * a folder's name
           * @type String
           */
          name: {
            get: function() {
              return params.name;
            },
            set: function(v) {
              // TODO Check for collisions among sibling folders
              params.name = v;
              if (title_row_name) {
                title_row_name.innerHTML = params.name;
              }
            }
          },

          /**
           * Whether the <code>GUI</code> is collapsed or not
           * @type Boolean
           */
          closed: {
            get: function() {
              return params.closed;
            },
            set: function(v) {
              params.closed = v;
              if (params.closed) {
                dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
              } else {
                dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
              }
              // For browsers that aren't going to respect the CSS transition,
              // Lets just check our height against the window height right off
              // the bat.
              this.onResize();

              if (_this.__closeButton) {
                _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
              }
            }
          },

          /**
           * Contains all presets
           * @type Object
           */
          load: {
            get: function() {
              return params.load;
            }
          },

          /**
           * Determines whether or not to use <a href="https://developer.mozilla.org/en/DOM/Storage#localStorage">localStorage</a> as the means for
           * <code>remember</code>ing
           * @type Boolean
           */
          useLocalStorage: {

            get: function() {
              return use_local_storage;
            },
            set: function(bool) {
              if (SUPPORTS_LOCAL_STORAGE) {
                use_local_storage = bool;
                if (bool) {
                  dom.bind(window, 'unload', saveToLocalStorage);
                } else {
                  dom.unbind(window, 'unload', saveToLocalStorage);
                }
                localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
              }
            }

          }

        });

    // Are we a root level GUI?
    if (common.isUndefined(params.parent)) {

      params.closed = false;

      dom.addClass(this.domElement, GUI.CLASS_MAIN);
      dom.makeSelectable(this.domElement, false);

      // Are we supposed to be loading locally?
      if (SUPPORTS_LOCAL_STORAGE) {

        if (use_local_storage) {

          _this.useLocalStorage = true;

          var saved_gui = localStorage.getItem(getLocalStorageHash(this, 'gui'));

          if (saved_gui) {
            params.load = JSON.parse(saved_gui);
          }

        }

      }

      this.__closeButton = document.createElement('div');
      this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
      this.domElement.appendChild(this.__closeButton);

      dom.bind(this.__closeButton, 'click', function() {

        _this.closed = !_this.closed;


      });


      // Oh, you're a nested GUI!
    } else {

      if (params.closed === undefined) {
        params.closed = true;
      }

      var title_row_name = document.createTextNode(params.name);
      dom.addClass(title_row_name, 'controller-name');

      var title_row = addRow(_this, title_row_name);

      var on_click_title = function(e) {
        e.preventDefault();
        _this.closed = !_this.closed;
        return false;
      };

      dom.addClass(this.__ul, GUI.CLASS_CLOSED);

      dom.addClass(title_row, 'title');
      dom.bind(title_row, 'click', on_click_title);

      if (!params.closed) {
        this.closed = false;
      }

    }

    if (params.autoPlace) {

      if (common.isUndefined(params.parent)) {

        if (auto_place_virgin) {
          auto_place_container = document.createElement('div');
          dom.addClass(auto_place_container, CSS_NAMESPACE);
          dom.addClass(auto_place_container, GUI.CLASS_AUTO_PLACE_CONTAINER);
          document.body.appendChild(auto_place_container);
          auto_place_virgin = false;
        }

        // Put it in the dom for you.
        auto_place_container.appendChild(this.domElement);

        // Apply the auto styles
        dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);

      }


      // Make it not elastic.
      if (!this.parent) setWidth(_this, params.width);

    }

    dom.bind(window, 'resize', function() { _this.onResize() });
    dom.bind(this.__ul, 'webkitTransitionEnd', function() { _this.onResize(); });
    dom.bind(this.__ul, 'transitionend', function() { _this.onResize() });
    dom.bind(this.__ul, 'oTransitionEnd', function() { _this.onResize() });
    this.onResize();


    if (params.resizable) {
      addResizeHandle(this);
    }

    function saveToLocalStorage() {
      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
    }

    var root = _this.getRoot();
    function resetWidth() {
        var root = _this.getRoot();
        root.width += 1;
        common.defer(function() {
          root.width -= 1;
        });
      }

      if (!params.parent) {
        resetWidth();
      }

  };

  GUI.toggleHide = function() {

    hide = !hide;
    common.each(hideable_guis, function(gui) {
      gui.domElement.style.zIndex = hide ? -999 : 999;
      gui.domElement.style.opacity = hide ? 0 : 1;
    });
  };

  GUI.CLASS_AUTO_PLACE = 'a';
  GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
  GUI.CLASS_MAIN = 'main';
  GUI.CLASS_CONTROLLER_ROW = 'cr';
  GUI.CLASS_TOO_TALL = 'taller-than-window';
  GUI.CLASS_CLOSED = 'closed';
  GUI.CLASS_CLOSE_BUTTON = 'close-button';
  GUI.CLASS_DRAG = 'drag';

  GUI.DEFAULT_WIDTH = 245;
  GUI.TEXT_CLOSED = 'Close Controls';
  GUI.TEXT_OPEN = 'Open Controls';

  dom.bind(window, 'keydown', function(e) {

    if (document.activeElement.type !== 'text' &&
        (e.which === HIDE_KEY_CODE || e.keyCode == HIDE_KEY_CODE)) {
      GUI.toggleHide();
    }

  }, false);

  common.extend(

      GUI.prototype,

      /** @lends dat.gui.GUI */
      {

        /**
         * @param object
         * @param property
         * @returns {dat.controllers.Controller} The new controller that was added.
         * @instance
         */
        add: function(object, property) {

          return add(
              this,
              object,
              property,
              {
                factoryArgs: Array.prototype.slice.call(arguments, 2)
              }
          );

        },

        /**
         * @param object
         * @param property
         * @returns {dat.controllers.ColorController} The new controller that was added.
         * @instance
         */
        addColor: function(object, property) {

          return add(
              this,
              object,
              property,
              {
                color: true
              }
          );

        },

        /**
         * @param controller
         * @instance
         */
        remove: function(controller) {

          // TODO listening?
          this.__ul.removeChild(controller.__li);
          this.__controllers.slice(this.__controllers.indexOf(controller), 1);
          var _this = this;
          common.defer(function() {
            _this.onResize();
          });

        },

        destroy: function() {

          if (this.autoPlace) {
            auto_place_container.removeChild(this.domElement);
          }

        },

        /**
         * @param name
         * @returns {dat.gui.GUI} The new folder.
         * @throws {Error} if this GUI already has a folder by the specified
         * name
         * @instance
         */
        addFolder: function(name) {

          // We have to prevent collisions on names in order to have a key
          // by which to remember saved values
          if (this.__folders[name] !== undefined) {
            throw new Error('You already have a folder in this GUI by the' +
                ' name "' + name + '"');
          }

          var new_gui_params = { name: name, parent: this };

          // We need to pass down the autoPlace trait so that we can
          // attach event listeners to open/close folder actions to
          // ensure that a scrollbar appears if the window is too short.
          new_gui_params.autoPlace = this.autoPlace;

          // Do we have saved appearance data for this folder?

          if (this.load && // Anything loaded?
              this.load.folders && // Was my parent a dead-end?
              this.load.folders[name]) { // Did daddy remember me?

            // Start me closed if I was closed
            new_gui_params.closed = this.load.folders[name].closed;

            // Pass down the loaded data
            new_gui_params.load = this.load.folders[name];

          }

          var gui = new GUI(new_gui_params);
          this.__folders[name] = gui;

          var li = addRow(this, gui.domElement);
          dom.addClass(li, 'folder');
          return gui;

        },

        open: function() {
          this.closed = false;
        },

        close: function() {
          this.closed = true;
        },

        onResize: function() {

          var root = this.getRoot();

          if (root.scrollable) {

            var top = dom.getOffset(root.__ul).top;
            var h = 0;

            common.each(root.__ul.childNodes, function(node) {
              if (! (root.autoPlace && node === root.__save_row))
                h += dom.getHeight(node);
            });

            if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
              dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
              root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
            } else {
              dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
              root.__ul.style.height = 'auto';
            }

          }

          if (root.__resize_handle) {
            common.defer(function() {
              root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
            });
          }

          if (root.__closeButton) {
            root.__closeButton.style.width = root.width + 'px';
          }

        },

        /**
         * Mark objects for saving. The order of these objects cannot change as
         * the GUI grows. When remembering new objects, append them to the end
         * of the list.
         *
         * @param {Object...} objects
         * @throws {Error} if not called on a top level GUI.
         * @instance
         */
        remember: function() {

          if (common.isUndefined(SAVE_DIALOGUE)) {
            SAVE_DIALOGUE = new CenteredDiv();
            SAVE_DIALOGUE.domElement.innerHTML = saveDialogueContents;
          }

          if (this.parent) {
            throw new Error("You can only call remember on a top level GUI.");
          }

          var _this = this;

          common.each(Array.prototype.slice.call(arguments), function(object) {
            if (_this.__rememberedObjects.length == 0) {
              addSaveMenu(_this);
            }
            if (_this.__rememberedObjects.indexOf(object) == -1) {
              _this.__rememberedObjects.push(object);
            }
          });

          if (this.autoPlace) {
            // Set save row width
            setWidth(this, this.width);
          }

        },

        /**
         * @returns {dat.gui.GUI} the topmost parent GUI of a nested GUI.
         * @instance
         */
        getRoot: function() {
          var gui = this;
          while (gui.parent) {
            gui = gui.parent;
          }
          return gui;
        },

        /**
         * @returns {Object} a JSON object representing the current state of
         * this GUI as well as its remembered properties.
         * @instance
         */
        getSaveObject: function() {

          var toReturn = this.load;

          toReturn.closed = this.closed;

          // Am I remembering any values?
          if (this.__rememberedObjects.length > 0) {

            toReturn.preset = this.preset;

            if (!toReturn.remembered) {
              toReturn.remembered = {};
            }

            toReturn.remembered[this.preset] = getCurrentPreset(this);

          }

          toReturn.folders = {};
          common.each(this.__folders, function(element, key) {
            toReturn.folders[key] = element.getSaveObject();
          });

          return toReturn;

        },

        save: function() {

          if (!this.load.remembered) {
            this.load.remembered = {};
          }

          this.load.remembered[this.preset] = getCurrentPreset(this);
          markPresetModified(this, false);

        },

        saveAs: function(presetName) {

          if (!this.load.remembered) {

            // Retain default values upon first save
            this.load.remembered = {};
            this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);

          }

          this.load.remembered[presetName] = getCurrentPreset(this);
          this.preset = presetName;
          addPresetOption(this, presetName, true);

        },

        revert: function(gui) {

          common.each(this.__controllers, function(controller) {
            // Make revert work on Default.
            if (!this.getRoot().load.remembered) {
              controller.setValue(controller.initialValue);
            } else {
              recallSavedValue(gui || this.getRoot(), controller);
            }
          }, this);

          common.each(this.__folders, function(folder) {
            folder.revert(folder);
          });

          if (!gui) {
            markPresetModified(this.getRoot(), false);
          }


        },

        listen: function(controller) {

          var init = this.__listening.length == 0;
          this.__listening.push(controller);
          if (init) updateDisplays(this.__listening);

        }

      }

  );

  function add(gui, object, property, params) {

    if (object[property] === undefined) {
      throw new Error("Object " + object + " has no property \"" + property + "\"");
    }

    var controller;

    if (params.color) {

      controller = new ColorController(object, property);

    } else {

      var factoryArgs = [object,property].concat(params.factoryArgs);
      controller = controllerFactory.apply(gui, factoryArgs);

    }

    if (params.before instanceof Controller) {
      params.before = params.before.__li;
    }

    recallSavedValue(gui, controller);

    dom.addClass(controller.domElement, 'c');

    var name = document.createElement('span');
    dom.addClass(name, 'property-name');
    name.innerHTML = controller.property;

    var container = document.createElement('div');
    container.appendChild(name);
    container.appendChild(controller.domElement);

    var li = addRow(gui, container, params.before);

    dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
    dom.addClass(li, typeof controller.getValue());

    augmentController(gui, li, controller);

    gui.__controllers.push(controller);

    return controller;

  }

  /**
   * Add a row to the end of the GUI or before another row.
   *
   * @param gui
   * @param [dom] If specified, inserts the dom content in the new row
   * @param [liBefore] If specified, places the new row before another row
   */
  function addRow(gui, dom, liBefore) {
    var li = document.createElement('li');
    if (dom) li.appendChild(dom);
    if (liBefore) {
      gui.__ul.insertBefore(li, params.before);
    } else {
      gui.__ul.appendChild(li);
    }
    gui.onResize();
    return li;
  }

  function augmentController(gui, li, controller) {

    controller.__li = li;
    controller.__gui = gui;

    common.extend(controller, {

      options: function(options) {

        if (arguments.length > 1) {
          controller.remove();

          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [common.toArray(arguments)]
              }
          );

        }

        if (common.isArray(options) || common.isObject(options)) {
          controller.remove();

          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [options]
              }
          );

        }

      },

      name: function(v) {
        controller.__li.firstElementChild.firstElementChild.innerHTML = v;
        return controller;
      },

      listen: function() {
        controller.__gui.listen(controller);
        return controller;
      },

      remove: function() {
        controller.__gui.remove(controller);
        return controller;
      }

    });

    // All sliders should be accompanied by a box.
    if (controller instanceof NumberControllerSlider) {

      var box = new NumberControllerBox(controller.object, controller.property,
          { min: controller.__min, max: controller.__max, step: controller.__step });

      common.each(['updateDisplay', 'onChange', 'onFinishChange'], function(method) {
        var pc = controller[method];
        var pb = box[method];
        controller[method] = box[method] = function() {
          var args = Array.prototype.slice.call(arguments);
          pc.apply(controller, args);
          return pb.apply(box, args);
        }
      });

      dom.addClass(li, 'has-slider');
      controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);

    }
    else if (controller instanceof NumberControllerBox) {

      var r = function(returned) {

        // Have we defined both boundaries?
        if (common.isNumber(controller.__min) && common.isNumber(controller.__max)) {

          // Well, then lets just replace this with a slider.
          controller.remove();
          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [controller.__min, controller.__max, controller.__step]
              });

        }

        return returned;

      };

      controller.min = common.compose(r, controller.min);
      controller.max = common.compose(r, controller.max);

    }
    else if (controller instanceof BooleanController) {

      dom.bind(li, 'click', function() {
        dom.fakeEvent(controller.__checkbox, 'click');
      });

      dom.bind(controller.__checkbox, 'click', function(e) {
        e.stopPropagation(); // Prevents double-toggle
      })

    }
    else if (controller instanceof FunctionController) {

      dom.bind(li, 'click', function() {
        dom.fakeEvent(controller.__button, 'click');
      });

      dom.bind(li, 'mouseover', function() {
        dom.addClass(controller.__button, 'hover');
      });

      dom.bind(li, 'mouseout', function() {
        dom.removeClass(controller.__button, 'hover');
      });

    }
    else if (controller instanceof ColorController) {

      dom.addClass(li, 'color');
      controller.updateDisplay = common.compose(function(r) {
        li.style.borderLeftColor = controller.__color.toString();
        return r;
      }, controller.updateDisplay);

      controller.updateDisplay();

    }

    controller.setValue = common.compose(function(r) {
      if (gui.getRoot().__preset_select && controller.isModified()) {
        markPresetModified(gui.getRoot(), true);
      }
      return r;
    }, controller.setValue);

  }

  function recallSavedValue(gui, controller) {

    // Find the topmost GUI, that's where remembered objects live.
    var root = gui.getRoot();

    // Does the object we're controlling match anything we've been told to
    // remember?
    var matched_index = root.__rememberedObjects.indexOf(controller.object);

    // Why yes, it does!
    if (matched_index != -1) {

      // Let me fetch a map of controllers for thcommon.isObject.
      var controller_map =
          root.__rememberedObjectIndecesToControllers[matched_index];

      // Ohp, I believe this is the first controller we've created for this
      // object. Lets make the map fresh.
      if (controller_map === undefined) {
        controller_map = {};
        root.__rememberedObjectIndecesToControllers[matched_index] =
            controller_map;
      }

      // Keep track of this controller
      controller_map[controller.property] = controller;

      // Okay, now have we saved any values for this controller?
      if (root.load && root.load.remembered) {

        var preset_map = root.load.remembered;

        // Which preset are we trying to load?
        var preset;

        if (preset_map[gui.preset]) {

          preset = preset_map[gui.preset];

        } else if (preset_map[DEFAULT_DEFAULT_PRESET_NAME]) {

          // Uhh, you can have the default instead?
          preset = preset_map[DEFAULT_DEFAULT_PRESET_NAME];

        } else {

          // Nada.

          return;

        }


        // Did the loaded object remember thcommon.isObject?
        if (preset[matched_index] &&

          // Did we remember this particular property?
            preset[matched_index][controller.property] !== undefined) {

          // We did remember something for this guy ...
          var value = preset[matched_index][controller.property];

          // And that's what it is.
          controller.initialValue = value;
          controller.setValue(value);

        }

      }

    }

  }

  function getLocalStorageHash(gui, key) {
    // TODO how does this deal with multiple GUI's?
    return document.location.href + '.' + key;

  }

  function addSaveMenu(gui) {

    var div = gui.__save_row = document.createElement('li');

    dom.addClass(gui.domElement, 'has-save');

    gui.__ul.insertBefore(div, gui.__ul.firstChild);

    dom.addClass(div, 'save-row');

    var gears = document.createElement('span');
    gears.innerHTML = '&nbsp;';
    dom.addClass(gears, 'button gears');

    // TODO replace with FunctionController
    var button = document.createElement('span');
    button.innerHTML = 'Save';
    dom.addClass(button, 'button');
    dom.addClass(button, 'save');

    var button2 = document.createElement('span');
    button2.innerHTML = 'New';
    dom.addClass(button2, 'button');
    dom.addClass(button2, 'save-as');

    var button3 = document.createElement('span');
    button3.innerHTML = 'Revert';
    dom.addClass(button3, 'button');
    dom.addClass(button3, 'revert');

    var select = gui.__preset_select = document.createElement('select');

    if (gui.load && gui.load.remembered) {

      common.each(gui.load.remembered, function(value, key) {
        addPresetOption(gui, key, key == gui.preset);
      });

    } else {
      addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
    }

    dom.bind(select, 'change', function() {


      for (var index = 0; index < gui.__preset_select.length; index++) {
        gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
      }

      gui.preset = this.value;

    });

    div.appendChild(select);
    div.appendChild(gears);
    div.appendChild(button);
    div.appendChild(button2);
    div.appendChild(button3);

    if (SUPPORTS_LOCAL_STORAGE) {

      var saveLocally = document.getElementById('dg-save-locally');
      var explain = document.getElementById('dg-local-explain');

      saveLocally.style.display = 'block';

      var localStorageCheckBox = document.getElementById('dg-local-storage');

      if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
        localStorageCheckBox.setAttribute('checked', 'checked');
      }

      function showHideExplain() {
        explain.style.display = gui.useLocalStorage ? 'block' : 'none';
      }

      showHideExplain();

      // TODO: Use a boolean controller, fool!
      dom.bind(localStorageCheckBox, 'change', function() {
        gui.useLocalStorage = !gui.useLocalStorage;
        showHideExplain();
      });

    }

    var newConstructorTextArea = document.getElementById('dg-new-constructor');

    dom.bind(newConstructorTextArea, 'keydown', function(e) {
      if (e.metaKey && (e.which === 67 || e.keyCode == 67)) {
        SAVE_DIALOGUE.hide();
      }
    });

    dom.bind(gears, 'click', function() {
      newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
      SAVE_DIALOGUE.show();
      newConstructorTextArea.focus();
      newConstructorTextArea.select();
    });

    dom.bind(button, 'click', function() {
      gui.save();
    });

    dom.bind(button2, 'click', function() {
      var presetName = prompt('Enter a new preset name.');
      if (presetName) gui.saveAs(presetName);
    });

    dom.bind(button3, 'click', function() {
      gui.revert();
    });

//    div.appendChild(button2);

  }

  function addResizeHandle(gui) {

    gui.__resize_handle = document.createElement('div');

    common.extend(gui.__resize_handle.style, {

      width: '6px',
      marginLeft: '-3px',
      height: '200px',
      cursor: 'ew-resize',
      position: 'absolute'
//      border: '1px solid blue'

    });

    var pmouseX;

    dom.bind(gui.__resize_handle, 'mousedown', dragStart);
    dom.bind(gui.__closeButton, 'mousedown', dragStart);

    gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);

    function dragStart(e) {

      e.preventDefault();

      pmouseX = e.clientX;

      dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.bind(window, 'mousemove', drag);
      dom.bind(window, 'mouseup', dragStop);

      return false;

    }

    function drag(e) {

      e.preventDefault();

      gui.width += pmouseX - e.clientX;
      gui.onResize();
      pmouseX = e.clientX;

      return false;

    }

    function dragStop() {

      dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.unbind(window, 'mousemove', drag);
      dom.unbind(window, 'mouseup', dragStop);

    }

  }

  function setWidth(gui, w) {
    gui.domElement.style.width = w + 'px';
    // Auto placed save-rows are position fixed, so we have to
    // set the width manually if we want it to bleed to the edge
    if (gui.__save_row && gui.autoPlace) {
      gui.__save_row.style.width = w + 'px';
    }if (gui.__closeButton) {
      gui.__closeButton.style.width = w + 'px';
    }
  }

  function getCurrentPreset(gui, useInitialValues) {

    var toReturn = {};

    // For each object I'm remembering
    common.each(gui.__rememberedObjects, function(val, index) {

      var saved_values = {};

      // The controllers I've made for thcommon.isObject by property
      var controller_map =
          gui.__rememberedObjectIndecesToControllers[index];

      // Remember each value for each property
      common.each(controller_map, function(controller, property) {
        saved_values[property] = useInitialValues ? controller.initialValue : controller.getValue();
      });

      // Save the values for thcommon.isObject
      toReturn[index] = saved_values;

    });

    return toReturn;

  }

  function addPresetOption(gui, name, setSelected) {
    var opt = document.createElement('option');
    opt.innerHTML = name;
    opt.value = name;
    gui.__preset_select.appendChild(opt);
    if (setSelected) {
      gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
    }
  }

  function setPresetSelectIndex(gui) {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      if (gui.__preset_select[index].value == gui.preset) {
        gui.__preset_select.selectedIndex = index;
      }
    }
  }

  function markPresetModified(gui, modified) {
    var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
//    console.log('mark', modified, opt);
    if (modified) {
      opt.innerHTML = opt.value + "*";
    } else {
      opt.innerHTML = opt.value;
    }
  }

  function updateDisplays(controllerArray) {


    if (controllerArray.length != 0) {

      requestAnimationFrame(function() {
        updateDisplays(controllerArray);
      });

    }

    common.each(controllerArray, function(c) {
      c.updateDisplay();
    });

  }

  return GUI;

})(dat.utils.css,
"<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n      \n    </div>\n    \n  </div>\n\n</div>",
".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear;border:0;position:absolute;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-x:hidden}.dg.a.has-save ul{margin-top:27px}.dg.a.has-save ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height 0.1s ease-out;-o-transition:height 0.1s ease-out;-moz-transition:height 0.1s ease-out;transition:height 0.1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li > *{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n",
dat.controllers.factory = (function (OptionController, NumberControllerBox, NumberControllerSlider, StringController, FunctionController, BooleanController, common) {

      return function(object, property) {

        var initialValue = object[property];

        // Providing options?
        if (common.isArray(arguments[2]) || common.isObject(arguments[2])) {
          return new OptionController(object, property, arguments[2]);
        }

        // Providing a map?

        if (common.isNumber(initialValue)) {

          if (common.isNumber(arguments[2]) && common.isNumber(arguments[3])) {

            // Has min and max.
            return new NumberControllerSlider(object, property, arguments[2], arguments[3]);

          } else {

            return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });

          }

        }

        if (common.isString(initialValue)) {
          return new StringController(object, property);
        }

        if (common.isFunction(initialValue)) {
          return new FunctionController(object, property, '');
        }

        if (common.isBoolean(initialValue)) {
          return new BooleanController(object, property);
        }

      }

    })(dat.controllers.OptionController,
dat.controllers.NumberControllerBox,
dat.controllers.NumberControllerSlider,
dat.controllers.StringController = (function (Controller, dom, common) {

  /**
   * @class Provides a text input to alter the string property of an object.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var StringController = function(object, property) {

    StringController.superclass.call(this, object, property);

    var _this = this;

    this.__input = document.createElement('input');
    this.__input.setAttribute('type', 'text');

    dom.bind(this.__input, 'keyup', onChange);
    dom.bind(this.__input, 'change', onChange);
    dom.bind(this.__input, 'blur', onBlur);
    dom.bind(this.__input, 'keydown', function(e) {
      if (e.keyCode === 13) {
        this.blur();
      }
    });
    

    function onChange() {
      _this.setValue(_this.__input.value);
    }

    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    this.updateDisplay();

    this.domElement.appendChild(this.__input);

  };

  StringController.superclass = Controller;

  common.extend(

      StringController.prototype,
      Controller.prototype,

      {

        updateDisplay: function() {
          // Stops the caret from moving on account of:
          // keyup -> setValue -> updateDisplay
          if (!dom.isActive(this.__input)) {
            this.__input.value = this.getValue();
          }
          return StringController.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  return StringController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common),
dat.controllers.FunctionController,
dat.controllers.BooleanController,
dat.utils.common),
dat.controllers.Controller,
dat.controllers.BooleanController,
dat.controllers.FunctionController,
dat.controllers.NumberControllerBox,
dat.controllers.NumberControllerSlider,
dat.controllers.OptionController,
dat.controllers.ColorController = (function (Controller, dom, Color, interpret, common) {

  var ColorController = function(object, property) {

    ColorController.superclass.call(this, object, property);

    this.__color = new Color(this.getValue());
    this.__temp = new Color(0);

    var _this = this;

    this.domElement = document.createElement('div');

    dom.makeSelectable(this.domElement, false);

    this.__selector = document.createElement('div');
    this.__selector.className = 'selector';

    this.__saturation_field = document.createElement('div');
    this.__saturation_field.className = 'saturation-field';

    this.__field_knob = document.createElement('div');
    this.__field_knob.className = 'field-knob';
    this.__field_knob_border = '2px solid ';

    this.__hue_knob = document.createElement('div');
    this.__hue_knob.className = 'hue-knob';

    this.__hue_field = document.createElement('div');
    this.__hue_field.className = 'hue-field';

    this.__input = document.createElement('input');
    this.__input.type = 'text';
    this.__input_textShadow = '0 1px 1px ';

    dom.bind(this.__input, 'keydown', function(e) {
      if (e.keyCode === 13) { // on enter
        onBlur.call(this);
      }
    });

    dom.bind(this.__input, 'blur', onBlur);

    dom.bind(this.__selector, 'mousedown', function(e) {

      dom
        .addClass(this, 'drag')
        .bind(window, 'mouseup', function(e) {
          dom.removeClass(_this.__selector, 'drag');
        });

    });

    var value_field = document.createElement('div');

    common.extend(this.__selector.style, {
      width: '122px',
      height: '102px',
      padding: '3px',
      backgroundColor: '#222',
      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
    });

    common.extend(this.__field_knob.style, {
      position: 'absolute',
      width: '12px',
      height: '12px',
      border: this.__field_knob_border + (this.__color.v < .5 ? '#fff' : '#000'),
      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
      borderRadius: '12px',
      zIndex: 1
    });
    
    common.extend(this.__hue_knob.style, {
      position: 'absolute',
      width: '15px',
      height: '2px',
      borderRight: '4px solid #fff',
      zIndex: 1
    });

    common.extend(this.__saturation_field.style, {
      width: '100px',
      height: '100px',
      border: '1px solid #555',
      marginRight: '3px',
      display: 'inline-block',
      cursor: 'pointer'
    });

    common.extend(value_field.style, {
      width: '100%',
      height: '100%',
      background: 'none'
    });
    
    linearGradient(value_field, 'top', 'rgba(0,0,0,0)', '#000');

    common.extend(this.__hue_field.style, {
      width: '15px',
      height: '100px',
      display: 'inline-block',
      border: '1px solid #555',
      cursor: 'ns-resize'
    });

    hueGradient(this.__hue_field);

    common.extend(this.__input.style, {
      outline: 'none',
//      width: '120px',
      textAlign: 'center',
//      padding: '4px',
//      marginBottom: '6px',
      color: '#fff',
      border: 0,
      fontWeight: 'bold',
      textShadow: this.__input_textShadow + 'rgba(0,0,0,0.7)'
    });

    dom.bind(this.__saturation_field, 'mousedown', fieldDown);
    dom.bind(this.__field_knob, 'mousedown', fieldDown);

    dom.bind(this.__hue_field, 'mousedown', function(e) {
      setH(e);
      dom.bind(window, 'mousemove', setH);
      dom.bind(window, 'mouseup', unbindH);
    });

    function fieldDown(e) {
      setSV(e);
      // document.body.style.cursor = 'none';
      dom.bind(window, 'mousemove', setSV);
      dom.bind(window, 'mouseup', unbindSV);
    }

    function unbindSV() {
      dom.unbind(window, 'mousemove', setSV);
      dom.unbind(window, 'mouseup', unbindSV);
      // document.body.style.cursor = 'default';
    }

    function onBlur() {
      var i = interpret(this.value);
      if (i !== false) {
        _this.__color.__state = i;
        _this.setValue(_this.__color.toOriginal());
      } else {
        this.value = _this.__color.toString();
      }
    }

    function unbindH() {
      dom.unbind(window, 'mousemove', setH);
      dom.unbind(window, 'mouseup', unbindH);
    }

    this.__saturation_field.appendChild(value_field);
    this.__selector.appendChild(this.__field_knob);
    this.__selector.appendChild(this.__saturation_field);
    this.__selector.appendChild(this.__hue_field);
    this.__hue_field.appendChild(this.__hue_knob);

    this.domElement.appendChild(this.__input);
    this.domElement.appendChild(this.__selector);

    this.updateDisplay();

    function setSV(e) {

      e.preventDefault();

      var w = dom.getWidth(_this.__saturation_field);
      var o = dom.getOffset(_this.__saturation_field);
      var s = (e.clientX - o.left + document.body.scrollLeft) / w;
      var v = 1 - (e.clientY - o.top + document.body.scrollTop) / w;

      if (v > 1) v = 1;
      else if (v < 0) v = 0;

      if (s > 1) s = 1;
      else if (s < 0) s = 0;

      _this.__color.v = v;
      _this.__color.s = s;

      _this.setValue(_this.__color.toOriginal());


      return false;

    }

    function setH(e) {

      e.preventDefault();

      var s = dom.getHeight(_this.__hue_field);
      var o = dom.getOffset(_this.__hue_field);
      var h = 1 - (e.clientY - o.top + document.body.scrollTop) / s;

      if (h > 1) h = 1;
      else if (h < 0) h = 0;

      _this.__color.h = h * 360;

      _this.setValue(_this.__color.toOriginal());

      return false;

    }

  };

  ColorController.superclass = Controller;

  common.extend(

      ColorController.prototype,
      Controller.prototype,

      {

        updateDisplay: function() {

          var i = interpret(this.getValue());

          if (i !== false) {

            var mismatch = false;

            // Check for mismatch on the interpreted value.

            common.each(Color.COMPONENTS, function(component) {
              if (!common.isUndefined(i[component]) &&
                  !common.isUndefined(this.__color.__state[component]) &&
                  i[component] !== this.__color.__state[component]) {
                mismatch = true;
                return {}; // break
              }
            }, this);

            // If nothing diverges, we keep our previous values
            // for statefulness, otherwise we recalculate fresh
            if (mismatch) {
              common.extend(this.__color.__state, i);
            }

          }

          common.extend(this.__temp.__state, this.__color.__state);

          this.__temp.a = 1;

          var flip = (this.__color.v < .5 || this.__color.s > .5) ? 255 : 0;
          var _flip = 255 - flip;

          common.extend(this.__field_knob.style, {
            marginLeft: 100 * this.__color.s - 7 + 'px',
            marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
            backgroundColor: this.__temp.toString(),
            border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip +')'
          });

          this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px'

          this.__temp.s = 1;
          this.__temp.v = 1;

          linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toString());

          common.extend(this.__input.style, {
            backgroundColor: this.__input.value = this.__color.toString(),
            color: 'rgb(' + flip + ',' + flip + ',' + flip +')',
            textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip +',.7)'
          });

        }

      }

  );
  
  var vendors = ['-moz-','-o-','-webkit-','-ms-',''];
  
  function linearGradient(elem, x, a, b) {
    elem.style.background = '';
    common.each(vendors, function(vendor) {
      elem.style.cssText += 'background: ' + vendor + 'linear-gradient('+x+', '+a+' 0%, ' + b + ' 100%); ';
    });
  }
  
  function hueGradient(elem) {
    elem.style.background = '';
    elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);'
    elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
  }


  return ColorController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.color.Color = (function (interpret, math, toString, common) {

  var Color = function() {

    this.__state = interpret.apply(this, arguments);

    if (this.__state === false) {
      throw 'Failed to interpret color arguments';
    }

    this.__state.a = this.__state.a || 1;


  };

  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];

  common.extend(Color.prototype, {

    toString: function() {
      return toString(this);
    },

    toOriginal: function() {
      return this.__state.conversion.write(this);
    }

  });

  defineRGBComponent(Color.prototype, 'r', 2);
  defineRGBComponent(Color.prototype, 'g', 1);
  defineRGBComponent(Color.prototype, 'b', 0);

  defineHSVComponent(Color.prototype, 'h');
  defineHSVComponent(Color.prototype, 's');
  defineHSVComponent(Color.prototype, 'v');

  Object.defineProperty(Color.prototype, 'a', {

    get: function() {
      return this.__state.a;
    },

    set: function(v) {
      this.__state.a = v;
    }

  });

  Object.defineProperty(Color.prototype, 'hex', {

    get: function() {

      if (!this.__state.space !== 'HEX') {
        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);
      }

      return this.__state.hex;

    },

    set: function(v) {

      this.__state.space = 'HEX';
      this.__state.hex = v;

    }

  });

  function defineRGBComponent(target, component, componentHexIndex) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'RGB') {
          return this.__state[component];
        }

        recalculateRGB(this, component, componentHexIndex);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'RGB') {
          recalculateRGB(this, component, componentHexIndex);
          this.__state.space = 'RGB';
        }

        this.__state[component] = v;

      }

    });

  }

  function defineHSVComponent(target, component) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'HSV')
          return this.__state[component];

        recalculateHSV(this);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'HSV') {
          recalculateHSV(this);
          this.__state.space = 'HSV';
        }

        this.__state[component] = v;

      }

    });

  }

  function recalculateRGB(color, component, componentHexIndex) {

    if (color.__state.space === 'HEX') {

      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);

    } else if (color.__state.space === 'HSV') {

      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));

    } else {

      throw 'Corrupted color state';

    }

  }

  function recalculateHSV(color) {

    var result = math.rgb_to_hsv(color.r, color.g, color.b);

    common.extend(color.__state,
        {
          s: result.s,
          v: result.v
        }
    );

    if (!common.isNaN(result.h)) {
      color.__state.h = result.h;
    } else if (common.isUndefined(color.__state.h)) {
      color.__state.h = 0;
    }

  }

  return Color;

})(dat.color.interpret,
dat.color.math = (function () {

  var tmpComponent;

  return {

    hsv_to_rgb: function(h, s, v) {

      var hi = Math.floor(h / 60) % 6;

      var f = h / 60 - Math.floor(h / 60);
      var p = v * (1.0 - s);
      var q = v * (1.0 - (f * s));
      var t = v * (1.0 - ((1.0 - f) * s));
      var c = [
        [v, t, p],
        [q, v, p],
        [p, v, t],
        [p, q, v],
        [t, p, v],
        [v, p, q]
      ][hi];

      return {
        r: c[0] * 255,
        g: c[1] * 255,
        b: c[2] * 255
      };

    },

    rgb_to_hsv: function(r, g, b) {

      var min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h, s;

      if (max != 0) {
        s = delta / max;
      } else {
        return {
          h: NaN,
          s: 0,
          v: 0
        };
      }

      if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }
      h /= 6;
      if (h < 0) {
        h += 1;
      }

      return {
        h: h * 360,
        s: s,
        v: max / 255
      };
    },

    rgb_to_hex: function(r, g, b) {
      var hex = this.hex_with_component(0, 2, r);
      hex = this.hex_with_component(hex, 1, g);
      hex = this.hex_with_component(hex, 0, b);
      return hex;
    },

    component_from_hex: function(hex, componentIndex) {
      return (hex >> (componentIndex * 8)) & 0xFF;
    },

    hex_with_component: function(hex, componentIndex, value) {
      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));
    }

  }

})(),
dat.color.toString,
dat.utils.common),
dat.color.interpret,
dat.utils.common),
dat.utils.requestAnimationFrame = (function () {

  /**
   * requirejs version of Paul Irish's RequestAnimationFrame
   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
   */

  return window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.oRequestAnimationFrame ||
      window.msRequestAnimationFrame ||
      function(callback, element) {

        window.setTimeout(callback, 1000 / 60);

      };
})(),
dat.dom.CenteredDiv = (function (dom, common) {


  var CenteredDiv = function() {

    this.backgroundElement = document.createElement('div');
    common.extend(this.backgroundElement.style, {
      backgroundColor: 'rgba(0,0,0,0.8)',
      top: 0,
      left: 0,
      display: 'none',
      zIndex: '1000',
      opacity: 0,
      WebkitTransition: 'opacity 0.2s linear'
    });

    dom.makeFullscreen(this.backgroundElement);
    this.backgroundElement.style.position = 'fixed';

    this.domElement = document.createElement('div');
    common.extend(this.domElement.style, {
      position: 'fixed',
      display: 'none',
      zIndex: '1001',
      opacity: 0,
      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear'
    });


    document.body.appendChild(this.backgroundElement);
    document.body.appendChild(this.domElement);

    var _this = this;
    dom.bind(this.backgroundElement, 'click', function() {
      _this.hide();
    });


  };

  CenteredDiv.prototype.show = function() {

    var _this = this;
    


    this.backgroundElement.style.display = 'block';

    this.domElement.style.display = 'block';
    this.domElement.style.opacity = 0;
//    this.domElement.style.top = '52%';
    this.domElement.style.webkitTransform = 'scale(1.1)';

    this.layout();

    common.defer(function() {
      _this.backgroundElement.style.opacity = 1;
      _this.domElement.style.opacity = 1;
      _this.domElement.style.webkitTransform = 'scale(1)';
    });

  };

  CenteredDiv.prototype.hide = function() {

    var _this = this;

    var hide = function() {

      _this.domElement.style.display = 'none';
      _this.backgroundElement.style.display = 'none';

      dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
      dom.unbind(_this.domElement, 'transitionend', hide);
      dom.unbind(_this.domElement, 'oTransitionEnd', hide);

    };

    dom.bind(this.domElement, 'webkitTransitionEnd', hide);
    dom.bind(this.domElement, 'transitionend', hide);
    dom.bind(this.domElement, 'oTransitionEnd', hide);

    this.backgroundElement.style.opacity = 0;
//    this.domElement.style.top = '48%';
    this.domElement.style.opacity = 0;
    this.domElement.style.webkitTransform = 'scale(1.1)';

  };

  CenteredDiv.prototype.layout = function() {
    this.domElement.style.left = window.innerWidth/2 - dom.getWidth(this.domElement) / 2 + 'px';
    this.domElement.style.top = window.innerHeight/2 - dom.getHeight(this.domElement) / 2 + 'px';
  };
  
  function lockScroll(e) {
    console.log(e);
  }

  return CenteredDiv;

})(dat.dom.dom,
dat.utils.common),
dat.dom.dom,
dat.utils.common);

/***/ }),
/* 127 */
/***/ (function(module, exports) {

/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

/** @namespace */
var dat = module.exports = dat || {};

/** @namespace */
dat.color = dat.color || {};

/** @namespace */
dat.utils = dat.utils || {};

dat.utils.common = (function () {
  
  var ARR_EACH = Array.prototype.forEach;
  var ARR_SLICE = Array.prototype.slice;

  /**
   * Band-aid methods for things that should be a lot easier in JavaScript.
   * Implementation and structure inspired by underscore.js
   * http://documentcloud.github.com/underscore/
   */

  return { 
    
    BREAK: {},
  
    extend: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (!this.isUndefined(obj[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
      
    },
    
    defaults: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (this.isUndefined(target[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
    
    },
    
    compose: function() {
      var toCall = ARR_SLICE.call(arguments);
            return function() {
              var args = ARR_SLICE.call(arguments);
              for (var i = toCall.length -1; i >= 0; i--) {
                args = [toCall[i].apply(this, args)];
              }
              return args[0];
            }
    },
    
    each: function(obj, itr, scope) {

      
      if (ARR_EACH && obj.forEach === ARR_EACH) { 
        
        obj.forEach(itr, scope);
        
      } else if (obj.length === obj.length + 0) { // Is number but not NaN
        
        for (var key = 0, l = obj.length; key < l; key++)
          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) 
            return;
            
      } else {

        for (var key in obj) 
          if (itr.call(scope, obj[key], key) === this.BREAK)
            return;
            
      }
            
    },
    
    defer: function(fnc) {
      setTimeout(fnc, 0);
    },
    
    toArray: function(obj) {
      if (obj.toArray) return obj.toArray();
      return ARR_SLICE.call(obj);
    },

    isUndefined: function(obj) {
      return obj === undefined;
    },
    
    isNull: function(obj) {
      return obj === null;
    },
    
    isNaN: function(obj) {
      return obj !== obj;
    },
    
    isArray: Array.isArray || function(obj) {
      return obj.constructor === Array;
    },
    
    isObject: function(obj) {
      return obj === Object(obj);
    },
    
    isNumber: function(obj) {
      return obj === obj+0;
    },
    
    isString: function(obj) {
      return obj === obj+'';
    },
    
    isBoolean: function(obj) {
      return obj === false || obj === true;
    },
    
    isFunction: function(obj) {
      return Object.prototype.toString.call(obj) === '[object Function]';
    }
  
  };
    
})();


dat.color.toString = (function (common) {

  return function(color) {

    if (color.a == 1 || common.isUndefined(color.a)) {

      var s = color.hex.toString(16);
      while (s.length < 6) {
        s = '0' + s;
      }

      return '#' + s;

    } else {

      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';

    }

  }

})(dat.utils.common);


dat.Color = dat.color.Color = (function (interpret, math, toString, common) {

  var Color = function() {

    this.__state = interpret.apply(this, arguments);

    if (this.__state === false) {
      throw 'Failed to interpret color arguments';
    }

    this.__state.a = this.__state.a || 1;


  };

  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];

  common.extend(Color.prototype, {

    toString: function() {
      return toString(this);
    },

    toOriginal: function() {
      return this.__state.conversion.write(this);
    }

  });

  defineRGBComponent(Color.prototype, 'r', 2);
  defineRGBComponent(Color.prototype, 'g', 1);
  defineRGBComponent(Color.prototype, 'b', 0);

  defineHSVComponent(Color.prototype, 'h');
  defineHSVComponent(Color.prototype, 's');
  defineHSVComponent(Color.prototype, 'v');

  Object.defineProperty(Color.prototype, 'a', {

    get: function() {
      return this.__state.a;
    },

    set: function(v) {
      this.__state.a = v;
    }

  });

  Object.defineProperty(Color.prototype, 'hex', {

    get: function() {

      if (!this.__state.space !== 'HEX') {
        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);
      }

      return this.__state.hex;

    },

    set: function(v) {

      this.__state.space = 'HEX';
      this.__state.hex = v;

    }

  });

  function defineRGBComponent(target, component, componentHexIndex) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'RGB') {
          return this.__state[component];
        }

        recalculateRGB(this, component, componentHexIndex);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'RGB') {
          recalculateRGB(this, component, componentHexIndex);
          this.__state.space = 'RGB';
        }

        this.__state[component] = v;

      }

    });

  }

  function defineHSVComponent(target, component) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'HSV')
          return this.__state[component];

        recalculateHSV(this);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'HSV') {
          recalculateHSV(this);
          this.__state.space = 'HSV';
        }

        this.__state[component] = v;

      }

    });

  }

  function recalculateRGB(color, component, componentHexIndex) {

    if (color.__state.space === 'HEX') {

      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);

    } else if (color.__state.space === 'HSV') {

      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));

    } else {

      throw 'Corrupted color state';

    }

  }

  function recalculateHSV(color) {

    var result = math.rgb_to_hsv(color.r, color.g, color.b);

    common.extend(color.__state,
        {
          s: result.s,
          v: result.v
        }
    );

    if (!common.isNaN(result.h)) {
      color.__state.h = result.h;
    } else if (common.isUndefined(color.__state.h)) {
      color.__state.h = 0;
    }

  }

  return Color;

})(dat.color.interpret = (function (toString, common) {

  var result, toReturn;

  var interpret = function() {

    toReturn = false;

    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];

    common.each(INTERPRETATIONS, function(family) {

      if (family.litmus(original)) {

        common.each(family.conversions, function(conversion, conversionName) {

          result = conversion.read(original);

          if (toReturn === false && result !== false) {
            toReturn = result;
            result.conversionName = conversionName;
            result.conversion = conversion;
            return common.BREAK;

          }

        });

        return common.BREAK;

      }

    });

    return toReturn;

  };

  var INTERPRETATIONS = [

    // Strings
    {

      litmus: common.isString,

      conversions: {

        THREE_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt(
                  '0x' +
                      test[1].toString() + test[1].toString() +
                      test[2].toString() + test[2].toString() +
                      test[3].toString() + test[3].toString())
            };

          },

          write: toString

        },

        SIX_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9]{6})$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt('0x' + test[1].toString())
            };

          },

          write: toString

        },

        CSS_RGB: {

          read: function(original) {

            var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3])
            };

          },

          write: toString

        },

        CSS_RGBA: {

          read: function(original) {

            var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3]),
              a: parseFloat(test[4])
            };

          },

          write: toString

        }

      }

    },

    // Numbers
    {

      litmus: common.isNumber,

      conversions: {

        HEX: {
          read: function(original) {
            return {
              space: 'HEX',
              hex: original,
              conversionName: 'HEX'
            }
          },

          write: function(color) {
            return color.hex;
          }
        }

      }

    },

    // Arrays
    {

      litmus: common.isArray,

      conversions: {

        RGB_ARRAY: {
          read: function(original) {
            if (original.length != 3) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b];
          }

        },

        RGBA_ARRAY: {
          read: function(original) {
            if (original.length != 4) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2],
              a: original[3]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b, color.a];
          }

        }

      }

    },

    // Objects
    {

      litmus: common.isObject,

      conversions: {

        RGBA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b) &&
                common.isNumber(original.a)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b,
              a: color.a
            }
          }
        },

        RGB_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b
            }
          }
        },

        HSVA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v) &&
                common.isNumber(original.a)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v,
              a: color.a
            }
          }
        },

        HSV_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v
            }
          }

        }

      }

    }


  ];

  return interpret;


})(dat.color.toString,
dat.utils.common),
dat.color.math = (function () {

  var tmpComponent;

  return {

    hsv_to_rgb: function(h, s, v) {

      var hi = Math.floor(h / 60) % 6;

      var f = h / 60 - Math.floor(h / 60);
      var p = v * (1.0 - s);
      var q = v * (1.0 - (f * s));
      var t = v * (1.0 - ((1.0 - f) * s));
      var c = [
        [v, t, p],
        [q, v, p],
        [p, v, t],
        [p, q, v],
        [t, p, v],
        [v, p, q]
      ][hi];

      return {
        r: c[0] * 255,
        g: c[1] * 255,
        b: c[2] * 255
      };

    },

    rgb_to_hsv: function(r, g, b) {

      var min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h, s;

      if (max != 0) {
        s = delta / max;
      } else {
        return {
          h: NaN,
          s: 0,
          v: 0
        };
      }

      if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }
      h /= 6;
      if (h < 0) {
        h += 1;
      }

      return {
        h: h * 360,
        s: s,
        v: max / 255
      };
    },

    rgb_to_hex: function(r, g, b) {
      var hex = this.hex_with_component(0, 2, r);
      hex = this.hex_with_component(hex, 1, g);
      hex = this.hex_with_component(hex, 0, b);
      return hex;
    },

    component_from_hex: function(hex, componentIndex) {
      return (hex >> (componentIndex * 8)) & 0xFF;
    },

    hex_with_component: function(hex, componentIndex, value) {
      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));
    }

  }

})(),
dat.color.toString,
dat.utils.common);

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

// stats.js - http://github.com/mrdoob/stats.js
(function(f,e){ true?module.exports=e():"function"===typeof define&&define.amd?define(e):f.Stats=e()})(this,function(){var f=function(){function e(a){c.appendChild(a.dom);return a}function u(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?"block":"none";l=a}var l=0,c=document.createElement("div");c.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";c.addEventListener("click",function(a){a.preventDefault();
u(++l%c.children.length)},!1);var k=(performance||Date).now(),g=k,a=0,r=e(new f.Panel("FPS","#0ff","#002")),h=e(new f.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var t=e(new f.Panel("MB","#f08","#201"));u(0);return{REVISION:16,dom:c,addPanel:e,showPanel:u,begin:function(){k=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();h.update(c-k,200);if(c>g+1E3&&(r.update(1E3*a/(c-g),100),g=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/
1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){k=this.end()},domElement:c,setMode:u}};f.Panel=function(e,f,l){var c=Infinity,k=0,g=Math.round,a=g(window.devicePixelRatio||1),r=80*a,h=48*a,t=3*a,v=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement("canvas");q.width=r;q.height=h;q.style.cssText="width:80px;height:48px";var b=q.getContext("2d");b.font="bold "+9*a+"px Helvetica,Arial,sans-serif";b.textBaseline="top";b.fillStyle=l;b.fillRect(0,0,r,h);b.fillStyle=f;b.fillText(e,t,v);
b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(h,w){c=Math.min(c,h);k=Math.max(k,h);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=f;b.fillText(g(h)+" "+e+" ("+g(c)+"-"+g(k)+")",t,v);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,g((1-h/w)*p))}}};return f});


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYWFjNGJjNzU0M2RjNzEzZDRkNTEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvR0xUb29sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9HTFNoYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvY29tbW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL01lc2guanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvQmF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NjaGVkdWxpbmcvc3JjL3NjaGVkdWxlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9HZW9tLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL1dlYmdsTnVtYmVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3Bvc3QvUGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9zaGFkZXJzL3NpbXBsZUNvbG9yLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9iYXNpYy52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL0ZyYW1lQnVmZmVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL0Vhc2VOdW1iZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvbWF0aC9SYXkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvY2FtZXJhcy9DYW1lcmEuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvY2FtZXJhcy9DYW1lcmFQZXJzcGVjdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9sb2FkZXJzL0JpbmFyeUxvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9zaGFkZXJzL2JpZ1RyaWFuZ2xlLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9jb3B5LmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvV2ViZ2xDb25zdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9nZXRBdHRyaWJMb2MuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvR0xUZXh0dXJlLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL0dMVGV4dHVyZTIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvR0xDdWJlVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9FdmVudERpc3BhdGNoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvT3JiaXRhbENvbnRyb2wuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvY2FtZXJhcy9DYW1lcmFPcnRoby5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9vYmplY3RzL09iamVjdDNELmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL1NoYWRlckxpYnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9nZW5lcmFsLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9za3lib3gudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9zaGFkZXJzL3NreWJveC5mcmFnIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3Bvc3QvUGFzc01hY3JvLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3Bvc3QvUGFzc1ZCbHVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3Bvc3QvUGFzc0JsdXJCYXNlLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3Bvc3QvUGFzc0hCbHVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3NoYWRlcnMvZnhhYS5mcmFnIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDJkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9xdWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC92ZWMyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL2dldEFuZEFwcGx5RXh0ZW5zaW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL2V4cG9zZUF0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvZ2V0RmxvYXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvZ2V0SGFsZkZsb2F0LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL0V4dGVuc2lvbnNMaXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbHNsaWZ5L2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9iYXNpYy5mcmFnIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL2dldFRleHR1cmVQYXJhbWV0ZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYXJzZS1kZHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvQ3ViZUZyYW1lQnVmZmVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL011bHRpc2FtcGxlRnJhbWVCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvVHJhbnNmb3JtRmVlZGJhY2tPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvVHdlZW5OdW1iZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvUXVhdFJvdGF0aW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL1RvdWNoRGV0ZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvZ2V0TW91c2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvY2FtZXJhcy9DYW1lcmFDdWJlLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2xvYWRlcnMvT2JqTG9hZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2xvYWRlcnMvSERSTG9hZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL0hEUlBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9sb2FkZXJzL0NvbGxhZGFQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvbGxhZGEtcGFyc2VyL2xpYi9Db2xsYWRhUGFyc2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb2xsYWRhLXBhcnNlci9saWIvQ29sbGFkYS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9sb2FkZXJzL0dsdGZMb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvbG9hZGVycy94aHIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvcG9zdC9FZmZlY3RDb21wb3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9wb3N0L1Bhc3NCbHVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3NoYWRlcnMvYmx1cjUuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9zaGFkZXJzL2JsdXI5LmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9ibHVyMTMuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9wb3N0L1Bhc3NGeGFhLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hDb3B5LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hBeGlzLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3NoYWRlcnMvYXhpcy52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3NoYWRlcnMvYXhpcy5mcmFnIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hCYWxsLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hEb3RzUGxhbmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9kb3RzUGxhbmUudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL0JhdGNoTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL0JhdGNoU2t5Ym94LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hTa3kuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9za3kudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL0JhdGNoRlhBQS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL1NjZW5lLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL1ZpZXczRC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZGVidWcvZGVidWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RhdC1ndWkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RhdC1ndWkvdmVuZG9yL2RhdC5ndWkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RhdC1ndWkvdmVuZG9yL2RhdC5jb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RhdHMuanMvYnVpbGQvc3RhdHMubWluLmpzIl0sIm5hbWVzIjpbImdsIiwiR0xUb29sIiwiY2FudmFzIiwiX3ZpZXdwb3J0IiwiX2VuYWJsZWRWZXJ0ZXhBdHRyaWJ1dGUiLCJpZGVudGl0eU1hdHJpeCIsImNyZWF0ZSIsIl9ub3JtYWxNYXRyaXgiLCJfaW52ZXJzZU1vZGVsVmlld01hdHJpeCIsIl9tb2RlbE1hdHJpeCIsIl9tYXRyaXgiLCJfbWF0cml4U3RhY2tzIiwiX2xhc3RNZXNoIiwiX3VzZVdlYkdMMiIsIl9oYXNBcnJheUluc3RhbmNlIiwiX2V4dEFycmF5SW5zdGFuY2UiLCJfaGFzQ2hlY2tlZEV4dCIsImlkZW50aXR5IiwiaXNNb2JpbGUiLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwibUNhbnZhcyIsIm1QYXJhbWV0ZXJzIiwidW5kZWZpbmVkIiwiY29uc29sZSIsImVycm9yIiwiZGVzdHJveSIsInNldFNpemUiLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJ1c2VXZWJnbDIiLCJjdHgiLCJnZXRDb250ZXh0IiwibG9nIiwid2ViZ2wyIiwiaW5pdFdpdGhHTCIsImV4dGVuc2lvbnMiLCJpIiwibGVuZ3RoIiwiZ2V0RXh0ZW5zaW9uIiwiZW5hYmxlIiwiREVQVEhfVEVTVCIsIkNVTExfRkFDRSIsIkJMRU5EIiwiZW5hYmxlQWxwaGFCbGVuZGluZyIsIngiLCJ5IiwidyIsImgiLCJoYXNDaGFuZ2VkIiwidmlld3BvcnQiLCJzY2lzc29yIiwiciIsImciLCJiIiwiYSIsImNsZWFyQ29sb3IiLCJjbGVhciIsIkNPTE9SX0JVRkZFUl9CSVQiLCJERVBUSF9CVUZGRVJfQklUIiwibVZhbHVlIiwiY3VsbEZhY2UiLCJtQ2FtZXJhIiwiY2FtZXJhIiwicm90YXRlIiwibVNoYWRlciIsInNoYWRlciIsInNoYWRlclByb2dyYW0iLCJtUm90YXRpb24iLCJjb3B5IiwibXVsdGlwbHkiLCJtYXRyaXgiLCJmcm9tTWF0NCIsImludmVydCIsInRyYW5zcG9zZSIsIm1NZXNoIiwibURyYXdpbmdUeXBlIiwiZHJhdyIsImJpbmQiLCJ1bmlmb3JtIiwicHJvamVjdGlvbiIsImRyYXdUeXBlIiwiaXNJbnN0YW5jZWQiLCJkcmF3RWxlbWVudHNJbnN0YW5jZWQiLCJpQnVmZmVyIiwibnVtSXRlbXMiLCJVTlNJR05FRF9TSE9SVCIsIm51bUluc3RhbmNlIiwiUE9JTlRTIiwiZHJhd0FycmF5cyIsInZlcnRleFNpemUiLCJkcmF3RWxlbWVudHMiLCJ1bmJpbmQiLCJtVHJhbnNmb3JtT2JqZWN0IiwibWVzaFNvdXJjZSIsIm1lc2hEZXN0aW5hdGlvbiIsIm51bVBvaW50cyIsInRyYW5zZm9ybUZlZWRiYWNrIiwiZ2VuZXJhdGVCdWZmZXJzIiwiYmluZFRyYW5zZm9ybUZlZWRiYWNrIiwiVFJBTlNGT1JNX0ZFRURCQUNLIiwiYXR0cmlidXRlcyIsImZvckVhY2giLCJhdHRyIiwiYmluZEJ1ZmZlckJhc2UiLCJUUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSIiwiYnVmZmVyIiwiUkFTVEVSSVpFUl9ESVNDQVJEIiwiYmVnaW5UcmFuc2Zvcm1GZWVkYmFjayIsImVuZFRyYW5zZm9ybUZlZWRiYWNrIiwiZGlzYWJsZSIsInVzZVByb2dyYW0iLCJiaW5kQnVmZmVyIiwiQVJSQVlfQlVGRkVSIiwibVdpZHRoIiwibUhlaWdodCIsIl93aWR0aCIsIl9oZWlnaHQiLCJ3aWR0aCIsImhlaWdodCIsIl9hc3BlY3RSYXRpbyIsImV4dCIsIm1FeHRlbnNpb24iLCJibGVuZEZ1bmMiLCJTUkNfQUxQSEEiLCJPTkVfTUlOVVNfU1JDX0FMUEhBIiwiT05FIiwibXR4IiwiY2xvbmUiLCJwdXNoIiwicG9wIiwibVBhcmFtZXRlciIsInNldFZpZXdwb3J0IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiZSIsIkdMIiwiZ2xzbGlmeSIsInJlcXVpcmUiLCJpc1NhbWUiLCJhcnJheTEiLCJhcnJheTIiLCJhZGRMaW5lTnVtYmVycyIsInN0cmluZyIsImxpbmVzIiwic3BsaXQiLCJqb2luIiwiY2xvbmVBcnJheSIsIm1BcnJheSIsInNsaWNlIiwiRmxvYXQzMkFycmF5IiwiZGVmYXVsdFZlcnRleFNoYWRlciIsImRlZmF1bHRGcmFnbWVudFNoYWRlciIsInVuaWZvcm1NYXBwaW5nIiwiZmxvYXQiLCJ2ZWMyIiwidmVjMyIsInZlYzQiLCJpbnQiLCJtYXQzIiwibWF0NCIsIkdMU2hhZGVyIiwic3RyVmVydGV4U2hhZGVyIiwic3RyRnJhZ21lbnRTaGFkZXIiLCJtVmFyeWluZ3MiLCJwYXJhbWV0ZXJzIiwidW5pZm9ybVRleHR1cmVzIiwiX3ZhcnlpbmdzIiwidnNTaGFkZXIiLCJfY3JlYXRlU2hhZGVyUHJvZ3JhbSIsImZzU2hhZGVyIiwiX2F0dGFjaFNoYWRlclByb2dyYW0iLCJ1c2VTaGFkZXIiLCJtTmFtZSIsIm1UeXBlIiwidW5pZm9ybU9iamVjdCIsInVuaWZvcm1UeXBlIiwiaGFzVW5pZm9ybSIsIm9Vbmlmb3JtIiwicGFyYW1ldGVySW5kZXgiLCJuYW1lIiwiaXNOdW1iZXIiLCJnZXRVbmlmb3JtTG9jYXRpb24iLCJ0eXBlIiwidmFsdWUiLCJ1bmlmb3JtTG9jIiwiaW5kZXhPZiIsIm5lZWRVcGRhdGUiLCJtVW5pZm9ybU9iaiIsInVuaWZvcm1OYW1lIiwidW5pZm9ybVZhbHVlIiwiZ2V0VW5pZm9ybVR5cGUiLCJjb25jYXQiLCJ0bXAiLCJtU2hhZGVyU3RyIiwiaXNWZXJ0ZXhTaGFkZXIiLCJzaGFkZXJUeXBlIiwiVkVSVEVYX1NIQURFUiIsIkZSQUdNRU5UX1NIQURFUiIsImNyZWF0ZVNoYWRlciIsInNoYWRlclNvdXJjZSIsImNvbXBpbGVTaGFkZXIiLCJnZXRTaGFkZXJQYXJhbWV0ZXIiLCJDT01QSUxFX1NUQVRVUyIsIndhcm4iLCJnZXRTaGFkZXJJbmZvTG9nIiwibVZlcnRleFNoYWRlciIsIm1GcmFnbWVudFNoYWRlciIsImNyZWF0ZVByb2dyYW0iLCJhdHRhY2hTaGFkZXIiLCJkZWxldGVTaGFkZXIiLCJ0cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzIiwiU0VQQVJBVEVfQVRUUklCUyIsImxpbmtQcm9ncmFtIiwiaXNBcnJheSIsImdldEFycmF5VW5pZm9ybVR5cGUiLCJTVEFUSUNfRFJBVyIsImdldEJ1ZmZlciIsImNyZWF0ZUJ1ZmZlciIsImZvcm1CdWZmZXIiLCJtRGF0YSIsIm1OdW0iLCJhcnkiLCJvIiwiaiIsIk1lc2giLCJtVXNlVmFvIiwiX2F0dHJpYnV0ZXMiLCJfbnVtSW5zdGFuY2UiLCJfaW5kaWNlcyIsIl9mYWNlcyIsIl9idWZmZXJDaGFuZ2VkIiwiX2hhc0luZGV4QnVmZmVyQ2hhbmdlZCIsIl9oYXNWQU8iLCJfaXNJbnN0YW5jZWQiLCJfZXh0VkFPIiwiY3JlYXRlVmVydGV4QXJyYXkiLCJfdXNlVkFPIiwibUFycmF5VmVydGljZXMiLCJtRHJhd1R5cGUiLCJidWZmZXJEYXRhIiwibm9ybWFscyIsInZlcnRpY2VzIiwiYnVmZmVyTm9ybWFsIiwibUFycmF5VGV4Q29vcmRzIiwibU5vcm1hbHMiLCJtQXJyYXlJbmRpY2VzIiwiaXNEeW5hbWljIiwiX2RyYXdUeXBlIiwiRFlOQU1JQ19EUkFXIiwiQXJyYXkiLCJVaW50MTZBcnJheSIsIl9udW1JdGVtcyIsIm1JdGVtU2l6ZSIsImRhdGEiLCJkYXRhQXJyYXkiLCJhdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJpdGVtU2l6ZSIsInNvdXJjZSIsInZlcnRleEF0dHJpYkRpdmlzb3IiLCJtU2hhZGVyUHJvZ3JhbSIsImhhc1ZBTyIsImJpbmRWZXJ0ZXhBcnJheSIsInZhbyIsImF0dHJQb3NpdGlvbiIsInZlcnRleEF0dHJpYlBvaW50ZXIiLCJGTE9BVCIsIkVMRU1FTlRfQVJSQVlfQlVGRkVSIiwiX3ZhbyIsImF0dHJPYmoiLCJlbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSIsIl91cGRhdGVJbmRleEJ1ZmZlciIsInVzaW5nRmFjZU5vcm1hbHMiLCJnZW5lcmF0ZUZhY2VzIiwiX2NvbXB1dGVGYWNlTm9ybWFscyIsIl9jb21wdXRlVmVydGV4Tm9ybWFscyIsImZhY2VJbmRleCIsImZhY2UiLCJOIiwibm9ybWFsIiwiaW5kaWNlcyIsInN1bU5vcm1hbCIsInNldCIsIm5vcm1hbGl6ZSIsImlhIiwiaWIiLCJpYyIsImMiLCJ2YmEiLCJ2Y2EiLCJ2Tm9ybWFsIiwiZmluZCIsImdldFNvdXJjZSIsIkJhdGNoIiwiX21lc2giLCJfc2hhZGVyIiwibWVzaCIsIkdlb20iLCJtZXNoVHJpIiwicGxhbmUiLCJudW1TZWdtZW50cyIsImF4aXMiLCJwb3NpdGlvbnMiLCJjb29yZHMiLCJnYXBYIiwiZ2FwWSIsImdhcFVWIiwic3giLCJzeSIsImluZGV4IiwidHgiLCJ0eSIsInUiLCJ2IiwiYnVmZmVyVmVydGV4IiwiYnVmZmVyVGV4Q29vcmQiLCJidWZmZXJJbmRleCIsInNwaGVyZSIsInNpemUiLCJpc0ludmVydCIsImdldFBvc2l0aW9uIiwiaXNOb3JtYWwiLCJyeCIsIk1hdGgiLCJQSSIsInJ5IiwicG9zIiwic2luIiwidCIsImNvcyIsInByZWNpc2lvbiIsImZsb29yIiwicmV2ZXJzZSIsImN1YmUiLCJkIiwieiIsImNvdW50Iiwic2t5Ym94IiwiYmlnVHJpYW5nbGUiLCJtb2R1bGUiLCJleHBvcnRzIiwiUGFzcyIsIm1Tb3VyY2UiLCJtUGFyYW1zIiwiYmlnVHJpYW5nbGVWZXJ0IiwiX3VuaWZvcm1zIiwiX2hhc093bkZibyIsIl9mYm8iLCJtUGFybWFzIiwidGV4dHVyZSIsIndlYmdsRGVwdGhUZXh0dXJlIiwiaGFzQ2hlY2tlZE11bHRpUmVuZGVyU3VwcG9ydCIsImV4dERyYXdCdWZmZXIiLCJjaGVja011bHRpUmVuZGVyIiwiRnJhbWVCdWZmZXIiLCJtTnVtVGFyZ2V0cyIsImNoZWNrRXh0ZW5zaW9uIiwiX251bVRhcmdldHMiLCJfbXVsdGlwbGVUYXJnZXRzIiwiX3BhcmFtZXRlcnMiLCJfY2hlY2tNYXhOdW1SZW5kZXJUYXJnZXQiLCJfaW5pdCIsIl9pbml0VGV4dHVyZXMiLCJmcmFtZUJ1ZmZlciIsImNyZWF0ZUZyYW1lYnVmZmVyIiwiYmluZEZyYW1lYnVmZmVyIiwiRlJBTUVCVUZGRVIiLCJidWZmZXJzIiwiZnJhbWVidWZmZXJUZXh0dXJlMkQiLCJEUkFXX0ZSQU1FQlVGRkVSIiwiQ09MT1JfQVRUQUNITUVOVDAiLCJURVhUVVJFXzJEIiwiX3RleHR1cmVzIiwiZHJhd0J1ZmZlcnMiLCJERVBUSF9BVFRBQ0hNRU5UIiwiZ2xEZXB0aFRleHR1cmUiLCJkcmF3QnVmZmVyc1dFQkdMIiwiRkJPc3RhdHVzIiwiY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyIsIkZSQU1FQlVGRkVSX0NPTVBMRVRFIiwiYmluZFRleHR1cmUiLCJiaW5kUmVuZGVyYnVmZmVyIiwiUkVOREVSQlVGRkVSIiwibWF4TnVtRHJhd0J1ZmZlcnMiLCJnZXRQYXJhbWV0ZXIiLCJNQVhfRFJBV19CVUZGRVJTX1dFQkdMIiwiZ2x0IiwiX2NyZWF0ZVRleHR1cmUiLCJERVBUSF9DT01QT05FTlQxNiIsIkRFUFRIX0NPTVBPTkVOVCIsIm1pbkZpbHRlciIsIkxJTkVBUiIsIm1JbnRlcm5hbGZvcm1hdCIsIm1UZXhlbFR5cGUiLCJtRm9ybWF0IiwiT2JqZWN0IiwiYXNzaWduIiwiaW50ZXJuYWxGb3JtYXQiLCJSR0JBIiwiZm9ybWF0IiwiVU5TSUdORURfQllURSIsInMiLCJtQXV0b1NldFZpZXdwb3J0IiwiZ2VuZXJhdGVNaXBtYXAiLCJtSW5kZXgiLCJzaG93UGFyYW1ldGVycyIsIm1hZ0ZpbHRlciIsIndyYXBTIiwid3JhcFQiLCJFYXNlTnVtYmVyIiwibUVhc2luZyIsImVhc2luZyIsIl92YWx1ZSIsIl90YXJnZXRWYWx1ZSIsIl9lZkluZGV4IiwiYWRkRUYiLCJfdXBkYXRlIiwiTUlOX0RJRkYiLCJfY2hlY2tMaW1pdCIsImFicyIsIm1BZGQiLCJtTWluIiwibU1heCIsImxpbWl0IiwiX21pbiIsIl9tYXgiLCJyZW1vdmVFRiIsInRhcmdldCIsImVkZ2UxIiwiZWRnZTIiLCJkaWZmIiwiUmF5IiwibU9yaWdpbiIsIm1EaXJlY3Rpb24iLCJvcmlnaW4iLCJkaXJlY3Rpb24iLCJzY2FsZSIsImFkZCIsIm1UYXJnZXQiLCJzdWIiLCJtUG9pbnQiLCJyZXN1bHQiLCJkaXJlY3Rpb25EaXN0YW5jZSIsImRvdCIsInNxcnQiLCJkaXN0YW5jZVNxVG9Qb2ludCIsInYxIiwic3F1YXJlZERpc3RhbmNlIiwibUNlbnRlciIsIm1SYWRpdXMiLCJkaXN0YW5jZVRvUG9pbnQiLCJ0Y2EiLCJkMiIsInJhZGl1czIiLCJ0aGMiLCJ0MCIsInQxIiwiYXQiLCJtUGxhbmVDZW50ZXIiLCJtTm9ybWFsIiwiZGVub21pbmF0b3IiLCJtUEEiLCJtUEIiLCJtUEMiLCJiYWNrZmFjZUN1bGxpbmciLCJjcm9zcyIsIkRkTiIsInNpZ24iLCJEZFF4RTIiLCJEZEUxeFEiLCJRZG4iLCJDYW1lcmEiLCJfcXVhdCIsIl9vcmllbnRhdGlvbiIsIl9wcm9qZWN0aW9uIiwicG9zaXRpb24iLCJhRXllIiwiYUNlbnRlciIsImFVcCIsIl9leWUiLCJfY2VudGVyIiwibG9va0F0IiwiZnJvbVF1YXQiLCJ0cmFuc2xhdGUiLCJwb3NpdGlvbk9mZnNldCIsIm1Qcm9qIiwibVZpZXciLCJzZXRWaWV3Iiwic2V0UHJvamVjdGlvbiIsIm1JbnZlcnNlVmlld1Byb2oiLCJjYW1lcmFEaXIiLCJDYW1lcmFQZXJzcGVjdGl2ZSIsIm1Gb3YiLCJtQXNwZWN0UmF0aW8iLCJtTmVhciIsIm1GYXIiLCJfZm92IiwiX25lYXIiLCJfZmFyIiwicGVyc3BlY3RpdmUiLCJtU2NyZWVuUG9zaXRpb24iLCJtUmF5IiwicHJvaiIsInByb2plY3Rpb25NYXRyaXgiLCJ2aWV3Iiwidmlld01hdHJpeCIsInRyYW5zZm9ybU1hdDQiLCJCaW5hcnlMb2FkZXIiLCJpc0FycmF5QnVmZmVyIiwiX3JlcSIsIlhNTEh0dHBSZXF1ZXN0IiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9vbkxvYWRlZCIsIl9vblByb2dyZXNzIiwicmVzcG9uc2VUeXBlIiwidXJsIiwiY2FsbGJhY2siLCJfY2FsbGJhY2siLCJvcGVuIiwic2VuZCIsInJlc3BvbnNlIiwiR0xNIiwiVkVSU0lPTiIsIkFsZnJpZCIsImdsbSIsIkdMVGV4dHVyZSIsIkdMVGV4dHVyZU9sZCIsIkdMQ3ViZVRleHR1cmUiLCJDdWJlRnJhbWVCdWZmZXIiLCJTY2hlZHVsZXIiLCJFdmVudERpc3BhdGNoZXIiLCJUd2Vlbk51bWJlciIsIkNhbWVyYU9ydGhvIiwiQ2FtZXJhQ3ViZSIsIk9yYml0YWxDb250cm9sIiwiUXVhdFJvdGF0aW9uIiwiT2JqTG9hZGVyIiwiQ29sbGFkYVBhcnNlciIsIkhEUkxvYWRlciIsIkdMVEZMb2FkZXIiLCJCYXRjaENvcHkiLCJCYXRjaEF4aXMiLCJCYXRjaEJhbGwiLCJCYXRjaExpbmUiLCJCYXRjaFNreWJveCIsIkJhdGNoU2t5IiwiQmF0Y2hGWEFBIiwiQmF0Y2hEb3RzUGxhbmUiLCJTY2VuZSIsIlZpZXciLCJWaWV3M0QiLCJPYmplY3QzRCIsIlNoYWRlckxpYnMiLCJXZWJnbE51bWJlciIsIkVmZmVjdENvbXBvc2VyIiwiUGFzc01hY3JvIiwiUGFzc0JsdXIiLCJQYXNzVkJsdXIiLCJQYXNzSEJsdXIiLCJQYXNzRnhhYSIsIk11bHRpc2FtcGxlRnJhbWVCdWZmZXIiLCJUcmFuc2Zvcm1GZWVkYmFja09iamVjdCIsImFsIiwiVG91Y2hEZXRlY3RvciIsIkFDVElWRV9BVFRSSUJVVEVTIiwiQUNUSVZFX0FUVFJJQlVURV9NQVhfTEVOR1RIIiwiQUNUSVZFX1RFWFRVUkUiLCJBQ1RJVkVfVU5JRk9STVMiLCJBQ1RJVkVfVU5JRk9STV9NQVhfTEVOR1RIIiwiQUxJQVNFRF9MSU5FX1dJRFRIX1JBTkdFIiwiQUxJQVNFRF9QT0lOVF9TSVpFX1JBTkdFIiwiQUxQSEEiLCJBTFBIQV9CSVRTIiwiQUxXQVlTIiwiQVJSQVlfQlVGRkVSX0JJTkRJTkciLCJBVFRBQ0hFRF9TSEFERVJTIiwiQkFDSyIsIkJMRU5EX0NPTE9SIiwiQkxFTkRfRFNUX0FMUEhBIiwiQkxFTkRfRFNUX1JHQiIsIkJMRU5EX0VRVUFUSU9OIiwiQkxFTkRfRVFVQVRJT05fQUxQSEEiLCJCTEVORF9FUVVBVElPTl9SR0IiLCJCTEVORF9TUkNfQUxQSEEiLCJCTEVORF9TUkNfUkdCIiwiQkxVRV9CSVRTIiwiQk9PTCIsIkJPT0xfVkVDMiIsIkJPT0xfVkVDMyIsIkJPT0xfVkVDNCIsIkJST1dTRVJfREVGQVVMVF9XRUJHTCIsIkJVRkZFUl9TSVpFIiwiQlVGRkVSX1VTQUdFIiwiQllURSIsIkNDVyIsIkNMQU1QX1RPX0VER0UiLCJDT0xPUl9DTEVBUl9WQUxVRSIsIkNPTE9SX1dSSVRFTUFTSyIsIkNPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTIiwiQ09OU1RBTlRfQUxQSEEiLCJDT05TVEFOVF9DT0xPUiIsIkNPTlRFWFRfTE9TVF9XRUJHTCIsIkNVTExfRkFDRV9NT0RFIiwiQ1VSUkVOVF9QUk9HUkFNIiwiQ1VSUkVOVF9WRVJURVhfQVRUUklCIiwiQ1ciLCJERUNSIiwiREVDUl9XUkFQIiwiREVMRVRFX1NUQVRVUyIsIkRFUFRIX0JJVFMiLCJERVBUSF9DTEVBUl9WQUxVRSIsIlJFRCIsIkRFUFRIX0ZVTkMiLCJERVBUSF9SQU5HRSIsIkRFUFRIX1NURU5DSUwiLCJERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQiLCJERVBUSF9XUklURU1BU0siLCJESVRIRVIiLCJET05UX0NBUkUiLCJEU1RfQUxQSEEiLCJEU1RfQ09MT1IiLCJFTEVNRU5UX0FSUkFZX0JVRkZFUl9CSU5ESU5HIiwiRVFVQUwiLCJGQVNURVNUIiwiRkxPQVRfTUFUMiIsIkZMT0FUX01BVDMiLCJGTE9BVF9NQVQ0IiwiRkxPQVRfVkVDMiIsIkZMT0FUX1ZFQzMiLCJGTE9BVF9WRUM0IiwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9PQkpFQ1RfTkFNRSIsIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfT0JKRUNUX1RZUEUiLCJGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX1RFWFRVUkVfQ1VCRV9NQVBfRkFDRSIsIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfVEVYVFVSRV9MRVZFTCIsIkZSQU1FQlVGRkVSX0JJTkRJTkciLCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQiLCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlMiLCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVCIsIkZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEIiwiRlJPTlQiLCJGUk9OVF9BTkRfQkFDSyIsIkZST05UX0ZBQ0UiLCJGVU5DX0FERCIsIkZVTkNfUkVWRVJTRV9TVUJUUkFDVCIsIkZVTkNfU1VCVFJBQ1QiLCJHRU5FUkFURV9NSVBNQVBfSElOVCIsIkdFUVVBTCIsIkdSRUFURVIiLCJHUkVFTl9CSVRTIiwiSElHSF9GTE9BVCIsIkhJR0hfSU5UIiwiSU5DUiIsIklOQ1JfV1JBUCIsIklORk9fTE9HX0xFTkdUSCIsIklOVCIsIklOVF9WRUMyIiwiSU5UX1ZFQzMiLCJJTlRfVkVDNCIsIklOVkFMSURfRU5VTSIsIklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OIiwiSU5WQUxJRF9PUEVSQVRJT04iLCJJTlZBTElEX1ZBTFVFIiwiSU5WRVJUIiwiS0VFUCIsIkxFUVVBTCIsIkxFU1MiLCJMSU5FQVJfTUlQTUFQX0xJTkVBUiIsIkxJTkVBUl9NSVBNQVBfTkVBUkVTVCIsIkxJTkVTIiwiTElORV9MT09QIiwiTElORV9TVFJJUCIsIkxJTkVfV0lEVEgiLCJMSU5LX1NUQVRVUyIsIkxPV19GTE9BVCIsIkxPV19JTlQiLCJMVU1JTkFOQ0UiLCJMVU1JTkFOQ0VfQUxQSEEiLCJNQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyIsIk1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUiLCJNQVhfRlJBR01FTlRfVU5JRk9STV9WRUNUT1JTIiwiTUFYX1JFTkRFUkJVRkZFUl9TSVpFIiwiTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMiLCJNQVhfVEVYVFVSRV9TSVpFIiwiTUFYX1ZBUllJTkdfVkVDVE9SUyIsIk1BWF9WRVJURVhfQVRUUklCUyIsIk1BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUyIsIk1BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTIiwiTUFYX1ZJRVdQT1JUX0RJTVMiLCJNRURJVU1fRkxPQVQiLCJNRURJVU1fSU5UIiwiTUlSUk9SRURfUkVQRUFUIiwiTkVBUkVTVCIsIk5FQVJFU1RfTUlQTUFQX0xJTkVBUiIsIk5FQVJFU1RfTUlQTUFQX05FQVJFU1QiLCJORVZFUiIsIk5JQ0VTVCIsIk5PTkUiLCJOT1RFUVVBTCIsIk5PX0VSUk9SIiwiTlVNX0NPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTIiwiT05FX01JTlVTX0NPTlNUQU5UX0FMUEhBIiwiT05FX01JTlVTX0NPTlNUQU5UX0NPTE9SIiwiT05FX01JTlVTX0RTVF9BTFBIQSIsIk9ORV9NSU5VU19EU1RfQ09MT1IiLCJPTkVfTUlOVVNfU1JDX0NPTE9SIiwiT1VUX09GX01FTU9SWSIsIlBBQ0tfQUxJR05NRU5UIiwiUE9MWUdPTl9PRkZTRVRfRkFDVE9SIiwiUE9MWUdPTl9PRkZTRVRfRklMTCIsIlBPTFlHT05fT0ZGU0VUX1VOSVRTIiwiUkVEX0JJVFMiLCJSRU5ERVJCVUZGRVJfQUxQSEFfU0laRSIsIlJFTkRFUkJVRkZFUl9CSU5ESU5HIiwiUkVOREVSQlVGRkVSX0JMVUVfU0laRSIsIlJFTkRFUkJVRkZFUl9ERVBUSF9TSVpFIiwiUkVOREVSQlVGRkVSX0dSRUVOX1NJWkUiLCJSRU5ERVJCVUZGRVJfSEVJR0hUIiwiUkVOREVSQlVGRkVSX0lOVEVSTkFMX0ZPUk1BVCIsIlJFTkRFUkJVRkZFUl9SRURfU0laRSIsIlJFTkRFUkJVRkZFUl9TVEVOQ0lMX1NJWkUiLCJSRU5ERVJCVUZGRVJfV0lEVEgiLCJSRU5ERVJFUiIsIlJFUEVBVCIsIlJFUExBQ0UiLCJSR0IiLCJSR0I1X0ExIiwiUkdCNTY1IiwiUkdCQTQiLCJTQU1QTEVSXzJEIiwiU0FNUExFUl9DVUJFIiwiU0FNUExFUyIsIlNBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRSIsIlNBTVBMRV9CVUZGRVJTIiwiU0FNUExFX0NPVkVSQUdFIiwiU0FNUExFX0NPVkVSQUdFX0lOVkVSVCIsIlNBTVBMRV9DT1ZFUkFHRV9WQUxVRSIsIlNDSVNTT1JfQk9YIiwiU0NJU1NPUl9URVNUIiwiU0hBREVSX0NPTVBJTEVSIiwiU0hBREVSX1NPVVJDRV9MRU5HVEgiLCJTSEFERVJfVFlQRSIsIlNIQURJTkdfTEFOR1VBR0VfVkVSU0lPTiIsIlNIT1JUIiwiU1JDX0FMUEhBX1NBVFVSQVRFIiwiU1JDX0NPTE9SIiwiU1RFTkNJTF9BVFRBQ0hNRU5UIiwiU1RFTkNJTF9CQUNLX0ZBSUwiLCJTVEVOQ0lMX0JBQ0tfRlVOQyIsIlNURU5DSUxfQkFDS19QQVNTX0RFUFRIX0ZBSUwiLCJTVEVOQ0lMX0JBQ0tfUEFTU19ERVBUSF9QQVNTIiwiU1RFTkNJTF9CQUNLX1JFRiIsIlNURU5DSUxfQkFDS19WQUxVRV9NQVNLIiwiU1RFTkNJTF9CQUNLX1dSSVRFTUFTSyIsIlNURU5DSUxfQklUUyIsIlNURU5DSUxfQlVGRkVSX0JJVCIsIlNURU5DSUxfQ0xFQVJfVkFMVUUiLCJTVEVOQ0lMX0ZBSUwiLCJTVEVOQ0lMX0ZVTkMiLCJTVEVOQ0lMX0lOREVYIiwiU1RFTkNJTF9JTkRFWDgiLCJTVEVOQ0lMX1BBU1NfREVQVEhfRkFJTCIsIlNURU5DSUxfUEFTU19ERVBUSF9QQVNTIiwiU1RFTkNJTF9SRUYiLCJTVEVOQ0lMX1RFU1QiLCJTVEVOQ0lMX1ZBTFVFX01BU0siLCJTVEVOQ0lMX1dSSVRFTUFTSyIsIlNUUkVBTV9EUkFXIiwiU1VCUElYRUxfQklUUyIsIlRFWFRVUkUiLCJURVhUVVJFMCIsIlRFWFRVUkUxIiwiVEVYVFVSRTIiLCJURVhUVVJFMyIsIlRFWFRVUkU0IiwiVEVYVFVSRTUiLCJURVhUVVJFNiIsIlRFWFRVUkU3IiwiVEVYVFVSRTgiLCJURVhUVVJFOSIsIlRFWFRVUkUxMCIsIlRFWFRVUkUxMSIsIlRFWFRVUkUxMiIsIlRFWFRVUkUxMyIsIlRFWFRVUkUxNCIsIlRFWFRVUkUxNSIsIlRFWFRVUkUxNiIsIlRFWFRVUkUxNyIsIlRFWFRVUkUxOCIsIlRFWFRVUkUxOSIsIlRFWFRVUkUyMCIsIlRFWFRVUkUyMSIsIlRFWFRVUkUyMiIsIlRFWFRVUkUyMyIsIlRFWFRVUkUyNCIsIlRFWFRVUkUyNSIsIlRFWFRVUkUyNiIsIlRFWFRVUkUyNyIsIlRFWFRVUkUyOCIsIlRFWFRVUkUyOSIsIlRFWFRVUkUzMCIsIlRFWFRVUkUzMSIsIlRFWFRVUkVfQklORElOR18yRCIsIlRFWFRVUkVfQklORElOR19DVUJFX01BUCIsIlRFWFRVUkVfQ1VCRV9NQVAiLCJURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1giLCJURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1kiLCJURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1oiLCJURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1giLCJURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1kiLCJURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1oiLCJURVhUVVJFX01BR19GSUxURVIiLCJURVhUVVJFX01JTl9GSUxURVIiLCJURVhUVVJFX1dSQVBfUyIsIlRFWFRVUkVfV1JBUF9UIiwiVFJJQU5HTEVTIiwiVFJJQU5HTEVfRkFOIiwiVFJJQU5HTEVfU1RSSVAiLCJVTlBBQ0tfQUxJR05NRU5UIiwiVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCIsIlVOUEFDS19GTElQX1lfV0VCR0wiLCJVTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wiLCJVTlNJR05FRF9JTlQiLCJVTlNJR05FRF9TSE9SVF80XzRfNF80IiwiVU5TSUdORURfU0hPUlRfNV81XzVfMSIsIlVOU0lHTkVEX1NIT1JUXzVfNl81IiwiVkFMSURBVEVfU1RBVFVTIiwiVkVORE9SIiwiVkVSVEVYX0FUVFJJQl9BUlJBWV9CVUZGRVJfQklORElORyIsIlZFUlRFWF9BVFRSSUJfQVJSQVlfRU5BQkxFRCIsIlZFUlRFWF9BVFRSSUJfQVJSQVlfTk9STUFMSVpFRCIsIlZFUlRFWF9BVFRSSUJfQVJSQVlfUE9JTlRFUiIsIlZFUlRFWF9BVFRSSUJfQVJSQVlfU0laRSIsIlZFUlRFWF9BVFRSSUJfQVJSQVlfU1RSSURFIiwiVkVSVEVYX0FUVFJJQl9BUlJBWV9UWVBFIiwiVklFV1BPUlQiLCJaRVJPIiwiUjgiLCJjYWNoZUF0dHJpYkxvYyIsImdldEF0dHJpYkxvY2F0aW9uIiwiaXNQb3dlck9mVHdvIiwiaXNTb3VyY2VQb3dlck9mVHdvIiwib2JqIiwidmlkZW9XaWR0aCIsInZpZGVvSGVpZ2h0IiwiaXNUZXh0dXJlIiwiX3RleHR1cmUiLCJfbVNvdXJjZSIsImNyZWF0ZVRleHR1cmUiLCJfaXNWaWRlbyIsInRhZ05hbWUiLCJfcHJlbXVsdGlwbHlBbHBoYSIsIl9tYWdGaWx0ZXIiLCJfbWluRmlsdGVyIiwiX3dyYXBTIiwiX3dyYXBUIiwicGl4ZWxTdG9yZWkiLCJleHBvc3VyZSIsInRleEltYWdlMkQiLCJzaGFwZSIsInRleFBhcmFtZXRlcmkiLCJtYXgiLCJNQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQiLCJ0ZXhQYXJhbWV0ZXJmIiwiVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQiLCJfY2FuR2VuZXJhdGVNaXBtYXAiLCJhY3RpdmVUZXh0dXJlIiwiX2JpbmRJbmRleCIsIl93aGl0ZVRleHR1cmUiLCJfZ3JleVRleHR1cmUiLCJfYmxhY2tUZXh0dXJlIiwid2hpdGVUZXh0dXJlIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJncmV5VGV4dHVyZSIsImJsYWNrVGV4dHVyZSIsIm1QYXJhbSIsIl9zb3VyY2UiLCJfZ2V0RGltZW5zaW9uIiwiX3NvdXJjZVR5cGUiLCJnZXRTb3VyY2VUeXBlIiwiX2NoZWNrU291cmNlIiwiX3RleGVsVHlwZSIsIl9nZXRUZXhlbFR5cGUiLCJfaXNUZXh0dXJlUmVhZHkiLCJfcGFyYW1zIiwiX2NoZWNrTWlwbWFwIiwiX2NoZWNrV3JhcHBpbmciLCJfbG9vcCIsIl91cGxvYWRUZXh0dXJlIiwicmVhZHlTdGF0ZSIsIl9pc1NvdXJjZUh0bWxFbGVtZW50IiwicHJlbXVsdGlwbHlBbHBoYSIsImFuaXNvdHJvcHkiLCJsZXZlbCIsIm1pbiIsIl9nZW5lcmF0ZU1pcG1hcCIsInRleGVsVHlwZSIsIlVpbnQ4QXJyYXkiLCJtaXBtYXAiLCJIVE1MSW1hZ2VFbGVtZW50IiwiSFRNTENhbnZhc0VsZW1lbnQiLCJIVE1MVmlkZW9FbGVtZW50IiwiRERTRF9NSVBNQVBDT1VOVCIsIk9GRl9NSVBNQVBDT1VOVCIsImhlYWRlckxlbmd0aEludCIsImlzQ3ViZVRleHR1cmUiLCJoYXNNaXBtYXBzIiwibWlwbWFwQ291bnQiLCJ0YXJnZXRzIiwibnVtTGV2ZWxzIiwidW5pZm9ybTFpIiwicGFyc2VERFMiLCJtQXJyYXlCdWZmZXIiLCJjbGFtcCIsImRkc0luZm9zIiwiZmxhZ3MiLCJoZWFkZXIiLCJJbnQzMkFycmF5Iiwic291cmNlcyIsImltYWdlcyIsIm1hcCIsImltZyIsImZhY2VEYXRhIiwib2Zmc2V0Iiwic3VwcG9ydHNDdXN0b21FdmVudHMiLCJuZXdUZXN0Q3VzdG9tRXZlbnQiLCJjcmVhdGVFdmVudCIsIl9ldmVudExpc3RlbmVycyIsImFFdmVudFR5cGUiLCJhRnVuY3Rpb24iLCJjdXJyZW50QXJyYXkiLCJjdXJyZW50QXJyYXlMZW5ndGgiLCJzcGxpY2UiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYUV2ZW50IiwiZXZlbnRUeXBlIiwiY3VycmVudFRhcmdldCIsInRoZUVycm9yIiwibmV3RXZlbnQiLCJkZXRhaWwiLCJkaXNwYXRjaGVyIiwiZGlzcGF0Y2hFdmVudCIsImN1cnJlbnRFdmVudExpc3RlbmVycyIsIl9jb3B5QXJyYXkiLCJjdXJyZW50RnVuY3Rpb24iLCJjYWxsIiwiYURldGFpbCIsImluaXRDdXN0b21FdmVudCIsImRpc3BhdGNoQ3VzdG9tRXZlbnQiLCJvYmplY3ROYW1lIiwiaGFzT3duUHJvcGVydHkiLCJhQXJyYXkiLCJnZXRNb3VzZSIsIm1FdmVudCIsInRvdWNoZXMiLCJwYWdlWCIsInBhZ2VZIiwiY2xpZW50WCIsImNsaWVudFkiLCJtTGlzdGVuZXJUYXJnZXQiLCJfdGFyZ2V0IiwiX2xpc3RlbmVyVGFyZ2V0IiwiX21vdXNlIiwiX3ByZU1vdXNlIiwiY2VudGVyIiwiX3VwIiwiZnJvbVZhbHVlcyIsInJhZGl1cyIsIl9yeCIsIl9yeSIsIl9wcmVSWCIsIl9wcmVSWSIsIl9pc0xvY2tab29tIiwiX2lzTG9ja1JvdGF0aW9uIiwiX2lzSW52ZXJ0Iiwic2Vuc2l0aXZpdHkiLCJfd2hlZWxCaW5kIiwiX29uV2hlZWwiLCJfZG93bkJpbmQiLCJfb25Eb3duIiwiX21vdmVCaW5kIiwiX29uTW92ZSIsIl91cEJpbmQiLCJfb25VcCIsImNvbm5lY3QiLCJkaXNjb25uZWN0IiwiX2lzTW91c2VEb3duIiwidGFyZ2V0VmFsdWUiLCJwcmV2ZW50RGVmYXVsdCIsImRpZmZYIiwiZGlmZlkiLCJ3aGVlbERlbHRhIiwiX3VwZGF0ZVBvc2l0aW9uIiwiX3VwZGF0ZUNhbWVyYSIsInRyIiwiZXllIiwidXAiLCJvcnRobyIsImxlZnQiLCJyaWdodCIsInRvcCIsImJvdHRvbSIsIm5lYXIiLCJmYXIiLCJfbmVlZFVwZGF0ZSIsIl94IiwiX3kiLCJfeiIsIl9zeCIsIl9zeSIsIl9zeiIsIl9yeiIsIl9wb3NpdGlvbiIsIl9zY2FsZSIsIl9yb3RhdGlvbiIsIl9tYXRyaXhSb3RhdGlvbiIsIl9tYXRyaXhTY2FsZSIsIl9tYXRyaXhUcmFuc2xhdGlvbiIsIl9tYXRyaXhRdWF0ZXJuaW9uIiwicm90YXRlWCIsInJvdGF0ZVkiLCJyb3RhdGVaIiwibXVsIiwibVF1YXQiLCJzaW1wbGVDb2xvckZyYWciLCJnZW5lcmFsVmVydCIsImNvcHlGcmFnIiwiYmFzaWNWZXJ0Iiwic2t5Ym94VmVydCIsInNreWJveEZyYWciLCJfcGFzc2VzIiwicGFzcyIsIm1RdWFsaXR5IiwiZnNCbHVyNSIsImZzQmx1cjkiLCJmc0JsdXIxMyIsIlBhc3NCbHVyQmFzZSIsImZzIiwiZ2V0QW5kQXBwbHlFeHRlbnNpb24iLCJzdWZmaXgiLCJzdWZmaXhSRSIsIlJlZ0V4cCIsImtleSIsInZhbCIsInVuc3VmZml4ZWRLZXkiLCJyZXBsYWNlIiwic3Vic3RyaW5nIiwiZXhwb3NlQXR0cmlidXRlcyIsImhhc0NoZWNrZWQiLCJfZmxvYXQiLCJjaGVja0Zsb2F0IiwiZXh0RmxvYXQiLCJoYWxmRmxvYXQiLCJjaGVja0hhbGZGbG9hdCIsIkhBTEZfRkxPQVQiLCJleHRIYWxmRmxvYXQiLCJIQUxGX0ZMT0FUX09FUyIsImdldFRleHR1cmVQYXJhbWV0ZXJzIiwiX3NpemUiLCJnbFRleHR1cmUiLCJfZnJhbWVCdWZmZXJzIiwic3RhdHVzIiwibVRhcmdldEluZGV4IiwidXNlRGVwdGgiLCJ1c2VTdGVuY2lsIiwiX251bVNhbXBsZSIsIm51bVNhbXBsZSIsImZyYW1lQnVmZmVyQ29sb3IiLCJyZW5kZXJCdWZmZXJDb2xvciIsImNyZWF0ZVJlbmRlcmJ1ZmZlciIsInJlbmRlckJ1ZmZlckRlcHRoIiwicmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlIiwiUkdCQTgiLCJmcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciIsImZvcmNlTmVhcmVzdCIsIlJFQURfRlJBTUVCVUZGRVIiLCJjbGVhckJ1ZmZlcmZ2IiwiQ09MT1IiLCJibGl0RnJhbWVidWZmZXIiLCJfdnMiLCJfZnMiLCJfbWVzaEN1cnJlbnQiLCJfbWVzaFRhcmdldCIsIl9udW1Qb2ludHMiLCJjcmVhdGVUcmFuc2Zvcm1GZWVkYmFjayIsIm1WYXJ5aW5nTmFtZSIsImlzVHJhbnNmb3JtRmVlZGJhY2siLCJTVFJFQU1fQ09QWSIsImdlbmVyYXRlIiwiZHJhd1RyYW5zZm9ybUZlZWRiYWNrIiwiX3N3YXAiLCJFYXNpbmciLCJMaW5lYXIiLCJOb25lIiwiayIsIlF1YWRyYXRpYyIsIkluIiwiT3V0IiwiSW5PdXQiLCJDdWJpYyIsIlF1YXJ0aWMiLCJRdWludGljIiwiU2ludXNvaWRhbCIsIkV4cG9uZW50aWFsIiwicG93IiwiQ2lyY3VsYXIiLCJFbGFzdGljIiwicCIsImFzaW4iLCJCYWNrIiwiQm91bmNlIiwiaW4iLCJvdXQiLCJpbk91dCIsImdldEZ1bmMiLCJtU3BlZWQiLCJfc3RhcnRWYWx1ZSIsIl9jb3VudGVyIiwic3BlZWQiLCJuZXdDb3VudGVyIiwiZiIsIm0iLCJfdlpheGlzIiwiX3pBeGlzIiwicHJlTW91c2UiLCJtb3VzZSIsInF1YXQiLCJ0ZW1wUm90YXRpb24iLCJfcm90YXRlWk1hcmdpbiIsIl9vZmZzZXQiLCJfc2xlcnAiLCJfaXNMb2NrZWQiLCJfZGlmZlgiLCJfZGlmZlkiLCJfdXBkYXRlUm90YXRpb24iLCJfY3VyckRpZmZYIiwiX2N1cnJEaWZmWSIsIl9pc1JvdGF0ZVoiLCJfdGFyZ2V0UXVhdCIsInNldFRvIiwibVRlbXBSb3RhdGlvbiIsImFuZ2xlIiwic2xlcnAiLCJ0cmFuc2Zvcm1RdWF0IiwiZGlzdGFuY2UiLCJkeCIsImR5IiwibVNraXBNb3ZlQ2hlY2siLCJfY2FtZXJhIiwiZmFjZVZlcnRpY2VzIiwiZmFjZXMiLCJjbGlja1RvbGVyYW5jZSIsIl9yYXkiLCJfaGl0IiwiX2xhc3RQb3MiLCJfZmlyc3RQb3MiLCJtdHhNb2RlbCIsIl9za2lwcGluZ01vdmUiLCJfb25Nb3ZlQmluZCIsIl9vbkRvd25CaW5kIiwiX29uVXBCaW5kIiwibXgiLCJteSIsImdlbmVyYXRlUmF5IiwiaGl0IiwidjAiLCJ2MiIsImRpc3QiLCJnZXRWZWN0b3IiLCJpbnRlcnNlY3RUcmlhbmdsZSIsImRpc3RUb0NhbSIsIl9jaGVja0hpdCIsIkNBTUVSQV9TRVRUSU5HUyIsInNldFBlcnNwZWN0aXZlIiwicGFyc2VPYmoiLCJvYmpTdHIiLCJmaW5hbE5vcm1hbHMiLCJ1dnMiLCJ2ZXJ0ZXhQYXR0ZXJuIiwibm9ybWFsUGF0dGVybiIsInV2UGF0dGVybiIsImZhY2VQYXR0ZXJuMSIsImZhY2VQYXR0ZXJuMiIsImZhY2VQYXR0ZXJuMyIsImZhY2VQYXR0ZXJuNCIsInBhcnNlVmVydGV4SW5kZXgiLCJwYXJzZUludCIsInBhcnNlTm9ybWFsSW5kZXgiLCJwYXJzZVVWSW5kZXgiLCJhZGRWZXJ0ZXgiLCJhZGRVViIsImFkZE5vcm1hbCIsImFkZEZhY2UiLCJ1YSIsInViIiwidWMiLCJ1ZCIsIm5hIiwibmIiLCJuYyIsIm5kIiwiaWQiLCJsaW5lIiwidHJpbSIsImNoYXJBdCIsImV4ZWMiLCJwYXJzZUZsb2F0IiwiX2dlbmVyYXRlTWVzaGVzIiwibWF4TnVtVmVydGljZXMiLCJoYXNOb3JtYWxzIiwiaGFzVVZzIiwibWVzaGVzIiwibGFzdEluZGV4Iiwib0NvcHkiLCJzbGljZU51bSIsInRtcEluZGV4IiwicGFyc2UiLCJsb2FkZXIiLCJyYWRpYW5jZVBhdHRlcm4iLCJjb21tZW50UGF0dGVybiIsImV4cG9zdXJlUGF0dGVybiIsImZvcm1hdFBhdHRlcm4iLCJ3aWR0aEhlaWdodFBhdHRlcm4iLCJyZWFkUGl4ZWxzUmF3UkxFIiwiZmlsZU9mZnNldCIsInNjYW5saW5lV2lkdGgiLCJudW1TY2FubGluZXMiLCJyZ2JlIiwic2NhbmxpbmVCdWZmZXIiLCJwdHIiLCJwdHJFbmQiLCJidWYiLCJidWZmZXJMZW5ndGgiLCJyZWFkQnVmIiwiYnl0ZXNSZWFkIiwicmVhZEJ1Zk9mZnNldCIsInJlYWRQaXhlbHNSYXciLCJudW1waXhlbHMiLCJudW1FeHBlY3RlZCIsIm51bVJlYWQiLCJFcnJvciIsInBhcnNlSGRyIiwiQXJyYXlCdWZmZXIiLCJORVdfTElORSIsInJlYWRMaW5lIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZ2FtbWEiLCJybGUiLCJtYXRjaCIsIk51bWJlciIsImZsb2F0RGF0YSIsImZsb2F0T2Zmc2V0IiwiZ2VuZXJhdGVNZXNoIiwiY2FjaGVzIiwidHJpYW5nbGVzIiwiZ2xNZXNoIiwiYnVmZmVyRmxhdHRlbkRhdGEiLCJsb2FkIiwibVBhdGgiLCJtQ2FsbGJhY2siLCJBUlJBWV9DVE9SX01BUCIsIkludDhBcnJheSIsIkludDE2QXJyYXkiLCJVaW50MzJBcnJheSIsIlNJWkVfTUFQIiwiU0NBTEFSIiwiVkVDMiIsIlZFQzMiLCJWRUM0IiwiTUFUMiIsIk1BVDMiLCJNQVQ0Iiwic2VtYW50aWNBdHRyaWJ1dGVNYXAiLCJOT1JNQUwiLCJQT1NJVElPTiIsIlRFWENPT1JEXzAiLCJURVhDT09SRF8xIiwiV0VJR0hUU18wIiwiSk9JTlRTXzAiLCJiYXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJsYXN0SW5kZXhPZiIsIl9sb2FkR2x0ZiIsInRoZW4iLCJfbG9hZEJpbiIsIl9nZXRCdWZmZXJWaWV3RGF0YSIsIl9sb2FkVGV4dHVyZXMiLCJfcGFyc2VNZXNoIiwiX3BhcnNlTm9kZXMiLCJnbHRmSW5mbyIsImNhdGNoIiwiZ2x0ZiIsIm5vZGVzIiwibm9kZUluZm8iLCJpbmNsdWRlQ2FtZXJhIiwiZ2VvbWV0cmllcyIsIm91dHB1dCIsInNjZW5lIiwicHJpbWl0aXZlcyIsImdlb21ldHJ5IiwicHJpbWl0aXZlSW5mbyIsInNlbWFudGljcyIsImtleXMiLCJzZW1hbnRpYyIsImFjY2Vzc29ySWR4IiwiYXR0cmlidXRlSW5mbyIsImFjY2Vzc29ycyIsImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGVBcnJheSIsIl9nZXRBY2Nlc3NvckRhdGEiLCJidWZmZXJWaWV3cyIsImJ1ZmZlclZpZXdJbmZvIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJKU09OIiwidXJsQmluIiwidXJpIiwibUdsdGZJbmZvIiwibUJpbiIsImlzSW5kaWNlcyIsImFjY2Vzc29ySW5mbyIsImJ1ZmZlclZpZXciLCJBcnJheUN0b3IiLCJjb21wb25lbnRUeXBlIiwiYXJyIiwicXVhbnRpemVFeHRlbnNpb24iLCJkZWNvZGVkQXJyIiwiZGVjb2RlTWF0cml4IiwiZGVjb2RlT2Zmc2V0IiwiZGVjb2RlU2NhbGUiLCJyZXEiLCJfcmV0dXJuVGV4dHVyZSIsInBhc3NlcyIsImFkZFBhc3MiLCJmYm9UYXJnZXQiLCJoYXNGYm8iLCJmYm8iLCJfZmJvVGFyZ2V0IiwicmVuZGVyIiwiZ2V0VGV4dHVyZSIsIl9mYm9DdXJyZW50IiwiX2N1cnJlbnQiLCJ2Qmx1ciIsImhCbHVyIiwidnMiLCJjb2xvcnMiLCJjb2xvciIsIm9wYWNpdHkiLCJtUG9zaXRpb25BIiwibVBvc2l0aW9uQiIsInNlZyIsIl9jaGlsZHJlbiIsIl9tYXRyaXhJZGVudGl0eSIsIl9pbml0Vmlld3MiLCJyZXNpemUiLCJzZXRBc3BlY3RSYXRpbyIsImFzcGVjdFJhdGlvIiwibUNoaWxkIiwiY2hpbGQiLCJ0b1JlbmRlciIsIm9yYml0YWxDb250cm9sIiwiY2FtZXJhT3J0aG8iLCJzZXRNYXRyaWNlcyIsInVwZGF0ZSIsIl9yZW5kZXJDaGlsZHJlbiIsIm1TdHJWZXJ0ZXgiLCJtU3RyRnJhZyIsIl9tYXRyaXhUZW1wIiwiZ3VpIiwiR1VJIiwiZGl2IiwiYm9keSIsInF1ZXJ5U2VsZWN0b3IiLCJzdHlsZSIsInpJbmRleCIsInN0YXRzIiwiYXBwZW5kQ2hpbGQiLCJkb21FbGVtZW50Il0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUEyRDtBQUMzRDtBQUNBO0FBQ0EsV0FBRzs7QUFFSCxvREFBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3REFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFNO0FBQ047QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0EsY0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGVBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJO0FBQ0o7Ozs7QUFJQTtBQUNBLHNEQUE4QztBQUM5QztBQUNBO0FBQ0Esb0NBQTRCO0FBQzVCLHFDQUE2QjtBQUM3Qix5Q0FBaUM7O0FBRWpDLCtDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBc0M7QUFDdEM7QUFDQTtBQUNBLHFDQUE2QjtBQUM3QixxQ0FBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGFBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQWlCLDhCQUE4QjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJO0FBQ0o7O0FBRUEsNERBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQSxjQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBSztBQUNmLFVBQVUsS0FBSztBQUNmO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7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QVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxL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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUFBO0FBQUE7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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hiQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLE1BQU07QUFDakIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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TztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFL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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEI7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9D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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFD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QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDOzs7Ozs7OzhDQ3ZIQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSw2Q0FBNkM7O0FBRTdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFCQUFxQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBLENBQUM7OztBQUdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7O0FBR0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxL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Q0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBLENBQUM7QUFDRDtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBLENBQUM7OztBQUdEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7O0FBRVg7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQSxtREFBbUQsRUFBRTtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXOztBQUVYOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVzs7QUFFWDs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVzs7QUFFWDs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7OztBQUdBLENBQUM7QUFDRDs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7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QUNBLG1CQUFtQixVQUFVO0FBQzdCLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7OztBQUdBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLFdBQVcsd0VBQXdFOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLDRCQUE0QjtBQUM1QixPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7O0FBR0EseUJBQXlCLG9DQUFvQztBQUM3RDtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0c7QUFDeEcsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSw2SkFBNko7QUFDN0osMEpBQTBKO0FBQzFKLHFKQUFxSjtBQUNySixzSkFBc0o7QUFDdEosa0pBQWtKO0FBQ2xKOzs7QUFHQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQztBQUNEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtCOzs7Ozs7QUMza0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVTs7QUFFQSxhQUFhOztBQUViOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7O0FBR0EsaUQ7O0FBRUE7O0FBRUEsT0FBTywwQ0FBMEM7O0FBRWpELHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOzs7QUFHRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBLENBQUM7OztBQUdEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7O0FBRVg7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQSxtREFBbUQsRUFBRTtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXOztBQUVYOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVzs7QUFFWDs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVzs7QUFFWDs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7OztBQUdBLENBQUM7QUFDRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7QUFDRDtBQUNBLGtCOzs7Ozs7QUNsdkJBO0FBQ0EsZUFBZSxzRkFBdUksa0JBQWtCLGlCQUFpQixjQUFjLHFCQUFxQixTQUFTLGNBQWMsWUFBWSxvQkFBb0IscURBQXFELElBQUksd0NBQXdDLGdDQUFnQyxNQUFNLE9BQU8sZUFBZSxZQUFZLGVBQWUsdUNBQXVDO0FBQ2xmLHlCQUF5QixLQUFLLG1IQUFtSCxzRkFBc0YsS0FBSyxPQUFPLDBEQUEwRCw0QkFBNEIsZ0JBQWdCLElBQUksZ0NBQWdDLGtCQUFrQixtREFBbUQseUJBQXlCO0FBQzNkLG1DQUFtQyxTQUFTLG1CQUFtQixhQUFhLDBCQUEwQix3QkFBd0Isd0pBQXdKLFVBQVUsV0FBVyw0QkFBNEIsYUFBYSx5QkFBeUIsbURBQW1ELHFCQUFxQixjQUFjLG9CQUFvQixjQUFjO0FBQ3JlLG9CQUFvQixjQUFjLGlCQUFpQixvQkFBb0IsT0FBTywyQkFBMkIsZ0JBQWdCLGdCQUFnQixjQUFjLGdCQUFnQixvQkFBb0IsY0FBYyxrREFBa0QscUNBQXFDLHdCQUF3QixjQUFjLGlCQUFpQixzQ0FBc0MsU0FBUyIsImZpbGUiOiJhc3NldHMvanMvZGVidWcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHRmdW5jdGlvbiBob3REaXNwb3NlQ2h1bmsoY2h1bmtJZCkge1xuIFx0XHRkZWxldGUgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdO1xuIFx0fVxuIFx0dmFyIHBhcmVudEhvdFVwZGF0ZUNhbGxiYWNrID0gd2luZG93W1wid2VicGFja0hvdFVwZGF0ZVwiXTtcbiBcdHdpbmRvd1tcIndlYnBhY2tIb3RVcGRhdGVcIl0gPSBcclxuIFx0ZnVuY3Rpb24gd2VicGFja0hvdFVwZGF0ZUNhbGxiYWNrKGNodW5rSWQsIG1vcmVNb2R1bGVzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHRob3RBZGRVcGRhdGVDaHVuayhjaHVua0lkLCBtb3JlTW9kdWxlcyk7XHJcbiBcdFx0aWYocGFyZW50SG90VXBkYXRlQ2FsbGJhY2spIHBhcmVudEhvdFVwZGF0ZUNhbGxiYWNrKGNodW5rSWQsIG1vcmVNb2R1bGVzKTtcclxuIFx0fSA7XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3REb3dubG9hZFVwZGF0ZUNodW5rKGNodW5rSWQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHRcdHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xyXG4gXHRcdHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xyXG4gXHRcdHNjcmlwdC50eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIjtcclxuIFx0XHRzY3JpcHQuY2hhcnNldCA9IFwidXRmLThcIjtcclxuIFx0XHRzY3JpcHQuc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgXCJcIiArIGNodW5rSWQgKyBcIi5cIiArIGhvdEN1cnJlbnRIYXNoICsgXCIuaG90LXVwZGF0ZS5qc1wiO1xyXG4gXHRcdDtcclxuIFx0XHRoZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XHJcbiBcdH1cclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdERvd25sb2FkTWFuaWZlc3QocmVxdWVzdFRpbWVvdXQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHRcdHJlcXVlc3RUaW1lb3V0ID0gcmVxdWVzdFRpbWVvdXQgfHwgMTAwMDA7XHJcbiBcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gXHRcdFx0aWYodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ID09PSBcInVuZGVmaW5lZFwiKVxyXG4gXHRcdFx0XHRyZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihcIk5vIGJyb3dzZXIgc3VwcG9ydFwiKSk7XHJcbiBcdFx0XHR0cnkge1xyXG4gXHRcdFx0XHR2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gXHRcdFx0XHR2YXIgcmVxdWVzdFBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBcIlwiICsgaG90Q3VycmVudEhhc2ggKyBcIi5ob3QtdXBkYXRlLmpzb25cIjtcclxuIFx0XHRcdFx0cmVxdWVzdC5vcGVuKFwiR0VUXCIsIHJlcXVlc3RQYXRoLCB0cnVlKTtcclxuIFx0XHRcdFx0cmVxdWVzdC50aW1lb3V0ID0gcmVxdWVzdFRpbWVvdXQ7XHJcbiBcdFx0XHRcdHJlcXVlc3Quc2VuZChudWxsKTtcclxuIFx0XHRcdH0gY2F0Y2goZXJyKSB7XHJcbiBcdFx0XHRcdHJldHVybiByZWplY3QoZXJyKTtcclxuIFx0XHRcdH1cclxuIFx0XHRcdHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XHJcbiBcdFx0XHRcdGlmKHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkgcmV0dXJuO1xyXG4gXHRcdFx0XHRpZihyZXF1ZXN0LnN0YXR1cyA9PT0gMCkge1xyXG4gXHRcdFx0XHRcdC8vIHRpbWVvdXRcclxuIFx0XHRcdFx0XHRyZWplY3QobmV3IEVycm9yKFwiTWFuaWZlc3QgcmVxdWVzdCB0byBcIiArIHJlcXVlc3RQYXRoICsgXCIgdGltZWQgb3V0LlwiKSk7XHJcbiBcdFx0XHRcdH0gZWxzZSBpZihyZXF1ZXN0LnN0YXR1cyA9PT0gNDA0KSB7XHJcbiBcdFx0XHRcdFx0Ly8gbm8gdXBkYXRlIGF2YWlsYWJsZVxyXG4gXHRcdFx0XHRcdHJlc29sdmUoKTtcclxuIFx0XHRcdFx0fSBlbHNlIGlmKHJlcXVlc3Quc3RhdHVzICE9PSAyMDAgJiYgcmVxdWVzdC5zdGF0dXMgIT09IDMwNCkge1xyXG4gXHRcdFx0XHRcdC8vIG90aGVyIGZhaWx1cmVcclxuIFx0XHRcdFx0XHRyZWplY3QobmV3IEVycm9yKFwiTWFuaWZlc3QgcmVxdWVzdCB0byBcIiArIHJlcXVlc3RQYXRoICsgXCIgZmFpbGVkLlwiKSk7XHJcbiBcdFx0XHRcdH0gZWxzZSB7XHJcbiBcdFx0XHRcdFx0Ly8gc3VjY2Vzc1xyXG4gXHRcdFx0XHRcdHRyeSB7XHJcbiBcdFx0XHRcdFx0XHR2YXIgdXBkYXRlID0gSlNPTi5wYXJzZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XHJcbiBcdFx0XHRcdFx0fSBjYXRjaChlKSB7XHJcbiBcdFx0XHRcdFx0XHRyZWplY3QoZSk7XHJcbiBcdFx0XHRcdFx0XHRyZXR1cm47XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdHJlc29sdmUodXBkYXRlKTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fTtcclxuIFx0XHR9KTtcclxuIFx0fVxyXG5cbiBcdFxyXG4gXHRcclxuIFx0dmFyIGhvdEFwcGx5T25VcGRhdGUgPSB0cnVlO1xyXG4gXHR2YXIgaG90Q3VycmVudEhhc2ggPSBcImFhYzRiYzc1NDNkYzcxM2Q0ZDUxXCI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0dmFyIGhvdFJlcXVlc3RUaW1lb3V0ID0gMTAwMDA7XHJcbiBcdHZhciBob3RDdXJyZW50TW9kdWxlRGF0YSA9IHt9O1xyXG4gXHR2YXIgaG90Q3VycmVudENoaWxkTW9kdWxlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdHZhciBob3RDdXJyZW50UGFyZW50cyA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdHZhciBob3RDdXJyZW50UGFyZW50c1RlbXAgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90Q3JlYXRlUmVxdWlyZShtb2R1bGVJZCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdFx0dmFyIG1lID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcbiBcdFx0aWYoIW1lKSByZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXztcclxuIFx0XHR2YXIgZm4gPSBmdW5jdGlvbihyZXF1ZXN0KSB7XHJcbiBcdFx0XHRpZihtZS5ob3QuYWN0aXZlKSB7XHJcbiBcdFx0XHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbcmVxdWVzdF0pIHtcclxuIFx0XHRcdFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW3JlcXVlc3RdLnBhcmVudHMuaW5kZXhPZihtb2R1bGVJZCkgPCAwKVxyXG4gXHRcdFx0XHRcdFx0aW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XS5wYXJlbnRzLnB1c2gobW9kdWxlSWQpO1xyXG4gXHRcdFx0XHR9IGVsc2Uge1xyXG4gXHRcdFx0XHRcdGhvdEN1cnJlbnRQYXJlbnRzID0gW21vZHVsZUlkXTtcclxuIFx0XHRcdFx0XHRob3RDdXJyZW50Q2hpbGRNb2R1bGUgPSByZXF1ZXN0O1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdGlmKG1lLmNoaWxkcmVuLmluZGV4T2YocmVxdWVzdCkgPCAwKVxyXG4gXHRcdFx0XHRcdG1lLmNoaWxkcmVuLnB1c2gocmVxdWVzdCk7XHJcbiBcdFx0XHR9IGVsc2Uge1xyXG4gXHRcdFx0XHRjb25zb2xlLndhcm4oXCJbSE1SXSB1bmV4cGVjdGVkIHJlcXVpcmUoXCIgKyByZXF1ZXN0ICsgXCIpIGZyb20gZGlzcG9zZWQgbW9kdWxlIFwiICsgbW9kdWxlSWQpO1xyXG4gXHRcdFx0XHRob3RDdXJyZW50UGFyZW50cyA9IFtdO1xyXG4gXHRcdFx0fVxyXG4gXHRcdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18ocmVxdWVzdCk7XHJcbiBcdFx0fTtcclxuIFx0XHR2YXIgT2JqZWN0RmFjdG9yeSA9IGZ1bmN0aW9uIE9iamVjdEZhY3RvcnkobmFtZSkge1xyXG4gXHRcdFx0cmV0dXJuIHtcclxuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxyXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG4gXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gXHRcdFx0XHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fW25hbWVdO1xyXG4gXHRcdFx0XHR9LFxyXG4gXHRcdFx0XHRzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiBcdFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfX1tuYW1lXSA9IHZhbHVlO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9O1xyXG4gXHRcdH07XHJcbiBcdFx0Zm9yKHZhciBuYW1lIGluIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfX3dlYnBhY2tfcmVxdWlyZV9fLCBuYW1lKSAmJiBuYW1lICE9PSBcImVcIikge1xyXG4gXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIG5hbWUsIE9iamVjdEZhY3RvcnkobmFtZSkpO1xyXG4gXHRcdFx0fVxyXG4gXHRcdH1cclxuIFx0XHRmbi5lID0gZnVuY3Rpb24oY2h1bmtJZCkge1xyXG4gXHRcdFx0aWYoaG90U3RhdHVzID09PSBcInJlYWR5XCIpXHJcbiBcdFx0XHRcdGhvdFNldFN0YXR1cyhcInByZXBhcmVcIik7XHJcbiBcdFx0XHRob3RDaHVua3NMb2FkaW5nKys7XHJcbiBcdFx0XHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXy5lKGNodW5rSWQpLnRoZW4oZmluaXNoQ2h1bmtMb2FkaW5nLCBmdW5jdGlvbihlcnIpIHtcclxuIFx0XHRcdFx0ZmluaXNoQ2h1bmtMb2FkaW5nKCk7XHJcbiBcdFx0XHRcdHRocm93IGVycjtcclxuIFx0XHRcdH0pO1xyXG4gXHRcclxuIFx0XHRcdGZ1bmN0aW9uIGZpbmlzaENodW5rTG9hZGluZygpIHtcclxuIFx0XHRcdFx0aG90Q2h1bmtzTG9hZGluZy0tO1xyXG4gXHRcdFx0XHRpZihob3RTdGF0dXMgPT09IFwicHJlcGFyZVwiKSB7XHJcbiBcdFx0XHRcdFx0aWYoIWhvdFdhaXRpbmdGaWxlc01hcFtjaHVua0lkXSkge1xyXG4gXHRcdFx0XHRcdFx0aG90RW5zdXJlVXBkYXRlQ2h1bmsoY2h1bmtJZCk7XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdGlmKGhvdENodW5rc0xvYWRpbmcgPT09IDAgJiYgaG90V2FpdGluZ0ZpbGVzID09PSAwKSB7XHJcbiBcdFx0XHRcdFx0XHRob3RVcGRhdGVEb3dubG9hZGVkKCk7XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0fTtcclxuIFx0XHRyZXR1cm4gZm47XHJcbiBcdH1cclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdENyZWF0ZU1vZHVsZShtb2R1bGVJZCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdFx0dmFyIGhvdCA9IHtcclxuIFx0XHRcdC8vIHByaXZhdGUgc3R1ZmZcclxuIFx0XHRcdF9hY2NlcHRlZERlcGVuZGVuY2llczoge30sXHJcbiBcdFx0XHRfZGVjbGluZWREZXBlbmRlbmNpZXM6IHt9LFxyXG4gXHRcdFx0X3NlbGZBY2NlcHRlZDogZmFsc2UsXHJcbiBcdFx0XHRfc2VsZkRlY2xpbmVkOiBmYWxzZSxcclxuIFx0XHRcdF9kaXNwb3NlSGFuZGxlcnM6IFtdLFxyXG4gXHRcdFx0X21haW46IGhvdEN1cnJlbnRDaGlsZE1vZHVsZSAhPT0gbW9kdWxlSWQsXHJcbiBcdFxyXG4gXHRcdFx0Ly8gTW9kdWxlIEFQSVxyXG4gXHRcdFx0YWN0aXZlOiB0cnVlLFxyXG4gXHRcdFx0YWNjZXB0OiBmdW5jdGlvbihkZXAsIGNhbGxiYWNrKSB7XHJcbiBcdFx0XHRcdGlmKHR5cGVvZiBkZXAgPT09IFwidW5kZWZpbmVkXCIpXHJcbiBcdFx0XHRcdFx0aG90Ll9zZWxmQWNjZXB0ZWQgPSB0cnVlO1xyXG4gXHRcdFx0XHRlbHNlIGlmKHR5cGVvZiBkZXAgPT09IFwiZnVuY3Rpb25cIilcclxuIFx0XHRcdFx0XHRob3QuX3NlbGZBY2NlcHRlZCA9IGRlcDtcclxuIFx0XHRcdFx0ZWxzZSBpZih0eXBlb2YgZGVwID09PSBcIm9iamVjdFwiKVxyXG4gXHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBkZXAubGVuZ3RoOyBpKyspXHJcbiBcdFx0XHRcdFx0XHRob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW2RlcFtpXV0gPSBjYWxsYmFjayB8fCBmdW5jdGlvbigpIHt9O1xyXG4gXHRcdFx0XHRlbHNlXHJcbiBcdFx0XHRcdFx0aG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1tkZXBdID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcclxuIFx0XHRcdH0sXHJcbiBcdFx0XHRkZWNsaW5lOiBmdW5jdGlvbihkZXApIHtcclxuIFx0XHRcdFx0aWYodHlwZW9mIGRlcCA9PT0gXCJ1bmRlZmluZWRcIilcclxuIFx0XHRcdFx0XHRob3QuX3NlbGZEZWNsaW5lZCA9IHRydWU7XHJcbiBcdFx0XHRcdGVsc2UgaWYodHlwZW9mIGRlcCA9PT0gXCJvYmplY3RcIilcclxuIFx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgZGVwLmxlbmd0aDsgaSsrKVxyXG4gXHRcdFx0XHRcdFx0aG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1tkZXBbaV1dID0gdHJ1ZTtcclxuIFx0XHRcdFx0ZWxzZVxyXG4gXHRcdFx0XHRcdGhvdC5fZGVjbGluZWREZXBlbmRlbmNpZXNbZGVwXSA9IHRydWU7XHJcbiBcdFx0XHR9LFxyXG4gXHRcdFx0ZGlzcG9zZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuIFx0XHRcdFx0aG90Ll9kaXNwb3NlSGFuZGxlcnMucHVzaChjYWxsYmFjayk7XHJcbiBcdFx0XHR9LFxyXG4gXHRcdFx0YWRkRGlzcG9zZUhhbmRsZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiBcdFx0XHRcdGhvdC5fZGlzcG9zZUhhbmRsZXJzLnB1c2goY2FsbGJhY2spO1xyXG4gXHRcdFx0fSxcclxuIFx0XHRcdHJlbW92ZURpc3Bvc2VIYW5kbGVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gXHRcdFx0XHR2YXIgaWR4ID0gaG90Ll9kaXNwb3NlSGFuZGxlcnMuaW5kZXhPZihjYWxsYmFjayk7XHJcbiBcdFx0XHRcdGlmKGlkeCA+PSAwKSBob3QuX2Rpc3Bvc2VIYW5kbGVycy5zcGxpY2UoaWR4LCAxKTtcclxuIFx0XHRcdH0sXHJcbiBcdFxyXG4gXHRcdFx0Ly8gTWFuYWdlbWVudCBBUElcclxuIFx0XHRcdGNoZWNrOiBob3RDaGVjayxcclxuIFx0XHRcdGFwcGx5OiBob3RBcHBseSxcclxuIFx0XHRcdHN0YXR1czogZnVuY3Rpb24obCkge1xyXG4gXHRcdFx0XHRpZighbCkgcmV0dXJuIGhvdFN0YXR1cztcclxuIFx0XHRcdFx0aG90U3RhdHVzSGFuZGxlcnMucHVzaChsKTtcclxuIFx0XHRcdH0sXHJcbiBcdFx0XHRhZGRTdGF0dXNIYW5kbGVyOiBmdW5jdGlvbihsKSB7XHJcbiBcdFx0XHRcdGhvdFN0YXR1c0hhbmRsZXJzLnB1c2gobCk7XHJcbiBcdFx0XHR9LFxyXG4gXHRcdFx0cmVtb3ZlU3RhdHVzSGFuZGxlcjogZnVuY3Rpb24obCkge1xyXG4gXHRcdFx0XHR2YXIgaWR4ID0gaG90U3RhdHVzSGFuZGxlcnMuaW5kZXhPZihsKTtcclxuIFx0XHRcdFx0aWYoaWR4ID49IDApIGhvdFN0YXR1c0hhbmRsZXJzLnNwbGljZShpZHgsIDEpO1xyXG4gXHRcdFx0fSxcclxuIFx0XHJcbiBcdFx0XHQvL2luaGVyaXQgZnJvbSBwcmV2aW91cyBkaXNwb3NlIGNhbGxcclxuIFx0XHRcdGRhdGE6IGhvdEN1cnJlbnRNb2R1bGVEYXRhW21vZHVsZUlkXVxyXG4gXHRcdH07XHJcbiBcdFx0aG90Q3VycmVudENoaWxkTW9kdWxlID0gdW5kZWZpbmVkO1xyXG4gXHRcdHJldHVybiBob3Q7XHJcbiBcdH1cclxuIFx0XHJcbiBcdHZhciBob3RTdGF0dXNIYW5kbGVycyA9IFtdO1xyXG4gXHR2YXIgaG90U3RhdHVzID0gXCJpZGxlXCI7XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RTZXRTdGF0dXMobmV3U3RhdHVzKSB7XHJcbiBcdFx0aG90U3RhdHVzID0gbmV3U3RhdHVzO1xyXG4gXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBob3RTdGF0dXNIYW5kbGVycy5sZW5ndGg7IGkrKylcclxuIFx0XHRcdGhvdFN0YXR1c0hhbmRsZXJzW2ldLmNhbGwobnVsbCwgbmV3U3RhdHVzKTtcclxuIFx0fVxyXG4gXHRcclxuIFx0Ly8gd2hpbGUgZG93bmxvYWRpbmdcclxuIFx0dmFyIGhvdFdhaXRpbmdGaWxlcyA9IDA7XHJcbiBcdHZhciBob3RDaHVua3NMb2FkaW5nID0gMDtcclxuIFx0dmFyIGhvdFdhaXRpbmdGaWxlc01hcCA9IHt9O1xyXG4gXHR2YXIgaG90UmVxdWVzdGVkRmlsZXNNYXAgPSB7fTtcclxuIFx0dmFyIGhvdEF2YWlsYWJsZUZpbGVzTWFwID0ge307XHJcbiBcdHZhciBob3REZWZlcnJlZDtcclxuIFx0XHJcbiBcdC8vIFRoZSB1cGRhdGUgaW5mb1xyXG4gXHR2YXIgaG90VXBkYXRlLCBob3RVcGRhdGVOZXdIYXNoO1xyXG4gXHRcclxuIFx0ZnVuY3Rpb24gdG9Nb2R1bGVJZChpZCkge1xyXG4gXHRcdHZhciBpc051bWJlciA9ICgraWQpICsgXCJcIiA9PT0gaWQ7XHJcbiBcdFx0cmV0dXJuIGlzTnVtYmVyID8gK2lkIDogaWQ7XHJcbiBcdH1cclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdENoZWNrKGFwcGx5KSB7XHJcbiBcdFx0aWYoaG90U3RhdHVzICE9PSBcImlkbGVcIikgdGhyb3cgbmV3IEVycm9yKFwiY2hlY2soKSBpcyBvbmx5IGFsbG93ZWQgaW4gaWRsZSBzdGF0dXNcIik7XHJcbiBcdFx0aG90QXBwbHlPblVwZGF0ZSA9IGFwcGx5O1xyXG4gXHRcdGhvdFNldFN0YXR1cyhcImNoZWNrXCIpO1xyXG4gXHRcdHJldHVybiBob3REb3dubG9hZE1hbmlmZXN0KGhvdFJlcXVlc3RUaW1lb3V0KS50aGVuKGZ1bmN0aW9uKHVwZGF0ZSkge1xyXG4gXHRcdFx0aWYoIXVwZGF0ZSkge1xyXG4gXHRcdFx0XHRob3RTZXRTdGF0dXMoXCJpZGxlXCIpO1xyXG4gXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuIFx0XHRcdH1cclxuIFx0XHRcdGhvdFJlcXVlc3RlZEZpbGVzTWFwID0ge307XHJcbiBcdFx0XHRob3RXYWl0aW5nRmlsZXNNYXAgPSB7fTtcclxuIFx0XHRcdGhvdEF2YWlsYWJsZUZpbGVzTWFwID0gdXBkYXRlLmM7XHJcbiBcdFx0XHRob3RVcGRhdGVOZXdIYXNoID0gdXBkYXRlLmg7XHJcbiBcdFxyXG4gXHRcdFx0aG90U2V0U3RhdHVzKFwicHJlcGFyZVwiKTtcclxuIFx0XHRcdHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiBcdFx0XHRcdGhvdERlZmVycmVkID0ge1xyXG4gXHRcdFx0XHRcdHJlc29sdmU6IHJlc29sdmUsXHJcbiBcdFx0XHRcdFx0cmVqZWN0OiByZWplY3RcclxuIFx0XHRcdFx0fTtcclxuIFx0XHRcdH0pO1xyXG4gXHRcdFx0aG90VXBkYXRlID0ge307XHJcbiBcdFx0XHR2YXIgY2h1bmtJZCA9IDE7XHJcbiBcdFx0XHR7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbG9uZS1ibG9ja3NcclxuIFx0XHRcdFx0LypnbG9iYWxzIGNodW5rSWQgKi9cclxuIFx0XHRcdFx0aG90RW5zdXJlVXBkYXRlQ2h1bmsoY2h1bmtJZCk7XHJcbiBcdFx0XHR9XHJcbiBcdFx0XHRpZihob3RTdGF0dXMgPT09IFwicHJlcGFyZVwiICYmIGhvdENodW5rc0xvYWRpbmcgPT09IDAgJiYgaG90V2FpdGluZ0ZpbGVzID09PSAwKSB7XHJcbiBcdFx0XHRcdGhvdFVwZGF0ZURvd25sb2FkZWQoKTtcclxuIFx0XHRcdH1cclxuIFx0XHRcdHJldHVybiBwcm9taXNlO1xyXG4gXHRcdH0pO1xyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RBZGRVcGRhdGVDaHVuayhjaHVua0lkLCBtb3JlTW9kdWxlcykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdFx0aWYoIWhvdEF2YWlsYWJsZUZpbGVzTWFwW2NodW5rSWRdIHx8ICFob3RSZXF1ZXN0ZWRGaWxlc01hcFtjaHVua0lkXSlcclxuIFx0XHRcdHJldHVybjtcclxuIFx0XHRob3RSZXF1ZXN0ZWRGaWxlc01hcFtjaHVua0lkXSA9IGZhbHNlO1xyXG4gXHRcdGZvcih2YXIgbW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcclxuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3JlTW9kdWxlcywgbW9kdWxlSWQpKSB7XHJcbiBcdFx0XHRcdGhvdFVwZGF0ZVttb2R1bGVJZF0gPSBtb3JlTW9kdWxlc1ttb2R1bGVJZF07XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcdGlmKC0taG90V2FpdGluZ0ZpbGVzID09PSAwICYmIGhvdENodW5rc0xvYWRpbmcgPT09IDApIHtcclxuIFx0XHRcdGhvdFVwZGF0ZURvd25sb2FkZWQoKTtcclxuIFx0XHR9XHJcbiBcdH1cclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdEVuc3VyZVVwZGF0ZUNodW5rKGNodW5rSWQpIHtcclxuIFx0XHRpZighaG90QXZhaWxhYmxlRmlsZXNNYXBbY2h1bmtJZF0pIHtcclxuIFx0XHRcdGhvdFdhaXRpbmdGaWxlc01hcFtjaHVua0lkXSA9IHRydWU7XHJcbiBcdFx0fSBlbHNlIHtcclxuIFx0XHRcdGhvdFJlcXVlc3RlZEZpbGVzTWFwW2NodW5rSWRdID0gdHJ1ZTtcclxuIFx0XHRcdGhvdFdhaXRpbmdGaWxlcysrO1xyXG4gXHRcdFx0aG90RG93bmxvYWRVcGRhdGVDaHVuayhjaHVua0lkKTtcclxuIFx0XHR9XHJcbiBcdH1cclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdFVwZGF0ZURvd25sb2FkZWQoKSB7XHJcbiBcdFx0aG90U2V0U3RhdHVzKFwicmVhZHlcIik7XHJcbiBcdFx0dmFyIGRlZmVycmVkID0gaG90RGVmZXJyZWQ7XHJcbiBcdFx0aG90RGVmZXJyZWQgPSBudWxsO1xyXG4gXHRcdGlmKCFkZWZlcnJlZCkgcmV0dXJuO1xyXG4gXHRcdGlmKGhvdEFwcGx5T25VcGRhdGUpIHtcclxuIFx0XHRcdC8vIFdyYXAgZGVmZXJyZWQgb2JqZWN0IGluIFByb21pc2UgdG8gbWFyayBpdCBhcyBhIHdlbGwtaGFuZGxlZCBQcm9taXNlIHRvXHJcbiBcdFx0XHQvLyBhdm9pZCB0cmlnZ2VyaW5nIHVuY2F1Z2h0IGV4Y2VwdGlvbiB3YXJuaW5nIGluIENocm9tZS5cclxuIFx0XHRcdC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NjU2NjZcclxuIFx0XHRcdFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiBcdFx0XHRcdHJldHVybiBob3RBcHBseShob3RBcHBseU9uVXBkYXRlKTtcclxuIFx0XHRcdH0pLnRoZW4oXHJcbiBcdFx0XHRcdGZ1bmN0aW9uKHJlc3VsdCkge1xyXG4gXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmUocmVzdWx0KTtcclxuIFx0XHRcdFx0fSxcclxuIFx0XHRcdFx0ZnVuY3Rpb24oZXJyKSB7XHJcbiBcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0KGVycik7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdCk7XHJcbiBcdFx0fSBlbHNlIHtcclxuIFx0XHRcdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbXTtcclxuIFx0XHRcdGZvcih2YXIgaWQgaW4gaG90VXBkYXRlKSB7XHJcbiBcdFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChob3RVcGRhdGUsIGlkKSkge1xyXG4gXHRcdFx0XHRcdG91dGRhdGVkTW9kdWxlcy5wdXNoKHRvTW9kdWxlSWQoaWQpKTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZShvdXRkYXRlZE1vZHVsZXMpO1xyXG4gXHRcdH1cclxuIFx0fVxyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90QXBwbHkob3B0aW9ucykge1xyXG4gXHRcdGlmKGhvdFN0YXR1cyAhPT0gXCJyZWFkeVwiKSB0aHJvdyBuZXcgRXJyb3IoXCJhcHBseSgpIGlzIG9ubHkgYWxsb3dlZCBpbiByZWFkeSBzdGF0dXNcIik7XHJcbiBcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiBcdFxyXG4gXHRcdHZhciBjYjtcclxuIFx0XHR2YXIgaTtcclxuIFx0XHR2YXIgajtcclxuIFx0XHR2YXIgbW9kdWxlO1xyXG4gXHRcdHZhciBtb2R1bGVJZDtcclxuIFx0XHJcbiBcdFx0ZnVuY3Rpb24gZ2V0QWZmZWN0ZWRTdHVmZih1cGRhdGVNb2R1bGVJZCkge1xyXG4gXHRcdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFt1cGRhdGVNb2R1bGVJZF07XHJcbiBcdFx0XHR2YXIgb3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSB7fTtcclxuIFx0XHJcbiBcdFx0XHR2YXIgcXVldWUgPSBvdXRkYXRlZE1vZHVsZXMuc2xpY2UoKS5tYXAoZnVuY3Rpb24oaWQpIHtcclxuIFx0XHRcdFx0cmV0dXJuIHtcclxuIFx0XHRcdFx0XHRjaGFpbjogW2lkXSxcclxuIFx0XHRcdFx0XHRpZDogaWRcclxuIFx0XHRcdFx0fTtcclxuIFx0XHRcdH0pO1xyXG4gXHRcdFx0d2hpbGUocXVldWUubGVuZ3RoID4gMCkge1xyXG4gXHRcdFx0XHR2YXIgcXVldWVJdGVtID0gcXVldWUucG9wKCk7XHJcbiBcdFx0XHRcdHZhciBtb2R1bGVJZCA9IHF1ZXVlSXRlbS5pZDtcclxuIFx0XHRcdFx0dmFyIGNoYWluID0gcXVldWVJdGVtLmNoYWluO1xyXG4gXHRcdFx0XHRtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcclxuIFx0XHRcdFx0aWYoIW1vZHVsZSB8fCBtb2R1bGUuaG90Ll9zZWxmQWNjZXB0ZWQpXHJcbiBcdFx0XHRcdFx0Y29udGludWU7XHJcbiBcdFx0XHRcdGlmKG1vZHVsZS5ob3QuX3NlbGZEZWNsaW5lZCkge1xyXG4gXHRcdFx0XHRcdHJldHVybiB7XHJcbiBcdFx0XHRcdFx0XHR0eXBlOiBcInNlbGYtZGVjbGluZWRcIixcclxuIFx0XHRcdFx0XHRcdGNoYWluOiBjaGFpbixcclxuIFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZFxyXG4gXHRcdFx0XHRcdH07XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdFx0aWYobW9kdWxlLmhvdC5fbWFpbikge1xyXG4gXHRcdFx0XHRcdHJldHVybiB7XHJcbiBcdFx0XHRcdFx0XHR0eXBlOiBcInVuYWNjZXB0ZWRcIixcclxuIFx0XHRcdFx0XHRcdGNoYWluOiBjaGFpbixcclxuIFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZFxyXG4gXHRcdFx0XHRcdH07XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1vZHVsZS5wYXJlbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiBcdFx0XHRcdFx0dmFyIHBhcmVudElkID0gbW9kdWxlLnBhcmVudHNbaV07XHJcbiBcdFx0XHRcdFx0dmFyIHBhcmVudCA9IGluc3RhbGxlZE1vZHVsZXNbcGFyZW50SWRdO1xyXG4gXHRcdFx0XHRcdGlmKCFwYXJlbnQpIGNvbnRpbnVlO1xyXG4gXHRcdFx0XHRcdGlmKHBhcmVudC5ob3QuX2RlY2xpbmVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSkge1xyXG4gXHRcdFx0XHRcdFx0cmV0dXJuIHtcclxuIFx0XHRcdFx0XHRcdFx0dHlwZTogXCJkZWNsaW5lZFwiLFxyXG4gXHRcdFx0XHRcdFx0XHRjaGFpbjogY2hhaW4uY29uY2F0KFtwYXJlbnRJZF0pLFxyXG4gXHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWQsXHJcbiBcdFx0XHRcdFx0XHRcdHBhcmVudElkOiBwYXJlbnRJZFxyXG4gXHRcdFx0XHRcdFx0fTtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0aWYob3V0ZGF0ZWRNb2R1bGVzLmluZGV4T2YocGFyZW50SWQpID49IDApIGNvbnRpbnVlO1xyXG4gXHRcdFx0XHRcdGlmKHBhcmVudC5ob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSkge1xyXG4gXHRcdFx0XHRcdFx0aWYoIW91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXSlcclxuIFx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdID0gW107XHJcbiBcdFx0XHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0sIFttb2R1bGVJZF0pO1xyXG4gXHRcdFx0XHRcdFx0Y29udGludWU7XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdGRlbGV0ZSBvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF07XHJcbiBcdFx0XHRcdFx0b3V0ZGF0ZWRNb2R1bGVzLnB1c2gocGFyZW50SWQpO1xyXG4gXHRcdFx0XHRcdHF1ZXVlLnB1c2goe1xyXG4gXHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLmNvbmNhdChbcGFyZW50SWRdKSxcclxuIFx0XHRcdFx0XHRcdGlkOiBwYXJlbnRJZFxyXG4gXHRcdFx0XHRcdH0pO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFxyXG4gXHRcdFx0cmV0dXJuIHtcclxuIFx0XHRcdFx0dHlwZTogXCJhY2NlcHRlZFwiLFxyXG4gXHRcdFx0XHRtb2R1bGVJZDogdXBkYXRlTW9kdWxlSWQsXHJcbiBcdFx0XHRcdG91dGRhdGVkTW9kdWxlczogb3V0ZGF0ZWRNb2R1bGVzLFxyXG4gXHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llczogb3V0ZGF0ZWREZXBlbmRlbmNpZXNcclxuIFx0XHRcdH07XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHRmdW5jdGlvbiBhZGRBbGxUb1NldChhLCBiKSB7XHJcbiBcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xyXG4gXHRcdFx0XHR2YXIgaXRlbSA9IGJbaV07XHJcbiBcdFx0XHRcdGlmKGEuaW5kZXhPZihpdGVtKSA8IDApXHJcbiBcdFx0XHRcdFx0YS5wdXNoKGl0ZW0pO1xyXG4gXHRcdFx0fVxyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0Ly8gYXQgYmVnaW4gYWxsIHVwZGF0ZXMgbW9kdWxlcyBhcmUgb3V0ZGF0ZWRcclxuIFx0XHQvLyB0aGUgXCJvdXRkYXRlZFwiIHN0YXR1cyBjYW4gcHJvcGFnYXRlIHRvIHBhcmVudHMgaWYgdGhleSBkb24ndCBhY2NlcHQgdGhlIGNoaWxkcmVuXHJcbiBcdFx0dmFyIG91dGRhdGVkRGVwZW5kZW5jaWVzID0ge307XHJcbiBcdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFtdO1xyXG4gXHRcdHZhciBhcHBsaWVkVXBkYXRlID0ge307XHJcbiBcdFxyXG4gXHRcdHZhciB3YXJuVW5leHBlY3RlZFJlcXVpcmUgPSBmdW5jdGlvbiB3YXJuVW5leHBlY3RlZFJlcXVpcmUoKSB7XHJcbiBcdFx0XHRjb25zb2xlLndhcm4oXCJbSE1SXSB1bmV4cGVjdGVkIHJlcXVpcmUoXCIgKyByZXN1bHQubW9kdWxlSWQgKyBcIikgdG8gZGlzcG9zZWQgbW9kdWxlXCIpO1xyXG4gXHRcdH07XHJcbiBcdFxyXG4gXHRcdGZvcih2YXIgaWQgaW4gaG90VXBkYXRlKSB7XHJcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaG90VXBkYXRlLCBpZCkpIHtcclxuIFx0XHRcdFx0bW9kdWxlSWQgPSB0b01vZHVsZUlkKGlkKTtcclxuIFx0XHRcdFx0dmFyIHJlc3VsdDtcclxuIFx0XHRcdFx0aWYoaG90VXBkYXRlW2lkXSkge1xyXG4gXHRcdFx0XHRcdHJlc3VsdCA9IGdldEFmZmVjdGVkU3R1ZmYobW9kdWxlSWQpO1xyXG4gXHRcdFx0XHR9IGVsc2Uge1xyXG4gXHRcdFx0XHRcdHJlc3VsdCA9IHtcclxuIFx0XHRcdFx0XHRcdHR5cGU6IFwiZGlzcG9zZWRcIixcclxuIFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBpZFxyXG4gXHRcdFx0XHRcdH07XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdFx0dmFyIGFib3J0RXJyb3IgPSBmYWxzZTtcclxuIFx0XHRcdFx0dmFyIGRvQXBwbHkgPSBmYWxzZTtcclxuIFx0XHRcdFx0dmFyIGRvRGlzcG9zZSA9IGZhbHNlO1xyXG4gXHRcdFx0XHR2YXIgY2hhaW5JbmZvID0gXCJcIjtcclxuIFx0XHRcdFx0aWYocmVzdWx0LmNoYWluKSB7XHJcbiBcdFx0XHRcdFx0Y2hhaW5JbmZvID0gXCJcXG5VcGRhdGUgcHJvcGFnYXRpb246IFwiICsgcmVzdWx0LmNoYWluLmpvaW4oXCIgLT4gXCIpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdHN3aXRjaChyZXN1bHQudHlwZSkge1xyXG4gXHRcdFx0XHRcdGNhc2UgXCJzZWxmLWRlY2xpbmVkXCI6XHJcbiBcdFx0XHRcdFx0XHRpZihvcHRpb25zLm9uRGVjbGluZWQpXHJcbiBcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25EZWNsaW5lZChyZXN1bHQpO1xyXG4gXHRcdFx0XHRcdFx0aWYoIW9wdGlvbnMuaWdub3JlRGVjbGluZWQpXHJcbiBcdFx0XHRcdFx0XHRcdGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoXCJBYm9ydGVkIGJlY2F1c2Ugb2Ygc2VsZiBkZWNsaW5lOiBcIiArIHJlc3VsdC5tb2R1bGVJZCArIGNoYWluSW5mbyk7XHJcbiBcdFx0XHRcdFx0XHRicmVhaztcclxuIFx0XHRcdFx0XHRjYXNlIFwiZGVjbGluZWRcIjpcclxuIFx0XHRcdFx0XHRcdGlmKG9wdGlvbnMub25EZWNsaW5lZClcclxuIFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkRlY2xpbmVkKHJlc3VsdCk7XHJcbiBcdFx0XHRcdFx0XHRpZighb3B0aW9ucy5pZ25vcmVEZWNsaW5lZClcclxuIFx0XHRcdFx0XHRcdFx0YWJvcnRFcnJvciA9IG5ldyBFcnJvcihcIkFib3J0ZWQgYmVjYXVzZSBvZiBkZWNsaW5lZCBkZXBlbmRlbmN5OiBcIiArIHJlc3VsdC5tb2R1bGVJZCArIFwiIGluIFwiICsgcmVzdWx0LnBhcmVudElkICsgY2hhaW5JbmZvKTtcclxuIFx0XHRcdFx0XHRcdGJyZWFrO1xyXG4gXHRcdFx0XHRcdGNhc2UgXCJ1bmFjY2VwdGVkXCI6XHJcbiBcdFx0XHRcdFx0XHRpZihvcHRpb25zLm9uVW5hY2NlcHRlZClcclxuIFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vblVuYWNjZXB0ZWQocmVzdWx0KTtcclxuIFx0XHRcdFx0XHRcdGlmKCFvcHRpb25zLmlnbm9yZVVuYWNjZXB0ZWQpXHJcbiBcdFx0XHRcdFx0XHRcdGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoXCJBYm9ydGVkIGJlY2F1c2UgXCIgKyBtb2R1bGVJZCArIFwiIGlzIG5vdCBhY2NlcHRlZFwiICsgY2hhaW5JbmZvKTtcclxuIFx0XHRcdFx0XHRcdGJyZWFrO1xyXG4gXHRcdFx0XHRcdGNhc2UgXCJhY2NlcHRlZFwiOlxyXG4gXHRcdFx0XHRcdFx0aWYob3B0aW9ucy5vbkFjY2VwdGVkKVxyXG4gXHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uQWNjZXB0ZWQocmVzdWx0KTtcclxuIFx0XHRcdFx0XHRcdGRvQXBwbHkgPSB0cnVlO1xyXG4gXHRcdFx0XHRcdFx0YnJlYWs7XHJcbiBcdFx0XHRcdFx0Y2FzZSBcImRpc3Bvc2VkXCI6XHJcbiBcdFx0XHRcdFx0XHRpZihvcHRpb25zLm9uRGlzcG9zZWQpXHJcbiBcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25EaXNwb3NlZChyZXN1bHQpO1xyXG4gXHRcdFx0XHRcdFx0ZG9EaXNwb3NlID0gdHJ1ZTtcclxuIFx0XHRcdFx0XHRcdGJyZWFrO1xyXG4gXHRcdFx0XHRcdGRlZmF1bHQ6XHJcbiBcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmV4Y2VwdGlvbiB0eXBlIFwiICsgcmVzdWx0LnR5cGUpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdGlmKGFib3J0RXJyb3IpIHtcclxuIFx0XHRcdFx0XHRob3RTZXRTdGF0dXMoXCJhYm9ydFwiKTtcclxuIFx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QoYWJvcnRFcnJvcik7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdFx0aWYoZG9BcHBseSkge1xyXG4gXHRcdFx0XHRcdGFwcGxpZWRVcGRhdGVbbW9kdWxlSWRdID0gaG90VXBkYXRlW21vZHVsZUlkXTtcclxuIFx0XHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZE1vZHVsZXMsIHJlc3VsdC5vdXRkYXRlZE1vZHVsZXMpO1xyXG4gXHRcdFx0XHRcdGZvcihtb2R1bGVJZCBpbiByZXN1bHQub3V0ZGF0ZWREZXBlbmRlbmNpZXMpIHtcclxuIFx0XHRcdFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQub3V0ZGF0ZWREZXBlbmRlbmNpZXMsIG1vZHVsZUlkKSkge1xyXG4gXHRcdFx0XHRcdFx0XHRpZighb3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKVxyXG4gXHRcdFx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSA9IFtdO1xyXG4gXHRcdFx0XHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0sIHJlc3VsdC5vdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pO1xyXG4gXHRcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRpZihkb0Rpc3Bvc2UpIHtcclxuIFx0XHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZE1vZHVsZXMsIFtyZXN1bHQubW9kdWxlSWRdKTtcclxuIFx0XHRcdFx0XHRhcHBsaWVkVXBkYXRlW21vZHVsZUlkXSA9IHdhcm5VbmV4cGVjdGVkUmVxdWlyZTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0Ly8gU3RvcmUgc2VsZiBhY2NlcHRlZCBvdXRkYXRlZCBtb2R1bGVzIHRvIHJlcXVpcmUgdGhlbSBsYXRlciBieSB0aGUgbW9kdWxlIHN5c3RlbVxyXG4gXHRcdHZhciBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXMgPSBbXTtcclxuIFx0XHRmb3IoaSA9IDA7IGkgPCBvdXRkYXRlZE1vZHVsZXMubGVuZ3RoOyBpKyspIHtcclxuIFx0XHRcdG1vZHVsZUlkID0gb3V0ZGF0ZWRNb2R1bGVzW2ldO1xyXG4gXHRcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gJiYgaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uaG90Ll9zZWxmQWNjZXB0ZWQpXHJcbiBcdFx0XHRcdG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcy5wdXNoKHtcclxuIFx0XHRcdFx0XHRtb2R1bGU6IG1vZHVsZUlkLFxyXG4gXHRcdFx0XHRcdGVycm9ySGFuZGxlcjogaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uaG90Ll9zZWxmQWNjZXB0ZWRcclxuIFx0XHRcdFx0fSk7XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBOb3cgaW4gXCJkaXNwb3NlXCIgcGhhc2VcclxuIFx0XHRob3RTZXRTdGF0dXMoXCJkaXNwb3NlXCIpO1xyXG4gXHRcdE9iamVjdC5rZXlzKGhvdEF2YWlsYWJsZUZpbGVzTWFwKS5mb3JFYWNoKGZ1bmN0aW9uKGNodW5rSWQpIHtcclxuIFx0XHRcdGlmKGhvdEF2YWlsYWJsZUZpbGVzTWFwW2NodW5rSWRdID09PSBmYWxzZSkge1xyXG4gXHRcdFx0XHRob3REaXNwb3NlQ2h1bmsoY2h1bmtJZCk7XHJcbiBcdFx0XHR9XHJcbiBcdFx0fSk7XHJcbiBcdFxyXG4gXHRcdHZhciBpZHg7XHJcbiBcdFx0dmFyIHF1ZXVlID0gb3V0ZGF0ZWRNb2R1bGVzLnNsaWNlKCk7XHJcbiBcdFx0d2hpbGUocXVldWUubGVuZ3RoID4gMCkge1xyXG4gXHRcdFx0bW9kdWxlSWQgPSBxdWV1ZS5wb3AoKTtcclxuIFx0XHRcdG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xyXG4gXHRcdFx0aWYoIW1vZHVsZSkgY29udGludWU7XHJcbiBcdFxyXG4gXHRcdFx0dmFyIGRhdGEgPSB7fTtcclxuIFx0XHJcbiBcdFx0XHQvLyBDYWxsIGRpc3Bvc2UgaGFuZGxlcnNcclxuIFx0XHRcdHZhciBkaXNwb3NlSGFuZGxlcnMgPSBtb2R1bGUuaG90Ll9kaXNwb3NlSGFuZGxlcnM7XHJcbiBcdFx0XHRmb3IoaiA9IDA7IGogPCBkaXNwb3NlSGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcclxuIFx0XHRcdFx0Y2IgPSBkaXNwb3NlSGFuZGxlcnNbal07XHJcbiBcdFx0XHRcdGNiKGRhdGEpO1xyXG4gXHRcdFx0fVxyXG4gXHRcdFx0aG90Q3VycmVudE1vZHVsZURhdGFbbW9kdWxlSWRdID0gZGF0YTtcclxuIFx0XHJcbiBcdFx0XHQvLyBkaXNhYmxlIG1vZHVsZSAodGhpcyBkaXNhYmxlcyByZXF1aXJlcyBmcm9tIHRoaXMgbW9kdWxlKVxyXG4gXHRcdFx0bW9kdWxlLmhvdC5hY3RpdmUgPSBmYWxzZTtcclxuIFx0XHJcbiBcdFx0XHQvLyByZW1vdmUgbW9kdWxlIGZyb20gY2FjaGVcclxuIFx0XHRcdGRlbGV0ZSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcclxuIFx0XHJcbiBcdFx0XHQvLyB3aGVuIGRpc3Bvc2luZyB0aGVyZSBpcyBubyBuZWVkIHRvIGNhbGwgZGlzcG9zZSBoYW5kbGVyXHJcbiBcdFx0XHRkZWxldGUgb3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdO1xyXG4gXHRcclxuIFx0XHRcdC8vIHJlbW92ZSBcInBhcmVudHNcIiByZWZlcmVuY2VzIGZyb20gYWxsIGNoaWxkcmVuXHJcbiBcdFx0XHRmb3IoaiA9IDA7IGogPCBtb2R1bGUuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcclxuIFx0XHRcdFx0dmFyIGNoaWxkID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGUuY2hpbGRyZW5bal1dO1xyXG4gXHRcdFx0XHRpZighY2hpbGQpIGNvbnRpbnVlO1xyXG4gXHRcdFx0XHRpZHggPSBjaGlsZC5wYXJlbnRzLmluZGV4T2YobW9kdWxlSWQpO1xyXG4gXHRcdFx0XHRpZihpZHggPj0gMCkge1xyXG4gXHRcdFx0XHRcdGNoaWxkLnBhcmVudHMuc3BsaWNlKGlkeCwgMSk7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdC8vIHJlbW92ZSBvdXRkYXRlZCBkZXBlbmRlbmN5IGZyb20gbW9kdWxlIGNoaWxkcmVuXHJcbiBcdFx0dmFyIGRlcGVuZGVuY3k7XHJcbiBcdFx0dmFyIG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzO1xyXG4gXHRcdGZvcihtb2R1bGVJZCBpbiBvdXRkYXRlZERlcGVuZGVuY2llcykge1xyXG4gXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG91dGRhdGVkRGVwZW5kZW5jaWVzLCBtb2R1bGVJZCkpIHtcclxuIFx0XHRcdFx0bW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcbiBcdFx0XHRcdGlmKG1vZHVsZSkge1xyXG4gXHRcdFx0XHRcdG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzID0gb3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdO1xyXG4gXHRcdFx0XHRcdGZvcihqID0gMDsgaiA8IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzLmxlbmd0aDsgaisrKSB7XHJcbiBcdFx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXNbal07XHJcbiBcdFx0XHRcdFx0XHRpZHggPSBtb2R1bGUuY2hpbGRyZW4uaW5kZXhPZihkZXBlbmRlbmN5KTtcclxuIFx0XHRcdFx0XHRcdGlmKGlkeCA+PSAwKSBtb2R1bGUuY2hpbGRyZW4uc3BsaWNlKGlkeCwgMSk7XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBOb3QgaW4gXCJhcHBseVwiIHBoYXNlXHJcbiBcdFx0aG90U2V0U3RhdHVzKFwiYXBwbHlcIik7XHJcbiBcdFxyXG4gXHRcdGhvdEN1cnJlbnRIYXNoID0gaG90VXBkYXRlTmV3SGFzaDtcclxuIFx0XHJcbiBcdFx0Ly8gaW5zZXJ0IG5ldyBjb2RlXHJcbiBcdFx0Zm9yKG1vZHVsZUlkIGluIGFwcGxpZWRVcGRhdGUpIHtcclxuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcHBsaWVkVXBkYXRlLCBtb2R1bGVJZCkpIHtcclxuIFx0XHRcdFx0bW9kdWxlc1ttb2R1bGVJZF0gPSBhcHBsaWVkVXBkYXRlW21vZHVsZUlkXTtcclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdC8vIGNhbGwgYWNjZXB0IGhhbmRsZXJzXHJcbiBcdFx0dmFyIGVycm9yID0gbnVsbDtcclxuIFx0XHRmb3IobW9kdWxlSWQgaW4gb3V0ZGF0ZWREZXBlbmRlbmNpZXMpIHtcclxuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvdXRkYXRlZERlcGVuZGVuY2llcywgbW9kdWxlSWQpKSB7XHJcbiBcdFx0XHRcdG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xyXG4gXHRcdFx0XHRpZihtb2R1bGUpIHtcclxuIFx0XHRcdFx0XHRtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyA9IG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXTtcclxuIFx0XHRcdFx0XHR2YXIgY2FsbGJhY2tzID0gW107XHJcbiBcdFx0XHRcdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcclxuIFx0XHRcdFx0XHRcdGRlcGVuZGVuY3kgPSBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llc1tpXTtcclxuIFx0XHRcdFx0XHRcdGNiID0gbW9kdWxlLmhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwZW5kZW5jeV07XHJcbiBcdFx0XHRcdFx0XHRpZihjYikge1xyXG4gXHRcdFx0XHRcdFx0XHRpZihjYWxsYmFja3MuaW5kZXhPZihjYikgPj0gMCkgY29udGludWU7XHJcbiBcdFx0XHRcdFx0XHRcdGNhbGxiYWNrcy5wdXNoKGNiKTtcclxuIFx0XHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0Zm9yKGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiBcdFx0XHRcdFx0XHRjYiA9IGNhbGxiYWNrc1tpXTtcclxuIFx0XHRcdFx0XHRcdHRyeSB7XHJcbiBcdFx0XHRcdFx0XHRcdGNiKG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzKTtcclxuIFx0XHRcdFx0XHRcdH0gY2F0Y2goZXJyKSB7XHJcbiBcdFx0XHRcdFx0XHRcdGlmKG9wdGlvbnMub25FcnJvcmVkKSB7XHJcbiBcdFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xyXG4gXHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJhY2NlcHQtZXJyb3JlZFwiLFxyXG4gXHRcdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxyXG4gXHRcdFx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jeUlkOiBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llc1tpXSxcclxuIFx0XHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnJcclxuIFx0XHRcdFx0XHRcdFx0XHR9KTtcclxuIFx0XHRcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdFx0XHRpZighb3B0aW9ucy5pZ25vcmVFcnJvcmVkKSB7XHJcbiBcdFx0XHRcdFx0XHRcdFx0aWYoIWVycm9yKVxyXG4gXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3IgPSBlcnI7XHJcbiBcdFx0XHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdC8vIExvYWQgc2VsZiBhY2NlcHRlZCBtb2R1bGVzXHJcbiBcdFx0Zm9yKGkgPSAwOyBpIDwgb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzLmxlbmd0aDsgaSsrKSB7XHJcbiBcdFx0XHR2YXIgaXRlbSA9IG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlc1tpXTtcclxuIFx0XHRcdG1vZHVsZUlkID0gaXRlbS5tb2R1bGU7XHJcbiBcdFx0XHRob3RDdXJyZW50UGFyZW50cyA9IFttb2R1bGVJZF07XHJcbiBcdFx0XHR0cnkge1xyXG4gXHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKTtcclxuIFx0XHRcdH0gY2F0Y2goZXJyKSB7XHJcbiBcdFx0XHRcdGlmKHR5cGVvZiBpdGVtLmVycm9ySGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiBcdFx0XHRcdFx0dHJ5IHtcclxuIFx0XHRcdFx0XHRcdGl0ZW0uZXJyb3JIYW5kbGVyKGVycik7XHJcbiBcdFx0XHRcdFx0fSBjYXRjaChlcnIyKSB7XHJcbiBcdFx0XHRcdFx0XHRpZihvcHRpb25zLm9uRXJyb3JlZCkge1xyXG4gXHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRXJyb3JlZCh7XHJcbiBcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzZWxmLWFjY2VwdC1lcnJvci1oYW5kbGVyLWVycm9yZWRcIixcclxuIFx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWQsXHJcbiBcdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVycjIsXHJcbiBcdFx0XHRcdFx0XHRcdFx0b3JnaW5hbEVycm9yOiBlcnIsIC8vIFRPRE8gcmVtb3ZlIGluIHdlYnBhY2sgNFxyXG4gXHRcdFx0XHRcdFx0XHRcdG9yaWdpbmFsRXJyb3I6IGVyclxyXG4gXHRcdFx0XHRcdFx0XHR9KTtcclxuIFx0XHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRcdGlmKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcclxuIFx0XHRcdFx0XHRcdFx0aWYoIWVycm9yKVxyXG4gXHRcdFx0XHRcdFx0XHRcdGVycm9yID0gZXJyMjtcclxuIFx0XHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRcdGlmKCFlcnJvcilcclxuIFx0XHRcdFx0XHRcdFx0ZXJyb3IgPSBlcnI7XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHR9IGVsc2Uge1xyXG4gXHRcdFx0XHRcdGlmKG9wdGlvbnMub25FcnJvcmVkKSB7XHJcbiBcdFx0XHRcdFx0XHRvcHRpb25zLm9uRXJyb3JlZCh7XHJcbiBcdFx0XHRcdFx0XHRcdHR5cGU6IFwic2VsZi1hY2NlcHQtZXJyb3JlZFwiLFxyXG4gXHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWQsXHJcbiBcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnJcclxuIFx0XHRcdFx0XHRcdH0pO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRpZighb3B0aW9ucy5pZ25vcmVFcnJvcmVkKSB7XHJcbiBcdFx0XHRcdFx0XHRpZighZXJyb3IpXHJcbiBcdFx0XHRcdFx0XHRcdGVycm9yID0gZXJyO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0Ly8gaGFuZGxlIGVycm9ycyBpbiBhY2NlcHQgaGFuZGxlcnMgYW5kIHNlbGYgYWNjZXB0ZWQgbW9kdWxlIGxvYWRcclxuIFx0XHRpZihlcnJvcikge1xyXG4gXHRcdFx0aG90U2V0U3RhdHVzKFwiZmFpbFwiKTtcclxuIFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHRob3RTZXRTdGF0dXMoXCJpZGxlXCIpO1xyXG4gXHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XHJcbiBcdFx0XHRyZXNvbHZlKG91dGRhdGVkTW9kdWxlcyk7XHJcbiBcdFx0fSk7XHJcbiBcdH1cclxuXG4gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRob3Q6IGhvdENyZWF0ZU1vZHVsZShtb2R1bGVJZCksXG4gXHRcdFx0cGFyZW50czogKGhvdEN1cnJlbnRQYXJlbnRzVGVtcCA9IGhvdEN1cnJlbnRQYXJlbnRzLCBob3RDdXJyZW50UGFyZW50cyA9IFtdLCBob3RDdXJyZW50UGFyZW50c1RlbXApLFxuIFx0XHRcdGNoaWxkcmVuOiBbXVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBob3RDcmVhdGVSZXF1aXJlKG1vZHVsZUlkKSk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIF9fd2VicGFja19oYXNoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18uaCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaG90Q3VycmVudEhhc2g7IH07XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIGhvdENyZWF0ZVJlcXVpcmUoMTI0KShfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxMjQpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGFhYzRiYzc1NDNkYzcxM2Q0ZDUxIiwiLy8gR0xUb29sLmpzXG5cbmltcG9ydCB7IG1hdDQsIG1hdDMgfSBmcm9tICdnbC1tYXRyaXgnO1xuXG5pbXBvcnQgZ2V0QW5kQXBwbHlFeHRlbnNpb24gZnJvbSAnLi91dGlscy9nZXRBbmRBcHBseUV4dGVuc2lvbic7XG5pbXBvcnQgZXhwb3NlQXR0cmlidXRlcyBmcm9tICcuL3V0aWxzL2V4cG9zZUF0dHJpYnV0ZXMnO1xuaW1wb3J0IGdldEZsb2F0IGZyb20gJy4vdXRpbHMvZ2V0RmxvYXQnO1xuaW1wb3J0IGdldEhhbGZGbG9hdCBmcm9tICcuL3V0aWxzL2dldEhhbGZGbG9hdCc7XG5pbXBvcnQgZ2V0QXR0cmliTG9jIGZyb20gJy4vdXRpbHMvZ2V0QXR0cmliTG9jJztcbmltcG9ydCBFeHRlbnNpb25zTGlzdCBmcm9tICcuL3V0aWxzL0V4dGVuc2lvbnNMaXN0JztcblxubGV0IGdsO1xuXG5jbGFzcyBHTFRvb2wge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuY2FudmFzO1xuXHRcdHRoaXMuX3ZpZXdwb3J0ICAgICAgICAgICAgICAgPSBbMCwgMCwgMCwgMF07XG5cdFx0dGhpcy5fZW5hYmxlZFZlcnRleEF0dHJpYnV0ZSA9IFtdO1xuXHRcdHRoaXMuaWRlbnRpdHlNYXRyaXggICAgICAgICAgPSBtYXQ0LmNyZWF0ZSgpO1xuXHRcdHRoaXMuX25vcm1hbE1hdHJpeCAgICAgICAgICAgPSBtYXQzLmNyZWF0ZSgpO1xuXHRcdHRoaXMuX2ludmVyc2VNb2RlbFZpZXdNYXRyaXggPSBtYXQzLmNyZWF0ZSgpO1xuXHRcdHRoaXMuX21vZGVsTWF0cml4ICAgICAgICAgICAgPSBtYXQ0LmNyZWF0ZSgpO1xuXHRcdHRoaXMuX21hdHJpeCAgICAgICAgICAgICAgICAgPSBtYXQ0LmNyZWF0ZSgpO1xuXHRcdHRoaXMuX21hdHJpeFN0YWNrcyBcdFx0XHQgPSBbXTtcblx0XHR0aGlzLl9sYXN0TWVzaFx0XHRcdFx0ID0gbnVsbDtcblx0XHR0aGlzLl91c2VXZWJHTDIgXHRcdFx0ID0gZmFsc2U7XG5cdFx0dGhpcy5faGFzQXJyYXlJbnN0YW5jZTtcblx0XHR0aGlzLl9leHRBcnJheUluc3RhbmNlO1xuXHRcdHRoaXMuX2hhc0NoZWNrZWRFeHQgPSBmYWxzZTtcblx0XHRtYXQ0LmlkZW50aXR5KHRoaXMuaWRlbnRpdHlNYXRyaXgsIHRoaXMuaWRlbnRpdHlNYXRyaXgpO1xuXG5cdFx0dGhpcy5pc01vYmlsZSA9IGZhbHNlO1xuXHRcdGlmKC9BbmRyb2lkfHdlYk9TfGlQaG9uZXxpUGFkfGlQb2R8QmxhY2tCZXJyeXxJRU1vYmlsZXxPcGVyYSBNaW5pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuXHRcdFx0dGhpcy5pc01vYmlsZSA9IHRydWU7XG5cdFx0fVxuXHR9XG5cblx0Ly9cdElOSVRJQUxJWkVcblxuXHRpbml0KG1DYW52YXMsIG1QYXJhbWV0ZXJzID0ge30pIHtcblxuXHRcdGlmKG1DYW52YXMgPT09IG51bGwgfHwgbUNhbnZhcyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdDYW52YXMgbm90IGV4aXN0Jyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdFxuXHRcdGlmKHRoaXMuY2FudmFzICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jYW52YXMgIT09IG51bGwpIHtcblx0XHRcdHRoaXMuZGVzdHJveSgpO1xuXHRcdH1cblx0XHRcblx0XHR0aGlzLmNhbnZhcyA9IG1DYW52YXM7XG5cdFx0dGhpcy5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuXG5cdFx0bVBhcmFtZXRlcnMudXNlV2ViZ2wyID0gbVBhcmFtZXRlcnMudXNlV2ViZ2wyIHx8IGZhbHNlO1xuXG5cdFx0bGV0IGN0eDtcblx0XHRpZihtUGFyYW1ldGVycy51c2VXZWJnbDIpIHtcblx0XHRcdGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbDInLCBtUGFyYW1ldGVycykgfHwgdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJywgbVBhcmFtZXRlcnMpO1xuXG5cdFx0XHRpZighY3R4KSB7XG5cdFx0XHRcdGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgbVBhcmFtZXRlcnMpIHx8IHRoaXMuY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIG1QYXJhbWV0ZXJzKTtcdFxuXHRcdFx0XHR0aGlzLl91c2VXZWJHTDIgPSBmYWxzZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3VzZVdlYkdMMiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsMicsIG1QYXJhbWV0ZXJzKSB8fCB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInLCBtUGFyYW1ldGVycyk7XG5cdFx0XHQvLyBpZihjdHgpIHtcblx0XHRcdC8vIFx0dGhpcy5fdXNlV2ViR0wyID0gdHJ1ZTtcblx0XHRcdC8vIH0gZWxzZSB7XG5cdFx0XHQvLyBcdGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgbVBhcmFtZXRlcnMpIHx8IHRoaXMuY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIG1QYXJhbWV0ZXJzKTtcblx0XHRcdC8vIH1cblxuXHRcdFx0Y3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBtUGFyYW1ldGVycykgfHwgdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgbVBhcmFtZXRlcnMpO1x0XG5cdFx0XHR0aGlzLl91c2VXZWJHTDIgPSBmYWxzZTtcblx0XHRcdFxuXHRcdH1cblxuXHRcdGNvbnNvbGUubG9nKCdVc2luZyBXZWJHTCAyID8nLCB0aGlzLndlYmdsMik7XG5cblx0XHQvL1x0ZXh0ZW5zaW9uc1xuXHRcdHRoaXMuaW5pdFdpdGhHTChjdHgpO1xuXHR9XG5cblx0aW5pdFdpdGhHTChjdHgpIHtcblx0XHRpZighdGhpcy5jYW52YXMpIHtcdHRoaXMuY2FudmFzID0gY3R4LmNhbnZhcztcdH1cblx0XHRnbCA9IHRoaXMuZ2wgPSBjdHg7XG5cblx0XHR0aGlzLmV4dGVuc2lvbnMgPSB7fTtcblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgRXh0ZW5zaW9uc0xpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRoaXMuZXh0ZW5zaW9uc1tFeHRlbnNpb25zTGlzdFtpXV0gPSBnbC5nZXRFeHRlbnNpb24oRXh0ZW5zaW9uc0xpc3RbaV0pO1xuXHRcdH1cblx0XHRcblx0XHQvL1x0Q29weSBnbCBBdHRyaWJ1dGVzXG5cdFx0ZXhwb3NlQXR0cmlidXRlcygpO1xuXHRcdGdldEFuZEFwcGx5RXh0ZW5zaW9uKGdsLCAnT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnKTtcblx0XHRnZXRBbmRBcHBseUV4dGVuc2lvbihnbCwgJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnKTtcblx0XHRnZXRBbmRBcHBseUV4dGVuc2lvbihnbCwgJ1dFQkdMX2RyYXdfYnVmZmVycycpO1xuXHRcdFxuXHRcdHRoaXMuZW5hYmxlKHRoaXMuREVQVEhfVEVTVCk7XG5cdFx0dGhpcy5lbmFibGUodGhpcy5DVUxMX0ZBQ0UpO1xuXHRcdHRoaXMuZW5hYmxlKHRoaXMuQkxFTkQpO1xuXHRcdHRoaXMuZW5hYmxlQWxwaGFCbGVuZGluZygpO1xuXHR9IFxuXG5cblxuXHQvL1x0UFVCTElDIE1FVEhPRFNcblxuXHRzZXRWaWV3cG9ydCh4LCB5LCB3LCBoKSB7XG5cdFx0bGV0IGhhc0NoYW5nZWQgPSBmYWxzZTtcblx0XHRpZih4ICE9PSB0aGlzLl92aWV3cG9ydFswXSkgeyBoYXNDaGFuZ2VkID0gdHJ1ZTsgfVxuXHRcdGlmKHkgIT09IHRoaXMuX3ZpZXdwb3J0WzFdKSB7IGhhc0NoYW5nZWQgPSB0cnVlOyB9XG5cdFx0aWYodyAhPT0gdGhpcy5fdmlld3BvcnRbMl0pIHsgaGFzQ2hhbmdlZCA9IHRydWU7IH1cblx0XHRpZihoICE9PSB0aGlzLl92aWV3cG9ydFszXSkgeyBoYXNDaGFuZ2VkID0gdHJ1ZTsgfVxuXG5cdFx0aWYoaGFzQ2hhbmdlZCkge1xuXHRcdFx0Z2wudmlld3BvcnQoeCwgeSwgdywgaCk7XG5cdFx0XHR0aGlzLl92aWV3cG9ydCA9IFt4LCB5LCB3LCBoXTtcblx0XHR9XG5cdH1cblxuXHRzY2lzc29yKHgsIHksIHcsIGgpIHtcblx0XHRnbC5zY2lzc29yKHgsIHksIHcsIGgpO1xuXHR9XG5cblxuXHRjbGVhcihyLCBnLCBiLCBhKSB7XG5cdFx0Z2wuY2xlYXJDb2xvcihyLCBnLCBiLCBhKTtcblx0XHRnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCk7XG5cdH1cblxuXG5cdGN1bGxGYWNlKG1WYWx1ZSkge1xuXHRcdGdsLmN1bGxGYWNlKG1WYWx1ZSk7XG5cdH1cblxuXG5cdHNldE1hdHJpY2VzKG1DYW1lcmEpIHtcblx0XHR0aGlzLmNhbWVyYSA9IG1DYW1lcmE7XG5cdFx0dGhpcy5yb3RhdGUodGhpcy5pZGVudGl0eU1hdHJpeCk7XG5cdH1cblxuXG5cdHVzZVNoYWRlcihtU2hhZGVyKSB7XG5cdFx0dGhpcy5zaGFkZXIgPSBtU2hhZGVyO1xuXHRcdHRoaXMuc2hhZGVyUHJvZ3JhbSA9IHRoaXMuc2hhZGVyLnNoYWRlclByb2dyYW07XG5cdH1cblxuXG5cdHJvdGF0ZShtUm90YXRpb24pIHtcblx0XHRtYXQ0LmNvcHkodGhpcy5fbW9kZWxNYXRyaXgsIG1Sb3RhdGlvbik7XG5cdFx0bWF0NC5tdWx0aXBseSh0aGlzLl9tYXRyaXgsIHRoaXMuY2FtZXJhLm1hdHJpeCwgdGhpcy5fbW9kZWxNYXRyaXgpO1xuXHRcdG1hdDMuZnJvbU1hdDQodGhpcy5fbm9ybWFsTWF0cml4LCB0aGlzLl9tYXRyaXgpO1xuXHRcdG1hdDMuaW52ZXJ0KHRoaXMuX25vcm1hbE1hdHJpeCwgdGhpcy5fbm9ybWFsTWF0cml4KTtcblx0XHRtYXQzLnRyYW5zcG9zZSh0aGlzLl9ub3JtYWxNYXRyaXgsIHRoaXMuX25vcm1hbE1hdHJpeCk7XG5cdFx0XG5cblx0XHRtYXQzLmZyb21NYXQ0KHRoaXMuX2ludmVyc2VNb2RlbFZpZXdNYXRyaXgsIHRoaXMuX21hdHJpeCk7XG5cdFx0bWF0My5pbnZlcnQodGhpcy5faW52ZXJzZU1vZGVsVmlld01hdHJpeCwgdGhpcy5faW52ZXJzZU1vZGVsVmlld01hdHJpeCk7XG5cdH1cblxuXG5cdGRyYXcobU1lc2gsIG1EcmF3aW5nVHlwZSkge1xuXHRcdGlmKG1NZXNoLmxlbmd0aCkge1xuXHRcdFx0Zm9yKGxldCBpID0gMDsgaSA8IG1NZXNoLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuZHJhdyhtTWVzaFtpXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bU1lc2guYmluZCh0aGlzLnNoYWRlclByb2dyYW0pO1xuXG5cdFx0Ly9cdERFRkFVTFQgVU5JRk9STVNcblx0XHRpZih0aGlzLmNhbWVyYSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNoYWRlci51bmlmb3JtKCd1UHJvamVjdGlvbk1hdHJpeCcsICdtYXQ0JywgdGhpcy5jYW1lcmEucHJvamVjdGlvbik7XHRcblx0XHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oJ3VWaWV3TWF0cml4JywgJ21hdDQnLCB0aGlzLmNhbWVyYS5tYXRyaXgpO1xuXHRcdH1cblx0XHRcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKCd1TW9kZWxNYXRyaXgnLCAnbWF0NCcsIHRoaXMuX21vZGVsTWF0cml4KTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKCd1Tm9ybWFsTWF0cml4JywgJ21hdDMnLCB0aGlzLl9ub3JtYWxNYXRyaXgpO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oJ3VNb2RlbFZpZXdNYXRyaXhJbnZlcnNlJywgJ21hdDMnLCB0aGlzLl9pbnZlcnNlTW9kZWxWaWV3TWF0cml4KTtcblxuXHRcdGxldCBkcmF3VHlwZSA9IG1NZXNoLmRyYXdUeXBlO1xuXHRcdGlmKG1EcmF3aW5nVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRkcmF3VHlwZSA9IG1EcmF3aW5nVHlwZTtcblx0XHR9XG5cblx0XHRpZihtTWVzaC5pc0luc3RhbmNlZCkge1xuXHRcdFx0Ly9cdERSQVdJTkdcblx0XHRcdGdsLmRyYXdFbGVtZW50c0luc3RhbmNlZChtTWVzaC5kcmF3VHlwZSwgbU1lc2guaUJ1ZmZlci5udW1JdGVtcywgZ2wuVU5TSUdORURfU0hPUlQsIDAsIG1NZXNoLm51bUluc3RhbmNlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYoZHJhd1R5cGUgPT09IGdsLlBPSU5UUykge1xuXHRcdFx0XHRnbC5kcmF3QXJyYXlzKGRyYXdUeXBlLCAwLCBtTWVzaC52ZXJ0ZXhTaXplKTtcdFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Z2wuZHJhd0VsZW1lbnRzKGRyYXdUeXBlLCBtTWVzaC5pQnVmZmVyLm51bUl0ZW1zLCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XHRcblx0XHRcdH1cdFxuXHRcdH1cblxuXHRcdG1NZXNoLnVuYmluZCgpO1xuXHR9XG5cblxuXHRkcmF3VHJhbnNmb3JtRmVlZGJhY2sobVRyYW5zZm9ybU9iamVjdCkge1xuXG5cdFx0Y29uc3QgeyBtZXNoU291cmNlLCBtZXNoRGVzdGluYXRpb24sIG51bVBvaW50cywgdHJhbnNmb3JtRmVlZGJhY2sgfSA9IG1UcmFuc2Zvcm1PYmplY3Q7XG5cdFx0XG5cdFx0Ly9cdEJJTkQgU09VUkNFIEJVRkZFUlMgLT4gc2V0dXBWZXJ0ZXhBdHRyKHNvdXJjZVZBTylcblx0XHRtZXNoU291cmNlLmJpbmQodGhpcy5zaGFkZXJQcm9ncmFtKTtcblx0XHRtZXNoRGVzdGluYXRpb24uZ2VuZXJhdGVCdWZmZXJzKHRoaXMuc2hhZGVyUHJvZ3JhbSk7XG5cblx0XHQvL1x0QklORCBERVNUSU5BVElPTiBCVUZGRVJTXG5cdFx0Z2wuYmluZFRyYW5zZm9ybUZlZWRiYWNrKGdsLlRSQU5TRk9STV9GRUVEQkFDSywgdHJhbnNmb3JtRmVlZGJhY2spO1xuXG5cdFx0bWVzaERlc3RpbmF0aW9uLmF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0ciwgaSk9PiB7XG5cdFx0XHRnbC5iaW5kQnVmZmVyQmFzZShnbC5UUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSLCBpLCBhdHRyLmJ1ZmZlcik7XG5cdFx0fSk7XG5cblx0XHRnbC5lbmFibGUoZ2wuUkFTVEVSSVpFUl9ESVNDQVJEKTtcblxuXHRcdGdsLmJlZ2luVHJhbnNmb3JtRmVlZGJhY2soZ2wuUE9JTlRTKTtcblx0XHRnbC5kcmF3QXJyYXlzKGdsLlBPSU5UUywgMCwgbnVtUG9pbnRzKTtcblx0XHRnbC5lbmRUcmFuc2Zvcm1GZWVkYmFjaygpO1x0XG5cdFx0XG5cblx0XHQvL1x0cmVzZXQgc3RhdGVcblx0XHRnbC5kaXNhYmxlKGdsLlJBU1RFUklaRVJfRElTQ0FSRCk7XG5cdFx0Z2wudXNlUHJvZ3JhbShudWxsKTtcblx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XG5cdFx0bWVzaERlc3RpbmF0aW9uLmF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0ciwgaSk9PiB7XG5cdFx0XHRnbC5iaW5kQnVmZmVyQmFzZShnbC5UUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSLCBpLCBudWxsKTtcblx0XHR9KTtcblx0XHRnbC5iaW5kVHJhbnNmb3JtRmVlZGJhY2soZ2wuVFJBTlNGT1JNX0ZFRURCQUNLLCBudWxsKTtcblxuXHRcdG1lc2hTb3VyY2UudW5iaW5kKCk7XG5cdH1cblxuXG5cdHNldFNpemUobVdpZHRoLCBtSGVpZ2h0KSB7XG5cdFx0dGhpcy5fd2lkdGggICAgICAgID0gbVdpZHRoO1xuXHRcdHRoaXMuX2hlaWdodCAgICAgICA9IG1IZWlnaHQ7XG5cdFx0dGhpcy5jYW52YXMud2lkdGggID0gdGhpcy5fd2lkdGg7XG5cdFx0dGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuXHRcdHRoaXMuX2FzcGVjdFJhdGlvICA9IHRoaXMuX3dpZHRoIC8gdGhpcy5faGVpZ2h0O1xuXG5cdFx0aWYoZ2wpIHtcblx0XHRcdHRoaXMudmlld3BvcnQoMCwgMCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XHRcblx0XHR9XG5cdH1cblxuXG5cdHNob3dFeHRlbnNpb25zKCkge1xuXHRcdGNvbnNvbGUubG9nKCdFeHRlbnNpb25zIDogJywgdGhpcy5leHRlbnNpb25zKTtcblx0XHRmb3IoY29uc3QgZXh0IGluIHRoaXMuZXh0ZW5zaW9ucykge1xuXHRcdFx0aWYodGhpcy5leHRlbnNpb25zW2V4dF0pIHtcblx0XHRcdFx0Y29uc29sZS5sb2coZXh0LCAnOicsIHRoaXMuZXh0ZW5zaW9uc1tleHRdKTtcdFxuXHRcdFx0fVxuXHRcdH1cdFxuXHR9XG5cblx0Y2hlY2tFeHRlbnNpb24obUV4dGVuc2lvbikge1xuXHRcdHJldHVybiAhIXRoaXMuZXh0ZW5zaW9uc1ttRXh0ZW5zaW9uXTtcblx0fVxuXG5cblx0Z2V0RXh0ZW5zaW9uKG1FeHRlbnNpb24pIHtcblx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zW21FeHRlbnNpb25dO1xuXHR9XG5cblx0Ly9cdEJMRU5EIE1PREVTXG5cblx0ZW5hYmxlQWxwaGFCbGVuZGluZygpIHtcblx0XHRnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcdFxuXHR9XG5cblx0ZW5hYmxlQWRkaXRpdmVCbGVuZGluZygpIHtcblx0XHRnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkUpO1xuXHR9XG5cblx0Ly9cdG1hdHJpY2VzXG5cblx0cHVzaE1hdHJpeCgpIHtcblx0XHRjb25zdCBtdHggPSBtYXQ0LmNsb25lKHRoaXMuX21vZGVsTWF0cml4KTtcblx0XHR0aGlzLl9tYXRyaXhTdGFja3MucHVzaChtdHgpO1xuXHR9XG5cblxuXHRwb3BNYXRyaXgoKSB7XG5cdFx0aWYodGhpcy5fbWF0cml4U3RhY2tzLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0Y29uc3QgbXR4ID0gdGhpcy5fbWF0cml4U3RhY2tzLnBvcCgpO1xuXHRcdHRoaXMucm90YXRlKG10eCk7XG5cdH1cblxuXG5cdC8vXHRHTCBOQVRJVkUgRlVOQ1RJT05TXG5cblx0ZW5hYmxlKG1QYXJhbWV0ZXIpIHtcdGdsLmVuYWJsZShtUGFyYW1ldGVyKTtcdFx0fVxuXG5cdGRpc2FibGUobVBhcmFtZXRlcikge1x0Z2wuZGlzYWJsZShtUGFyYW1ldGVyKTtcdH1cblxuXHR2aWV3cG9ydCh4LCB5LCB3LCBoKSB7XHR0aGlzLnNldFZpZXdwb3J0KHgsIHksIHcsIGgpO1x0fVxuXG5cblx0Ly9cdEdFVFRFUiBBTkQgU0VUVEVSU1xuXG5cdGdldCBGTE9BVCgpIHsgcmV0dXJuIGdldEZsb2F0KCk7IH1cblx0XG5cdGdldCBIQUxGX0ZMT0FUKCkgeyByZXR1cm4gZ2V0SGFsZkZsb2F0KCk7IH1cblxuXHRnZXQgd2lkdGgoKSB7XHRyZXR1cm4gdGhpcy5fd2lkdGg7XHRcdH1cblxuXHRnZXQgaGVpZ2h0KCkge1x0cmV0dXJuIHRoaXMuX2hlaWdodDtcdH1cblxuXHRnZXQgYXNwZWN0UmF0aW8oKSB7XHRyZXR1cm4gdGhpcy5fYXNwZWN0UmF0aW87XHR9XG5cblx0Z2V0IHdlYmdsMigpIHtcdHJldHVybiB0aGlzLl91c2VXZWJHTDI7XHR9XG5cblx0Ly9cdERFU1RST1lcblxuXHRkZXN0cm95KCkge1xuXHRcdFxuXHRcdGlmKHRoaXMuY2FudmFzLnBhcmVudE5vZGUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoaXMuY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jYW52YXMpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnRXJyb3IgOiAnLCBlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmNhbnZhcyA9IG51bGw7XG5cdH1cbn1cblxuY29uc3QgR0wgPSBuZXcgR0xUb29sKCk7XG5cbmV4cG9ydCBkZWZhdWx0IEdMO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvR0xUb29sLmpzIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGdsLW1hdHJpeCAtIEhpZ2ggcGVyZm9ybWFuY2UgbWF0cml4IGFuZCB2ZWN0b3Igb3BlcmF0aW9uc1xuICogQGF1dGhvciBCcmFuZG9uIEpvbmVzXG4gKiBAYXV0aG9yIENvbGluIE1hY0tlbnppZSBJVlxuICogQHZlcnNpb24gMi40LjBcbiAqL1xuXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuLy8gRU5EIEhFQURFUlxuXG5pbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9nbC1tYXRyaXgvY29tbW9uXCI7XG5pbXBvcnQgKiBhcyBtYXQyIGZyb20gXCIuL2dsLW1hdHJpeC9tYXQyXCI7XG5pbXBvcnQgKiBhcyBtYXQyZCBmcm9tIFwiLi9nbC1tYXRyaXgvbWF0MmRcIjtcbmltcG9ydCAqIGFzIG1hdDMgZnJvbSBcIi4vZ2wtbWF0cml4L21hdDNcIjtcbmltcG9ydCAqIGFzIG1hdDQgZnJvbSBcIi4vZ2wtbWF0cml4L21hdDRcIjtcbmltcG9ydCAqIGFzIHF1YXQgZnJvbSBcIi4vZ2wtbWF0cml4L3F1YXRcIjtcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSBcIi4vZ2wtbWF0cml4L3ZlYzJcIjtcbmltcG9ydCAqIGFzIHZlYzMgZnJvbSBcIi4vZ2wtbWF0cml4L3ZlYzNcIjtcbmltcG9ydCAqIGFzIHZlYzQgZnJvbSBcIi4vZ2wtbWF0cml4L3ZlYzRcIjtcblxuZXhwb3J0IHtcbiAgZ2xNYXRyaXgsXG4gIG1hdDIsIG1hdDJkLCBtYXQzLCBtYXQ0LFxuICBxdWF0LFxuICB2ZWMyLCB2ZWMzLCB2ZWM0LFxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIEdMU2hhZGVyLmpzXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEdMIGZyb20gJy4vR0xUb29sJztcbmNvbnN0IGdsc2xpZnkgPSByZXF1aXJlKCdnbHNsaWZ5Jyk7XG5jb25zdCBpc1NhbWUgPSAoYXJyYXkxLCBhcnJheTIpID0+IHtcblx0aWYoYXJyYXkxLmxlbmd0aCAhPT0gYXJyYXkyLmxlbmd0aCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGZvcihsZXQgaSA9IDA7IGkgPCBhcnJheTEubGVuZ3RoOyBpKyspIHtcblx0XHRpZihhcnJheTFbaV0gIT09IGFycmF5MltpXSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgYWRkTGluZU51bWJlcnMgPSAoc3RyaW5nKSA9PiB7XG5cdGNvbnN0IGxpbmVzID0gc3RyaW5nLnNwbGl0KCdcXG4nKTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkgKyspIHtcblx0XHRsaW5lc1tpXSA9IGAkeyhpICsgMSl9OiAke2xpbmVzW2ldfWA7XG5cdH1cblx0cmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xufTtcblxuXG5jb25zdCBjbG9uZUFycmF5ID0gKG1BcnJheSkgPT4ge1xuXHRpZihtQXJyYXkuc2xpY2UpIHtcblx0XHRyZXR1cm4gbUFycmF5LnNsaWNlKDApOyBcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShtQXJyYXkpO1xuXHR9XG59O1xuXG5sZXQgZ2w7XG5jb25zdCBkZWZhdWx0VmVydGV4U2hhZGVyID0gcmVxdWlyZSgnLi9zaGFkZXJzL2Jhc2ljLnZlcnQnKTtcbmNvbnN0IGRlZmF1bHRGcmFnbWVudFNoYWRlciA9IHJlcXVpcmUoJy4vc2hhZGVycy9iYXNpYy5mcmFnJyk7XG5cbmNvbnN0IHVuaWZvcm1NYXBwaW5nID0ge1xuXHRmbG9hdDogJ3VuaWZvcm0xZicsXG5cdHZlYzI6ICd1bmlmb3JtMmZ2Jyxcblx0dmVjMzogJ3VuaWZvcm0zZnYnLFxuXHR2ZWM0OiAndW5pZm9ybTRmdicsXG5cdGludDogJ3VuaWZvcm0xaScsXG5cdG1hdDM6ICd1bmlmb3JtTWF0cml4M2Z2Jyxcblx0bWF0NDogJ3VuaWZvcm1NYXRyaXg0ZnYnXG59O1xuXG5jbGFzcyBHTFNoYWRlciB7XG5cdGNvbnN0cnVjdG9yKHN0clZlcnRleFNoYWRlciA9IGRlZmF1bHRWZXJ0ZXhTaGFkZXIsIHN0ckZyYWdtZW50U2hhZGVyID0gZGVmYXVsdEZyYWdtZW50U2hhZGVyLCBtVmFyeWluZ3MpIHtcblxuXHRcdGdsICAgICAgICAgICAgICAgICAgID0gR0wuZ2w7XG5cdFx0dGhpcy5wYXJhbWV0ZXJzICAgICAgPSBbXTtcblx0XHR0aGlzLnVuaWZvcm1UZXh0dXJlcyA9IFtdO1xuXHRcdHRoaXMuX3ZhcnlpbmdzIFx0XHQgPSBtVmFyeWluZ3M7XG5cblx0XHRpZighc3RyVmVydGV4U2hhZGVyKSB7IHN0clZlcnRleFNoYWRlciA9IGRlZmF1bHRWZXJ0ZXhTaGFkZXI7IH1cblx0XHRpZighc3RyRnJhZ21lbnRTaGFkZXIpIHsgc3RyRnJhZ21lbnRTaGFkZXIgPSBkZWZhdWx0VmVydGV4U2hhZGVyOyB9XG5cblx0XHRjb25zdCB2c1NoYWRlciA9IHRoaXMuX2NyZWF0ZVNoYWRlclByb2dyYW0oc3RyVmVydGV4U2hhZGVyLCB0cnVlKTtcblx0XHRjb25zdCBmc1NoYWRlciA9IHRoaXMuX2NyZWF0ZVNoYWRlclByb2dyYW0oc3RyRnJhZ21lbnRTaGFkZXIsIGZhbHNlKTtcblx0XHR0aGlzLl9hdHRhY2hTaGFkZXJQcm9ncmFtKHZzU2hhZGVyLCBmc1NoYWRlcik7XG5cblx0fVxuXG5cblx0YmluZCgpIHtcblxuXHRcdGlmKEdMLnNoYWRlciA9PT0gdGhpcykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRnbC51c2VQcm9ncmFtKHRoaXMuc2hhZGVyUHJvZ3JhbSk7XG5cdFx0R0wudXNlU2hhZGVyKHRoaXMpO1xuXHRcdHRoaXMudW5pZm9ybVRleHR1cmVzID0gW107XG5cblx0fVxuXG5cblx0dW5pZm9ybShtTmFtZSwgbVR5cGUsIG1WYWx1ZSkge1xuXHRcdGlmKHR5cGVvZiBtTmFtZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdHRoaXMudW5pZm9ybU9iamVjdChtTmFtZSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdC8qXG5cdFx0aWYoISFtVmFsdWUgPT09IHVuZGVmaW5lZCB8fCBtVmFsdWUgPT09IG51bGwpIHtcblx0XHRcdGNvbnNvbGUud2FybignbVZhbHVlIEVycm9yOicsIG1OYW1lKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdCovXG5cdFx0Y29uc3QgdW5pZm9ybVR5cGUgPSB1bmlmb3JtTWFwcGluZ1ttVHlwZV0gfHwgbVR5cGU7XG5cdFx0XG5cdFx0bGV0IGhhc1VuaWZvcm0gPSBmYWxzZTtcblx0XHRsZXQgb1VuaWZvcm07XG5cdFx0bGV0IHBhcmFtZXRlckluZGV4ID0gLTE7XG5cblxuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLnBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdG9Vbmlmb3JtID0gdGhpcy5wYXJhbWV0ZXJzW2ldO1xuXHRcdFx0aWYob1VuaWZvcm0ubmFtZSA9PT0gbU5hbWUpIHtcblx0XHRcdFx0aGFzVW5pZm9ybSA9IHRydWU7XG5cdFx0XHRcdHBhcmFtZXRlckluZGV4ID0gaTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IGlzTnVtYmVyID0gZmFsc2U7XG5cblx0XHRpZighaGFzVW5pZm9ybSkge1xuXHRcdFx0aXNOdW1iZXIgPSB1bmlmb3JtVHlwZSA9PT0gJ3VuaWZvcm0xaScgfHwgdW5pZm9ybVR5cGUgPT09ICd1bmlmb3JtMWYnO1xuXHRcdFx0dGhpcy5zaGFkZXJQcm9ncmFtW21OYW1lXSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnNoYWRlclByb2dyYW0sIG1OYW1lKTtcblx0XHRcdGlmKGlzTnVtYmVyKSB7XG5cdFx0XHRcdHRoaXMucGFyYW1ldGVycy5wdXNoKHsgbmFtZSA6IG1OYW1lLCB0eXBlOiB1bmlmb3JtVHlwZSwgdmFsdWU6IG1WYWx1ZSwgdW5pZm9ybUxvYzogdGhpcy5zaGFkZXJQcm9ncmFtW21OYW1lXSwgaXNOdW1iZXIgfSk7XHRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMucGFyYW1ldGVycy5wdXNoKHsgbmFtZSA6IG1OYW1lLCB0eXBlOiB1bmlmb3JtVHlwZSwgdmFsdWU6IGNsb25lQXJyYXkobVZhbHVlKSwgdW5pZm9ybUxvYzogdGhpcy5zaGFkZXJQcm9ncmFtW21OYW1lXSwgaXNOdW1iZXIgfSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHBhcmFtZXRlckluZGV4ID0gdGhpcy5wYXJhbWV0ZXJzLmxlbmd0aCAtIDE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuc2hhZGVyUHJvZ3JhbVttTmFtZV0gPSBvVW5pZm9ybS51bmlmb3JtTG9jO1xuXHRcdFx0aXNOdW1iZXIgPSBvVW5pZm9ybS5pc051bWJlcjtcblx0XHR9XG5cblxuXHRcdGlmKCF0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVySW5kZXhdLnVuaWZvcm1Mb2MpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblxuXHRcdGlmKHVuaWZvcm1UeXBlLmluZGV4T2YoJ01hdHJpeCcpID09PSAtMSkge1xuXHRcdFx0aWYoIWlzTnVtYmVyKSB7XG5cdFx0XHRcdGlmKCFpc1NhbWUodGhpcy5wYXJhbWV0ZXJzW3BhcmFtZXRlckluZGV4XS52YWx1ZSwgbVZhbHVlKSB8fCAhaGFzVW5pZm9ybSkge1xuXHRcdFx0XHRcdGdsW3VuaWZvcm1UeXBlXSh0aGlzLnNoYWRlclByb2dyYW1bbU5hbWVdLCBtVmFsdWUpO1x0XG5cdFx0XHRcdFx0dGhpcy5wYXJhbWV0ZXJzW3BhcmFtZXRlckluZGV4XS52YWx1ZSA9IGNsb25lQXJyYXkobVZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgbmVlZFVwZGF0ZSA9ICh0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVySW5kZXhdLnZhbHVlICE9PSBtVmFsdWUgfHwgIWhhc1VuaWZvcm0pO1xuXHRcdFx0XHRpZihuZWVkVXBkYXRlKSB7XG5cdFx0XHRcdFx0Z2xbdW5pZm9ybVR5cGVdKHRoaXMuc2hhZGVyUHJvZ3JhbVttTmFtZV0sIG1WYWx1ZSk7XHRcblx0XHRcdFx0XHR0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVySW5kZXhdLnZhbHVlID0gbVZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYoIWlzU2FtZSh0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVySW5kZXhdLnZhbHVlLCBtVmFsdWUpIHx8ICFoYXNVbmlmb3JtKSB7XG5cdFx0XHRcdGdsW3VuaWZvcm1UeXBlXSh0aGlzLnNoYWRlclByb2dyYW1bbU5hbWVdLCBmYWxzZSwgbVZhbHVlKTtcdFxuXHRcdFx0XHR0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVySW5kZXhdLnZhbHVlID0gY2xvbmVBcnJheShtVmFsdWUpO1xuXG5cdFx0XHR9XG5cdFx0fVxuXG5cdH1cblxuXHR1bmlmb3JtT2JqZWN0KG1Vbmlmb3JtT2JqKSB7XG5cdFx0Zm9yKGNvbnN0IHVuaWZvcm1OYW1lIGluIG1Vbmlmb3JtT2JqKSB7XG5cdFx0XHRsZXQgdW5pZm9ybVZhbHVlID0gbVVuaWZvcm1PYmpbdW5pZm9ybU5hbWVdO1xuXHRcdFx0Y29uc3QgdW5pZm9ybVR5cGUgPSBHTFNoYWRlci5nZXRVbmlmb3JtVHlwZSh1bmlmb3JtVmFsdWUpO1xuXG5cdFx0XHRpZih1bmlmb3JtVmFsdWUuY29uY2F0ICYmIHVuaWZvcm1WYWx1ZVswXS5jb25jYXQpIHtcblx0XHRcdFx0bGV0IHRtcCA9IFtdO1xuXHRcdFx0XHRmb3IobGV0IGk9MDsgaTx1bmlmb3JtVmFsdWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAuY29uY2F0KHVuaWZvcm1WYWx1ZVtpXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dW5pZm9ybVZhbHVlID0gdG1wO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR0aGlzLnVuaWZvcm0odW5pZm9ybU5hbWUsIHVuaWZvcm1UeXBlLCB1bmlmb3JtVmFsdWUpO1xuXHRcdH1cblxuXHR9XG5cblxuXHRfY3JlYXRlU2hhZGVyUHJvZ3JhbShtU2hhZGVyU3RyLCBpc1ZlcnRleFNoYWRlcikge1xuXHRcdFxuXHRcdGNvbnN0IHNoYWRlclR5cGUgPSBpc1ZlcnRleFNoYWRlciA/IEdMLlZFUlRFWF9TSEFERVIgOiBHTC5GUkFHTUVOVF9TSEFERVI7XG5cdFx0Y29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHNoYWRlclR5cGUpO1xuXG5cdFx0Z2wuc2hhZGVyU291cmNlKHNoYWRlciwgbVNoYWRlclN0cik7XG5cdFx0Z2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuXG5cdFx0aWYoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdFcnJvciBpbiBTaGFkZXIgOiAnLCBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xuXHRcdFx0Y29uc29sZS5sb2coYWRkTGluZU51bWJlcnMobVNoYWRlclN0cikpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNoYWRlcjtcblx0fVxuXG5cdF9hdHRhY2hTaGFkZXJQcm9ncmFtKG1WZXJ0ZXhTaGFkZXIsIG1GcmFnbWVudFNoYWRlcikge1xuXG5cdFx0dGhpcy5zaGFkZXJQcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXHRcdGdsLmF0dGFjaFNoYWRlcih0aGlzLnNoYWRlclByb2dyYW0sIG1WZXJ0ZXhTaGFkZXIpO1xuXHRcdGdsLmF0dGFjaFNoYWRlcih0aGlzLnNoYWRlclByb2dyYW0sIG1GcmFnbWVudFNoYWRlcik7XG5cblx0XHRnbC5kZWxldGVTaGFkZXIobVZlcnRleFNoYWRlcik7XG5cdFx0Z2wuZGVsZXRlU2hhZGVyKG1GcmFnbWVudFNoYWRlcik7XG5cblx0XHRpZih0aGlzLl92YXJ5aW5ncykge1xuXHRcdFx0Y29uc29sZS5sb2coJ1RyYW5zZm9ybSBmZWVkYmFjayBzZXR1cCA6ICcsIHRoaXMuX3ZhcnlpbmdzKTtcblx0XHRcdGdsLnRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3ModGhpcy5zaGFkZXJQcm9ncmFtLCB0aGlzLl92YXJ5aW5ncywgZ2wuU0VQQVJBVEVfQVRUUklCUyk7XG5cdFx0fVxuXG5cdFx0Z2wubGlua1Byb2dyYW0odGhpcy5zaGFkZXJQcm9ncmFtKTtcblxuXHR9XG5cbn1cblxuR0xTaGFkZXIuZ2V0VW5pZm9ybVR5cGUgPSBmdW5jdGlvbiAobVZhbHVlKSB7XG5cdGNvbnN0IGlzQXJyYXkgPSAhIW1WYWx1ZS5jb25jYXQ7XG5cblx0Y29uc3QgZ2V0QXJyYXlVbmlmb3JtVHlwZSA9IGZ1bmN0aW9uIChtVmFsdWUpIHtcblx0XHRpZihtVmFsdWUubGVuZ3RoID09PSA5KSB7XG5cdFx0XHRyZXR1cm4gJ3VuaWZvcm1NYXRyaXgzZnYnO1xuXHRcdH0gZWxzZSBpZihtVmFsdWUubGVuZ3RoID09PSAxNikge1xuXHRcdFx0cmV0dXJuICd1bmlmb3JtTWF0cml4NGZ2Jztcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGB2ZWMke21WYWx1ZS5sZW5ndGh9YDtcdFxuXHRcdH1cblx0fTtcblxuXHRpZighaXNBcnJheSkge1xuXHRcdHJldHVybiAnZmxvYXQnO1xuXHR9IGVsc2Uge1xuXHRcdGlmICghbVZhbHVlWzBdLmNvbmNhdCkge1xuXHRcdFx0cmV0dXJuIGdldEFycmF5VW5pZm9ybVR5cGUobVZhbHVlKTtcdFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZ2V0QXJyYXlVbmlmb3JtVHlwZShtVmFsdWVbMF0pO1xuXHRcdH1cblx0fVxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBHTFNoYWRlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9HTFNoYWRlci5qcyIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbi8qKlxuICogQ29tbW9uIHV0aWxpdGllc1xuICogQG1vZHVsZSBnbE1hdHJpeFxuICovXG5cbi8vIENvbmZpZ3VyYXRpb24gQ29uc3RhbnRzXG5leHBvcnQgY29uc3QgRVBTSUxPTiA9IDAuMDAwMDAxO1xuZXhwb3J0IGxldCBBUlJBWV9UWVBFID0gKHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKSA/IEZsb2F0MzJBcnJheSA6IEFycmF5O1xuZXhwb3J0IGNvbnN0IFJBTkRPTSA9IE1hdGgucmFuZG9tO1xuXG4vKipcbiAqIFNldHMgdGhlIHR5cGUgb2YgYXJyYXkgdXNlZCB3aGVuIGNyZWF0aW5nIG5ldyB2ZWN0b3JzIGFuZCBtYXRyaWNlc1xuICpcbiAqIEBwYXJhbSB7VHlwZX0gdHlwZSBBcnJheSB0eXBlLCBzdWNoIGFzIEZsb2F0MzJBcnJheSBvciBBcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0TWF0cml4QXJyYXlUeXBlKHR5cGUpIHtcbiAgQVJSQVlfVFlQRSA9IHR5cGU7XG59XG5cbmNvbnN0IGRlZ3JlZSA9IE1hdGguUEkgLyAxODA7XG5cbi8qKlxuICogQ29udmVydCBEZWdyZWUgVG8gUmFkaWFuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGEgQW5nbGUgaW4gRGVncmVlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdG9SYWRpYW4oYSkge1xuICByZXR1cm4gYSAqIGRlZ3JlZTtcbn1cblxuLyoqXG4gKiBUZXN0cyB3aGV0aGVyIG9yIG5vdCB0aGUgYXJndW1lbnRzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSB2YWx1ZSwgd2l0aGluIGFuIGFic29sdXRlXG4gKiBvciByZWxhdGl2ZSB0b2xlcmFuY2Ugb2YgZ2xNYXRyaXguRVBTSUxPTiAoYW4gYWJzb2x1dGUgdG9sZXJhbmNlIGlzIHVzZWQgZm9yIHZhbHVlcyBsZXNzXG4gKiB0aGFuIG9yIGVxdWFsIHRvIDEuMCwgYW5kIGEgcmVsYXRpdmUgdG9sZXJhbmNlIGlzIHVzZWQgZm9yIGxhcmdlciB2YWx1ZXMpXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGEgVGhlIGZpcnN0IG51bWJlciB0byB0ZXN0LlxuICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIHNlY29uZCBudW1iZXIgdG8gdGVzdC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBudW1iZXJzIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDw9IEVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhKSwgTWF0aC5hYnMoYikpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvY29tbW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgR0wgZnJvbSAnLi9HTFRvb2wnO1xuaW1wb3J0IHsgdmVjMyB9IGZyb20gJ2dsLW1hdHJpeCc7XG5pbXBvcnQgZ2V0QXR0cmliTG9jIGZyb20gJy4vdXRpbHMvZ2V0QXR0cmliTG9jJztcblxubGV0IGdsO1xuY29uc3QgU1RBVElDX0RSQVcgPSAzNTA0NDtcblxuY29uc3QgZ2V0QnVmZmVyID0gZnVuY3Rpb24gKGF0dHIpIHtcblx0bGV0IGJ1ZmZlcjtcblx0XG5cdGlmKGF0dHIuYnVmZmVyICE9PSB1bmRlZmluZWQpIHtcblx0XHRidWZmZXIgPSBhdHRyLmJ1ZmZlcjtcdFxuXHR9IGVsc2Uge1xuXHRcdGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdGF0dHIuYnVmZmVyID0gYnVmZmVyO1xuXHR9XG5cblx0cmV0dXJuIGJ1ZmZlcjtcbn07XG5cblxuY29uc3QgZm9ybUJ1ZmZlciA9IGZ1bmN0aW9uIChtRGF0YSwgbU51bSkge1xuXHRjb25zdCBhcnkgPSBbXTtcblxuXHRmb3IobGV0IGk9MDsgaTxtRGF0YS5sZW5ndGg7IGkrPSBtTnVtKSB7XG5cdFx0Y29uc3QgbyA9IFtdO1xuXHRcdGZvcihsZXQgaj0wOyBqPG1OdW07IGorKykge1xuXHRcdFx0by5wdXNoKG1EYXRhW2kral0pO1xuXHRcdH1cblxuXHRcdGFyeS5wdXNoKG8pO1xuXHR9XG5cblx0cmV0dXJuIGFyeTtcbn07XG5cbmNsYXNzIE1lc2gge1xuXHRjb25zdHJ1Y3RvcihtRHJhd2luZ1R5cGUgPSA0LCBtVXNlVmFvID0gdHJ1ZSkge1xuXHRcdGdsICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBHTC5nbDtcblx0XHR0aGlzLmRyYXdUeXBlICAgICAgICAgICAgICAgID0gbURyYXdpbmdUeXBlO1xuXHRcdHRoaXMuX2F0dHJpYnV0ZXMgICAgICAgICAgICAgPSBbXTtcblx0XHR0aGlzLl9udW1JbnN0YW5jZSBcdFx0XHQgPSAtMTtcblx0XHR0aGlzLl9lbmFibGVkVmVydGV4QXR0cmlidXRlID0gW107XG5cdFx0XG5cdFx0dGhpcy5faW5kaWNlcyAgICAgICAgICAgICAgICA9IFtdO1xuXHRcdHRoaXMuX2ZhY2VzICAgICAgICAgICAgICAgICAgPSBbXTtcblx0XHR0aGlzLl9idWZmZXJDaGFuZ2VkICAgICAgICAgID0gW107XG5cdFx0dGhpcy5faGFzSW5kZXhCdWZmZXJDaGFuZ2VkICA9IGZhbHNlO1xuXHRcdHRoaXMuX2hhc1ZBTyAgICAgICAgICAgICAgICAgPSBmYWxzZTtcblx0XHR0aGlzLl9pc0luc3RhbmNlZCBcdFx0XHQgPSBmYWxzZTtcblx0XHRcblx0XHR0aGlzLl9leHRWQU8gICAgICAgICAgICAgICAgID0gISFHTC5nbC5jcmVhdGVWZXJ0ZXhBcnJheTtcblx0XHR0aGlzLl91c2VWQU8gICAgICAgICAgICAgXHQgPSAhIXRoaXMuX2V4dFZBTyAmJiBtVXNlVmFvO1xuXHRcdC8vIHRoaXMuX3VzZVZBTyA9IGZhbHNlO1xuXHR9XG5cblxuXHRidWZmZXJWZXJ0ZXgobUFycmF5VmVydGljZXMsIG1EcmF3VHlwZSA9IFNUQVRJQ19EUkFXKSB7XG5cblx0XHR0aGlzLmJ1ZmZlckRhdGEobUFycmF5VmVydGljZXMsICdhVmVydGV4UG9zaXRpb24nLCAzLCBtRHJhd1R5cGUpO1xuXG5cdFx0aWYgKHRoaXMubm9ybWFscy5sZW5ndGggPCB0aGlzLnZlcnRpY2VzLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5idWZmZXJOb3JtYWwobUFycmF5VmVydGljZXMsIG1EcmF3VHlwZSk7XHRcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cblx0YnVmZmVyVGV4Q29vcmQobUFycmF5VGV4Q29vcmRzLCBtRHJhd1R5cGUgPSBTVEFUSUNfRFJBVykge1xuXG5cdFx0dGhpcy5idWZmZXJEYXRhKG1BcnJheVRleENvb3JkcywgJ2FUZXh0dXJlQ29vcmQnLCAyLCBtRHJhd1R5cGUpO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXG5cdGJ1ZmZlck5vcm1hbChtTm9ybWFscywgbURyYXdUeXBlID0gU1RBVElDX0RSQVcpIHtcblxuXHRcdHRoaXMuYnVmZmVyRGF0YShtTm9ybWFscywgJ2FOb3JtYWwnLCAzLCBtRHJhd1R5cGUpO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXG5cdGJ1ZmZlckluZGV4KG1BcnJheUluZGljZXMsIGlzRHluYW1pYyA9IGZhbHNlKSB7XG5cdFx0dGhpcy5fZHJhd1R5cGUgICAgICAgID0gaXNEeW5hbWljID8gZ2wuRFlOQU1JQ19EUkFXIDogZ2wuU1RBVElDX0RSQVc7XG5cdFx0aWYobUFycmF5SW5kaWNlcyBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHR0aGlzLl9pbmRpY2VzXHQgID0gbmV3IFVpbnQxNkFycmF5KG1BcnJheUluZGljZXMpO1x0XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2luZGljZXMgPSBtQXJyYXlJbmRpY2VzO1xuXHRcdH1cblx0XHRcblx0XHR0aGlzLl9udW1JdGVtcyBcdFx0ICA9IHRoaXMuX2luZGljZXMubGVuZ3RoO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRidWZmZXJGbGF0dGVuRGF0YShtRGF0YSwgbU5hbWUsIG1JdGVtU2l6ZSwgbURyYXdUeXBlID0gU1RBVElDX0RSQVcsIGlzSW5zdGFuY2VkID0gZmFsc2UpIHtcblx0XHRcblx0XHRjb25zdCBkYXRhID0gZm9ybUJ1ZmZlcihtRGF0YSwgbUl0ZW1TaXplKTtcblx0XHR0aGlzLmJ1ZmZlckRhdGEoZGF0YSwgbU5hbWUsIG1JdGVtU2l6ZSwgbURyYXdUeXBlID0gU1RBVElDX0RSQVcsIGlzSW5zdGFuY2VkID0gZmFsc2UpO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRidWZmZXJEYXRhKG1EYXRhLCBtTmFtZSwgbUl0ZW1TaXplLCBtRHJhd1R5cGUgPSBTVEFUSUNfRFJBVywgaXNJbnN0YW5jZWQgPSBmYWxzZSkge1xuXHRcdGxldCBpID0gMDtcblx0XHRjb25zdCBkcmF3VHlwZSAgID0gbURyYXdUeXBlO1xuXHRcdGlmKCFkcmF3VHlwZSkgZGVidWdnZXI7XG5cblx0XHRjb25zdCBidWZmZXJEYXRhID0gW107XG5cdFx0aWYgKCFtSXRlbVNpemUpIHtcdG1JdGVtU2l6ZSA9IG1EYXRhWzBdLmxlbmd0aDsgfVxuXHRcdHRoaXMuX2lzSW5zdGFuY2VkID0gaXNJbnN0YW5jZWQgfHwgdGhpcy5faXNJbnN0YW5jZWQ7XG5cblx0XHQvL1x0ZmxhdHRlbiBidWZmZXIgZGF0YVx0XHRcblx0XHRmb3IoaSA9IDA7IGkgPCBtRGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0Zm9yKGxldCBqID0gMDsgaiA8IG1EYXRhW2ldLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGJ1ZmZlckRhdGEucHVzaChtRGF0YVtpXVtqXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnN0IGRhdGFBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyRGF0YSk7XG5cdFx0Y29uc3QgYXR0cmlidXRlID0gdGhpcy5nZXRBdHRyaWJ1dGUobU5hbWUpO1xuXG5cdFx0XG5cdFx0aWYoYXR0cmlidXRlKSB7XHRcblx0XHRcdC8vXHRhdHRyaWJ1dGUgZXhpc3RlZCwgcmVwbGFjZSB3aXRoIG5ldyBkYXRhXG5cdFx0XHRhdHRyaWJ1dGUuaXRlbVNpemUgPSBtSXRlbVNpemU7XG5cdFx0XHRhdHRyaWJ1dGUuZGF0YUFycmF5ID0gZGF0YUFycmF5O1xuXHRcdFx0YXR0cmlidXRlLnNvdXJjZSA9IG1EYXRhO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvL1x0YXR0cmlidXRlIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBuZXcgYXR0cmlidXRlIG9iamVjdFxuXHRcdFx0dGhpcy5fYXR0cmlidXRlcy5wdXNoKHsgbmFtZTptTmFtZSwgc291cmNlOm1EYXRhLCBpdGVtU2l6ZTogbUl0ZW1TaXplLCBkcmF3VHlwZSwgZGF0YUFycmF5LCBpc0luc3RhbmNlZCB9KTtcblx0XHR9XG5cblx0XHR0aGlzLl9idWZmZXJDaGFuZ2VkLnB1c2gobU5hbWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0YnVmZmVySW5zdGFuY2UobURhdGEsIG1OYW1lKSB7XG5cdFx0aWYgKCFHTC5nbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdFeHRlbnNpb24gOiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aCB0aGlzIGRldmljZSAhJyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgaXRlbVNpemUgPSBtRGF0YVswXS5sZW5ndGg7XG5cdFx0dGhpcy5fbnVtSW5zdGFuY2UgPSBtRGF0YS5sZW5ndGg7XG5cdFx0dGhpcy5idWZmZXJEYXRhKG1EYXRhLCBtTmFtZSwgaXRlbVNpemUsIFNUQVRJQ19EUkFXLCB0cnVlKTtcblx0fVxuXG5cblx0YmluZChtU2hhZGVyUHJvZ3JhbSkge1xuXHRcdHRoaXMuZ2VuZXJhdGVCdWZmZXJzKG1TaGFkZXJQcm9ncmFtKTtcblxuXHRcdGlmKHRoaXMuaGFzVkFPKSB7XG5cdFx0XHRnbC5iaW5kVmVydGV4QXJyYXkodGhpcy52YW8pOyBcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzLmZvckVhY2goKGF0dHJpYnV0ZSk9PiB7XG5cdFx0XHRcdGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBhdHRyaWJ1dGUuYnVmZmVyKTtcblx0XHRcdFx0Y29uc3QgYXR0clBvc2l0aW9uID0gYXR0cmlidXRlLmF0dHJQb3NpdGlvbjtcblx0XHRcdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlcihhdHRyUG9zaXRpb24sIGF0dHJpYnV0ZS5pdGVtU2l6ZSwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcblxuXHRcdFx0XHRpZihhdHRyaWJ1dGUuaXNJbnN0YW5jZWQpIHtcblx0XHRcdFx0XHRnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGF0dHJQb3NpdGlvbiwgMSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSk7XG5cblx0XHRcdC8vXHRCSU5EIElOREVYIEJVRkZFUlxuXHRcdFx0Z2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pQnVmZmVyKTtcdFxuXHRcdH1cblx0fVxuXG5cdGdlbmVyYXRlQnVmZmVycyhtU2hhZGVyUHJvZ3JhbSkge1xuXHRcdGlmKHRoaXMuX2J1ZmZlckNoYW5nZWQubGVuZ3RoID09IDApIHsgcmV0dXJuOyB9XG5cblx0XHRpZih0aGlzLl91c2VWQU8pIHsgLy9cdElGIFNVUFBPUlRFRCwgQ1JFQVRFIFZBT1xuXG5cdFx0XHQvL1x0Q1JFQVRFICYgQklORCBWQU9cblx0XHRcdGlmKCF0aGlzLl92YW8pIHtcblx0XHRcdFx0dGhpcy5fdmFvID0gZ2wuY3JlYXRlVmVydGV4QXJyYXkoKTtcdFxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRnbC5iaW5kVmVydGV4QXJyYXkodGhpcy5fdmFvKTtcblxuXHRcdFx0Ly9cdFVQREFURSBCVUZGRVJTXG5cdFx0XHR0aGlzLl9hdHRyaWJ1dGVzLmZvckVhY2goKGF0dHJPYmopID0+IHtcblxuXHRcdFx0XHRpZih0aGlzLl9idWZmZXJDaGFuZ2VkLmluZGV4T2YoYXR0ck9iai5uYW1lKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRjb25zdCBidWZmZXIgPSBnZXRCdWZmZXIoYXR0ck9iaik7XG5cdFx0XHRcdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG5cdFx0XHRcdFx0Z2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGF0dHJPYmouZGF0YUFycmF5LCBhdHRyT2JqLmRyYXdUeXBlKTtcblxuXHRcdFx0XHRcdGNvbnN0IGF0dHJQb3NpdGlvbiA9IGdldEF0dHJpYkxvYyhnbCwgbVNoYWRlclByb2dyYW0sIGF0dHJPYmoubmFtZSk7XG5cdFx0XHRcdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0clBvc2l0aW9uKTsgXG5cdFx0XHRcdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlcihhdHRyUG9zaXRpb24sIGF0dHJPYmouaXRlbVNpemUsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG5cdFx0XHRcdFx0YXR0ck9iai5hdHRyUG9zaXRpb24gPSBhdHRyUG9zaXRpb247XG5cblx0XHRcdFx0XHRpZihhdHRyT2JqLmlzSW5zdGFuY2VkKSB7XG5cdFx0XHRcdFx0XHRnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGF0dHJQb3NpdGlvbiwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0fSk7XG5cdFx0XHRcdFxuXHRcdFx0Ly9cdGNoZWNrIGluZGV4IGJ1ZmZlclxuXHRcdFx0dGhpcy5fdXBkYXRlSW5kZXhCdWZmZXIoKTtcblxuXHRcdFx0Ly9cdFVOQklORCBWQU9cblx0XHRcdGdsLmJpbmRWZXJ0ZXhBcnJheShudWxsKTtcdFxuXHRcdFx0XG5cdFx0XHR0aGlzLl9oYXNWQU8gPSB0cnVlO1xuXG5cdFx0fSBlbHNlIHsgLy9cdEVMU0UsIFVTRSBUUkFESVRJT05BTCBNRVRIT0RcblxuXHRcdFx0dGhpcy5fYXR0cmlidXRlcy5mb3JFYWNoKChhdHRyT2JqKSA9PiB7XG5cdFx0XHRcdC8vXHRTS0lQIElGIEJVRkZFUiBIQVNOJ1QgQ0hBTkdFRFxuXHRcdFx0XHRpZih0aGlzLl9idWZmZXJDaGFuZ2VkLmluZGV4T2YoYXR0ck9iai5uYW1lKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRjb25zdCBidWZmZXIgPSBnZXRCdWZmZXIoYXR0ck9iaik7XG5cdFx0XHRcdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG5cdFx0XHRcdFx0Z2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGF0dHJPYmouZGF0YUFycmF5LCBhdHRyT2JqLmRyYXdUeXBlKTtcblxuXHRcdFx0XHRcdGNvbnN0IGF0dHJQb3NpdGlvbiA9IGdldEF0dHJpYkxvYyhnbCwgbVNoYWRlclByb2dyYW0sIGF0dHJPYmoubmFtZSk7XG5cdFx0XHRcdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0clBvc2l0aW9uKTtcblx0XHRcdFx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGF0dHJQb3NpdGlvbiwgYXR0ck9iai5pdGVtU2l6ZSwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcblx0XHRcdFx0XHRhdHRyT2JqLmF0dHJQb3NpdGlvbiA9IGF0dHJQb3NpdGlvbjtcblxuXHRcdFx0XHRcdGlmKGF0dHJPYmouaXNJbnN0YW5jZWQpIHtcblx0XHRcdFx0XHRcdGdsLnZlcnRleEF0dHJpYkRpdmlzb3IoYXR0clBvc2l0aW9uLCAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLl91cGRhdGVJbmRleEJ1ZmZlcigpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2hhc0luZGV4QnVmZmVyQ2hhbmdlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX2J1ZmZlckNoYW5nZWQgPSBbXTtcblx0fVxuXG5cblx0dW5iaW5kKCkge1xuXHRcdGlmKHRoaXMuX3VzZVZBTykge1xuXHRcdFx0Z2wuYmluZFZlcnRleEFycmF5KG51bGwpO1x0XG5cdFx0fVxuXHRcdFxuXHRcdHRoaXMuX2F0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0cmlidXRlKT0+IHtcblx0XHRcdGlmKGF0dHJpYnV0ZS5pc0luc3RhbmNlZCkge1xuXHRcdFx0XHRnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGF0dHJpYnV0ZS5hdHRyUG9zaXRpb24sIDApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblxuXHRfdXBkYXRlSW5kZXhCdWZmZXIoKSB7XG5cdFx0aWYoIXRoaXMuX2hhc0luZGV4QnVmZmVyQ2hhbmdlZCkge1xuXHRcdFx0aWYgKCF0aGlzLmlCdWZmZXIpIHsgdGhpcy5pQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHQgfVxuXHRcdFx0Z2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pQnVmZmVyKTtcblx0XHRcdGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuX2luZGljZXMsIHRoaXMuX2RyYXdUeXBlKTtcblx0XHRcdHRoaXMuaUJ1ZmZlci5pdGVtU2l6ZSA9IDE7XG5cdFx0XHR0aGlzLmlCdWZmZXIubnVtSXRlbXMgPSB0aGlzLl9udW1JdGVtcztcblx0XHR9XG5cdH1cblxuXG5cdGNvbXB1dGVOb3JtYWxzKHVzaW5nRmFjZU5vcm1hbHMgPSBmYWxzZSkge1xuXG5cdFx0dGhpcy5nZW5lcmF0ZUZhY2VzKCk7XG5cblx0XHRpZih1c2luZ0ZhY2VOb3JtYWxzKSB7XG5cdFx0XHR0aGlzLl9jb21wdXRlRmFjZU5vcm1hbHMoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblx0XHR9XG5cdH1cblxuXHQvL1x0UFJJVkFURSBNRVRIT0RTXG5cblx0X2NvbXB1dGVGYWNlTm9ybWFscygpIHtcblxuXHRcdGxldCBmYWNlSW5kZXg7XG5cdFx0bGV0IGZhY2U7XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHRoaXMuX2luZGljZXMubGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdGZhY2VJbmRleCA9IGkgLyAzO1xuXHRcdFx0ZmFjZSA9IHRoaXMuX2ZhY2VzW2ZhY2VJbmRleF07XG5cdFx0XHRjb25zdCBOID0gZmFjZS5ub3JtYWw7XG5cblx0XHRcdG5vcm1hbHNbZmFjZS5pbmRpY2VzWzBdXSA9IE47XG5cdFx0XHRub3JtYWxzW2ZhY2UuaW5kaWNlc1sxXV0gPSBOO1xuXHRcdFx0bm9ybWFsc1tmYWNlLmluZGljZXNbMl1dID0gTjtcblx0XHR9XG5cblx0XHR0aGlzLmJ1ZmZlck5vcm1hbChub3JtYWxzKTtcblx0fVxuXG5cblx0X2NvbXB1dGVWZXJ0ZXhOb3JtYWxzKCkge1xuXHRcdC8vXHRsb29wIHRocm91Z2ggYWxsIHZlcnRpY2VzXG5cdFx0bGV0IGZhY2U7XG5cdFx0Y29uc3Qgc3VtTm9ybWFsID0gdmVjMy5jcmVhdGUoKTtcblx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0Y29uc3QgeyB2ZXJ0aWNlcyB9ID0gdGhpcztcblxuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuXG5cdFx0XHR2ZWMzLnNldChzdW1Ob3JtYWwsIDAsIDAsIDApO1xuXG5cdFx0XHRmb3IobGV0IGogPSAwOyBqIDwgdGhpcy5fZmFjZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZmFjZSA9IHRoaXMuX2ZhY2VzW2pdO1xuXG5cdFx0XHRcdC8vXHRpZiB2ZXJ0ZXggZXhpc3QgaW4gdGhlIGZhY2UsIGFkZCB0aGUgbm9ybWFsIHRvIHN1bSBub3JtYWxcblx0XHRcdFx0aWYoZmFjZS5pbmRpY2VzLmluZGV4T2YoaSkgPj0gMCkge1xuXG5cdFx0XHRcdFx0c3VtTm9ybWFsWzBdICs9IGZhY2Uubm9ybWFsWzBdO1xuXHRcdFx0XHRcdHN1bU5vcm1hbFsxXSArPSBmYWNlLm5vcm1hbFsxXTtcblx0XHRcdFx0XHRzdW1Ob3JtYWxbMl0gKz0gZmFjZS5ub3JtYWxbMl07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZlYzMubm9ybWFsaXplKHN1bU5vcm1hbCwgc3VtTm9ybWFsKTtcblx0XHRcdG5vcm1hbHMucHVzaChbc3VtTm9ybWFsWzBdLCBzdW1Ob3JtYWxbMV0sIHN1bU5vcm1hbFsyXV0pO1xuXHRcdH1cblxuXHRcdHRoaXMuYnVmZmVyTm9ybWFsKG5vcm1hbHMpO1xuXG5cdH1cblxuXG5cdGdlbmVyYXRlRmFjZXMoKSB7XG5cdFx0bGV0IGlhLCBpYiwgaWM7XG5cdFx0bGV0IGEsIGIsIGM7XG5cdFx0Y29uc3QgdmJhID0gdmVjMy5jcmVhdGUoKSwgdmNhID0gdmVjMy5jcmVhdGUoKSwgdk5vcm1hbCA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0Y29uc3QgeyB2ZXJ0aWNlcyB9ID0gdGhpcztcblxuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLl9pbmRpY2VzLmxlbmd0aDsgaSArPSAzKSB7XG5cblx0XHRcdGlhID0gdGhpcy5faW5kaWNlc1tpXTtcblx0XHRcdGliID0gdGhpcy5faW5kaWNlc1tpICsgMV07XG5cdFx0XHRpYyA9IHRoaXMuX2luZGljZXNbaSArIDJdO1xuXG5cdFx0XHRhID0gdmVydGljZXNbaWFdO1xuXHRcdFx0YiA9IHZlcnRpY2VzW2liXTtcblx0XHRcdGMgPSB2ZXJ0aWNlc1tpY107XG5cblx0XHRcdGNvbnN0IGZhY2UgPSB7XG5cdFx0XHRcdGluZGljZXM6W2lhLCBpYiwgaWNdLFxuXHRcdFx0XHR2ZXJ0aWNlczpbYSwgYiwgY10sXG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLl9mYWNlcy5wdXNoKGZhY2UpO1xuXHRcdH1cblxuXHR9XG5cblxuXHRnZXRBdHRyaWJ1dGUobU5hbWUpIHtcdHJldHVybiB0aGlzLl9hdHRyaWJ1dGVzLmZpbmQoKGEpID0+IGEubmFtZSA9PT0gbU5hbWUpO1x0fVxuXHRnZXRTb3VyY2UobU5hbWUpIHtcblx0XHRjb25zdCBhdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUobU5hbWUpO1xuXHRcdHJldHVybiBhdHRyID8gYXR0ci5zb3VyY2UgOiBbXTtcblx0fVxuXG5cblx0Ly9cdEdFVFRFUiBBTkQgU0VUVEVSU1xuXG5cdGdldCB2ZXJ0aWNlcygpIHtcdHJldHVybiB0aGlzLmdldFNvdXJjZSgnYVZlcnRleFBvc2l0aW9uJyk7XHR9XG5cblx0Z2V0IG5vcm1hbHMoKSB7XHRcdHJldHVybiB0aGlzLmdldFNvdXJjZSgnYU5vcm1hbCcpO1x0fVxuXG5cdGdldCBjb29yZHMoKSB7XHRcdHJldHVybiB0aGlzLmdldFNvdXJjZSgnYVRleHR1cmVDb29yZCcpO1x0fVxuXG5cdGdldCBpbmRpY2VzKCkge1x0XHRyZXR1cm4gdGhpcy5faW5kaWNlcztcdH1cblxuXHRnZXQgdmVydGV4U2l6ZSgpIHtcdHJldHVybiB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcdH1cblxuXHRnZXQgZmFjZXMoKSB7XHRyZXR1cm4gdGhpcy5fZmFjZXM7XHR9XG5cblx0Z2V0IGF0dHJpYnV0ZXMoKSB7XHRyZXR1cm4gdGhpcy5fYXR0cmlidXRlcztcdH1cblxuXHRnZXQgaGFzVkFPKCkge1x0cmV0dXJuIHRoaXMuX2hhc1ZBTztcdH1cblxuXHRnZXQgdmFvKCkge1x0cmV0dXJuIHRoaXMuX3ZhbztcdH1cblxuXHRnZXQgbnVtSW5zdGFuY2UoKSB7XHRyZXR1cm4gdGhpcy5fbnVtSW5zdGFuY2U7XHR9XG5cblx0Z2V0IGlzSW5zdGFuY2VkKCkgeyByZXR1cm4gdGhpcy5faXNJbnN0YW5jZWQ7XHR9XG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBNZXNoO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL01lc2guanMiLCIvLyBCYXRjaC5qc1xuXG5pbXBvcnQgR0wgZnJvbSAnLi9HTFRvb2wnO1xuXG5jbGFzcyBCYXRjaCB7XG5cblx0Y29uc3RydWN0b3IobU1lc2gsIG1TaGFkZXIpIHtcblx0XHR0aGlzLl9tZXNoID0gbU1lc2g7XG5cdFx0dGhpcy5fc2hhZGVyID0gbVNoYWRlcjtcblx0fVxuXG5cblx0Ly9cdFBVQkxJQyBNRVRIT0RTXG5cblx0ZHJhdygpIHtcblx0XHR0aGlzLl9zaGFkZXIuYmluZCgpO1xuXHRcdEdMLmRyYXcodGhpcy5tZXNoKTtcblx0fVxuXG5cblx0Ly9cdEdFVFRFUiBBTkQgU0VUVEVSXG5cblx0Z2V0IG1lc2goKSB7XHRyZXR1cm4gdGhpcy5fbWVzaDtcdH1cblxuXHRnZXQgc2hhZGVyKCkge1x0cmV0dXJuIHRoaXMuX3NoYWRlcjtcdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmF0Y2g7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvQmF0Y2guanMiLCIvLyBTY2hlZHVsZXIuanNcblxuXG5jbGFzcyBTY2hlZHVsZXIge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuX2RlbGF5VGFza3MgPSBbXTtcblx0XHR0aGlzLl9uZXh0VGFza3MgPSBbXTtcblx0XHR0aGlzLl9kZWZlclRhc2tzID0gW107XG5cdFx0dGhpcy5faGlnaFRhc2tzID0gW107XG5cdFx0dGhpcy5fdXN1cnBUYXNrID0gW107XG5cdFx0dGhpcy5fZW50ZXJmcmFtZVRhc2tzID0gW107XG5cdFx0dGhpcy5faWRUYWJsZSA9IDA7XG5cdFx0dGhpcy5mcmFtZVJhdGUgPSA2MDtcblx0XHR0aGlzLl9zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuXHRcdHRoaXMuX2RlbHRhVGltZSA9IDA7XG5cblx0XHR0aGlzLl9sb29wKCk7XG5cdH1cblxuXG5cdC8vICBQVUJMSUMgTUVUSE9EU1xuXG5cdGFkZEVGKGZ1bmMsIHBhcmFtcykge1xuXHRcdHBhcmFtcyA9IHBhcmFtcyB8fCBbXTtcblx0XHRjb25zdCBpZCA9IHRoaXMuX2lkVGFibGU7XG5cdFx0dGhpcy5fZW50ZXJmcmFtZVRhc2tzW2lkXSA9IHsgZnVuYywgcGFyYW1zIH07XG5cdFx0dGhpcy5faWRUYWJsZSArKztcblx0XHRyZXR1cm4gaWQ7XG5cdH1cblxuXHRyZW1vdmVFRihpZCkge1xuXHRcdGlmICh0aGlzLl9lbnRlcmZyYW1lVGFza3NbaWRdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuX2VudGVyZnJhbWVUYXNrc1tpZF0gPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH1cblxuXHRkZWxheShmdW5jLCBwYXJhbXMsIGRlbGF5KSB7XG5cdFx0Y29uc3QgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHRcdGNvbnN0IHQgPSB7IGZ1bmMsIHBhcmFtcywgZGVsYXksIHRpbWUgfTtcblx0XHR0aGlzLl9kZWxheVRhc2tzLnB1c2godCk7XG5cdH1cblxuXHRkZWZlcihmdW5jLCBwYXJhbXMpIHtcblx0XHRjb25zdCB0ID0geyBmdW5jLCBwYXJhbXMgfTtcblx0XHR0aGlzLl9kZWZlclRhc2tzLnB1c2godCk7XG5cdH1cblxuXHRuZXh0KGZ1bmMsIHBhcmFtcykge1xuXHRcdGNvbnN0IHQgPSB7IGZ1bmMsIHBhcmFtcyB9O1xuXHRcdHRoaXMuX25leHRUYXNrcy5wdXNoKHQpO1xuXHR9XG5cblx0dXN1cnAoZnVuYywgcGFyYW1zKSB7XG5cdFx0Y29uc3QgdCA9IHsgZnVuYywgcGFyYW1zIH07XG5cdFx0dGhpcy5fdXN1cnBUYXNrLnB1c2godCk7XG5cdH1cblxuXG5cdC8vICBQUklWQVRFIE1FVEhPRFNcblxuXHRfcHJvY2VzcygpIHtcblx0XHRsZXQgaSA9IDA7XG5cdFx0bGV0IHRhc2s7XG5cdFx0bGV0IGludGVydmFsO1xuXHRcdGxldCBjdXJyZW50O1xuXHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLl9lbnRlcmZyYW1lVGFza3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRhc2sgPSB0aGlzLl9lbnRlcmZyYW1lVGFza3NbaV07XG5cdFx0XHRpZiAodGFzayAhPT0gbnVsbCAmJiB0YXNrICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGFzay5mdW5jKHRhc2sucGFyYW1zKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR3aGlsZSAodGhpcy5faGlnaFRhc2tzLmxlbmd0aCA+IDApIHtcblx0XHRcdHRhc2sgPSB0aGlzLl9oaWdoVGFza3MucG9wKCk7XG5cdFx0XHR0YXNrLmZ1bmModGFzay5wYXJhbXMpO1xuXHRcdH1cblxuXG5cdFx0bGV0IHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHRcdHRoaXMuX2RlbHRhVGltZSA9IChzdGFydFRpbWUgLSB0aGlzLl9zdGFydFRpbWUpLzEwMDA7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5fZGVsYXlUYXNrcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGFzayA9IHRoaXMuX2RlbGF5VGFza3NbaV07XG5cdFx0XHRpZiAoc3RhcnRUaW1lIC0gdGFzay50aW1lID4gdGFzay5kZWxheSkge1xuXHRcdFx0XHR0YXNrLmZ1bmModGFzay5wYXJhbXMpO1xuXHRcdFx0XHR0aGlzLl9kZWxheVRhc2tzLnNwbGljZShpLCAxKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0XHR0aGlzLl9kZWx0YVRpbWUgPSAoc3RhcnRUaW1lIC0gdGhpcy5fc3RhcnRUaW1lKS8xMDAwO1xuXHRcdGludGVydmFsID0gMTAwMCAvIHRoaXMuZnJhbWVSYXRlO1xuXHRcdHdoaWxlICh0aGlzLl9kZWZlclRhc2tzLmxlbmd0aCA+IDApIHtcblx0XHRcdHRhc2sgPSB0aGlzLl9kZWZlclRhc2tzLnNoaWZ0KCk7XG5cdFx0XHRjdXJyZW50ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdFx0XHRpZiAoY3VycmVudCAtIHN0YXJ0VGltZSA8IGludGVydmFsKSB7XG5cdFx0XHRcdHRhc2suZnVuYyh0YXNrLnBhcmFtcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9kZWZlclRhc2tzLnVuc2hpZnQodGFzayk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0c3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdFx0dGhpcy5fZGVsdGFUaW1lID0gKHN0YXJ0VGltZSAtIHRoaXMuX3N0YXJ0VGltZSkvMTAwMDtcblx0XHRpbnRlcnZhbCA9IDEwMDAgLyB0aGlzLmZyYW1lUmF0ZTtcblx0XHR3aGlsZSAodGhpcy5fdXN1cnBUYXNrLmxlbmd0aCA+IDApIHtcblx0XHRcdHRhc2sgPSB0aGlzLl91c3VycFRhc2suc2hpZnQoKTtcblx0XHRcdGN1cnJlbnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0XHRcdGlmIChjdXJyZW50IC0gc3RhcnRUaW1lIDwgaW50ZXJ2YWwpIHtcblx0XHRcdFx0dGFzay5mdW5jKHRhc2sucGFyYW1zKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9oaWdoVGFza3MgPSB0aGlzLl9oaWdoVGFza3MuY29uY2F0KHRoaXMuX25leHRUYXNrcyk7XG5cdFx0dGhpcy5fbmV4dFRhc2tzID0gW107XG5cdFx0dGhpcy5fdXN1cnBUYXNrID0gW107XG5cdH1cblxuXG5cdF9sb29wKCkge1xuXHRcdHRoaXMuX3Byb2Nlc3MoKTtcblx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuX2xvb3AoKSk7XG5cdH1cblxuXHRnZXQgZGVsdGFUaW1lKCkge1xuXHRcdHJldHVybiB0aGlzLl9kZWx0YVRpbWU7XG5cdH1cbn1cblxuY29uc3Qgc2NoZWR1bGVyID0gbmV3IFNjaGVkdWxlcigpO1xuXG5leHBvcnQgZGVmYXVsdCBzY2hlZHVsZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zY2hlZHVsaW5nL3NyYy9zY2hlZHVsZXIuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBHZW9tLmpzXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IE1lc2ggZnJvbSAnLi9NZXNoJztcblxuY29uc3QgR2VvbSA9IHt9O1xubGV0IG1lc2hUcmk7XG5cbkdlb20ucGxhbmUgPSBmdW5jdGlvbiBwbGFuZSh3aWR0aCwgaGVpZ2h0LCBudW1TZWdtZW50cywgYXhpcyA9ICd4eScsIGRyYXdUeXBlID0gNCkge1xuXHRjb25zdCBwb3NpdGlvbnMgPSBbXTtcblx0Y29uc3QgY29vcmRzICAgID0gW107XG5cdGNvbnN0IGluZGljZXMgICA9IFtdO1xuXHRjb25zdCBub3JtYWxzICAgPSBbXTtcblxuXHRjb25zdCBnYXBYICA9IHdpZHRoIC8gbnVtU2VnbWVudHM7XG5cdGNvbnN0IGdhcFkgID0gaGVpZ2h0IC8gbnVtU2VnbWVudHM7XG5cdGNvbnN0IGdhcFVWID0gMSAvIG51bVNlZ21lbnRzO1xuXHRjb25zdCBzeCAgICA9IC13aWR0aCAqIDAuNTtcblx0Y29uc3Qgc3kgICAgPSAtaGVpZ2h0ICogMC41O1xuXHRsZXQgaW5kZXggPSAwO1xuXG5cdGZvcihsZXQgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG5cdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBudW1TZWdtZW50czsgaisrKSB7XG5cdFx0XHRjb25zdCB0eCA9IGdhcFggKiBpICsgc3g7XG5cdFx0XHRjb25zdCB0eSA9IGdhcFkgKiBqICsgc3k7XG5cblx0XHRcdGNvbnN0IHUgPSBpIC8gbnVtU2VnbWVudHM7XG5cdFx0XHRjb25zdCB2ID0gaiAvIG51bVNlZ21lbnRzO1xuXG5cdFx0XHRpZihheGlzID09PSAneHonKSB7XG5cdFx0XHRcdHBvc2l0aW9ucy5wdXNoKFt0eCwgXHRcdDAsIFx0IHR5ICsgZ2FwWV0pO1xuXHRcdFx0XHRwb3NpdGlvbnMucHVzaChbdHggKyBnYXBYLCBcdDAsIFx0IHR5ICsgZ2FwWV0pO1xuXHRcdFx0XHRwb3NpdGlvbnMucHVzaChbdHggKyBnYXBYLCBcdDAsIFx0IHR5XSk7XG5cdFx0XHRcdHBvc2l0aW9ucy5wdXNoKFt0eCwgXHRcdDAsIFx0IHR5XSk7XHRcblxuXHRcdFx0XHRjb29yZHMucHVzaChbdSwgMS4wIC0gKHYgKyBnYXBVVildKTtcblx0XHRcdFx0Y29vcmRzLnB1c2goW3UgKyBnYXBVViwgMS4wIC0gKHYgKyBnYXBVVildKTtcblx0XHRcdFx0Y29vcmRzLnB1c2goW3UgKyBnYXBVViwgMS4wIC0gdl0pO1xuXHRcdFx0XHRjb29yZHMucHVzaChbdSwgMS4wIC0gdl0pO1xuXG5cdFx0XHRcdG5vcm1hbHMucHVzaChbMCwgMSwgMF0pO1xuXHRcdFx0XHRub3JtYWxzLnB1c2goWzAsIDEsIDBdKTtcblx0XHRcdFx0bm9ybWFscy5wdXNoKFswLCAxLCAwXSk7XG5cdFx0XHRcdG5vcm1hbHMucHVzaChbMCwgMSwgMF0pO1xuXHRcdFx0fSBlbHNlIGlmKGF4aXMgPT09ICd5eicpIHtcblx0XHRcdFx0cG9zaXRpb25zLnB1c2goWzAsIHR5LCB0eF0pO1xuXHRcdFx0XHRwb3NpdGlvbnMucHVzaChbMCwgdHksIHR4ICsgZ2FwWF0pO1xuXHRcdFx0XHRwb3NpdGlvbnMucHVzaChbMCwgdHkgKyBnYXBZLCB0eCArIGdhcFhdKTtcblx0XHRcdFx0cG9zaXRpb25zLnB1c2goWzAsIHR5ICsgZ2FwWSwgdHhdKTtcdFxuXG5cdFx0XHRcdGNvb3Jkcy5wdXNoKFt1LCB2XSk7XG5cdFx0XHRcdGNvb3Jkcy5wdXNoKFt1ICsgZ2FwVVYsIHZdKTtcblx0XHRcdFx0Y29vcmRzLnB1c2goW3UgKyBnYXBVViwgdiArIGdhcFVWXSk7XG5cdFx0XHRcdGNvb3Jkcy5wdXNoKFt1LCB2ICsgZ2FwVVZdKTtcblxuXHRcdFx0XHRub3JtYWxzLnB1c2goWzEsIDAsIDBdKTtcblx0XHRcdFx0bm9ybWFscy5wdXNoKFsxLCAwLCAwXSk7XG5cdFx0XHRcdG5vcm1hbHMucHVzaChbMSwgMCwgMF0pO1xuXHRcdFx0XHRub3JtYWxzLnB1c2goWzEsIDAsIDBdKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvc2l0aW9ucy5wdXNoKFt0eCwgXHRcdHR5LCBcdDBdKTtcblx0XHRcdFx0cG9zaXRpb25zLnB1c2goW3R4ICsgZ2FwWCwgXHR0eSwgXHQwXSk7XG5cdFx0XHRcdHBvc2l0aW9ucy5wdXNoKFt0eCArIGdhcFgsIFx0dHkgKyBnYXBZLCBcdDBdKTtcblx0XHRcdFx0cG9zaXRpb25zLnB1c2goW3R4LCBcdFx0dHkgKyBnYXBZLCBcdDBdKTtcdFxuXG5cdFx0XHRcdGNvb3Jkcy5wdXNoKFt1LCB2XSk7XG5cdFx0XHRcdGNvb3Jkcy5wdXNoKFt1ICsgZ2FwVVYsIHZdKTtcblx0XHRcdFx0Y29vcmRzLnB1c2goW3UgKyBnYXBVViwgdiArIGdhcFVWXSk7XG5cdFx0XHRcdGNvb3Jkcy5wdXNoKFt1LCB2ICsgZ2FwVVZdKTtcblxuXHRcdFx0XHRub3JtYWxzLnB1c2goWzAsIDAsIDFdKTtcblx0XHRcdFx0bm9ybWFscy5wdXNoKFswLCAwLCAxXSk7XG5cdFx0XHRcdG5vcm1hbHMucHVzaChbMCwgMCwgMV0pO1xuXHRcdFx0XHRub3JtYWxzLnB1c2goWzAsIDAsIDFdKTtcblx0XHRcdH0gXG5cblxuXHRcdFx0aW5kaWNlcy5wdXNoKGluZGV4ICogNCArIDApO1xuXHRcdFx0aW5kaWNlcy5wdXNoKGluZGV4ICogNCArIDEpO1xuXHRcdFx0aW5kaWNlcy5wdXNoKGluZGV4ICogNCArIDIpO1xuXHRcdFx0aW5kaWNlcy5wdXNoKGluZGV4ICogNCArIDApO1xuXHRcdFx0aW5kaWNlcy5wdXNoKGluZGV4ICogNCArIDIpO1xuXHRcdFx0aW5kaWNlcy5wdXNoKGluZGV4ICogNCArIDMpO1xuXG5cdFx0XHRpbmRleCsrO1xuXHRcdH1cblx0fVxuXG5cdGNvbnN0IG1lc2ggPSBuZXcgTWVzaChkcmF3VHlwZSk7XG5cdG1lc2guYnVmZmVyVmVydGV4KHBvc2l0aW9ucyk7XG5cdG1lc2guYnVmZmVyVGV4Q29vcmQoY29vcmRzKTtcblx0bWVzaC5idWZmZXJJbmRleChpbmRpY2VzKTtcblx0bWVzaC5idWZmZXJOb3JtYWwobm9ybWFscyk7XG5cblx0cmV0dXJuIG1lc2g7XG59O1xuXG5HZW9tLnNwaGVyZSA9IGZ1bmN0aW9uIHNwaGVyZShzaXplLCBudW1TZWdtZW50cywgaXNJbnZlcnQgPSBmYWxzZSwgZHJhd1R5cGUgPSA0KSB7XG5cdGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuXHRjb25zdCBjb29yZHMgICAgPSBbXTtcblx0Y29uc3QgaW5kaWNlcyAgID0gW107XG5cdGNvbnN0IG5vcm1hbHMgICA9IFtdO1xuXHRjb25zdCBnYXBVViAgICAgPSAxIC8gbnVtU2VnbWVudHM7XG5cdGxldCBpbmRleCAgICAgXHQ9IDA7XG5cdFxuXG5cdGZ1bmN0aW9uIGdldFBvc2l0aW9uKGksIGosIGlzTm9ybWFsID0gZmFsc2UpIHtcdC8vXHRyeCA6IC05MCB+IDkwICwgcnkgOiAwIH4gMzYwXG5cdFx0Y29uc3QgcnggICAgICAgID0gaSAvIG51bVNlZ21lbnRzICogTWF0aC5QSSAtIE1hdGguUEkgKiAwLjU7XG5cdFx0Y29uc3QgcnkgICAgICAgID0gaiAvIG51bVNlZ21lbnRzICogTWF0aC5QSSAqIDI7XG5cdFx0Y29uc3QgciAgICAgICAgID0gaXNOb3JtYWwgPyAxIDogc2l6ZTtcblx0XHRjb25zdCBwb3MgICAgICAgPSBbXTtcblx0XHRwb3NbMV0gICAgICAgIFx0PSBNYXRoLnNpbihyeCkgKiByO1xuXHRcdGNvbnN0IHQgICAgICAgICA9IE1hdGguY29zKHJ4KSAqIHI7XG5cdFx0cG9zWzBdICAgICAgICBcdD0gTWF0aC5jb3MocnkpICogdDtcblx0XHRwb3NbMl0gICAgICAgIFx0PSBNYXRoLnNpbihyeSkgKiB0O1xuXHRcdFxuXHRcdGNvbnN0IHByZWNpc2lvbiA9IDEwMDAwO1xuXHRcdHBvc1swXSAgICAgICAgPSBNYXRoLmZsb29yKHBvc1swXSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG5cdFx0cG9zWzFdICAgICAgICA9IE1hdGguZmxvb3IocG9zWzFdICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcblx0XHRwb3NbMl0gICAgICAgID0gTWF0aC5mbG9vcihwb3NbMl0gKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuXG5cdFx0cmV0dXJuIHBvcztcblx0fTtcblxuXHRcblx0Zm9yKGxldCBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcblx0XHRmb3IobGV0IGogPSAwOyBqIDwgbnVtU2VnbWVudHM7IGorKykge1xuXHRcdFx0cG9zaXRpb25zLnB1c2goZ2V0UG9zaXRpb24oaSwgaikpO1xuXHRcdFx0cG9zaXRpb25zLnB1c2goZ2V0UG9zaXRpb24oaSArIDEsIGopKTtcblx0XHRcdHBvc2l0aW9ucy5wdXNoKGdldFBvc2l0aW9uKGkgKyAxLCBqICsgMSkpO1xuXHRcdFx0cG9zaXRpb25zLnB1c2goZ2V0UG9zaXRpb24oaSwgaiArIDEpKTtcblxuXHRcdFx0bm9ybWFscy5wdXNoKGdldFBvc2l0aW9uKGksIGosIHRydWUpKTtcblx0XHRcdG5vcm1hbHMucHVzaChnZXRQb3NpdGlvbihpICsgMSwgaiwgdHJ1ZSkpO1xuXHRcdFx0bm9ybWFscy5wdXNoKGdldFBvc2l0aW9uKGkgKyAxLCBqICsgMSwgdHJ1ZSkpO1xuXHRcdFx0bm9ybWFscy5wdXNoKGdldFBvc2l0aW9uKGksIGogKyAxLCB0cnVlKSk7XG5cdFx0XHRcblxuXHRcdFx0Y29uc3QgdSA9IGogLyBudW1TZWdtZW50cztcblx0XHRcdGNvbnN0IHYgPSBpIC8gbnVtU2VnbWVudHM7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0Y29vcmRzLnB1c2goWzEuMCAtIHUsIHZdKTtcblx0XHRcdGNvb3Jkcy5wdXNoKFsxLjAgLSB1LCB2ICsgZ2FwVVZdKTtcblx0XHRcdGNvb3Jkcy5wdXNoKFsxLjAgLSB1IC0gZ2FwVVYsIHYgKyBnYXBVVl0pO1xuXHRcdFx0Y29vcmRzLnB1c2goWzEuMCAtIHUgLSBnYXBVViwgdl0pO1xuXG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMCk7XG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMSk7XG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMik7XG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMCk7XG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMik7XG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMyk7XG5cblx0XHRcdGluZGV4Kys7XG5cdFx0fVxuXHR9XG5cblxuXHRpZihpc0ludmVydCkge1xuXHRcdGluZGljZXMucmV2ZXJzZSgpO1xuXHR9XG5cblx0Y29uc3QgbWVzaCA9IG5ldyBNZXNoKGRyYXdUeXBlKTtcblx0bWVzaC5idWZmZXJWZXJ0ZXgocG9zaXRpb25zKTtcblx0bWVzaC5idWZmZXJUZXhDb29yZChjb29yZHMpO1xuXHRtZXNoLmJ1ZmZlckluZGV4KGluZGljZXMpO1xuXHRtZXNoLmJ1ZmZlck5vcm1hbChub3JtYWxzKTtcblxuXHRyZXR1cm4gbWVzaDtcbn07XG5cbkdlb20uY3ViZSA9IGZ1bmN0aW9uIGN1YmUodywgaCwgZCwgZHJhd1R5cGUgPSA0KSB7XG5cdGggPSBoIHx8IHc7XG5cdGQgPSBkIHx8IHc7XG5cblx0Y29uc3QgeCA9IHcgLyAyO1xuXHRjb25zdCB5ID0gaCAvIDI7XG5cdGNvbnN0IHogPSBkIC8gMjtcblxuXHRjb25zdCBwb3NpdGlvbnMgPSBbXTtcblx0Y29uc3QgY29vcmRzICAgID0gW107XG5cdGNvbnN0IGluZGljZXMgICA9IFtdOyBcblx0Y29uc3Qgbm9ybWFscyAgID0gW107IFxuXHRsZXQgY291bnQgICAgID0gMDtcblxuXG5cdC8vIEJBQ0tcblx0cG9zaXRpb25zLnB1c2goWy14LCAgeSwgLXpdKTtcblx0cG9zaXRpb25zLnB1c2goW3gsICB5LCAtel0pO1xuXHRwb3NpdGlvbnMucHVzaChbeCwgLXksIC16XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgLXksIC16XSk7XG5cblx0bm9ybWFscy5wdXNoKFswLCAwLCAtMV0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDAsIC0xXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMCwgLTFdKTtcblx0bm9ybWFscy5wdXNoKFswLCAwLCAtMV0pO1xuXG5cdGNvb3Jkcy5wdXNoKFswLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAxXSk7XG5cdGNvb3Jkcy5wdXNoKFswLCAxXSk7XG5cblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMSk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAzKTtcblxuXHRjb3VudCArKztcblxuXHQvLyBSSUdIVFxuXHRwb3NpdGlvbnMucHVzaChbeCwgIHksIC16XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFt4LCAgeSwgIHpdKTtcblx0cG9zaXRpb25zLnB1c2goW3gsIC15LCAgel0pO1xuXHRwb3NpdGlvbnMucHVzaChbeCwgLXksIC16XSk7XG5cblx0bm9ybWFscy5wdXNoKFsxLCAwLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMSwgMCwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzEsIDAsIDBdKTtcblx0bm9ybWFscy5wdXNoKFsxLCAwLCAwXSk7XG5cblx0Y29vcmRzLnB1c2goWzAsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDFdKTtcblx0Y29vcmRzLnB1c2goWzAsIDFdKTtcblxuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAxKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDMpO1xuXG5cdGNvdW50ICsrO1xuXG5cdC8vIEZST05UXG5cdHBvc2l0aW9ucy5wdXNoKFt4LCAgeSwgIHpdKTtcblx0cG9zaXRpb25zLnB1c2goWy14LCAgeSwgIHpdKTtcblx0cG9zaXRpb25zLnB1c2goWy14LCAteSwgIHpdKTtcblx0cG9zaXRpb25zLnB1c2goW3gsIC15LCAgel0pO1xuXG5cdG5vcm1hbHMucHVzaChbMCwgMCwgMV0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDAsIDFdKTtcblx0bm9ybWFscy5wdXNoKFswLCAwLCAxXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMCwgMV0pO1xuXG5cdGNvb3Jkcy5wdXNoKFswLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAxXSk7XG5cdGNvb3Jkcy5wdXNoKFswLCAxXSk7XG5cblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMSk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAzKTtcblxuXHRjb3VudCArKztcblxuXG5cdC8vIExFRlRcblx0cG9zaXRpb25zLnB1c2goWy14LCAgeSwgIHpdKTtcblx0cG9zaXRpb25zLnB1c2goWy14LCAgeSwgLXpdKTtcblx0cG9zaXRpb25zLnB1c2goWy14LCAteSwgLXpdKTtcblx0cG9zaXRpb25zLnB1c2goWy14LCAteSwgIHpdKTtcblxuXHRub3JtYWxzLnB1c2goWy0xLCAwLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbLTEsIDAsIDBdKTtcblx0bm9ybWFscy5wdXNoKFstMSwgMCwgMF0pO1xuXHRub3JtYWxzLnB1c2goWy0xLCAwLCAwXSk7XG5cblx0Y29vcmRzLnB1c2goWzAsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDFdKTtcblx0Y29vcmRzLnB1c2goWzAsIDFdKTtcblxuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAxKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDMpO1xuXG5cdGNvdW50ICsrO1xuXG5cdC8vIFRPUFxuXHRwb3NpdGlvbnMucHVzaChbeCwgIHksIC16XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgIHksIC16XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgIHksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFt4LCAgeSwgIHpdKTtcblxuXHRub3JtYWxzLnB1c2goWzAsIDEsIDBdKTtcblx0bm9ybWFscy5wdXNoKFswLCAxLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMSwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDEsIDBdKTtcblxuXHRjb29yZHMucHVzaChbMCwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMV0pO1xuXHRjb29yZHMucHVzaChbMCwgMV0pO1xuXG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDEpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMyk7XG5cblx0Y291bnQgKys7XG5cblx0Ly8gQk9UVE9NXG5cdHBvc2l0aW9ucy5wdXNoKFt4LCAteSwgIHpdKTtcblx0cG9zaXRpb25zLnB1c2goWy14LCAteSwgIHpdKTtcblx0cG9zaXRpb25zLnB1c2goWy14LCAteSwgLXpdKTtcblx0cG9zaXRpb25zLnB1c2goW3gsIC15LCAtel0pO1xuXG5cdG5vcm1hbHMucHVzaChbMCwgLTEsIDBdKTtcblx0bm9ybWFscy5wdXNoKFswLCAtMSwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzAsIC0xLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgLTEsIDBdKTtcblxuXHRjb29yZHMucHVzaChbMCwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMV0pO1xuXHRjb29yZHMucHVzaChbMCwgMV0pO1xuXG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDEpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMyk7XG5cblx0Y291bnQgKys7XG5cblxuXHRjb25zdCBtZXNoID0gbmV3IE1lc2goZHJhd1R5cGUpO1xuXHRtZXNoLmJ1ZmZlclZlcnRleChwb3NpdGlvbnMpO1xuXHRtZXNoLmJ1ZmZlclRleENvb3JkKGNvb3Jkcyk7XG5cdG1lc2guYnVmZmVySW5kZXgoaW5kaWNlcyk7XG5cdG1lc2guYnVmZmVyTm9ybWFsKG5vcm1hbHMpO1xuXG5cdHJldHVybiBtZXNoO1xufTtcblxuR2VvbS5za3lib3ggPSBmdW5jdGlvbiBza3lib3goc2l6ZSwgZHJhd1R5cGUgPSA0KSB7XG5cdGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuXHRjb25zdCBjb29yZHMgICAgPSBbXTtcblx0Y29uc3QgaW5kaWNlcyAgID0gW107IFxuXHRjb25zdCBub3JtYWxzICAgPSBbXTsgXG5cdGxldCBjb3VudCAgICAgPSAwO1xuXG5cdC8vIEJBQ0tcblx0cG9zaXRpb25zLnB1c2goW3NpemUsICBzaXplLCAtc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbLXNpemUsICBzaXplLCAtc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbLXNpemUsIC1zaXplLCAtc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbc2l6ZSwgLXNpemUsIC1zaXplXSk7XG5cblx0bm9ybWFscy5wdXNoKFswLCAwLCAtMV0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDAsIC0xXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMCwgLTFdKTtcblx0bm9ybWFscy5wdXNoKFswLCAwLCAtMV0pO1xuXG5cdGNvb3Jkcy5wdXNoKFswLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAxXSk7XG5cdGNvb3Jkcy5wdXNoKFswLCAxXSk7XG5cblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMSk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAzKTtcblxuXHRjb3VudCArKztcblxuXHQvLyBSSUdIVFxuXHRwb3NpdGlvbnMucHVzaChbc2l6ZSwgLXNpemUsIC1zaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFtzaXplLCAtc2l6ZSwgIHNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goW3NpemUsICBzaXplLCAgc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbc2l6ZSwgIHNpemUsIC1zaXplXSk7XG5cblx0bm9ybWFscy5wdXNoKFsxLCAwLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMSwgMCwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzEsIDAsIDBdKTtcblx0bm9ybWFscy5wdXNoKFsxLCAwLCAwXSk7XG5cblx0Y29vcmRzLnB1c2goWzAsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDFdKTtcblx0Y29vcmRzLnB1c2goWzAsIDFdKTtcblxuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAxKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDMpO1xuXG5cdGNvdW50ICsrO1xuXG5cdC8vIEZST05UXG5cdHBvc2l0aW9ucy5wdXNoKFstc2l6ZSwgIHNpemUsICBzaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFtzaXplLCAgc2l6ZSwgIHNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goW3NpemUsIC1zaXplLCAgc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbLXNpemUsIC1zaXplLCAgc2l6ZV0pO1xuXG5cdG5vcm1hbHMucHVzaChbMCwgMCwgMV0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDAsIDFdKTtcblx0bm9ybWFscy5wdXNoKFswLCAwLCAxXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMCwgMV0pO1xuXG5cdGNvb3Jkcy5wdXNoKFswLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAxXSk7XG5cdGNvb3Jkcy5wdXNoKFswLCAxXSk7XG5cblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMSk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAzKTtcblxuXHRjb3VudCArKztcblxuXHQvLyBMRUZUXG5cdHBvc2l0aW9ucy5wdXNoKFstc2l6ZSwgLXNpemUsICBzaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFstc2l6ZSwgLXNpemUsIC1zaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFstc2l6ZSwgIHNpemUsIC1zaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFstc2l6ZSwgIHNpemUsICBzaXplXSk7XG5cblx0bm9ybWFscy5wdXNoKFstMSwgMCwgMF0pO1xuXHRub3JtYWxzLnB1c2goWy0xLCAwLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbLTEsIDAsIDBdKTtcblx0bm9ybWFscy5wdXNoKFstMSwgMCwgMF0pO1xuXG5cdGNvb3Jkcy5wdXNoKFswLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAxXSk7XG5cdGNvb3Jkcy5wdXNoKFswLCAxXSk7XG5cblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMSk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAzKTtcblxuXHRjb3VudCArKztcblxuXHQvLyBUT1Bcblx0cG9zaXRpb25zLnB1c2goW3NpemUsICBzaXplLCAgc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbLXNpemUsICBzaXplLCAgc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbLXNpemUsICBzaXplLCAtc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbc2l6ZSwgIHNpemUsIC1zaXplXSk7XG5cblx0bm9ybWFscy5wdXNoKFswLCAxLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMSwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDEsIDBdKTtcblx0bm9ybWFscy5wdXNoKFswLCAxLCAwXSk7XG5cblx0Y29vcmRzLnB1c2goWzAsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDFdKTtcblx0Y29vcmRzLnB1c2goWzAsIDFdKTtcblxuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAxKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDMpO1xuXG5cdGNvdW50ICsrO1xuXG5cdC8vIEJPVFRPTVxuXHRwb3NpdGlvbnMucHVzaChbc2l6ZSwgLXNpemUsIC1zaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFstc2l6ZSwgLXNpemUsIC1zaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFstc2l6ZSwgLXNpemUsICBzaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFtzaXplLCAtc2l6ZSwgIHNpemVdKTtcblxuXHRub3JtYWxzLnB1c2goWzAsIC0xLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgLTEsIDBdKTtcblx0bm9ybWFscy5wdXNoKFswLCAtMSwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzAsIC0xLCAwXSk7XG5cblx0Y29vcmRzLnB1c2goWzAsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDFdKTtcblx0Y29vcmRzLnB1c2goWzAsIDFdKTtcblxuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAxKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDMpO1xuXG5cdGNvbnN0IG1lc2ggPSBuZXcgTWVzaChkcmF3VHlwZSk7XG5cdG1lc2guYnVmZmVyVmVydGV4KHBvc2l0aW9ucyk7XG5cdG1lc2guYnVmZmVyVGV4Q29vcmQoY29vcmRzKTtcblx0bWVzaC5idWZmZXJJbmRleChpbmRpY2VzKTtcblx0bWVzaC5idWZmZXJOb3JtYWwobm9ybWFscyk7XG5cblx0cmV0dXJuIG1lc2g7XG59O1xuXG5HZW9tLmJpZ1RyaWFuZ2xlID0gZnVuY3Rpb24gYmlnVHJpYW5nbGUoKSB7XG5cblx0aWYoIW1lc2hUcmkpIHtcblx0XHRjb25zdCBpbmRpY2VzID0gWzIsIDEsIDBdO1xuXHRcdGNvbnN0IHBvc2l0aW9ucyA9IFtcblx0XHRcdFstMSwgLTFdLCBcblx0XHRcdFstMSwgNF0sIFxuXHRcdFx0WzQsIC0xXVxuXHRcdF07XG5cdFx0XG5cdFx0bWVzaFRyaSA9IG5ldyBNZXNoKCk7XG5cdFx0bWVzaFRyaS5idWZmZXJEYXRhKHBvc2l0aW9ucywgJ2FQb3NpdGlvbicsIDIpO1xuXHRcdG1lc2hUcmkuYnVmZmVySW5kZXgoaW5kaWNlcyk7XHRcblx0fVxuXHRcblxuXHRyZXR1cm4gbWVzaFRyaTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEdlb207XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvR2VvbS5qcyIsIi8vIHN0b2xlbiB0aGVyZSBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wvZ2wtY29uc3RhbnRzIHRoYW5rcyBAbWF0dGRlc2wgXl5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHQwOiAnTk9ORScsXG5cdDE6ICdPTkUnLFxuXHQyOiAnTElORV9MT09QJyxcblx0MzogJ0xJTkVfU1RSSVAnLFxuXHQ0OiAnVFJJQU5HTEVTJyxcblx0NTogJ1RSSUFOR0xFX1NUUklQJyxcblx0NjogJ1RSSUFOR0xFX0ZBTicsXG5cdDI1NjogJ0RFUFRIX0JVRkZFUl9CSVQnLFxuXHQ1MTI6ICdORVZFUicsXG5cdDUxMzogJ0xFU1MnLFxuXHQ1MTQ6ICdFUVVBTCcsXG5cdDUxNTogJ0xFUVVBTCcsXG5cdDUxNjogJ0dSRUFURVInLFxuXHQ1MTc6ICdOT1RFUVVBTCcsXG5cdDUxODogJ0dFUVVBTCcsXG5cdDUxOTogJ0FMV0FZUycsXG5cdDc2ODogJ1NSQ19DT0xPUicsXG5cdDc2OTogJ09ORV9NSU5VU19TUkNfQ09MT1InLFxuXHQ3NzA6ICdTUkNfQUxQSEEnLFxuXHQ3NzE6ICdPTkVfTUlOVVNfU1JDX0FMUEhBJyxcblx0NzcyOiAnRFNUX0FMUEhBJyxcblx0NzczOiAnT05FX01JTlVTX0RTVF9BTFBIQScsXG5cdDc3NDogJ0RTVF9DT0xPUicsXG5cdDc3NTogJ09ORV9NSU5VU19EU1RfQ09MT1InLFxuXHQ3NzY6ICdTUkNfQUxQSEFfU0FUVVJBVEUnLFxuXHQxMDI0OiAnU1RFTkNJTF9CVUZGRVJfQklUJyxcblx0MTAyODogJ0ZST05UJyxcblx0MTAyOTogJ0JBQ0snLFxuXHQxMDMyOiAnRlJPTlRfQU5EX0JBQ0snLFxuXHQxMjgwOiAnSU5WQUxJRF9FTlVNJyxcblx0MTI4MTogJ0lOVkFMSURfVkFMVUUnLFxuXHQxMjgyOiAnSU5WQUxJRF9PUEVSQVRJT04nLFxuXHQxMjg1OiAnT1VUX09GX01FTU9SWScsXG5cdDEyODY6ICdJTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTicsXG5cdDIzMDQ6ICdDVycsXG5cdDIzMDU6ICdDQ1cnLFxuXHQyODQ5OiAnTElORV9XSURUSCcsXG5cdDI4ODQ6ICdDVUxMX0ZBQ0UnLFxuXHQyODg1OiAnQ1VMTF9GQUNFX01PREUnLFxuXHQyODg2OiAnRlJPTlRfRkFDRScsXG5cdDI5Mjg6ICdERVBUSF9SQU5HRScsXG5cdDI5Mjk6ICdERVBUSF9URVNUJyxcblx0MjkzMDogJ0RFUFRIX1dSSVRFTUFTSycsXG5cdDI5MzE6ICdERVBUSF9DTEVBUl9WQUxVRScsXG5cdDI5MzI6ICdERVBUSF9GVU5DJyxcblx0Mjk2MDogJ1NURU5DSUxfVEVTVCcsXG5cdDI5NjE6ICdTVEVOQ0lMX0NMRUFSX1ZBTFVFJyxcblx0Mjk2MjogJ1NURU5DSUxfRlVOQycsXG5cdDI5NjM6ICdTVEVOQ0lMX1ZBTFVFX01BU0snLFxuXHQyOTY0OiAnU1RFTkNJTF9GQUlMJyxcblx0Mjk2NTogJ1NURU5DSUxfUEFTU19ERVBUSF9GQUlMJyxcblx0Mjk2NjogJ1NURU5DSUxfUEFTU19ERVBUSF9QQVNTJyxcblx0Mjk2NzogJ1NURU5DSUxfUkVGJyxcblx0Mjk2ODogJ1NURU5DSUxfV1JJVEVNQVNLJyxcblx0Mjk3ODogJ1ZJRVdQT1JUJyxcblx0MzAyNDogJ0RJVEhFUicsXG5cdDMwNDI6ICdCTEVORCcsXG5cdDMwODg6ICdTQ0lTU09SX0JPWCcsXG5cdDMwODk6ICdTQ0lTU09SX1RFU1QnLFxuXHQzMTA2OiAnQ09MT1JfQ0xFQVJfVkFMVUUnLFxuXHQzMTA3OiAnQ09MT1JfV1JJVEVNQVNLJyxcblx0MzMxNzogJ1VOUEFDS19BTElHTk1FTlQnLFxuXHQzMzMzOiAnUEFDS19BTElHTk1FTlQnLFxuXHQzMzc5OiAnTUFYX1RFWFRVUkVfU0laRScsXG5cdDMzODY6ICdNQVhfVklFV1BPUlRfRElNUycsXG5cdDM0MDg6ICdTVUJQSVhFTF9CSVRTJyxcblx0MzQxMDogJ1JFRF9CSVRTJyxcblx0MzQxMTogJ0dSRUVOX0JJVFMnLFxuXHQzNDEyOiAnQkxVRV9CSVRTJyxcblx0MzQxMzogJ0FMUEhBX0JJVFMnLFxuXHQzNDE0OiAnREVQVEhfQklUUycsXG5cdDM0MTU6ICdTVEVOQ0lMX0JJVFMnLFxuXHQzNTUzOiAnVEVYVFVSRV8yRCcsXG5cdDQzNTI6ICdET05UX0NBUkUnLFxuXHQ0MzUzOiAnRkFTVEVTVCcsXG5cdDQzNTQ6ICdOSUNFU1QnLFxuXHQ1MTIwOiAnQllURScsXG5cdDUxMjE6ICdVTlNJR05FRF9CWVRFJyxcblx0NTEyMjogJ1NIT1JUJyxcblx0NTEyMzogJ1VOU0lHTkVEX1NIT1JUJyxcblx0NTEyNDogJ0lOVCcsXG5cdDUxMjU6ICdVTlNJR05FRF9JTlQnLFxuXHQ1MTI2OiAnRkxPQVQnLFxuXHQ1Mzg2OiAnSU5WRVJUJyxcblx0NTg5MDogJ1RFWFRVUkUnLFxuXHQ2NDAxOiAnU1RFTkNJTF9JTkRFWCcsXG5cdDY0MDI6ICdERVBUSF9DT01QT05FTlQnLFxuXHQ2NDAzOiAnUkVEJyxcblx0NjQwNjogJ0FMUEhBJyxcblx0NjQwNzogJ1JHQicsXG5cdDY0MDg6ICdSR0JBJyxcblx0NjQwOTogJ0xVTUlOQU5DRScsXG5cdDY0MTA6ICdMVU1JTkFOQ0VfQUxQSEEnLFxuXHQ3NjgwOiAnS0VFUCcsXG5cdDc2ODE6ICdSRVBMQUNFJyxcblx0NzY4MjogJ0lOQ1InLFxuXHQ3NjgzOiAnREVDUicsXG5cdDc5MzY6ICdWRU5ET1InLFxuXHQ3OTM3OiAnUkVOREVSRVInLFxuXHQ3OTM4OiAnVkVSU0lPTicsXG5cdDk3Mjg6ICdORUFSRVNUJyxcblx0OTcyOTogJ0xJTkVBUicsXG5cdDk5ODQ6ICdORUFSRVNUX01JUE1BUF9ORUFSRVNUJyxcblx0OTk4NTogJ0xJTkVBUl9NSVBNQVBfTkVBUkVTVCcsXG5cdDk5ODY6ICdORUFSRVNUX01JUE1BUF9MSU5FQVInLFxuXHQ5OTg3OiAnTElORUFSX01JUE1BUF9MSU5FQVInLFxuXHQxMDI0MDogJ1RFWFRVUkVfTUFHX0ZJTFRFUicsXG5cdDEwMjQxOiAnVEVYVFVSRV9NSU5fRklMVEVSJyxcblx0MTAyNDI6ICdURVhUVVJFX1dSQVBfUycsXG5cdDEwMjQzOiAnVEVYVFVSRV9XUkFQX1QnLFxuXHQxMDQ5NzogJ1JFUEVBVCcsXG5cdDEwNzUyOiAnUE9MWUdPTl9PRkZTRVRfVU5JVFMnLFxuXHQxNjM4NDogJ0NPTE9SX0JVRkZFUl9CSVQnLFxuXHQzMjc2OTogJ0NPTlNUQU5UX0NPTE9SJyxcblx0MzI3NzA6ICdPTkVfTUlOVVNfQ09OU1RBTlRfQ09MT1InLFxuXHQzMjc3MTogJ0NPTlNUQU5UX0FMUEhBJyxcblx0MzI3NzI6ICdPTkVfTUlOVVNfQ09OU1RBTlRfQUxQSEEnLFxuXHQzMjc3MzogJ0JMRU5EX0NPTE9SJyxcblx0MzI3NzQ6ICdGVU5DX0FERCcsXG5cdDMyNzc3OiAnQkxFTkRfRVFVQVRJT05fUkdCJyxcblx0MzI3Nzg6ICdGVU5DX1NVQlRSQUNUJyxcblx0MzI3Nzk6ICdGVU5DX1JFVkVSU0VfU1VCVFJBQ1QnLFxuXHQzMjgxOTogJ1VOU0lHTkVEX1NIT1JUXzRfNF80XzQnLFxuXHQzMjgyMDogJ1VOU0lHTkVEX1NIT1JUXzVfNV81XzEnLFxuXHQzMjgyMzogJ1BPTFlHT05fT0ZGU0VUX0ZJTEwnLFxuXHQzMjgyNDogJ1BPTFlHT05fT0ZGU0VUX0ZBQ1RPUicsXG5cdDMyODU0OiAnUkdCQTQnLFxuXHQzMjg1NTogJ1JHQjVfQTEnLFxuXHQzMjg3MzogJ1RFWFRVUkVfQklORElOR18yRCcsXG5cdDMyOTI2OiAnU0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFJyxcblx0MzI5Mjg6ICdTQU1QTEVfQ09WRVJBR0UnLFxuXHQzMjkzNjogJ1NBTVBMRV9CVUZGRVJTJyxcblx0MzI5Mzc6ICdTQU1QTEVTJyxcblx0MzI5Mzg6ICdTQU1QTEVfQ09WRVJBR0VfVkFMVUUnLFxuXHQzMjkzOTogJ1NBTVBMRV9DT1ZFUkFHRV9JTlZFUlQnLFxuXHQzMjk2ODogJ0JMRU5EX0RTVF9SR0InLFxuXHQzMjk2OTogJ0JMRU5EX1NSQ19SR0InLFxuXHQzMjk3MDogJ0JMRU5EX0RTVF9BTFBIQScsXG5cdDMyOTcxOiAnQkxFTkRfU1JDX0FMUEhBJyxcblx0MzMwNzE6ICdDTEFNUF9UT19FREdFJyxcblx0MzMxNzA6ICdHRU5FUkFURV9NSVBNQVBfSElOVCcsXG5cdDMzMTg5OiAnREVQVEhfQ09NUE9ORU5UMTYnLFxuXHQzMzMwNjogJ0RFUFRIX1NURU5DSUxfQVRUQUNITUVOVCcsXG5cdDMzMzIxOiAnUjgnLFxuXHQzMzYzNTogJ1VOU0lHTkVEX1NIT1JUXzVfNl81Jyxcblx0MzM2NDg6ICdNSVJST1JFRF9SRVBFQVQnLFxuXHQzMzkwMTogJ0FMSUFTRURfUE9JTlRfU0laRV9SQU5HRScsXG5cdDMzOTAyOiAnQUxJQVNFRF9MSU5FX1dJRFRIX1JBTkdFJyxcblx0MzM5ODQ6ICdURVhUVVJFMCcsXG5cdDMzOTg1OiAnVEVYVFVSRTEnLFxuXHQzMzk4NjogJ1RFWFRVUkUyJyxcblx0MzM5ODc6ICdURVhUVVJFMycsXG5cdDMzOTg4OiAnVEVYVFVSRTQnLFxuXHQzMzk4OTogJ1RFWFRVUkU1Jyxcblx0MzM5OTA6ICdURVhUVVJFNicsXG5cdDMzOTkxOiAnVEVYVFVSRTcnLFxuXHQzMzk5MjogJ1RFWFRVUkU4Jyxcblx0MzM5OTM6ICdURVhUVVJFOScsXG5cdDMzOTk0OiAnVEVYVFVSRTEwJyxcblx0MzM5OTU6ICdURVhUVVJFMTEnLFxuXHQzMzk5NjogJ1RFWFRVUkUxMicsXG5cdDMzOTk3OiAnVEVYVFVSRTEzJyxcblx0MzM5OTg6ICdURVhUVVJFMTQnLFxuXHQzMzk5OTogJ1RFWFRVUkUxNScsXG5cdDM0MDAwOiAnVEVYVFVSRTE2Jyxcblx0MzQwMDE6ICdURVhUVVJFMTcnLFxuXHQzNDAwMjogJ1RFWFRVUkUxOCcsXG5cdDM0MDAzOiAnVEVYVFVSRTE5Jyxcblx0MzQwMDQ6ICdURVhUVVJFMjAnLFxuXHQzNDAwNTogJ1RFWFRVUkUyMScsXG5cdDM0MDA2OiAnVEVYVFVSRTIyJyxcblx0MzQwMDc6ICdURVhUVVJFMjMnLFxuXHQzNDAwODogJ1RFWFRVUkUyNCcsXG5cdDM0MDA5OiAnVEVYVFVSRTI1Jyxcblx0MzQwMTA6ICdURVhUVVJFMjYnLFxuXHQzNDAxMTogJ1RFWFRVUkUyNycsXG5cdDM0MDEyOiAnVEVYVFVSRTI4Jyxcblx0MzQwMTM6ICdURVhUVVJFMjknLFxuXHQzNDAxNDogJ1RFWFRVUkUzMCcsXG5cdDM0MDE1OiAnVEVYVFVSRTMxJyxcblx0MzQwMTY6ICdBQ1RJVkVfVEVYVFVSRScsXG5cdDM0MDI0OiAnTUFYX1JFTkRFUkJVRkZFUl9TSVpFJyxcblx0MzQwNDE6ICdERVBUSF9TVEVOQ0lMJyxcblx0MzQwNTU6ICdJTkNSX1dSQVAnLFxuXHQzNDA1NjogJ0RFQ1JfV1JBUCcsXG5cdDM0MDY3OiAnVEVYVFVSRV9DVUJFX01BUCcsXG5cdDM0MDY4OiAnVEVYVFVSRV9CSU5ESU5HX0NVQkVfTUFQJyxcblx0MzQwNjk6ICdURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gnLFxuXHQzNDA3MDogJ1RFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWCcsXG5cdDM0MDcxOiAnVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9ZJyxcblx0MzQwNzI6ICdURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1knLFxuXHQzNDA3MzogJ1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWicsXG5cdDM0MDc0OiAnVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9aJyxcblx0MzQwNzY6ICdNQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFJyxcblx0MzQzMzg6ICdWRVJURVhfQVRUUklCX0FSUkFZX0VOQUJMRUQnLFxuXHQzNDMzOTogJ1ZFUlRFWF9BVFRSSUJfQVJSQVlfU0laRScsXG5cdDM0MzQwOiAnVkVSVEVYX0FUVFJJQl9BUlJBWV9TVFJJREUnLFxuXHQzNDM0MTogJ1ZFUlRFWF9BVFRSSUJfQVJSQVlfVFlQRScsXG5cdDM0MzQyOiAnQ1VSUkVOVF9WRVJURVhfQVRUUklCJyxcblx0MzQzNzM6ICdWRVJURVhfQVRUUklCX0FSUkFZX1BPSU5URVInLFxuXHQzNDQ2NjogJ05VTV9DT01QUkVTU0VEX1RFWFRVUkVfRk9STUFUUycsXG5cdDM0NDY3OiAnQ09NUFJFU1NFRF9URVhUVVJFX0ZPUk1BVFMnLFxuXHQzNDY2MDogJ0JVRkZFUl9TSVpFJyxcblx0MzQ2NjE6ICdCVUZGRVJfVVNBR0UnLFxuXHQzNDgxNjogJ1NURU5DSUxfQkFDS19GVU5DJyxcblx0MzQ4MTc6ICdTVEVOQ0lMX0JBQ0tfRkFJTCcsXG5cdDM0ODE4OiAnU1RFTkNJTF9CQUNLX1BBU1NfREVQVEhfRkFJTCcsXG5cdDM0ODE5OiAnU1RFTkNJTF9CQUNLX1BBU1NfREVQVEhfUEFTUycsXG5cdDM0ODc3OiAnQkxFTkRfRVFVQVRJT05fQUxQSEEnLFxuXHQzNDkyMTogJ01BWF9WRVJURVhfQVRUUklCUycsXG5cdDM0OTIyOiAnVkVSVEVYX0FUVFJJQl9BUlJBWV9OT1JNQUxJWkVEJyxcblx0MzQ5MzA6ICdNQVhfVEVYVFVSRV9JTUFHRV9VTklUUycsXG5cdDM0OTYyOiAnQVJSQVlfQlVGRkVSJyxcblx0MzQ5NjM6ICdFTEVNRU5UX0FSUkFZX0JVRkZFUicsXG5cdDM0OTY0OiAnQVJSQVlfQlVGRkVSX0JJTkRJTkcnLFxuXHQzNDk2NTogJ0VMRU1FTlRfQVJSQVlfQlVGRkVSX0JJTkRJTkcnLFxuXHQzNDk3NTogJ1ZFUlRFWF9BVFRSSUJfQVJSQVlfQlVGRkVSX0JJTkRJTkcnLFxuXHQzNTA0MDogJ1NUUkVBTV9EUkFXJyxcblx0MzUwNDQ6ICdTVEFUSUNfRFJBVycsXG5cdDM1MDQ4OiAnRFlOQU1JQ19EUkFXJyxcblx0MzU2MzI6ICdGUkFHTUVOVF9TSEFERVInLFxuXHQzNTYzMzogJ1ZFUlRFWF9TSEFERVInLFxuXHQzNTY2MDogJ01BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUycsXG5cdDM1NjYxOiAnTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMnLFxuXHQzNTY2MzogJ1NIQURFUl9UWVBFJyxcblx0MzU2NjQ6ICdGTE9BVF9WRUMyJyxcblx0MzU2NjU6ICdGTE9BVF9WRUMzJyxcblx0MzU2NjY6ICdGTE9BVF9WRUM0Jyxcblx0MzU2Njc6ICdJTlRfVkVDMicsXG5cdDM1NjY4OiAnSU5UX1ZFQzMnLFxuXHQzNTY2OTogJ0lOVF9WRUM0Jyxcblx0MzU2NzA6ICdCT09MJyxcblx0MzU2NzE6ICdCT09MX1ZFQzInLFxuXHQzNTY3MjogJ0JPT0xfVkVDMycsXG5cdDM1NjczOiAnQk9PTF9WRUM0Jyxcblx0MzU2NzQ6ICdGTE9BVF9NQVQyJyxcblx0MzU2NzU6ICdGTE9BVF9NQVQzJyxcblx0MzU2NzY6ICdGTE9BVF9NQVQ0Jyxcblx0MzU2Nzg6ICdTQU1QTEVSXzJEJyxcblx0MzU2ODA6ICdTQU1QTEVSX0NVQkUnLFxuXHQzNTcxMjogJ0RFTEVURV9TVEFUVVMnLFxuXHQzNTcxMzogJ0NPTVBJTEVfU1RBVFVTJyxcblx0MzU3MTQ6ICdMSU5LX1NUQVRVUycsXG5cdDM1NzE1OiAnVkFMSURBVEVfU1RBVFVTJyxcblx0MzU3MTY6ICdJTkZPX0xPR19MRU5HVEgnLFxuXHQzNTcxNzogJ0FUVEFDSEVEX1NIQURFUlMnLFxuXHQzNTcxODogJ0FDVElWRV9VTklGT1JNUycsXG5cdDM1NzE5OiAnQUNUSVZFX1VOSUZPUk1fTUFYX0xFTkdUSCcsXG5cdDM1NzIwOiAnU0hBREVSX1NPVVJDRV9MRU5HVEgnLFxuXHQzNTcyMTogJ0FDVElWRV9BVFRSSUJVVEVTJyxcblx0MzU3MjI6ICdBQ1RJVkVfQVRUUklCVVRFX01BWF9MRU5HVEgnLFxuXHQzNTcyNDogJ1NIQURJTkdfTEFOR1VBR0VfVkVSU0lPTicsXG5cdDM1NzI1OiAnQ1VSUkVOVF9QUk9HUkFNJyxcblx0MzYwMDM6ICdTVEVOQ0lMX0JBQ0tfUkVGJyxcblx0MzYwMDQ6ICdTVEVOQ0lMX0JBQ0tfVkFMVUVfTUFTSycsXG5cdDM2MDA1OiAnU1RFTkNJTF9CQUNLX1dSSVRFTUFTSycsXG5cdDM2MDA2OiAnRlJBTUVCVUZGRVJfQklORElORycsXG5cdDM2MDA3OiAnUkVOREVSQlVGRkVSX0JJTkRJTkcnLFxuXHQzNjA0ODogJ0ZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfT0JKRUNUX1RZUEUnLFxuXHQzNjA0OTogJ0ZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfT0JKRUNUX05BTUUnLFxuXHQzNjA1MDogJ0ZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfVEVYVFVSRV9MRVZFTCcsXG5cdDM2MDUxOiAnRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9URVhUVVJFX0NVQkVfTUFQX0ZBQ0UnLFxuXHQzNjA1MzogJ0ZSQU1FQlVGRkVSX0NPTVBMRVRFJyxcblx0MzYwNTQ6ICdGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQnLFxuXHQzNjA1NTogJ0ZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UJyxcblx0MzYwNTc6ICdGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlMnLFxuXHQzNjA2MTogJ0ZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEJyxcblx0MzYwNjQ6ICdDT0xPUl9BVFRBQ0hNRU5UMCcsXG5cdDM2MDk2OiAnREVQVEhfQVRUQUNITUVOVCcsXG5cdDM2MTI4OiAnU1RFTkNJTF9BVFRBQ0hNRU5UJyxcblx0MzYxNjA6ICdGUkFNRUJVRkZFUicsXG5cdDM2MTYxOiAnUkVOREVSQlVGRkVSJyxcblx0MzYxNjI6ICdSRU5ERVJCVUZGRVJfV0lEVEgnLFxuXHQzNjE2MzogJ1JFTkRFUkJVRkZFUl9IRUlHSFQnLFxuXHQzNjE2NDogJ1JFTkRFUkJVRkZFUl9JTlRFUk5BTF9GT1JNQVQnLFxuXHQzNjE2ODogJ1NURU5DSUxfSU5ERVg4Jyxcblx0MzYxNzY6ICdSRU5ERVJCVUZGRVJfUkVEX1NJWkUnLFxuXHQzNjE3NzogJ1JFTkRFUkJVRkZFUl9HUkVFTl9TSVpFJyxcblx0MzYxNzg6ICdSRU5ERVJCVUZGRVJfQkxVRV9TSVpFJyxcblx0MzYxNzk6ICdSRU5ERVJCVUZGRVJfQUxQSEFfU0laRScsXG5cdDM2MTgwOiAnUkVOREVSQlVGRkVSX0RFUFRIX1NJWkUnLFxuXHQzNjE4MTogJ1JFTkRFUkJVRkZFUl9TVEVOQ0lMX1NJWkUnLFxuXHQzNjE5NDogJ1JHQjU2NScsXG5cdDM2MzM2OiAnTE9XX0ZMT0FUJyxcblx0MzYzMzc6ICdNRURJVU1fRkxPQVQnLFxuXHQzNjMzODogJ0hJR0hfRkxPQVQnLFxuXHQzNjMzOTogJ0xPV19JTlQnLFxuXHQzNjM0MDogJ01FRElVTV9JTlQnLFxuXHQzNjM0MTogJ0hJR0hfSU5UJyxcblx0MzYzNDY6ICdTSEFERVJfQ09NUElMRVInLFxuXHQzNjM0NzogJ01BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTJyxcblx0MzYzNDg6ICdNQVhfVkFSWUlOR19WRUNUT1JTJyxcblx0MzYzNDk6ICdNQVhfRlJBR01FTlRfVU5JRk9STV9WRUNUT1JTJyxcblx0Mzc0NDA6ICdVTlBBQ0tfRkxJUF9ZX1dFQkdMJyxcblx0Mzc0NDE6ICdVTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wnLFxuXHQzNzQ0MjogJ0NPTlRFWFRfTE9TVF9XRUJHTCcsXG5cdDM3NDQzOiAnVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCcsXG5cdDM3NDQ0OiAnQlJPV1NFUl9ERUZBVUxUX1dFQkdMJ1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9XZWJnbE51bWJlci5qcyIsIi8vIFBhc3MuanNcblxuaW1wb3J0IEdMU2hhZGVyIGZyb20gJy4uL0dMU2hhZGVyJztcbmltcG9ydCBGcmFtZUJ1ZmZlciBmcm9tICcuLi9GcmFtZUJ1ZmZlcic7XG5pbXBvcnQgU2hhZGVyTGlicyBmcm9tICcuLi91dGlscy9TaGFkZXJMaWJzJztcblxuY2xhc3MgUGFzcyB7XG5cdGNvbnN0cnVjdG9yKG1Tb3VyY2UsIG1XaWR0aCA9IDAsIG1IZWlnaHQgPSAwLCBtUGFyYW1zID0ge30pIHtcblx0XHR0aGlzLnNoYWRlciA9IG5ldyBHTFNoYWRlcihTaGFkZXJMaWJzLmJpZ1RyaWFuZ2xlVmVydCwgbVNvdXJjZSk7XG5cblx0XHR0aGlzLl93aWR0aCA9IG1XaWR0aDtcblx0XHR0aGlzLl9oZWlnaHQgPSBtSGVpZ2h0O1xuXHRcdHRoaXMuX3VuaWZvcm1zID0ge307XG5cdFx0dGhpcy5faGFzT3duRmJvID0gdGhpcy5fd2lkdGggPiAwICYmIHRoaXMuX3dpZHRoID4gMDtcblx0XHR0aGlzLl91bmlmb3JtcyA9IHt9O1xuXG5cdFx0aWYgKHRoaXMuX2hhc093bkZibykge1xuXHRcdFx0dGhpcy5fZmJvID0gbmV3IEZyYW1lQnVmZmVyKHRoaXMuX3dpZHRoLCB0aGlzLmhlaWdodCwgbVBhcm1hcyk7XG5cdFx0fVxuXHR9XG5cblxuXHR1bmlmb3JtKG1OYW1lLCBtVmFsdWUpIHtcblx0XHR0aGlzLl91bmlmb3Jtc1ttTmFtZV0gPSBtVmFsdWU7XG5cdH1cblxuXG5cdHJlbmRlcih0ZXh0dXJlKSB7XG5cdFx0dGhpcy5zaGFkZXIuYmluZCgpO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oJ3RleHR1cmUnLCAndW5pZm9ybTFpJywgMCk7XG5cdFx0dGV4dHVyZS5iaW5kKDApO1xuXG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSh0aGlzLl91bmlmb3Jtcyk7XG5cdH1cblxuXHRnZXQgd2lkdGgoKSB7XHRyZXR1cm4gdGhpcy5fd2lkdGg7XHR9XG5cdGdldCBoZWlnaHQoKSB7XHRyZXR1cm4gdGhpcy5faGVpZ2h0O1x0fVxuXHRnZXQgZmJvKCkge1x0cmV0dXJuIHRoaXMuX2ZibztcdH1cblx0Z2V0IGhhc0ZibygpIHtcdHJldHVybiB0aGlzLl9oYXNPd25GYm87IH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFzcztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9wb3N0L1Bhc3MuanMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gc2ltcGxlQ29sb3IuZnJhZ1xcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgU0lNUExFX0NPTE9SXFxuXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIHZlYzMgY29sb3I7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIG9wYWNpdHkpO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9zaW1wbGVDb2xvci5mcmFnXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0gXCIvLyBiYXNpYy52ZXJ0XFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBCQVNJQ19WRVJURVhcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMyBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5hdHRyaWJ1dGUgdmVjMyBhTm9ybWFsO1xcblxcbnVuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVWaWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHVQcm9qZWN0aW9uTWF0cml4ICogdVZpZXdNYXRyaXggKiB1TW9kZWxNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKTtcXG4gICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxuICAgIHZOb3JtYWwgPSBhTm9ybWFsO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9iYXNpYy52ZXJ0XG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIEZyYW1lQnVmZmVyLmpzXG5cbmltcG9ydCBHTCBmcm9tICcuL0dMVG9vbCc7XG5pbXBvcnQgR0xUZXh0dXJlMiBmcm9tICcuL0dMVGV4dHVyZTInO1xuaW1wb3J0IFdlYmdsTnVtYmVyIGZyb20gJy4vdXRpbHMvV2ViZ2xOdW1iZXInO1xuXG5sZXQgZ2w7XG5sZXQgd2ViZ2xEZXB0aFRleHR1cmU7XG5sZXQgaGFzQ2hlY2tlZE11bHRpUmVuZGVyU3VwcG9ydCA9IGZhbHNlO1xubGV0IGV4dERyYXdCdWZmZXI7XG5cblxuY29uc3QgY2hlY2tNdWx0aVJlbmRlciA9IGZ1bmN0aW9uICgpIHtcblx0aWYoR0wud2ViZ2wyKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gZWxzZSB7XG5cdFx0ZXh0RHJhd0J1ZmZlciA9IEdMLmdldEV4dGVuc2lvbignV0VCR0xfZHJhd19idWZmZXJzJyk7XG5cdFx0cmV0dXJuICEhZXh0RHJhd0J1ZmZlcjtcblx0fVxuXHRcblx0aGFzQ2hlY2tlZE11bHRpUmVuZGVyU3VwcG9ydCA9IHRydWU7XG59O1xuXG5jbGFzcyBGcmFtZUJ1ZmZlciB7XG5cblx0Y29uc3RydWN0b3IobVdpZHRoLCBtSGVpZ2h0LCBtUGFyYW1ldGVycyA9IHt9LCBtTnVtVGFyZ2V0cyA9IDEpIHtcblx0XHRnbCA9IEdMLmdsO1xuXHRcdHdlYmdsRGVwdGhUZXh0dXJlID0gR0wuY2hlY2tFeHRlbnNpb24oJ1dFQkdMX2RlcHRoX3RleHR1cmUnKTtcblxuXHRcdHRoaXMud2lkdGggICAgICAgICAgICA9IG1XaWR0aDtcblx0XHR0aGlzLmhlaWdodCAgICAgICAgICAgPSBtSGVpZ2h0O1xuXHRcdHRoaXMuX251bVRhcmdldHMgXHQgID0gbU51bVRhcmdldHM7XG5cdFx0dGhpcy5fbXVsdGlwbGVUYXJnZXRzID0gbU51bVRhcmdldHMgPiAxO1xuXHRcdHRoaXMuX3BhcmFtZXRlcnMgPSBtUGFyYW1ldGVycztcblxuXHRcdGlmKCFoYXNDaGVja2VkTXVsdGlSZW5kZXJTdXBwb3J0KSB7XG5cdFx0XHRjaGVja011bHRpUmVuZGVyKCk7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy5fbXVsdGlwbGVUYXJnZXRzKSB7XG5cdFx0XHR0aGlzLl9jaGVja01heE51bVJlbmRlclRhcmdldCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2luaXQoKTtcblx0fVxuXG5cblx0X2luaXQoKSB7XG5cdFx0dGhpcy5faW5pdFRleHR1cmVzKCk7XG5cdFx0XG5cdFx0dGhpcy5mcmFtZUJ1ZmZlciAgICAgICAgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1x0XHRcblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVCdWZmZXIpO1xuXG5cdFx0aWYoR0wud2ViZ2wyKSB7XG5cdFx0XHQvLyB0aGlzLnJlbmRlckJ1ZmZlckRlcHRoID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cdFx0XHQvLyBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5yZW5kZXJCdWZmZXJEZXB0aCk7XG5cdFx0XHQvLyBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfQ09NUE9ORU5UMTYsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0XHRcdC8vIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIHRoaXMucmVuZGVyQnVmZmVyRGVwdGgpO1xuXG5cdFx0XHRjb25zdCBidWZmZXJzID0gW107XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX251bVRhcmdldHM7IGkrKykge1xuXHRcdFx0XHRnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5EUkFXX0ZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGksIGdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmVzW2ldLnRleHR1cmUsIDApO1xuXHRcdFx0XHRidWZmZXJzLnB1c2goZ2xbYENPTE9SX0FUVEFDSE1FTlQke2l9YF0pO1xuXHRcdFx0fVxuXG5cdFx0XHRnbC5kcmF3QnVmZmVycyhidWZmZXJzKTtcblxuXHRcdFx0Z2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRFJBV19GUkFNRUJVRkZFUiwgZ2wuREVQVEhfQVRUQUNITUVOVCwgZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbERlcHRoVGV4dHVyZS50ZXh0dXJlLCAwKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX251bVRhcmdldHM7IGkrKykge1xuXHRcdFx0XHRnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpLCBnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlc1tpXS50ZXh0dXJlLCAwKTtcdFxuXHRcdFx0fVxuXG5cdFx0XHRpZih0aGlzLl9tdWx0aXBsZVRhcmdldHMpIHtcblx0XHRcdFx0Y29uc3QgZHJhd0J1ZmZlcnMgPSBbXTtcblx0XHRcdFx0Zm9yKGxldCBpPTA7IGk8dGhpcy5fbnVtVGFyZ2V0czsgaSsrKSB7XG5cdFx0XHRcdFx0ZHJhd0J1ZmZlcnMucHVzaChleHREcmF3QnVmZmVyW2BDT0xPUl9BVFRBQ0hNRU5UJHtpfV9XRUJHTGBdKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGV4dERyYXdCdWZmZXIuZHJhd0J1ZmZlcnNXRUJHTChkcmF3QnVmZmVycyk7XHRcblx0XHRcdH1cblxuXHRcdFx0aWYod2ViZ2xEZXB0aFRleHR1cmUpIHtcblx0XHRcdFx0Z2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlRFWFRVUkVfMkQsIHRoaXMuZ2xEZXB0aFRleHR1cmUudGV4dHVyZSwgMCk7XHRcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cblx0XHQvL1x0Q0hFQ0tJTkcgRkJPXG5cdFx0Y29uc3QgRkJPc3RhdHVzID0gZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUik7XG5cdFx0aWYoRkJPc3RhdHVzICE9IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdHTF9GUkFNRUJVRkZFUl9DT01QTEVURSBmYWlsZWQsIENBTk5PVCB1c2UgRnJhbWVidWZmZXInLCBXZWJnbE51bWJlcltGQk9zdGF0dXNdKTtcblx0XHR9XG5cblx0XHQvL1x0VU5CSU5EXG5cblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblx0XHRnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgbnVsbCk7XG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblxuXHRcdFxuXHRcdC8vXHRDTEVBUiBGUkFNRUJVRkZFUiBcblxuXHRcdHRoaXMuY2xlYXIoKTtcblx0fVxuXG5cdF9jaGVja01heE51bVJlbmRlclRhcmdldCgpIHtcblx0XHRjb25zdCBtYXhOdW1EcmF3QnVmZmVycyA9IEdMLmdsLmdldFBhcmFtZXRlcihleHREcmF3QnVmZmVyLk1BWF9EUkFXX0JVRkZFUlNfV0VCR0wpO1xuXHRcdGlmKHRoaXMuX251bVRhcmdldHMgPiBtYXhOdW1EcmF3QnVmZmVycykge1xuXHRcdFx0Y29uc29sZS5lcnJvcignT3ZlciBtYXggbnVtYmVyIG9mIGRyYXcgYnVmZmVycyBzdXBwb3J0ZWQgOiAnLCBtYXhOdW1EcmF3QnVmZmVycyk7XG5cdFx0XHR0aGlzLl9udW1UYXJnZXRzID0gbWF4TnVtRHJhd0J1ZmZlcnM7XG5cdFx0fVxuXHR9XG5cblx0X2luaXRUZXh0dXJlcygpIHtcblx0XHR0aGlzLl90ZXh0dXJlcyA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbnVtVGFyZ2V0czsgaSsrKSB7XG5cdFx0XHRjb25zdCBnbHQgPSB0aGlzLl9jcmVhdGVUZXh0dXJlKCk7XG5cdFx0XHR0aGlzLl90ZXh0dXJlcy5wdXNoKGdsdCk7XG5cdFx0fVxuXG5cdFx0XG5cdFx0aWYoR0wud2ViZ2wyKSB7IFxuXHRcdFx0dGhpcy5nbERlcHRoVGV4dHVyZSA9IHRoaXMuX2NyZWF0ZVRleHR1cmUoZ2wuREVQVEhfQ09NUE9ORU5UMTYsIGdsLlVOU0lHTkVEX1NIT1JULCBnbC5ERVBUSF9DT01QT05FTlQsIHRydWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmdsRGVwdGhUZXh0dXJlID0gdGhpcy5fY3JlYXRlVGV4dHVyZShnbC5ERVBUSF9DT01QT05FTlQsIGdsLlVOU0lHTkVEX1NIT1JULCBnbC5ERVBUSF9DT01QT05FTlQsIHsgbWluRmlsdGVyOkdMLkxJTkVBUiB9KTtcblx0XHR9XG5cdH1cblxuXHRfY3JlYXRlVGV4dHVyZShtSW50ZXJuYWxmb3JtYXQsIG1UZXhlbFR5cGUsIG1Gb3JtYXQsIG1QYXJhbWV0ZXJzID0ge30pIHtcblx0XHRjb25zdCBwYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fcGFyYW1ldGVycyk7XG5cdFx0aWYoIW1Gb3JtYXQpIHtcdG1Gb3JtYXQgPSBtSW50ZXJuYWxmb3JtYXQ7IH1cblx0XHRcblx0XHRwYXJhbWV0ZXJzLmludGVybmFsRm9ybWF0ID0gbUludGVybmFsZm9ybWF0IHx8IGdsLlJHQkE7XG5cdFx0cGFyYW1ldGVycy5mb3JtYXQgPSBtRm9ybWF0O1xuXHRcdHBhcmFtZXRlcnMudHlwZSA9IG1UZXhlbFR5cGUgfHwgcGFyYW1ldGVycy50eXBlIHx8IEdMLlVOU0lHTkVEX0JZVEU7XG5cdFx0Zm9yKGNvbnN0IHMgaW4gbVBhcmFtZXRlcnMpIHtcblx0XHRcdHBhcmFtZXRlcnNbc10gPSBtUGFyYW1ldGVyc1tzXTtcblx0XHR9XG5cblx0XHRjb25zdCB0ZXh0dXJlID0gbmV3IEdMVGV4dHVyZTIobnVsbCwgcGFyYW1ldGVycywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXHRcdHJldHVybiB0ZXh0dXJlO1xuXHR9XG5cblx0Ly9cdFBVQkxJQyBNRVRIT0RTXG5cblx0YmluZChtQXV0b1NldFZpZXdwb3J0PXRydWUpIHtcblx0XHRpZihtQXV0b1NldFZpZXdwb3J0KSB7XG5cdFx0XHRHTC52aWV3cG9ydCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHRcblx0XHR9XG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lQnVmZmVyKTtcblx0fVxuXG5cblx0dW5iaW5kKG1BdXRvU2V0Vmlld3BvcnQ9dHJ1ZSkge1xuXHRcdGlmKG1BdXRvU2V0Vmlld3BvcnQpIHtcblx0XHRcdEdMLnZpZXdwb3J0KDAsIDAsIEdMLndpZHRoLCBHTC5oZWlnaHQpO1x0XG5cdFx0fVxuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cblx0XHR0aGlzLl90ZXh0dXJlcy5mb3JFYWNoKHRleHR1cmUgPT4ge1xuXHRcdFx0dGV4dHVyZS5nZW5lcmF0ZU1pcG1hcCgpO1xuXHRcdH0pO1xuXHR9XG5cblxuXHRjbGVhcihyID0gMCwgZyA9IDAsIGIgPSAwLCBhID0gMCkge1xuXHRcdHRoaXMuYmluZCgpO1xuXHRcdEdMLmNsZWFyKHIsIGcsIGIsIGEpO1xuXHRcdHRoaXMudW5iaW5kKCk7XG5cdH1cdFxuXG5cblx0Ly9cdFRFWFRVUkVTXG5cblx0Z2V0VGV4dHVyZShtSW5kZXggPSAwKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RleHR1cmVzW21JbmRleF07XG5cdH1cblxuXHRnZXREZXB0aFRleHR1cmUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2xEZXB0aFRleHR1cmU7XG5cdH1cblxuXHQvL1x0VE9VR0hUUyA6IFNob3VsZCBJIHJlbW92ZSB0aGVzZSBmcm9tIGZyYW1lIGJ1ZmZlciA/IFxuXHQvL1x0U2hvdWxkbid0IHRoZXNlIGJlIHNldCBpbmRpdmlkdWFsbHkgdG8gZWFjaCB0ZXh0dXJlID8gXG5cdC8vXHRlLmcuIGZiby5nZXRUZXh0dXJlKDApLm1pbkZpbHRlciA9IEdMLk5FQVJFU1Q7XG5cdC8vXHRcdCBmYm8uZ2V0VGV4dHVyZSgxKS5taW5GaWx0ZXIgPSBHTC5MSU5FQVI7IC4uLiBldGMgPyBcblxuXHQvL1x0TUlQTUFQIEZJTFRFUlxuXG5cdGdldCBtaW5GaWx0ZXIoKSB7XHRyZXR1cm4gdGhpcy5fdGV4dHVyZXNbMF0ubWluRmlsdGVyO1x0fVxuXG5cdHNldCBtaW5GaWx0ZXIobVZhbHVlKSB7XG5cdFx0dGhpcy5fdGV4dHVyZXMuZm9yRWFjaCh0ZXh0dXJlID0+IHtcblx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gbVZhbHVlO1xuXHRcdH0pO1xuXHR9XG5cblx0Z2V0IG1hZ0ZpbHRlcigpIHtcdHJldHVybiB0aGlzLl90ZXh0dXJlc1swXS5tYWdGaWx0ZXI7XHR9XG5cblx0c2V0IG1hZ0ZpbHRlcihtVmFsdWUpIHtcblx0XHR0aGlzLl90ZXh0dXJlcy5mb3JFYWNoKHRleHR1cmUgPT4ge1xuXHRcdFx0dGV4dHVyZS5tYWdGaWx0ZXIgPSBtVmFsdWU7XG5cdFx0fSk7XG5cdH1cblxuXG5cdC8vXHRXUkFQUElOR1xuXG5cdGdldCB3cmFwUygpIHtcdHJldHVybiB0aGlzLl90ZXh0dXJlc1swXS53cmFwUztcdH1cblxuXHRzZXQgd3JhcFMobVZhbHVlKSB7XG5cdFx0dGhpcy5fdGV4dHVyZXMuZm9yRWFjaCh0ZXh0dXJlID0+IHtcblx0XHRcdHRleHR1cmUud3JhcFMgPSBtVmFsdWU7XG5cdFx0fSk7XG5cdH1cblxuXG5cdGdldCB3cmFwVCgpIHtcdHJldHVybiB0aGlzLl90ZXh0dXJlc1swXS53cmFwVDtcdH1cblxuXHRzZXQgd3JhcFQobVZhbHVlKSB7XG5cdFx0dGhpcy5fdGV4dHVyZXMuZm9yRWFjaCh0ZXh0dXJlID0+IHtcblx0XHRcdHRleHR1cmUud3JhcFQgPSBtVmFsdWU7XG5cdFx0fSk7XG5cdH1cblxuXHQvL1x0VVRJTFNcblxuXHRzaG93UGFyYW1ldGVycygpIHtcblx0XHR0aGlzLl90ZXh0dXJlc1swXS5zaG93UGFyYW1ldGVycygpO1xuXHR9XG5cblx0Z2V0IG51bVRhcmdldHMoKSB7XHRyZXR1cm4gdGhpcy5fbnVtVGFyZ2V0cztcdH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBGcmFtZUJ1ZmZlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9GcmFtZUJ1ZmZlci5qcyIsIi8vIEVhc2VOdW1iZXIuanNcblxuaW1wb3J0IFNjaGVkdWxlciBmcm9tICdzY2hlZHVsaW5nJztcblxuY2xhc3MgRWFzZU51bWJlciB7XG5cdGNvbnN0cnVjdG9yKG1WYWx1ZSwgbUVhc2luZyA9IDAuMSkge1xuXHRcdHRoaXMuZWFzaW5nICAgICAgID0gbUVhc2luZztcblx0XHR0aGlzLl92YWx1ZSAgICAgICA9IG1WYWx1ZTtcblx0XHR0aGlzLl90YXJnZXRWYWx1ZSA9IG1WYWx1ZTtcblx0XHR0aGlzLl9lZkluZGV4ICAgICA9IFNjaGVkdWxlci5hZGRFRigoKT0+IHRoaXMuX3VwZGF0ZSgpKTtcblx0fVxuXG5cblx0X3VwZGF0ZSgpIHtcblx0XHRjb25zdCBNSU5fRElGRiA9IDAuMDAwMTtcblx0XHR0aGlzLl9jaGVja0xpbWl0KCk7XG5cdFx0dGhpcy5fdmFsdWUgKz0gKHRoaXMuX3RhcmdldFZhbHVlIC0gdGhpcy5fdmFsdWUpICogdGhpcy5lYXNpbmc7XHRcblx0XHRpZihNYXRoLmFicyh0aGlzLl90YXJnZXRWYWx1ZSAtIHRoaXMuX3ZhbHVlKSA8IE1JTl9ESUZGKSB7XG5cdFx0XHR0aGlzLl92YWx1ZSA9IHRoaXMuX3RhcmdldFZhbHVlO1xuXHRcdH1cblx0fVxuXG5cdHNldFRvKG1WYWx1ZSkge1xuXHRcdHRoaXMuX3RhcmdldFZhbHVlID0gdGhpcy5fdmFsdWUgPSBtVmFsdWU7XG5cdH1cblxuXG5cdGFkZChtQWRkKSB7XG5cdFx0dGhpcy5fdGFyZ2V0VmFsdWUgKz0gbUFkZDtcblx0fVxuXG5cdGxpbWl0KG1NaW4sIG1NYXgpIHtcblx0XHRpZihtTWluID4gbU1heCkge1xuXHRcdFx0dGhpcy5saW1pdChtTWF4LCBtTWluKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9taW4gPSBtTWluO1xuXHRcdHRoaXMuX21heCA9IG1NYXg7XG5cblx0XHR0aGlzLl9jaGVja0xpbWl0KCk7XG5cdH1cblxuXG5cdF9jaGVja0xpbWl0KCkge1xuXHRcdGlmKHRoaXMuX21pbiAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX3RhcmdldFZhbHVlIDwgdGhpcy5fbWluKSB7XG5cdFx0XHR0aGlzLl90YXJnZXRWYWx1ZSA9IHRoaXMuX21pbjtcblx0XHR9IFxuXG5cdFx0aWYodGhpcy5fbWF4ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fdGFyZ2V0VmFsdWUgPiB0aGlzLl9tYXgpIHtcblx0XHRcdHRoaXMuX3RhcmdldFZhbHVlID0gdGhpcy5fbWF4O1xuXHRcdH0gXG5cdH1cblxuXG5cdGRlc3Ryb3koKSB7XG5cdFx0U2NoZWR1bGVyLnJlbW92ZUVGKHRoaXMuX2VmSW5kZXgpO1xuXHR9XG5cblxuXHQvL1x0R0VUVEVSUyAvIFNFVFRFUlNcblxuXHRzZXQgdmFsdWUobVZhbHVlKSB7XG5cdFx0dGhpcy5fdGFyZ2V0VmFsdWUgPSBtVmFsdWU7XG5cdH1cblxuXHRnZXQgdmFsdWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlO1xuXHR9XG5cblx0Z2V0IHRhcmdldFZhbHVlKCkge1xuXHRcdHJldHVybiB0aGlzLl90YXJnZXRWYWx1ZTtcblx0fVxuXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgRWFzZU51bWJlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9FYXNlTnVtYmVyLmpzIiwiLy8gUmF5LmpzXG5cbmltcG9ydCB7IG1hdDQsIHZlYzMgfSBmcm9tICdnbC1tYXRyaXgnO1xuXG5cbmNvbnN0IGEgPSB2ZWMzLmNyZWF0ZSgpO1xuY29uc3QgYiA9IHZlYzMuY3JlYXRlKCk7XG5jb25zdCBjID0gdmVjMy5jcmVhdGUoKTtcbmNvbnN0IHRhcmdldCA9IHZlYzMuY3JlYXRlKCk7XG5jb25zdCBlZGdlMSA9IHZlYzMuY3JlYXRlKCk7XG5jb25zdCBlZGdlMiA9IHZlYzMuY3JlYXRlKCk7XG5jb25zdCBub3JtYWwgPSB2ZWMzLmNyZWF0ZSgpO1xuY29uc3QgZGlmZiA9IHZlYzMuY3JlYXRlKCk7XG5cbmNsYXNzIFJheSB7XG5cdGNvbnN0cnVjdG9yKG1PcmlnaW4sIG1EaXJlY3Rpb24pIHtcblx0XHR0aGlzLm9yaWdpbiA9IHZlYzMuY2xvbmUobU9yaWdpbik7XG5cdFx0dGhpcy5kaXJlY3Rpb24gPSB2ZWMzLmNsb25lKG1EaXJlY3Rpb24pO1xuXHR9XG5cblx0YXQodCkge1xuXHRcdHZlYzMuY29weSh0YXJnZXQsIHRoaXMuZGlyZWN0aW9uKTtcblx0XHR2ZWMzLnNjYWxlKHRhcmdldCwgdGFyZ2V0LCB0KTtcblx0XHR2ZWMzLmFkZCh0YXJnZXQsIHRhcmdldCwgdGhpcy5vcmlnaW4pO1xuXG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fVxuXG5cblx0bG9va0F0KG1UYXJnZXQpIHtcblx0XHR2ZWMzLnN1Yih0aGlzLmRpcmVjdGlvbiwgbVRhcmdldCwgdGhpcy5vcmlnaW4pO1xuXHRcdHZlYzMubm9ybWFsaXplKHRoaXMub3JpZ2luLCB0aGlzLm9yaWdpbik7XG5cdH1cblxuXHRjbG9zZXN0UG9pbnRUb1BvaW50KG1Qb2ludCkge1xuXHRcdGNvbnN0IHJlc3VsdCA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0dmVjMy5zdWIobVBvaW50LCB0aGlzLm9yaWdpbik7XG5cdFx0Y29uc3QgZGlyZWN0aW9uRGlzdGFuY2UgPSB2ZWMzLmRvdChyZXN1bHQsIHRoaXMuZGlyZWN0aW9uKTtcblxuXHRcdGlmIChkaXJlY3Rpb25EaXN0YW5jZSA8IDApIHtcblx0XHRcdHJldHVybiB2ZWMzLmNsb25lKHRoaXMub3JpZ2luKTtcblx0XHR9XG5cblx0XHR2ZWMzLmNvcHkocmVzdWx0LCB0aGlzLmRpcmVjdGlvbik7XG5cdFx0dmVjMy5zY2FsZShyZXN1bHQsIHJlc3VsdCwgZGlyZWN0aW9uRGlzdGFuY2UpO1xuXHRcdHZlYzMuYWRkKHJlc3VsdCwgcmVzdWx0LCB0aGlzLm9yaWdpbik7XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblxuXHRkaXN0YW5jZVRvUG9pbnQobVBvaW50KSB7XG5cdFx0cmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlU3FUb1BvaW50KG1Qb2ludCkpO1xuXHR9XG5cblxuXHRkaXN0YW5jZVNxVG9Qb2ludChtUG9pbnQpIHtcblx0XHRjb25zdCB2MSA9IHZlYzMuY3JlYXRlKCk7XG5cblx0XHR2ZWMzLnN1Yih2MSwgbVBvaW50LCB0aGlzLm9yaWdpbik7XG5cdFx0Y29uc3QgZGlyZWN0aW9uRGlzdGFuY2UgPSB2ZWMzLmRvdCh2MSwgdGhpcy5kaXJlY3Rpb24pO1xuXG5cdFx0aWYgKGRpcmVjdGlvbkRpc3RhbmNlIDwgMCkge1xuXHRcdFx0cmV0dXJuIHZlYzMuc3F1YXJlZERpc3RhbmNlKHRoaXMub3JpZ2luLCBtUG9pbnQpO1xuXHRcdH1cblxuXHRcdHZlYzMuY29weSh2MSwgdGhpcy5kaXJlY3Rpb24pO1xuXHRcdHZlYzMuc2NhbGUodjEsIHYxLCBkaXJlY3Rpb25EaXN0YW5jZSk7XG5cdFx0dmVjMy5hZGQodjEsIHYxLCB0aGlzLm9yaWdpbik7XG5cdFx0cmV0dXJuIHZlYzMuc3F1YXJlZERpc3RhbmNlKHYxLCBtUG9pbnQpO1xuXHR9XG5cblxuXHRpbnRlcnNlY3RzU3BoZXJlKG1DZW50ZXIsIG1SYWRpdXMpIHtcblx0XHRyZXR1cm4gdGhpcy5kaXN0YW5jZVRvUG9pbnQobUNlbnRlcikgPD0gbVJhZGl1cztcblx0fVxuXG5cblx0aW50ZXJzZWN0U3BoZXJlKG1DZW50ZXIsIG1SYWRpdXMpIHtcblx0XHRjb25zdCB2MSA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0dmVjMy5zdWIodjEsIG1DZW50ZXIsIHRoaXMub3JpZ2luKTtcblx0XHRjb25zdCB0Y2EgPSB2ZWMzLmRvdCh2MSwgdGhpcy5kaXJlY3Rpb24pO1xuXHRcdGNvbnN0IGQyID0gdmVjMy5kb3QodjEsIHYxKSAtIHRjYSAqIHRjYTtcblx0XHRjb25zdCByYWRpdXMyID0gbVJhZGl1cyAqIG1SYWRpdXM7XG5cblx0XHRpZihkMiA+IHJhZGl1czIpIHJldHVybiBudWxsO1xuXG5cdFx0Y29uc3QgdGhjID0gTWF0aC5zcXJ0KHJhZGl1czIgLSBkMik7XG5cblx0XHRjb25zdCB0MCA9IHRjYSAtIHRoYztcblxuXHRcdGNvbnN0IHQxID0gdGNhICsgdGhjO1xuXG5cdFx0aWYodDAgPCAwICYmIHQxIDwgMCkgcmV0dXJuIG51bGw7XG5cblx0XHRpZih0MCA8IDApIHJldHVybiB0aGlzLmF0KHQxKTtcblxuXHRcdHJldHVybiB0aGlzLmF0KHQwKTtcblx0fVxuXG5cblx0ZGlzdGFuY2VUb1BsYW5lKG1QbGFuZUNlbnRlciwgbU5vcm1hbCkge1xuXHRcdGNvbnN0IGRlbm9taW5hdG9yID0gdmVjMy5kb3QobU5vcm1hbCwgdGhpcy5kaXJlY3Rpb24pO1xuXG5cdFx0aWYoZGVub21pbmF0b3IgPT09IDApIHtcblx0XHR9XG5cdH1cblxuXG5cdGludGVyc2VjdFRyaWFuZ2xlKG1QQSwgbVBCLCBtUEMsIGJhY2tmYWNlQ3VsbGluZyA9IHRydWUpIHtcblx0XHR2ZWMzLmNvcHkoYSwgbVBBKTtcblx0XHR2ZWMzLmNvcHkoYiwgbVBCKTtcblx0XHR2ZWMzLmNvcHkoYywgbVBDKTtcblxuXHRcdC8vIGNvbnN0IGVkZ2UxID0gdmVjMy5jcmVhdGUoKTtcblx0XHQvLyBjb25zdCBlZGdlMiA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0Ly8gY29uc3Qgbm9ybWFsID0gdmVjMy5jcmVhdGUoKTtcblx0XHQvLyBjb25zdCBkaWZmID0gdmVjMy5jcmVhdGUoKTtcblxuXHRcdHZlYzMuc3ViKGVkZ2UxLCBiLCBhKTtcblx0XHR2ZWMzLnN1YihlZGdlMiwgYywgYSk7XG5cdFx0dmVjMy5jcm9zcyhub3JtYWwsIGVkZ2UxLCBlZGdlMik7XG5cblx0XHRsZXQgRGROID0gdmVjMy5kb3QodGhpcy5kaXJlY3Rpb24sIG5vcm1hbCk7XG5cdFx0bGV0IHNpZ247XG5cblx0XHRpZiAoRGROID4gMCkge1xuXHRcdFx0aWYgKGJhY2tmYWNlQ3VsbGluZykge1x0cmV0dXJuIG51bGw7XHR9XG5cdFx0XHRzaWduID0gMTtcblx0XHR9IGVsc2UgaWYgKERkTiA8IDApIHtcblx0XHRcdHNpZ24gPSAtMTtcblx0XHRcdERkTiA9IC0gRGROO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHR2ZWMzLnN1YihkaWZmLCB0aGlzLm9yaWdpbiwgYSk7XG5cblx0XHR2ZWMzLmNyb3NzKGVkZ2UyLCBkaWZmLCBlZGdlMik7XG5cdFx0Y29uc3QgRGRReEUyID0gc2lnbiAqIHZlYzMuZG90KHRoaXMuZGlyZWN0aW9uLCBlZGdlMik7XG5cdFx0aWYgKERkUXhFMiA8IDApIHsgXHRyZXR1cm4gbnVsbDsgXHR9XG5cblx0XHR2ZWMzLmNyb3NzKGVkZ2UxLCBlZGdlMSwgZGlmZik7XG5cdFx0Y29uc3QgRGRFMXhRID0gc2lnbiAqIHZlYzMuZG90KHRoaXMuZGlyZWN0aW9uLCBlZGdlMSk7XG5cdFx0aWYgKERkRTF4USA8IDApIHtcdHJldHVybiBudWxsO1x0fVxuXG5cdFx0aWYoRGRReEUyICsgRGRFMXhRID4gRGROKSB7XHRyZXR1cm4gbnVsbDtcdH1cblxuXHRcdGNvbnN0IFFkbiA9IC0gc2lnbiAqIHZlYzMuZG90KGRpZmYsIG5vcm1hbCk7XG5cdFx0aWYoUWRuIDwgMCkge1x0cmV0dXJuIG51bGw7XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5hdChRZG4gLyBEZE4pO1xuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmF5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvbWF0aC9SYXkuanMiLCIvLyBDYW1lcmEuanNcblxuaW1wb3J0IHsgbWF0NCwgbWF0MywgcXVhdCB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmNsYXNzIENhbWVyYSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdC8vXHRWSUVXIE1BVFJJWFxuXHRcdHRoaXMuX21hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cblx0XHQvL1x0Rk9SIFRSQU5TRk9STSBGUk9NIE9SSUVOVEFUSU9OXG5cdFx0dGhpcy5fcXVhdCA9IHF1YXQuY3JlYXRlKCk7XG5cdFx0dGhpcy5fb3JpZW50YXRpb24gPSBtYXQ0LmNyZWF0ZSgpO1xuXG5cdFx0Ly9cdFBST0pFQ1RJT04gTUFUUklYXG5cdFx0dGhpcy5fcHJvamVjdGlvbiA9IG1hdDQuY3JlYXRlKCk7XG5cblx0XHQvL1x0UE9TSVRJT04gT0YgQ0FNRVJBXG5cdFx0dGhpcy5wb3NpdGlvbiA9IHZlYzMuY3JlYXRlKCk7XG5cdH1cblxuXG5cdGxvb2tBdChhRXllLCBhQ2VudGVyLCBhVXAgPSBbMCwgMSwgMF0pIHtcblx0XHR0aGlzLl9leWUgPSB2ZWMzLmNsb25lKGFFeWUpO1xuXHRcdHRoaXMuX2NlbnRlciA9IHZlYzMuY2xvbmUoYUNlbnRlcik7XG5cblx0XHR2ZWMzLmNvcHkodGhpcy5wb3NpdGlvbiwgYUV5ZSk7XG5cdFx0bWF0NC5pZGVudGl0eSh0aGlzLl9tYXRyaXgpO1xuXHRcdG1hdDQubG9va0F0KHRoaXMuX21hdHJpeCwgYUV5ZSwgYUNlbnRlciwgYVVwKTtcblx0fVxuXG5cblx0c2V0RnJvbU9yaWVudGF0aW9uKHgsIHksIHosIHcpIHtcblx0XHRxdWF0LnNldCh0aGlzLl9xdWF0LCB4LCB5LCB6LCB3KTtcblx0XHRtYXQ0LmZyb21RdWF0KHRoaXMuX29yaWVudGF0aW9uLCB0aGlzLl9xdWF0KTtcblx0XHRtYXQ0LnRyYW5zbGF0ZSh0aGlzLl9tYXRyaXgsIHRoaXMuX29yaWVudGF0aW9uLCB0aGlzLnBvc2l0aW9uT2Zmc2V0KTtcblx0fVxuXG5cblx0c2V0UHJvamVjdGlvbihtUHJvaikge1xuXHRcdHRoaXMuX3Byb2plY3Rpb24gPSBtYXQ0LmNsb25lKG1Qcm9qKTtcblx0fVxuXG5cblx0c2V0VmlldyhtVmlldykge1xuXHRcdHRoaXMuX21hdHJpeCA9IG1hdDQuY2xvbmUobVZpZXcpO1xuXHR9XG5cdFxuXG5cdHNldEZyb21WaWV3UHJvaihtVmlldywgbVByb2opIHtcblx0XHR0aGlzLnNldFZpZXcobVZpZXcpO1xuXHRcdHRoaXMuc2V0UHJvamVjdGlvbihtUHJvaik7XG5cdH1cblxuXG5cdC8vXHRHRVRURVJTIFxuXG5cdGdldCBtYXRyaXgoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hdHJpeDtcblx0fVxuXG5cdGdldCB2aWV3TWF0cml4KCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXRyaXg7XG5cdH1cblxuXG5cdGdldCBwcm9qZWN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wcm9qZWN0aW9uO1xuXHR9IFxuXG5cdGdldCBwcm9qZWN0aW9uTWF0cml4KCkge1xuXHRcdHJldHVybiB0aGlzLl9wcm9qZWN0aW9uO1xuXHR9IFxuXG5cblx0Z2V0IGV5ZSgpIHtcdHJldHVybiB0aGlzLl9leWU7XHR9XG5cblx0Z2V0IGNlbnRlcigpIHtcdHJldHVybiB0aGlzLl9jZW50ZXI7XHR9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgQ2FtZXJhO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2NhbWVyYXMvQ2FtZXJhLmpzIiwiLy8gQ2FtZXJhUGVyc3BlY3RpdmUuanNcblxuaW1wb3J0IENhbWVyYSBmcm9tICcuL0NhbWVyYSc7XG5pbXBvcnQgUmF5IGZyb20gJy4uL21hdGgvUmF5JztcbmltcG9ydCB7IG1hdDQsIHZlYzMgfSBmcm9tICdnbC1tYXRyaXgnO1xuXG5jb25zdCBtSW52ZXJzZVZpZXdQcm9qID0gbWF0NC5jcmVhdGUoKTtcbmNvbnN0IGNhbWVyYURpciA9IHZlYzMuY3JlYXRlKCk7XG5cblxuY2xhc3MgQ2FtZXJhUGVyc3BlY3RpdmUgZXh0ZW5kcyBDYW1lcmEge1xuXG5cdHNldFBlcnNwZWN0aXZlKG1Gb3YsIG1Bc3BlY3RSYXRpbywgbU5lYXIsIG1GYXIpIHtcblx0XHRcblx0XHR0aGlzLl9mb3YgICAgICAgICA9IG1Gb3Y7XG5cdFx0dGhpcy5fbmVhciAgICAgICAgPSBtTmVhcjtcblx0XHR0aGlzLl9mYXIgICAgICAgICA9IG1GYXI7XG5cdFx0dGhpcy5fYXNwZWN0UmF0aW8gPSBtQXNwZWN0UmF0aW87XG5cdFx0bWF0NC5wZXJzcGVjdGl2ZSh0aGlzLl9wcm9qZWN0aW9uLCBtRm92LCBtQXNwZWN0UmF0aW8sIG1OZWFyLCBtRmFyKTtcblxuXHRcdC8vIHRoaXMuX2ZydXN0dW1Ub3AgPSB0aGlzLl9uZWFyICogTWF0aC50YW4odGhpcy5fZm92ICogMC41KTtcblx0XHQvLyB0aGlzLl9mcnVzdHVtQnV0dG9tID0gLXRoaXMuX2ZydXN0dW1Ub3A7XG5cdFx0Ly8gdGhpcy5fZnJ1c3R1bVJpZ2h0ID0gdGhpcy5fZnJ1c3R1bVRvcCAqIHRoaXMuX2FzcGVjdFJhdGlvO1xuXHRcdC8vIHRoaXMuX2ZydXN0dW1MZWZ0ID0gLXRoaXMuX2ZydXN0dW1SaWdodDtcblx0fVxuXG5cblx0c2V0QXNwZWN0UmF0aW8obUFzcGVjdFJhdGlvKSB7XG5cdFx0dGhpcy5fYXNwZWN0UmF0aW8gPSBtQXNwZWN0UmF0aW87XG5cdFx0bWF0NC5wZXJzcGVjdGl2ZSh0aGlzLnByb2plY3Rpb24sIHRoaXMuX2ZvdiwgbUFzcGVjdFJhdGlvLCB0aGlzLl9uZWFyLCB0aGlzLl9mYXIpO1xuXHR9XG5cblxuXHRnZW5lcmF0ZVJheShtU2NyZWVuUG9zaXRpb24sIG1SYXkpIHtcblx0XHRjb25zdCBwcm9qID0gdGhpcy5wcm9qZWN0aW9uTWF0cml4O1xuXHRcdGNvbnN0IHZpZXcgPSB0aGlzLnZpZXdNYXRyaXg7XG5cblx0XHRtYXQ0Lm11bHRpcGx5KG1JbnZlcnNlVmlld1Byb2osIHByb2osIHZpZXcpO1xuXHRcdG1hdDQuaW52ZXJ0KG1JbnZlcnNlVmlld1Byb2osIG1JbnZlcnNlVmlld1Byb2opO1xuXG5cdFx0dmVjMy50cmFuc2Zvcm1NYXQ0KGNhbWVyYURpciwgbVNjcmVlblBvc2l0aW9uLCBtSW52ZXJzZVZpZXdQcm9qKTtcblx0XHR2ZWMzLnN1YihjYW1lcmFEaXIsIGNhbWVyYURpciwgdGhpcy5wb3NpdGlvbik7XG5cdFx0dmVjMy5ub3JtYWxpemUoY2FtZXJhRGlyLCBjYW1lcmFEaXIpO1xuXG5cdFx0aWYgKCFtUmF5KSB7XG5cdFx0XHRtUmF5ID0gbmV3IFJheSh0aGlzLnBvc2l0aW9uLCBjYW1lcmFEaXIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtUmF5Lm9yaWdpbiA9IHRoaXMucG9zaXRpb247XG5cdFx0XHRtUmF5LmRpcmVjdGlvbiA9IGNhbWVyYURpcjtcblx0XHR9XG5cblxuXHRcdHJldHVybiBtUmF5O1xuXHR9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgQ2FtZXJhUGVyc3BlY3RpdmU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvY2FtZXJhcy9DYW1lcmFQZXJzcGVjdGl2ZS5qcyIsIi8vIEJpbmFyeUxvYWRlci5qc1xuXG5jbGFzcyBCaW5hcnlMb2FkZXIge1xuXG5cdGNvbnN0cnVjdG9yKGlzQXJyYXlCdWZmZXIgPSBmYWxzZSkge1xuXHRcdHRoaXMuX3JlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHRcdHRoaXMuX3JlcS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKGUpPT50aGlzLl9vbkxvYWRlZChlKSk7XG5cdFx0dGhpcy5fcmVxLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgKGUpPT50aGlzLl9vblByb2dyZXNzKGUpKTtcblx0XHRpZihpc0FycmF5QnVmZmVyKSB7XG5cdFx0XHR0aGlzLl9yZXEucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcblx0XHR9XG5cdH1cdFxuXG5cblx0bG9hZCh1cmwsIGNhbGxiYWNrKSB7XG5cdFx0Y29uc29sZS5sb2coJ0xvYWRpbmcgOiAnLCB1cmwpO1xuXHRcdHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2s7XG5cblx0XHR0aGlzLl9yZXEub3BlbignR0VUJywgdXJsKTtcblx0XHR0aGlzLl9yZXEuc2VuZCgpO1xuXHR9XG5cblxuXHRfb25Mb2FkZWQoKSB7XG5cdFx0dGhpcy5fY2FsbGJhY2sodGhpcy5fcmVxLnJlc3BvbnNlKTtcblx0fVxuXG5cdF9vblByb2dyZXNzKC8qIGUqLykge1xuXHRcdC8vIGNvbnNvbGUubG9nKCdvbiBQcm9ncmVzczonLCAoZS5sb2FkZWQvZS50b3RhbCoxMDApLnRvRml4ZWQoMikpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJpbmFyeUxvYWRlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9sb2FkZXJzL0JpbmFyeUxvYWRlci5qcyIsIm1vZHVsZS5leHBvcnRzID0gXCIvLyBiaWdUcmlhbmdsZS52ZXJ0XFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBCSUdfVFJJQU5HTEVfVkVSVEVYXFxuXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFQb3NpdGlvbiwgMC4wLCAxLjApO1xcbiAgICB2VGV4dHVyZUNvb3JkID0gYVBvc2l0aW9uICogLjUgKyAuNTtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3NoYWRlcnMvYmlnVHJpYW5nbGUudmVydFxuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gY29weS5mcmFnXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBDT1BZX0ZSQUdNRU5UXFxuXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4dHVyZUNvb3JkKTtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3NoYWRlcnMvY29weS5mcmFnXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIGFsZnJpZC5qc1xuXG5pbXBvcnQgKiBhcyBHTE0gXHRcdFx0ZnJvbSAnZ2wtbWF0cml4JztcbmltcG9ydCBHTCBcdFx0XHRcdFx0ZnJvbSAnLi9hbGZyaWQvR0xUb29sJztcbmltcG9ydCBHTFNoYWRlciBcdFx0XHRmcm9tICcuL2FsZnJpZC9HTFNoYWRlcic7XG5pbXBvcnQgR0xUZXh0dXJlT2xkIFx0XHRmcm9tICcuL2FsZnJpZC9HTFRleHR1cmUnO1xuaW1wb3J0IEdMVGV4dHVyZSBcdFx0XHRmcm9tICcuL2FsZnJpZC9HTFRleHR1cmUyJztcbmltcG9ydCBHTEN1YmVUZXh0dXJlIFx0XHRmcm9tICcuL2FsZnJpZC9HTEN1YmVUZXh0dXJlJztcbmltcG9ydCBNZXNoIFx0XHRcdFx0ZnJvbSAnLi9hbGZyaWQvTWVzaCc7XG5pbXBvcnQgR2VvbVx0XHRcdFx0XHRmcm9tICcuL2FsZnJpZC9HZW9tJztcbmltcG9ydCBCYXRjaFx0XHRcdFx0ZnJvbSAnLi9hbGZyaWQvQmF0Y2gnO1xuaW1wb3J0IEZyYW1lQnVmZmVyXHRcdFx0ZnJvbSAnLi9hbGZyaWQvRnJhbWVCdWZmZXInO1xuaW1wb3J0IEN1YmVGcmFtZUJ1ZmZlclx0XHRmcm9tICcuL2FsZnJpZC9DdWJlRnJhbWVCdWZmZXInO1xuXG4vL1x0V0VCR0wgMlxuaW1wb3J0IE11bHRpc2FtcGxlRnJhbWVCdWZmZXIgIGZyb20gJy4vYWxmcmlkL011bHRpc2FtcGxlRnJhbWVCdWZmZXInO1xuaW1wb3J0IFRyYW5zZm9ybUZlZWRiYWNrT2JqZWN0IGZyb20gJy4vYWxmcmlkL1RyYW5zZm9ybUZlZWRiYWNrT2JqZWN0JztcblxuLy9cdFRPT0xTXG5pbXBvcnQgU2NoZWR1bGVyIFx0XHRcdGZyb20gJ3NjaGVkdWxpbmcnO1xuaW1wb3J0IEV2ZW50RGlzcGF0Y2hlciBcdFx0ZnJvbSAnLi9hbGZyaWQvdXRpbHMvRXZlbnREaXNwYXRjaGVyJztcbmltcG9ydCBFYXNlTnVtYmVyIFx0XHRcdGZyb20gJy4vYWxmcmlkL3V0aWxzL0Vhc2VOdW1iZXInO1xuaW1wb3J0IFR3ZWVuTnVtYmVyIFx0XHRcdGZyb20gJy4vYWxmcmlkL3V0aWxzL1R3ZWVuTnVtYmVyJztcbmltcG9ydCBPcmJpdGFsQ29udHJvbFx0XHRmcm9tICcuL2FsZnJpZC91dGlscy9PcmJpdGFsQ29udHJvbCc7XG5pbXBvcnQgUXVhdFJvdGF0aW9uXHRcdFx0ZnJvbSAnLi9hbGZyaWQvdXRpbHMvUXVhdFJvdGF0aW9uJztcbmltcG9ydCBUb3VjaERldGVjdG9yXHRcdGZyb20gJy4vYWxmcmlkL3V0aWxzL1RvdWNoRGV0ZWN0b3InO1xuaW1wb3J0IFdlYmdsTnVtYmVyXHRcdFx0ZnJvbSAnLi9hbGZyaWQvdXRpbHMvV2ViZ2xOdW1iZXInO1xuaW1wb3J0IFdlYmdsQ29uc3RcdFx0XHRmcm9tICcuL2FsZnJpZC91dGlscy9XZWJnbENvbnN0JztcblxuLy9cdENBTUVSQVNcbmltcG9ydCBDYW1lcmEgXHRcdFx0XHRmcm9tICcuL2FsZnJpZC9jYW1lcmFzL0NhbWVyYSc7XG5pbXBvcnQgQ2FtZXJhT3J0aG8gXHRcdFx0ZnJvbSAnLi9hbGZyaWQvY2FtZXJhcy9DYW1lcmFPcnRobyc7XG5pbXBvcnQgQ2FtZXJhUGVyc3BlY3RpdmVcdGZyb20gJy4vYWxmcmlkL2NhbWVyYXMvQ2FtZXJhUGVyc3BlY3RpdmUnO1xuaW1wb3J0IENhbWVyYUN1YmVcdFx0XHRmcm9tICcuL2FsZnJpZC9jYW1lcmFzL0NhbWVyYUN1YmUnO1xuXG4vL1x0TUFUSFxuaW1wb3J0IFJheSBcdFx0XHRcdFx0ZnJvbSAnLi9hbGZyaWQvbWF0aC9SYXknO1xuXG4vL1x0T0JKRUNUXG5pbXBvcnQgT2JqZWN0M0QgXHRcdFx0ZnJvbSAnLi9hbGZyaWQvb2JqZWN0cy9PYmplY3QzRCc7XG5cbi8vXHRMT0FERVJTXG5pbXBvcnQgQmluYXJ5TG9hZGVyXHRcdFx0ZnJvbSAnLi9hbGZyaWQvbG9hZGVycy9CaW5hcnlMb2FkZXInO1xuaW1wb3J0IE9iakxvYWRlclx0XHRcdGZyb20gJy4vYWxmcmlkL2xvYWRlcnMvT2JqTG9hZGVyJztcbmltcG9ydCBIRFJMb2FkZXJcdFx0XHRmcm9tICcuL2FsZnJpZC9sb2FkZXJzL0hEUkxvYWRlcic7XG5pbXBvcnQgQ29sbGFkYVBhcnNlclx0XHRmcm9tICcuL2FsZnJpZC9sb2FkZXJzL0NvbGxhZGFQYXJzZXInO1xuaW1wb3J0IEdMVEZMb2FkZXJcdFx0XHRmcm9tICcuL2FsZnJpZC9sb2FkZXJzL0dsdGZMb2FkZXInO1xuXG4vL1x0UE9TVCBFRkZFQ1RcbmltcG9ydCBFZmZlY3RDb21wb3NlciBcdFx0ZnJvbSAnLi9hbGZyaWQvcG9zdC9FZmZlY3RDb21wb3Nlcic7XG5pbXBvcnQgUGFzcyBcdFx0XHRcdGZyb20gJy4vYWxmcmlkL3Bvc3QvUGFzcyc7XG5pbXBvcnQgUGFzc01hY3JvIFx0XHRcdGZyb20gJy4vYWxmcmlkL3Bvc3QvUGFzc01hY3JvJztcbmltcG9ydCBQYXNzQmx1ciBcdFx0XHRmcm9tICcuL2FsZnJpZC9wb3N0L1Bhc3NCbHVyJztcbmltcG9ydCBQYXNzVkJsdXIgXHRcdFx0ZnJvbSAnLi9hbGZyaWQvcG9zdC9QYXNzVkJsdXInO1xuaW1wb3J0IFBhc3NIQmx1ciBcdFx0XHRmcm9tICcuL2FsZnJpZC9wb3N0L1Bhc3NIQmx1cic7XG5pbXBvcnQgUGFzc0Z4YWEgXHRcdFx0ZnJvbSAnLi9hbGZyaWQvcG9zdC9QYXNzRnhhYSc7XG5cblxuLy9cdEhFTFBFUlNcbmltcG9ydCBCYXRjaENvcHlcdFx0XHRmcm9tICcuL2FsZnJpZC9oZWxwZXJzL0JhdGNoQ29weSc7XG5pbXBvcnQgQmF0Y2hBeGlzXHRcdFx0ZnJvbSAnLi9hbGZyaWQvaGVscGVycy9CYXRjaEF4aXMnO1xuaW1wb3J0IEJhdGNoQmFsbFx0XHRcdGZyb20gJy4vYWxmcmlkL2hlbHBlcnMvQmF0Y2hCYWxsJztcbmltcG9ydCBCYXRjaERvdHNQbGFuZVx0XHRmcm9tICcuL2FsZnJpZC9oZWxwZXJzL0JhdGNoRG90c1BsYW5lJztcbmltcG9ydCBCYXRjaExpbmUgXHRcdFx0ZnJvbSAnLi9hbGZyaWQvaGVscGVycy9CYXRjaExpbmUnO1xuaW1wb3J0IEJhdGNoU2t5Ym94XHRcdFx0ZnJvbSAnLi9hbGZyaWQvaGVscGVycy9CYXRjaFNreWJveCc7XG5pbXBvcnQgQmF0Y2hTa3lcdFx0XHRcdGZyb20gJy4vYWxmcmlkL2hlbHBlcnMvQmF0Y2hTa3knO1xuaW1wb3J0IEJhdGNoRlhBQVx0XHRcdGZyb20gJy4vYWxmcmlkL2hlbHBlcnMvQmF0Y2hGWEFBJztcbmltcG9ydCBTY2VuZVx0XHRcdFx0ZnJvbSAnLi9hbGZyaWQvaGVscGVycy9TY2VuZSc7XG5pbXBvcnQgVmlld1x0XHRcdFx0XHRmcm9tICcuL2FsZnJpZC9oZWxwZXJzL1ZpZXcnO1xuaW1wb3J0IFZpZXczRFx0XHRcdFx0ZnJvbSAnLi9hbGZyaWQvaGVscGVycy9WaWV3M0QnO1xuaW1wb3J0IFNoYWRlckxpYnNcdFx0XHRmcm9tICcuL2FsZnJpZC91dGlscy9TaGFkZXJMaWJzJztcblxuXG5jb25zdCBWRVJTSU9OID0gJzAuMi4wJztcblxuY2xhc3MgQWxmcmlkIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5nbG0gICAgICAgICAgICAgICA9IEdMTTtcblx0XHR0aGlzLkdMICAgICAgICAgICAgICAgID0gR0w7XG5cdFx0dGhpcy5HTFRvb2wgICAgICAgICAgICA9IEdMO1xuXHRcdHRoaXMuR0xTaGFkZXIgICAgICAgICAgPSBHTFNoYWRlcjtcblx0XHR0aGlzLkdMVGV4dHVyZSAgICAgICAgID0gR0xUZXh0dXJlO1xuXHRcdHRoaXMuR0xUZXh0dXJlT2xkICAgICAgPSBHTFRleHR1cmVPbGQ7XG5cdFx0dGhpcy5HTEN1YmVUZXh0dXJlICAgICA9IEdMQ3ViZVRleHR1cmU7XG5cdFx0dGhpcy5NZXNoICAgICAgICAgICAgICA9IE1lc2g7XG5cdFx0dGhpcy5HZW9tICAgICAgICAgICAgICA9IEdlb207XG5cdFx0dGhpcy5CYXRjaCAgICAgICAgICAgICA9IEJhdGNoO1xuXHRcdHRoaXMuRnJhbWVCdWZmZXIgICAgICAgPSBGcmFtZUJ1ZmZlcjtcblx0XHR0aGlzLkN1YmVGcmFtZUJ1ZmZlciAgID0gQ3ViZUZyYW1lQnVmZmVyO1xuXHRcdHRoaXMuU2NoZWR1bGVyICAgICAgICAgPSBTY2hlZHVsZXI7XG5cdFx0dGhpcy5FdmVudERpc3BhdGNoZXIgICA9IEV2ZW50RGlzcGF0Y2hlcjtcblx0XHR0aGlzLkVhc2VOdW1iZXIgICAgICAgID0gRWFzZU51bWJlcjtcblx0XHR0aGlzLlR3ZWVuTnVtYmVyICAgICAgID0gVHdlZW5OdW1iZXI7XG5cdFx0dGhpcy5DYW1lcmEgICAgICAgICAgICA9IENhbWVyYTtcblx0XHR0aGlzLkNhbWVyYU9ydGhvICAgICAgID0gQ2FtZXJhT3J0aG87XG5cdFx0dGhpcy5DYW1lcmFQZXJzcGVjdGl2ZSA9IENhbWVyYVBlcnNwZWN0aXZlO1xuXHRcdHRoaXMuUmF5IFx0XHRcdCAgID0gUmF5O1xuXHRcdHRoaXMuQ2FtZXJhQ3ViZSAgICAgICAgPSBDYW1lcmFDdWJlO1xuXHRcdHRoaXMuT3JiaXRhbENvbnRyb2wgICAgPSBPcmJpdGFsQ29udHJvbDtcblx0XHR0aGlzLlF1YXRSb3RhdGlvbiAgICAgID0gUXVhdFJvdGF0aW9uO1xuXHRcdHRoaXMuQmluYXJ5TG9hZGVyICAgICAgPSBCaW5hcnlMb2FkZXI7XG5cdFx0dGhpcy5PYmpMb2FkZXIgICAgICAgICA9IE9iakxvYWRlcjtcblx0XHR0aGlzLkNvbGxhZGFQYXJzZXIgICAgID0gQ29sbGFkYVBhcnNlcjtcblx0XHR0aGlzLkhEUkxvYWRlciAgICAgICAgID0gSERSTG9hZGVyO1xuXHRcdHRoaXMuR0xURkxvYWRlciAgICAgICAgPSBHTFRGTG9hZGVyO1xuXHRcdHRoaXMuQmF0Y2hDb3B5ICAgICAgICAgPSBCYXRjaENvcHk7XG5cdFx0dGhpcy5CYXRjaEF4aXMgICAgICAgICA9IEJhdGNoQXhpcztcblx0XHR0aGlzLkJhdGNoQmFsbCAgICAgICAgID0gQmF0Y2hCYWxsO1xuXHRcdHRoaXMuQmF0Y2hCYWxsICAgICAgICAgPSBCYXRjaEJhbGw7XG5cdFx0dGhpcy5CYXRjaExpbmUgICAgICAgICA9IEJhdGNoTGluZTtcblx0XHR0aGlzLkJhdGNoU2t5Ym94ICAgICAgID0gQmF0Y2hTa3lib3g7XG5cdFx0dGhpcy5CYXRjaFNreSAgICAgICAgICA9IEJhdGNoU2t5O1xuXHRcdHRoaXMuQmF0Y2hGWEFBICAgICAgICAgPSBCYXRjaEZYQUE7XG5cdFx0dGhpcy5CYXRjaERvdHNQbGFuZSAgICA9IEJhdGNoRG90c1BsYW5lO1xuXHRcdHRoaXMuU2NlbmUgICAgICAgICAgICAgPSBTY2VuZTtcblx0XHR0aGlzLlZpZXcgICAgICAgICAgICAgID0gVmlldztcblx0XHR0aGlzLlZpZXczRCAgICAgICAgICAgID0gVmlldzNEO1xuXHRcdHRoaXMuT2JqZWN0M0QgICAgICAgICAgPSBPYmplY3QzRDtcblx0XHR0aGlzLlNoYWRlckxpYnMgICAgICAgID0gU2hhZGVyTGlicztcblx0XHR0aGlzLldlYmdsTnVtYmVyICAgICAgID0gV2ViZ2xOdW1iZXI7XG5cdFx0XG5cdFx0dGhpcy5FZmZlY3RDb21wb3NlciAgICA9IEVmZmVjdENvbXBvc2VyO1xuXHRcdHRoaXMuUGFzcyAgICAgICAgXHQgICA9IFBhc3M7XG5cdFx0dGhpcy5QYXNzTWFjcm8gICAgICAgICA9IFBhc3NNYWNybztcblx0XHR0aGlzLlBhc3NCbHVyICAgICAgICAgID0gUGFzc0JsdXI7XG5cdFx0dGhpcy5QYXNzVkJsdXIgICAgICAgICA9IFBhc3NWQmx1cjtcblx0XHR0aGlzLlBhc3NIQmx1ciAgICAgICAgID0gUGFzc0hCbHVyO1xuXHRcdHRoaXMuUGFzc0Z4YWEgICAgICAgICAgPSBQYXNzRnhhYTtcblxuXHRcdHRoaXMuTXVsdGlzYW1wbGVGcmFtZUJ1ZmZlciAgID0gTXVsdGlzYW1wbGVGcmFtZUJ1ZmZlcjtcblx0XHR0aGlzLlRyYW5zZm9ybUZlZWRiYWNrT2JqZWN0ICA9IFRyYW5zZm9ybUZlZWRiYWNrT2JqZWN0O1xuXG5cblx0XHQvL1x0Tk9UIFNVUEVSIFNVUkUgSSdWRSBET05FIFRISVMgSVMgQSBHT09EIFdBWVxuXG5cdFx0Zm9yKGNvbnN0IHMgaW4gR0xNKSB7XG5cdFx0XHRpZihHTE1bc10pIHtcblx0XHRcdFx0d2luZG93W3NdID0gR0xNW3NdO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGxvZygpIHtcblx0XHRpZihuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpID4gLTEpIHtcblx0XHRcdGNvbnNvbGUubG9nKGAlY2xpYiBhbGZyaWQgOiBWRVJTSU9OICR7VkVSU0lPTn1gLCAnYmFja2dyb3VuZDogIzE5MzQ0MTsgY29sb3I6ICNGQ0ZGRjUnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS5sb2coJ2xpYiBhbGZyaWQgOiBWRVJTSU9OICcsIFZFUlNJT04pO1xuXHRcdH1cblx0XHRjb25zb2xlLmxvZygnJWNDbGFzc2VzIDogJywgJ2NvbG9yOiAjMTkzNDQxJyk7XG5cblx0XHRmb3IoY29uc3QgcyBpbiB0aGlzKSB7XG5cdFx0XHRpZih0aGlzW3NdKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGAlYyAtICR7c31gLCAnY29sb3I6ICMzRTYwNkYnKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuY29uc3QgYWwgPSBuZXcgQWxmcmlkKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGFsO1xuZXhwb3J0IHtcblx0R0wsXG5cdEdMU2hhZGVyLFxuXHRHTFRleHR1cmUsXG5cdEdMVGV4dHVyZU9sZCxcblx0R0xDdWJlVGV4dHVyZSxcblx0TWVzaCxcblx0R2VvbSxcblx0QmF0Y2gsXG5cdEZyYW1lQnVmZmVyLFxuXHRDdWJlRnJhbWVCdWZmZXIsXG5cdE11bHRpc2FtcGxlRnJhbWVCdWZmZXIsXG5cdFRyYW5zZm9ybUZlZWRiYWNrT2JqZWN0LFxuXHRTY2hlZHVsZXIsXG5cdEV2ZW50RGlzcGF0Y2hlcixcblx0RWFzZU51bWJlcixcblx0VHdlZW5OdW1iZXIsXG5cdE9yYml0YWxDb250cm9sLFxuXHRXZWJnbE51bWJlcixcblx0UXVhdFJvdGF0aW9uLFxuXHRUb3VjaERldGVjdG9yLFxuXHRDYW1lcmEsXG5cdENhbWVyYU9ydGhvLFxuXHRDYW1lcmFQZXJzcGVjdGl2ZSxcblx0Q2FtZXJhQ3ViZSxcblx0UmF5LFxuXHRPYmplY3QzRCxcblx0QmluYXJ5TG9hZGVyLFxuXHRPYmpMb2FkZXIsXG5cdEhEUkxvYWRlcixcblx0R0xURkxvYWRlcixcblx0Q29sbGFkYVBhcnNlcixcblx0RWZmZWN0Q29tcG9zZXIsXG5cdFBhc3MsXG5cdFBhc3NNYWNybyxcblx0UGFzc0JsdXIsXG5cdFBhc3NWQmx1cixcblx0UGFzc0hCbHVyLFxuXHRQYXNzRnhhYSxcblx0QmF0Y2hDb3B5LFxuXHRCYXRjaEF4aXMsXG5cdEJhdGNoQmFsbCxcblx0QmF0Y2hEb3RzUGxhbmUsXG5cdEJhdGNoTGluZSxcblx0QmF0Y2hTa3lib3gsXG5cdEJhdGNoU2t5LFxuXHRCYXRjaEZYQUEsXG5cdFNjZW5lLFxuXHRWaWV3LFxuXHRWaWV3M0QsXG5cdFNoYWRlckxpYnNcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQuanMiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG5pbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb25cIjtcblxuLyoqXG4gKiAzeDMgTWF0cml4XG4gKiBAbW9kdWxlIG1hdDNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0M1xuICpcbiAqIEByZXR1cm5zIHttYXQzfSBhIG5ldyAzeDMgbWF0cml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMTtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDb3BpZXMgdGhlIHVwcGVyLWxlZnQgM3gzIHZhbHVlcyBpbnRvIHRoZSBnaXZlbiBtYXQzLlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgM3gzIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhICAgdGhlIHNvdXJjZSA0eDQgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTWF0NChvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVs0XTtcbiAgb3V0WzRdID0gYVs1XTtcbiAgb3V0WzVdID0gYVs2XTtcbiAgb3V0WzZdID0gYVs4XTtcbiAgb3V0WzddID0gYVs5XTtcbiAgb3V0WzhdID0gYVsxMF07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQzfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDN9IGEgbmV3IDN4MyBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQzIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBtYXQzIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggOClcbiAqIEByZXR1cm5zIHttYXQzfSBBIG5ldyBtYXQzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKG0wMCwgbTAxLCBtMDIsIG0xMCwgbTExLCBtMTIsIG0yMCwgbTIxLCBtMjIpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMTA7XG4gIG91dFs0XSA9IG0xMTtcbiAgb3V0WzVdID0gbTEyO1xuICBvdXRbNl0gPSBtMjA7XG4gIG91dFs3XSA9IG0yMTtcbiAgb3V0WzhdID0gbTIyO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDMgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDQpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDIgcG9zaXRpb24gKGluZGV4IDUpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDYpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDcpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDgpXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCBtMDAsIG0wMSwgbTAyLCBtMTAsIG0xMSwgbTEyLCBtMjAsIG0yMSwgbTIyKSB7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMDI7XG4gIG91dFszXSA9IG0xMDtcbiAgb3V0WzRdID0gbTExO1xuICBvdXRbNV0gPSBtMTI7XG4gIG91dFs2XSA9IG0yMDtcbiAgb3V0WzddID0gbTIxO1xuICBvdXRbOF0gPSBtMjI7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2V0IGEgbWF0MyB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAxO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zcG9zZShvdXQsIGEpIHtcbiAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICBpZiAob3V0ID09PSBhKSB7XG4gICAgbGV0IGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGExMiA9IGFbNV07XG4gICAgb3V0WzFdID0gYVszXTtcbiAgICBvdXRbMl0gPSBhWzZdO1xuICAgIG91dFszXSA9IGEwMTtcbiAgICBvdXRbNV0gPSBhWzddO1xuICAgIG91dFs2XSA9IGEwMjtcbiAgICBvdXRbN10gPSBhMTI7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzNdO1xuICAgIG91dFsyXSA9IGFbNl07XG4gICAgb3V0WzNdID0gYVsxXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbN107XG4gICAgb3V0WzZdID0gYVsyXTtcbiAgICBvdXRbN10gPSBhWzVdO1xuICAgIG91dFs4XSA9IGFbOF07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEludmVydHMgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICBsZXQgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXTtcbiAgbGV0IGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV07XG4gIGxldCBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdO1xuXG4gIGxldCBiMDEgPSBhMjIgKiBhMTEgLSBhMTIgKiBhMjE7XG4gIGxldCBiMTEgPSAtYTIyICogYTEwICsgYTEyICogYTIwO1xuICBsZXQgYjIxID0gYTIxICogYTEwIC0gYTExICogYTIwO1xuXG4gIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgbGV0IGRldCA9IGEwMCAqIGIwMSArIGEwMSAqIGIxMSArIGEwMiAqIGIyMTtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGRldCA9IDEuMCAvIGRldDtcblxuICBvdXRbMF0gPSBiMDEgKiBkZXQ7XG4gIG91dFsxXSA9ICgtYTIyICogYTAxICsgYTAyICogYTIxKSAqIGRldDtcbiAgb3V0WzJdID0gKGExMiAqIGEwMSAtIGEwMiAqIGExMSkgKiBkZXQ7XG4gIG91dFszXSA9IGIxMSAqIGRldDtcbiAgb3V0WzRdID0gKGEyMiAqIGEwMCAtIGEwMiAqIGEyMCkgKiBkZXQ7XG4gIG91dFs1XSA9ICgtYTEyICogYTAwICsgYTAyICogYTEwKSAqIGRldDtcbiAgb3V0WzZdID0gYjIxICogZGV0O1xuICBvdXRbN10gPSAoLWEyMSAqIGEwMCArIGEwMSAqIGEyMCkgKiBkZXQ7XG4gIG91dFs4XSA9IChhMTEgKiBhMDAgLSBhMDEgKiBhMTApICogZGV0O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gIGxldCBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdO1xuICBsZXQgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XTtcbiAgbGV0IGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF07XG5cbiAgb3V0WzBdID0gKGExMSAqIGEyMiAtIGExMiAqIGEyMSk7XG4gIG91dFsxXSA9IChhMDIgKiBhMjEgLSBhMDEgKiBhMjIpO1xuICBvdXRbMl0gPSAoYTAxICogYTEyIC0gYTAyICogYTExKTtcbiAgb3V0WzNdID0gKGExMiAqIGEyMCAtIGExMCAqIGEyMik7XG4gIG91dFs0XSA9IChhMDAgKiBhMjIgLSBhMDIgKiBhMjApO1xuICBvdXRbNV0gPSAoYTAyICogYTEwIC0gYTAwICogYTEyKTtcbiAgb3V0WzZdID0gKGExMCAqIGEyMSAtIGExMSAqIGEyMCk7XG4gIG91dFs3XSA9IChhMDEgKiBhMjAgLSBhMDAgKiBhMjEpO1xuICBvdXRbOF0gPSAoYTAwICogYTExIC0gYTAxICogYTEwKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgbGV0IGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl07XG4gIGxldCBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdO1xuICBsZXQgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XTtcblxuICByZXR1cm4gYTAwICogKGEyMiAqIGExMSAtIGExMiAqIGEyMSkgKyBhMDEgKiAoLWEyMiAqIGExMCArIGExMiAqIGEyMCkgKyBhMDIgKiAoYTIxICogYTEwIC0gYTExICogYTIwKTtcbn1cblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQzJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgbGV0IGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl07XG4gIGxldCBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdO1xuICBsZXQgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XTtcblxuICBsZXQgYjAwID0gYlswXSwgYjAxID0gYlsxXSwgYjAyID0gYlsyXTtcbiAgbGV0IGIxMCA9IGJbM10sIGIxMSA9IGJbNF0sIGIxMiA9IGJbNV07XG4gIGxldCBiMjAgPSBiWzZdLCBiMjEgPSBiWzddLCBiMjIgPSBiWzhdO1xuXG4gIG91dFswXSA9IGIwMCAqIGEwMCArIGIwMSAqIGExMCArIGIwMiAqIGEyMDtcbiAgb3V0WzFdID0gYjAwICogYTAxICsgYjAxICogYTExICsgYjAyICogYTIxO1xuICBvdXRbMl0gPSBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjI7XG5cbiAgb3V0WzNdID0gYjEwICogYTAwICsgYjExICogYTEwICsgYjEyICogYTIwO1xuICBvdXRbNF0gPSBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjE7XG4gIG91dFs1XSA9IGIxMCAqIGEwMiArIGIxMSAqIGExMiArIGIxMiAqIGEyMjtcblxuICBvdXRbNl0gPSBiMjAgKiBhMDAgKyBiMjEgKiBhMTAgKyBiMjIgKiBhMjA7XG4gIG91dFs3XSA9IGIyMCAqIGEwMSArIGIyMSAqIGExMSArIGIyMiAqIGEyMTtcbiAgb3V0WzhdID0gYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZSBhIG1hdDMgYnkgdGhlIGdpdmVuIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gIGxldCBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcbiAgICB4ID0gdlswXSwgeSA9IHZbMV07XG5cbiAgb3V0WzBdID0gYTAwO1xuICBvdXRbMV0gPSBhMDE7XG4gIG91dFsyXSA9IGEwMjtcblxuICBvdXRbM10gPSBhMTA7XG4gIG91dFs0XSA9IGExMTtcbiAgb3V0WzVdID0gYTEyO1xuXG4gIG91dFs2XSA9IHggKiBhMDAgKyB5ICogYTEwICsgYTIwO1xuICBvdXRbN10gPSB4ICogYTAxICsgeSAqIGExMSArIGEyMTtcbiAgb3V0WzhdID0geCAqIGEwMiArIHkgKiBhMTIgKyBhMjI7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDMgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICBsZXQgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXG5cbiAgICBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICBjID0gTWF0aC5jb3MocmFkKTtcblxuICBvdXRbMF0gPSBjICogYTAwICsgcyAqIGExMDtcbiAgb3V0WzFdID0gYyAqIGEwMSArIHMgKiBhMTE7XG4gIG91dFsyXSA9IGMgKiBhMDIgKyBzICogYTEyO1xuXG4gIG91dFszXSA9IGMgKiBhMTAgLSBzICogYTAwO1xuICBvdXRbNF0gPSBjICogYTExIC0gcyAqIGEwMTtcbiAgb3V0WzVdID0gYyAqIGExMiAtIHMgKiBhMDI7XG5cbiAgb3V0WzZdID0gYTIwO1xuICBvdXRbN10gPSBhMjE7XG4gIG91dFs4XSA9IGEyMjtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQzIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgbGV0IHggPSB2WzBdLCB5ID0gdlsxXTtcblxuICBvdXRbMF0gPSB4ICogYVswXTtcbiAgb3V0WzFdID0geCAqIGFbMV07XG4gIG91dFsyXSA9IHggKiBhWzJdO1xuXG4gIG91dFszXSA9IHkgKiBhWzNdO1xuICBvdXRbNF0gPSB5ICogYVs0XTtcbiAgb3V0WzVdID0geSAqIGFbNV07XG5cbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDMudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdikge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAxO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSB2WzBdO1xuICBvdXRbN10gPSB2WzFdO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0My5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQzLnJvdGF0ZShkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCByYWQpIHtcbiAgbGV0IHMgPSBNYXRoLnNpbihyYWQpLCBjID0gTWF0aC5jb3MocmFkKTtcblxuICBvdXRbMF0gPSBjO1xuICBvdXRbMV0gPSBzO1xuICBvdXRbMl0gPSAwO1xuXG4gIG91dFszXSA9IC1zO1xuICBvdXRbNF0gPSBjO1xuICBvdXRbNV0gPSAwO1xuXG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDMuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzJ9IHYgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21TY2FsaW5nKG91dCwgdikge1xuICBvdXRbMF0gPSB2WzBdO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuXG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHZbMV07XG4gIG91dFs1XSA9IDA7XG5cbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBmcm9tIGEgbWF0MmQgaW50byBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIGNvcHlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTWF0MmQob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IDA7XG5cbiAgb3V0WzNdID0gYVsyXTtcbiAgb3V0WzRdID0gYVszXTtcbiAgb3V0WzVdID0gMDtcblxuICBvdXRbNl0gPSBhWzRdO1xuICBvdXRbN10gPSBhWzVdO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiogQ2FsY3VsYXRlcyBhIDN4MyBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gcXVhdGVybmlvblxuKlxuKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4qIEBwYXJhbSB7cXVhdH0gcSBRdWF0ZXJuaW9uIHRvIGNyZWF0ZSBtYXRyaXggZnJvbVxuKlxuKiBAcmV0dXJucyB7bWF0M30gb3V0XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21RdWF0KG91dCwgcSkge1xuICBsZXQgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM107XG4gIGxldCB4MiA9IHggKyB4O1xuICBsZXQgeTIgPSB5ICsgeTtcbiAgbGV0IHoyID0geiArIHo7XG5cbiAgbGV0IHh4ID0geCAqIHgyO1xuICBsZXQgeXggPSB5ICogeDI7XG4gIGxldCB5eSA9IHkgKiB5MjtcbiAgbGV0IHp4ID0geiAqIHgyO1xuICBsZXQgenkgPSB6ICogeTI7XG4gIGxldCB6eiA9IHogKiB6MjtcbiAgbGV0IHd4ID0gdyAqIHgyO1xuICBsZXQgd3kgPSB3ICogeTI7XG4gIGxldCB3eiA9IHcgKiB6MjtcblxuICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgb3V0WzNdID0geXggLSB3ejtcbiAgb3V0WzZdID0genggKyB3eTtcblxuICBvdXRbMV0gPSB5eCArIHd6O1xuICBvdXRbNF0gPSAxIC0geHggLSB6ejtcbiAgb3V0WzddID0genkgLSB3eDtcblxuICBvdXRbMl0gPSB6eCAtIHd5O1xuICBvdXRbNV0gPSB6eSArIHd4O1xuICBvdXRbOF0gPSAxIC0geHggLSB5eTtcblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiogQ2FsY3VsYXRlcyBhIDN4MyBub3JtYWwgbWF0cml4ICh0cmFuc3Bvc2UgaW52ZXJzZSkgZnJvbSB0aGUgNHg0IG1hdHJpeFxuKlxuKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4qIEBwYXJhbSB7bWF0NH0gYSBNYXQ0IHRvIGRlcml2ZSB0aGUgbm9ybWFsIG1hdHJpeCBmcm9tXG4qXG4qIEByZXR1cm5zIHttYXQzfSBvdXRcbiovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsRnJvbU1hdDQob3V0LCBhKSB7XG4gIGxldCBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdO1xuICBsZXQgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XTtcbiAgbGV0IGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXTtcbiAgbGV0IGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdO1xuXG4gIGxldCBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIGxldCBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7XG4gIGxldCBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XG4gIGxldCBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIGxldCBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTE7XG4gIGxldCBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XG4gIGxldCBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzA7XG4gIGxldCBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzA7XG4gIGxldCBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7XG4gIGxldCBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzE7XG4gIGxldCBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7XG4gIGxldCBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICBsZXQgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICBvdXRbMV0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgb3V0WzJdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG5cbiAgb3V0WzNdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFs0XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICBvdXRbNV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcblxuICBvdXRbNl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgb3V0WzddID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XG4gIG91dFs4XSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgMkQgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFdpZHRoIG9mIHlvdXIgZ2wgY29udGV4dFxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgZ2wgY29udGV4dFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvamVjdGlvbihvdXQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBvdXRbMF0gPSAyIC8gd2lkdGg7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gLTIgLyBoZWlnaHQ7XG4gICAgb3V0WzVdID0gMDtcbiAgICBvdXRbNl0gPSAtMTtcbiAgICBvdXRbN10gPSAxO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gYSBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuICdtYXQzKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgK1xuICAgICAgICAgIGFbM10gKyAnLCAnICsgYVs0XSArICcsICcgKyBhWzVdICsgJywgJyArXG4gICAgICAgICAgYVs2XSArICcsICcgKyBhWzddICsgJywgJyArIGFbOF0gKyAnKSc7XG59XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9iKGEpIHtcbiAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyBNYXRoLnBvdyhhWzZdLCAyKSArIE1hdGgucG93KGFbN10sIDIpICsgTWF0aC5wb3coYVs4XSwgMikpKVxufVxuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDMnc1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl07XG4gIG91dFs3XSA9IGFbN10gKyBiWzddO1xuICBvdXRbOF0gPSBhWzhdICsgYls4XTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgb3V0WzRdID0gYVs0XSAtIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gLSBiWzVdO1xuICBvdXRbNl0gPSBhWzZdIC0gYls2XTtcbiAgb3V0WzddID0gYVs3XSAtIGJbN107XG4gIG91dFs4XSA9IGFbOF0gLSBiWzhdO1xuICByZXR1cm4gb3V0O1xufVxuXG5cblxuLyoqXG4gKiBNdWx0aXBseSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhci5cbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgb3V0WzRdID0gYVs0XSAqIGI7XG4gIG91dFs1XSA9IGFbNV0gKiBiO1xuICBvdXRbNl0gPSBhWzZdICogYjtcbiAgb3V0WzddID0gYVs3XSAqIGI7XG4gIG91dFs4XSA9IGFbOF0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDMncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIncyBlbGVtZW50cyBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhckFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICBvdXRbMl0gPSBhWzJdICsgKGJbMl0gKiBzY2FsZSk7XG4gIG91dFszXSA9IGFbM10gKyAoYlszXSAqIHNjYWxlKTtcbiAgb3V0WzRdID0gYVs0XSArIChiWzRdICogc2NhbGUpO1xuICBvdXRbNV0gPSBhWzVdICsgKGJbNV0gKiBzY2FsZSk7XG4gIG91dFs2XSA9IGFbNl0gKyAoYls2XSAqIHNjYWxlKTtcbiAgb3V0WzddID0gYVs3XSArIChiWzddICogc2NhbGUpO1xuICBvdXRbOF0gPSBhWzhdICsgKGJbOF0gKiBzY2FsZSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7bWF0M30gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQzfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiZcbiAgICAgICAgIGFbM10gPT09IGJbM10gJiYgYVs0XSA9PT0gYls0XSAmJiBhWzVdID09PSBiWzVdICYmXG4gICAgICAgICBhWzZdID09PSBiWzZdICYmIGFbN10gPT09IGJbN10gJiYgYVs4XSA9PT0gYls4XTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHttYXQzfSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge21hdDN9IGIgVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICBsZXQgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSwgYTYgPSBhWzZdLCBhNyA9IGFbN10sIGE4ID0gYVs4XTtcbiAgbGV0IGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXSwgYjQgPSBiWzRdLCBiNSA9IGJbNV0sIGI2ID0gYls2XSwgYjcgPSBiWzddLCBiOCA9IGJbOF07XG4gIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTYgLSBiNikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE2KSwgTWF0aC5hYnMoYjYpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGE3IC0gYjcpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNyksIE1hdGguYWJzKGI3KSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhOCAtIGI4KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTgpLCBNYXRoLmFicyhiOCkpKTtcbn1cblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDMubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IG11bCA9IG11bHRpcGx5O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0My5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc3ViID0gc3VidHJhY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbmltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vblwiO1xuXG4vKipcbiAqIDMgRGltZW5zaW9uYWwgVmVjdG9yXG4gKiBAbW9kdWxlIHZlYzNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzNcbiAqXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgb3V0WzBdID0gMDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgbGV0IHggPSBhWzBdO1xuICBsZXQgeSA9IGFbMV07XG4gIGxldCB6ID0gYVsyXTtcbiAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHksIHopIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMzIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCB4LCB5LCB6KSB7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjZWlsXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5jZWlsKGFbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmZsb29yKGFbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXgob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byByb3VuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGgucm91bmQoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMyBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgbGV0IHggPSBiWzBdIC0gYVswXTtcbiAgbGV0IHkgPSBiWzFdIC0gYVsxXTtcbiAgbGV0IHogPSBiWzJdIC0gYVsyXTtcbiAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gIGxldCB4ID0gYlswXSAtIGFbMF07XG4gIGxldCB5ID0gYlsxXSAtIGFbMV07XG4gIGxldCB6ID0gYlsyXSAtIGFbMl07XG4gIHJldHVybiB4KnggKyB5KnkgKyB6Kno7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICBsZXQgeCA9IGFbMF07XG4gIGxldCB5ID0gYVsxXTtcbiAgbGV0IHogPSBhWzJdO1xuICByZXR1cm4geCp4ICsgeSp5ICsgeip6O1xufVxuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuZWdhdGUob3V0LCBhKSB7XG4gIG91dFswXSA9IC1hWzBdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgb3V0WzJdID0gLWFbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIG91dFsyXSA9IDEuMCAvIGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICBsZXQgeCA9IGFbMF07XG4gIGxldCB5ID0gYVsxXTtcbiAgbGV0IHogPSBhWzJdO1xuICBsZXQgbGVuID0geCp4ICsgeSp5ICsgeip6O1xuICBpZiAobGVuID4gMCkge1xuICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgICBvdXRbMl0gPSBhWzJdICogbGVuO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5leHBvcnQgZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXTtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3Jvc3Mob3V0LCBhLCBiKSB7XG4gIGxldCBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdO1xuICBsZXQgYnggPSBiWzBdLCBieSA9IGJbMV0sIGJ6ID0gYlsyXTtcblxuICBvdXRbMF0gPSBheSAqIGJ6IC0gYXogKiBieTtcbiAgb3V0WzFdID0gYXogKiBieCAtIGF4ICogYno7XG4gIG91dFsyXSA9IGF4ICogYnkgLSBheSAqIGJ4O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgbGV0IGF4ID0gYVswXTtcbiAgbGV0IGF5ID0gYVsxXTtcbiAgbGV0IGF6ID0gYVsyXTtcbiAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhIGhlcm1pdGUgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYyB0aGUgdGhpcmQgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBkIHRoZSBmb3VydGggb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGVybWl0ZShvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgbGV0IGZhY3RvclRpbWVzMiA9IHQgKiB0O1xuICBsZXQgZmFjdG9yMSA9IGZhY3RvclRpbWVzMiAqICgyICogdCAtIDMpICsgMTtcbiAgbGV0IGZhY3RvcjIgPSBmYWN0b3JUaW1lczIgKiAodCAtIDIpICsgdDtcbiAgbGV0IGZhY3RvcjMgPSBmYWN0b3JUaW1lczIgKiAodCAtIDEpO1xuICBsZXQgZmFjdG9yNCA9IGZhY3RvclRpbWVzMiAqICgzIC0gMiAqIHQpO1xuXG4gIG91dFswXSA9IGFbMF0gKiBmYWN0b3IxICsgYlswXSAqIGZhY3RvcjIgKyBjWzBdICogZmFjdG9yMyArIGRbMF0gKiBmYWN0b3I0O1xuICBvdXRbMV0gPSBhWzFdICogZmFjdG9yMSArIGJbMV0gKiBmYWN0b3IyICsgY1sxXSAqIGZhY3RvcjMgKyBkWzFdICogZmFjdG9yNDtcbiAgb3V0WzJdID0gYVsyXSAqIGZhY3RvcjEgKyBiWzJdICogZmFjdG9yMiArIGNbMl0gKiBmYWN0b3IzICsgZFsyXSAqIGZhY3RvcjQ7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhIGJlemllciBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBjIHRoZSB0aGlyZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiZXppZXIob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gIGxldCBpbnZlcnNlRmFjdG9yID0gMSAtIHQ7XG4gIGxldCBpbnZlcnNlRmFjdG9yVGltZXNUd28gPSBpbnZlcnNlRmFjdG9yICogaW52ZXJzZUZhY3RvcjtcbiAgbGV0IGZhY3RvclRpbWVzMiA9IHQgKiB0O1xuICBsZXQgZmFjdG9yMSA9IGludmVyc2VGYWN0b3JUaW1lc1R3byAqIGludmVyc2VGYWN0b3I7XG4gIGxldCBmYWN0b3IyID0gMyAqIHQgKiBpbnZlcnNlRmFjdG9yVGltZXNUd287XG4gIGxldCBmYWN0b3IzID0gMyAqIGZhY3RvclRpbWVzMiAqIGludmVyc2VGYWN0b3I7XG4gIGxldCBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogdDtcblxuICBvdXRbMF0gPSBhWzBdICogZmFjdG9yMSArIGJbMF0gKiBmYWN0b3IyICsgY1swXSAqIGZhY3RvcjMgKyBkWzBdICogZmFjdG9yNDtcbiAgb3V0WzFdID0gYVsxXSAqIGZhY3RvcjEgKyBiWzFdICogZmFjdG9yMiArIGNbMV0gKiBmYWN0b3IzICsgZFsxXSAqIGZhY3RvcjQ7XG4gIG91dFsyXSA9IGFbMl0gKiBmYWN0b3IxICsgYlsyXSAqIGZhY3RvcjIgKyBjWzJdICogZmFjdG9yMyArIGRbMl0gKiBmYWN0b3I0O1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuXG4gIGxldCByID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJO1xuICBsZXQgeiA9IChnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCkgLSAxLjA7XG4gIGxldCB6U2NhbGUgPSBNYXRoLnNxcnQoMS4wLXoqeikgKiBzY2FsZTtcblxuICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHpTY2FsZTtcbiAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiB6U2NhbGU7XG4gIG91dFsyXSA9IHogKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQ0LlxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICBsZXQgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXTtcbiAgbGV0IHcgPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV07XG4gIHcgPSB3IHx8IDEuMDtcbiAgb3V0WzBdID0gKG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdKSAvIHc7XG4gIG91dFsxXSA9IChtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSkgLyB3O1xuICBvdXRbMl0gPSAobVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdKSAvIHc7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0My5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDN9IG0gdGhlIDN4MyBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDMob3V0LCBhLCBtKSB7XG4gIGxldCB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdO1xuICBvdXRbMF0gPSB4ICogbVswXSArIHkgKiBtWzNdICsgeiAqIG1bNl07XG4gIG91dFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNF0gKyB6ICogbVs3XTtcbiAgb3V0WzJdID0geCAqIG1bMl0gKyB5ICogbVs1XSArIHogKiBtWzhdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge3F1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtUXVhdChvdXQsIGEsIHEpIHtcbiAgLy8gYmVuY2htYXJrczogaHR0cDovL2pzcGVyZi5jb20vcXVhdGVybmlvbi10cmFuc2Zvcm0tdmVjMy1pbXBsZW1lbnRhdGlvbnNcblxuICBsZXQgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXTtcbiAgbGV0IHF4ID0gcVswXSwgcXkgPSBxWzFdLCBxeiA9IHFbMl0sIHF3ID0gcVszXTtcblxuICAvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY1xuICBsZXQgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XG4gIGxldCBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcbiAgbGV0IGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xuICBsZXQgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG4gIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcbiAgb3V0WzBdID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcbiAgb3V0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgb3V0WzJdID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB4LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVgob3V0LCBhLCBiLCBjKXtcbiAgbGV0IHAgPSBbXSwgcj1bXTtcbiAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdO1xuXG4gIC8vcGVyZm9ybSByb3RhdGlvblxuICByWzBdID0gcFswXTtcbiAgclsxXSA9IHBbMV0qTWF0aC5jb3MoYykgLSBwWzJdKk1hdGguc2luKGMpO1xuICByWzJdID0gcFsxXSpNYXRoLnNpbihjKSArIHBbMl0qTWF0aC5jb3MoYyk7XG5cbiAgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICBvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgb3V0WzFdID0gclsxXSArIGJbMV07XG4gIG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeS1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgYiwgYyl7XG4gIGxldCBwID0gW10sIHI9W107XG4gIC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIHBbMl0gPSBhWzJdIC0gYlsyXTtcblxuICAvL3BlcmZvcm0gcm90YXRpb25cbiAgclswXSA9IHBbMl0qTWF0aC5zaW4oYykgKyBwWzBdKk1hdGguY29zKGMpO1xuICByWzFdID0gcFsxXTtcbiAgclsyXSA9IHBbMl0qTWF0aC5jb3MoYykgLSBwWzBdKk1hdGguc2luKGMpO1xuXG4gIC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHotYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIGIsIGMpe1xuICBsZXQgcCA9IFtdLCByPVtdO1xuICAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBwWzJdID0gYVsyXSAtIGJbMl07XG5cbiAgLy9wZXJmb3JtIHJvdGF0aW9uXG4gIHJbMF0gPSBwWzBdKk1hdGguY29zKGMpIC0gcFsxXSpNYXRoLnNpbihjKTtcbiAgclsxXSA9IHBbMF0qTWF0aC5zaW4oYykgKyBwWzFdKk1hdGguY29zKGMpO1xuICByWzJdID0gcFsyXTtcblxuICAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gclsyXSArIGJbMl07XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIDNEIHZlY3RvcnNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFuZ2xlKGEsIGIpIHtcbiAgbGV0IHRlbXBBID0gZnJvbVZhbHVlcyhhWzBdLCBhWzFdLCBhWzJdKTtcbiAgbGV0IHRlbXBCID0gZnJvbVZhbHVlcyhiWzBdLCBiWzFdLCBiWzJdKTtcblxuICBub3JtYWxpemUodGVtcEEsIHRlbXBBKTtcbiAgbm9ybWFsaXplKHRlbXBCLCB0ZW1wQik7XG5cbiAgbGV0IGNvc2luZSA9IGRvdCh0ZW1wQSwgdGVtcEIpO1xuXG4gIGlmKGNvc2luZSA+IDEuMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGVsc2UgaWYoY29zaW5lIDwgLTEuMCkge1xuICAgIHJldHVybiBNYXRoLlBJO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBNYXRoLmFjb3MoY29zaW5lKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiAndmVjMygnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnKSc7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICBsZXQgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXTtcbiAgbGV0IGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl07XG4gIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpKTtcbn1cblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHN1YiA9IHN1YnRyYWN0O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgbXVsID0gbXVsdGlwbHk7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZGl2ID0gZGl2aWRlO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZGlzdCA9IGRpc3RhbmNlO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNxckRpc3QgPSBzcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgbGVuID0gbGVuZ3RoO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMzcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMzLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjM3MgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBmb3JFYWNoID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgdmVjID0gY3JlYXRlKCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgIGxldCBpLCBsO1xuICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgIHN0cmlkZSA9IDM7XG4gICAgfVxuXG4gICAgaWYoIW9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG5cbiAgICBpZihjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbCA9IGEubGVuZ3RoO1xuICAgIH1cblxuICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHZlY1swXSA9IGFbaV07IHZlY1sxXSA9IGFbaSsxXTsgdmVjWzJdID0gYVtpKzJdO1xuICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICBhW2ldID0gdmVjWzBdOyBhW2krMV0gPSB2ZWNbMV07IGFbaSsyXSA9IHZlY1syXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfTtcbn0pKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC92ZWMzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbmltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vblwiO1xuXG4vKipcbiAqIDQgRGltZW5zaW9uYWwgVmVjdG9yXG4gKiBAbW9kdWxlIHZlYzRcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzRcbiAqXG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgb3V0WzBdID0gMDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzQgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSwgeiwgdykge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIG91dFszXSA9IHc7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCB4LCB5LCB6LCB3KSB7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIG91dFszXSA9IHc7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQWRkcyB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICogYlsyXTtcbiAgb3V0WzNdID0gYVszXSAqIGJbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLyBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC8gYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguY2VpbChhWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5jZWlsKGFbM10pO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmZsb29yKGFbMl0pO1xuICBvdXRbM10gPSBNYXRoLmZsb29yKGFbM10pO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5taW4oYVszXSwgYlszXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICBvdXRbM10gPSBNYXRoLm1heChhWzNdLCBiWzNdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIHJvdW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3VuZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5yb3VuZChhWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5yb3VuZChhWzNdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWM0IGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byB2ZWM0J3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgb3V0WzNdID0gYVszXSArIChiWzNdICogc2NhbGUpO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICBsZXQgeCA9IGJbMF0gLSBhWzBdO1xuICBsZXQgeSA9IGJbMV0gLSBhWzFdO1xuICBsZXQgeiA9IGJbMl0gLSBhWzJdO1xuICBsZXQgdyA9IGJbM10gLSBhWzNdO1xuICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeiArIHcqdyk7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgbGV0IHggPSBiWzBdIC0gYVswXTtcbiAgbGV0IHkgPSBiWzFdIC0gYVsxXTtcbiAgbGV0IHogPSBiWzJdIC0gYVsyXTtcbiAgbGV0IHcgPSBiWzNdIC0gYVszXTtcbiAgcmV0dXJuIHgqeCArIHkqeSArIHoqeiArIHcqdztcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgbGV0IHggPSBhWzBdO1xuICBsZXQgeSA9IGFbMV07XG4gIGxldCB6ID0gYVsyXTtcbiAgbGV0IHcgPSBhWzNdO1xuICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeiArIHcqdyk7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICBsZXQgeCA9IGFbMF07XG4gIGxldCB5ID0gYVsxXTtcbiAgbGV0IHogPSBhWzJdO1xuICBsZXQgdyA9IGFbM107XG4gIHJldHVybiB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG59XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgb3V0WzNdID0gLWFbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIG91dFsyXSA9IDEuMCAvIGFbMl07XG4gIG91dFszXSA9IDEuMCAvIGFbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICBsZXQgeCA9IGFbMF07XG4gIGxldCB5ID0gYVsxXTtcbiAgbGV0IHogPSBhWzJdO1xuICBsZXQgdyA9IGFbM107XG4gIGxldCBsZW4gPSB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgIG91dFswXSA9IHggKiBsZW47XG4gICAgb3V0WzFdID0geSAqIGxlbjtcbiAgICBvdXRbMl0gPSB6ICogbGVuO1xuICAgIG91dFszXSA9IHcgKiBsZW47XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdICsgYVszXSAqIGJbM107XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICBsZXQgYXggPSBhWzBdO1xuICBsZXQgYXkgPSBhWzFdO1xuICBsZXQgYXogPSBhWzJdO1xuICBsZXQgYXcgPSBhWzNdO1xuICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopO1xuICBvdXRbM10gPSBhdyArIHQgKiAoYlszXSAtIGF3KTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tKG91dCwgdmVjdG9yU2NhbGUpIHtcbiAgdmVjdG9yU2NhbGUgPSB2ZWN0b3JTY2FsZSB8fCAxLjA7XG5cbiAgLy9UT0RPOiBUaGlzIGlzIGEgcHJldHR5IGF3ZnVsIHdheSBvZiBkb2luZyB0aGlzLiBGaW5kIHNvbWV0aGluZyBiZXR0ZXIuXG4gIG91dFswXSA9IGdsTWF0cml4LlJBTkRPTSgpO1xuICBvdXRbMV0gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgb3V0WzJdID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gIG91dFszXSA9IGdsTWF0cml4LlJBTkRPTSgpO1xuICBub3JtYWxpemUob3V0LCBvdXQpO1xuICBzY2FsZShvdXQsIG91dCwgdmVjdG9yU2NhbGUpO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzQgd2l0aCBhIG1hdDQuXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgbGV0IHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sIHcgPSBhWzNdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSAqIHc7XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdICogdztcbiAgb3V0WzJdID0gbVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdICogdztcbiAgb3V0WzNdID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdICogdztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWM0IHdpdGggYSBxdWF0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtxdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVF1YXQob3V0LCBhLCBxKSB7XG4gIGxldCB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdO1xuICBsZXQgcXggPSBxWzBdLCBxeSA9IHFbMV0sIHF6ID0gcVsyXSwgcXcgPSBxWzNdO1xuXG4gIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXG4gIGxldCBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeTtcbiAgbGV0IGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6O1xuICBsZXQgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHg7XG4gIGxldCBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cbiAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuICBvdXRbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuICBvdXRbMV0gPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiAndmVjNCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcpJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjNH0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjNH0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXTtcbiAgbGV0IGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTtcbiAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpKTtcbn1cblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHN1YiA9IHN1YnRyYWN0O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgbXVsID0gbXVsdGlwbHk7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZGl2ID0gZGl2aWRlO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZGlzdCA9IGRpc3RhbmNlO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNxckRpc3QgPSBzcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0Lmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgbGVuID0gbGVuZ3RoO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWM0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWM0LiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjNHMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBmb3JFYWNoID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgdmVjID0gY3JlYXRlKCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgIGxldCBpLCBsO1xuICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgIHN0cmlkZSA9IDQ7XG4gICAgfVxuXG4gICAgaWYoIW9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG5cbiAgICBpZihjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbCA9IGEubGVuZ3RoO1xuICAgIH1cblxuICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHZlY1swXSA9IGFbaV07IHZlY1sxXSA9IGFbaSsxXTsgdmVjWzJdID0gYVtpKzJdOyB2ZWNbM10gPSBhW2krM107XG4gICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgIGFbaV0gPSB2ZWNbMF07IGFbaSsxXSA9IHZlY1sxXTsgYVtpKzJdID0gdmVjWzJdOyBhW2krM10gPSB2ZWNbM107XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH07XG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvdmVjNC5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBXZWJnbENvbnN0LmpzXG5cbi8vIHN0b2xlbiB0aGVyZSBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wvZ2wtY29uc3RhbnRzIHRoYW5rcyBAbWF0dGRlc2wgXl5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdEFDVElWRV9BVFRSSUJVVEVTOiAzNTcyMSxcblx0QUNUSVZFX0FUVFJJQlVURV9NQVhfTEVOR1RIOiAzNTcyMixcblx0QUNUSVZFX1RFWFRVUkU6IDM0MDE2LFxuXHRBQ1RJVkVfVU5JRk9STVM6IDM1NzE4LFxuXHRBQ1RJVkVfVU5JRk9STV9NQVhfTEVOR1RIOiAzNTcxOSxcblx0QUxJQVNFRF9MSU5FX1dJRFRIX1JBTkdFOiAzMzkwMixcblx0QUxJQVNFRF9QT0lOVF9TSVpFX1JBTkdFOiAzMzkwMSxcblx0QUxQSEE6IDY0MDYsXG5cdEFMUEhBX0JJVFM6IDM0MTMsXG5cdEFMV0FZUzogNTE5LFxuXHRBUlJBWV9CVUZGRVI6IDM0OTYyLFxuXHRBUlJBWV9CVUZGRVJfQklORElORzogMzQ5NjQsXG5cdEFUVEFDSEVEX1NIQURFUlM6IDM1NzE3LFxuXHRCQUNLOiAxMDI5LFxuXHRCTEVORDogMzA0Mixcblx0QkxFTkRfQ09MT1I6IDMyNzczLFxuXHRCTEVORF9EU1RfQUxQSEE6IDMyOTcwLFxuXHRCTEVORF9EU1RfUkdCOiAzMjk2OCxcblx0QkxFTkRfRVFVQVRJT046IDMyNzc3LFxuXHRCTEVORF9FUVVBVElPTl9BTFBIQTogMzQ4NzcsXG5cdEJMRU5EX0VRVUFUSU9OX1JHQjogMzI3NzcsXG5cdEJMRU5EX1NSQ19BTFBIQTogMzI5NzEsXG5cdEJMRU5EX1NSQ19SR0I6IDMyOTY5LFxuXHRCTFVFX0JJVFM6IDM0MTIsXG5cdEJPT0w6IDM1NjcwLFxuXHRCT09MX1ZFQzI6IDM1NjcxLFxuXHRCT09MX1ZFQzM6IDM1NjcyLFxuXHRCT09MX1ZFQzQ6IDM1NjczLFxuXHRCUk9XU0VSX0RFRkFVTFRfV0VCR0w6IDM3NDQ0LFxuXHRCVUZGRVJfU0laRTogMzQ2NjAsXG5cdEJVRkZFUl9VU0FHRTogMzQ2NjEsXG5cdEJZVEU6IDUxMjAsXG5cdENDVzogMjMwNSxcblx0Q0xBTVBfVE9fRURHRTogMzMwNzEsXG5cdENPTE9SX0FUVEFDSE1FTlQwOiAzNjA2NCxcblx0Q09MT1JfQlVGRkVSX0JJVDogMTYzODQsXG5cdENPTE9SX0NMRUFSX1ZBTFVFOiAzMTA2LFxuXHRDT0xPUl9XUklURU1BU0s6IDMxMDcsXG5cdENPTVBJTEVfU1RBVFVTOiAzNTcxMyxcblx0Q09NUFJFU1NFRF9URVhUVVJFX0ZPUk1BVFM6IDM0NDY3LFxuXHRDT05TVEFOVF9BTFBIQTogMzI3NzEsXG5cdENPTlNUQU5UX0NPTE9SOiAzMjc2OSxcblx0Q09OVEVYVF9MT1NUX1dFQkdMOiAzNzQ0Mixcblx0Q1VMTF9GQUNFOiAyODg0LFxuXHRDVUxMX0ZBQ0VfTU9ERTogMjg4NSxcblx0Q1VSUkVOVF9QUk9HUkFNOiAzNTcyNSxcblx0Q1VSUkVOVF9WRVJURVhfQVRUUklCOiAzNDM0Mixcblx0Q1c6IDIzMDQsXG5cdERFQ1I6IDc2ODMsXG5cdERFQ1JfV1JBUDogMzQwNTYsXG5cdERFTEVURV9TVEFUVVM6IDM1NzEyLFxuXHRERVBUSF9BVFRBQ0hNRU5UOiAzNjA5Nixcblx0REVQVEhfQklUUzogMzQxNCxcblx0REVQVEhfQlVGRkVSX0JJVDogMjU2LFxuXHRERVBUSF9DTEVBUl9WQUxVRTogMjkzMSxcblx0REVQVEhfQ09NUE9ORU5UOiA2NDAyLFxuXHRSRUQ6IDY0MDMsXG5cdERFUFRIX0NPTVBPTkVOVDE2OiAzMzE4OSxcblx0REVQVEhfRlVOQzogMjkzMixcblx0REVQVEhfUkFOR0U6IDI5MjgsXG5cdERFUFRIX1NURU5DSUw6IDM0MDQxLFxuXHRERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQ6IDMzMzA2LFxuXHRERVBUSF9URVNUOiAyOTI5LFxuXHRERVBUSF9XUklURU1BU0s6IDI5MzAsXG5cdERJVEhFUjogMzAyNCxcblx0RE9OVF9DQVJFOiA0MzUyLFxuXHREU1RfQUxQSEE6IDc3Mixcblx0RFNUX0NPTE9SOiA3NzQsXG5cdERZTkFNSUNfRFJBVzogMzUwNDgsXG5cdEVMRU1FTlRfQVJSQVlfQlVGRkVSOiAzNDk2Myxcblx0RUxFTUVOVF9BUlJBWV9CVUZGRVJfQklORElORzogMzQ5NjUsXG5cdEVRVUFMOiA1MTQsXG5cdEZBU1RFU1Q6IDQzNTMsXG5cdEZMT0FUOiA1MTI2LFxuXHRGTE9BVF9NQVQyOiAzNTY3NCxcblx0RkxPQVRfTUFUMzogMzU2NzUsXG5cdEZMT0FUX01BVDQ6IDM1Njc2LFxuXHRGTE9BVF9WRUMyOiAzNTY2NCxcblx0RkxPQVRfVkVDMzogMzU2NjUsXG5cdEZMT0FUX1ZFQzQ6IDM1NjY2LFxuXHRGUkFHTUVOVF9TSEFERVI6IDM1NjMyLFxuXHRGUkFNRUJVRkZFUjogMzYxNjAsXG5cdEZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfT0JKRUNUX05BTUU6IDM2MDQ5LFxuXHRGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX09CSkVDVF9UWVBFOiAzNjA0OCxcblx0RlJBTUVCVUZGRVJfQVRUQUNITUVOVF9URVhUVVJFX0NVQkVfTUFQX0ZBQ0U6IDM2MDUxLFxuXHRGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX1RFWFRVUkVfTEVWRUw6IDM2MDUwLFxuXHRGUkFNRUJVRkZFUl9CSU5ESU5HOiAzNjAwNixcblx0RlJBTUVCVUZGRVJfQ09NUExFVEU6IDM2MDUzLFxuXHRGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQ6IDM2MDU0LFxuXHRGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlM6IDM2MDU3LFxuXHRGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVDogMzYwNTUsXG5cdEZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEOiAzNjA2MSxcblx0RlJPTlQ6IDEwMjgsXG5cdEZST05UX0FORF9CQUNLOiAxMDMyLFxuXHRGUk9OVF9GQUNFOiAyODg2LFxuXHRGVU5DX0FERDogMzI3NzQsXG5cdEZVTkNfUkVWRVJTRV9TVUJUUkFDVDogMzI3NzksXG5cdEZVTkNfU1VCVFJBQ1Q6IDMyNzc4LFxuXHRHRU5FUkFURV9NSVBNQVBfSElOVDogMzMxNzAsXG5cdEdFUVVBTDogNTE4LFxuXHRHUkVBVEVSOiA1MTYsXG5cdEdSRUVOX0JJVFM6IDM0MTEsXG5cdEhJR0hfRkxPQVQ6IDM2MzM4LFxuXHRISUdIX0lOVDogMzYzNDEsXG5cdElOQ1I6IDc2ODIsXG5cdElOQ1JfV1JBUDogMzQwNTUsXG5cdElORk9fTE9HX0xFTkdUSDogMzU3MTYsXG5cdElOVDogNTEyNCxcblx0SU5UX1ZFQzI6IDM1NjY3LFxuXHRJTlRfVkVDMzogMzU2NjgsXG5cdElOVF9WRUM0OiAzNTY2OSxcblx0SU5WQUxJRF9FTlVNOiAxMjgwLFxuXHRJTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTjogMTI4Nixcblx0SU5WQUxJRF9PUEVSQVRJT046IDEyODIsXG5cdElOVkFMSURfVkFMVUU6IDEyODEsXG5cdElOVkVSVDogNTM4Nixcblx0S0VFUDogNzY4MCxcblx0TEVRVUFMOiA1MTUsXG5cdExFU1M6IDUxMyxcblx0TElORUFSOiA5NzI5LFxuXHRMSU5FQVJfTUlQTUFQX0xJTkVBUjogOTk4Nyxcblx0TElORUFSX01JUE1BUF9ORUFSRVNUOiA5OTg1LFxuXHRMSU5FUzogMSxcblx0TElORV9MT09QOiAyLFxuXHRMSU5FX1NUUklQOiAzLFxuXHRMSU5FX1dJRFRIOiAyODQ5LFxuXHRMSU5LX1NUQVRVUzogMzU3MTQsXG5cdExPV19GTE9BVDogMzYzMzYsXG5cdExPV19JTlQ6IDM2MzM5LFxuXHRMVU1JTkFOQ0U6IDY0MDksXG5cdExVTUlOQU5DRV9BTFBIQTogNjQxMCxcblx0TUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFM6IDM1NjYxLFxuXHRNQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFOiAzNDA3Nixcblx0TUFYX0ZSQUdNRU5UX1VOSUZPUk1fVkVDVE9SUzogMzYzNDksXG5cdE1BWF9SRU5ERVJCVUZGRVJfU0laRTogMzQwMjQsXG5cdE1BWF9URVhUVVJFX0lNQUdFX1VOSVRTOiAzNDkzMCxcblx0TUFYX1RFWFRVUkVfU0laRTogMzM3OSxcblx0TUFYX1ZBUllJTkdfVkVDVE9SUzogMzYzNDgsXG5cdE1BWF9WRVJURVhfQVRUUklCUzogMzQ5MjEsXG5cdE1BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUzogMzU2NjAsXG5cdE1BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTOiAzNjM0Nyxcblx0TUFYX1ZJRVdQT1JUX0RJTVM6IDMzODYsXG5cdE1FRElVTV9GTE9BVDogMzYzMzcsXG5cdE1FRElVTV9JTlQ6IDM2MzQwLFxuXHRNSVJST1JFRF9SRVBFQVQ6IDMzNjQ4LFxuXHRORUFSRVNUOiA5NzI4LFxuXHRORUFSRVNUX01JUE1BUF9MSU5FQVI6IDk5ODYsXG5cdE5FQVJFU1RfTUlQTUFQX05FQVJFU1Q6IDk5ODQsXG5cdE5FVkVSOiA1MTIsXG5cdE5JQ0VTVDogNDM1NCxcblx0Tk9ORTogMCxcblx0Tk9URVFVQUw6IDUxNyxcblx0Tk9fRVJST1I6IDAsXG5cdE5VTV9DT01QUkVTU0VEX1RFWFRVUkVfRk9STUFUUzogMzQ0NjYsXG5cdE9ORTogMSxcblx0T05FX01JTlVTX0NPTlNUQU5UX0FMUEhBOiAzMjc3Mixcblx0T05FX01JTlVTX0NPTlNUQU5UX0NPTE9SOiAzMjc3MCxcblx0T05FX01JTlVTX0RTVF9BTFBIQTogNzczLFxuXHRPTkVfTUlOVVNfRFNUX0NPTE9SOiA3NzUsXG5cdE9ORV9NSU5VU19TUkNfQUxQSEE6IDc3MSxcblx0T05FX01JTlVTX1NSQ19DT0xPUjogNzY5LFxuXHRPVVRfT0ZfTUVNT1JZOiAxMjg1LFxuXHRQQUNLX0FMSUdOTUVOVDogMzMzMyxcblx0UE9JTlRTOiAwLFxuXHRQT0xZR09OX09GRlNFVF9GQUNUT1I6IDMyODI0LFxuXHRQT0xZR09OX09GRlNFVF9GSUxMOiAzMjgyMyxcblx0UE9MWUdPTl9PRkZTRVRfVU5JVFM6IDEwNzUyLFxuXHRSRURfQklUUzogMzQxMCxcblx0UkVOREVSQlVGRkVSOiAzNjE2MSxcblx0UkVOREVSQlVGRkVSX0FMUEhBX1NJWkU6IDM2MTc5LFxuXHRSRU5ERVJCVUZGRVJfQklORElORzogMzYwMDcsXG5cdFJFTkRFUkJVRkZFUl9CTFVFX1NJWkU6IDM2MTc4LFxuXHRSRU5ERVJCVUZGRVJfREVQVEhfU0laRTogMzYxODAsXG5cdFJFTkRFUkJVRkZFUl9HUkVFTl9TSVpFOiAzNjE3Nyxcblx0UkVOREVSQlVGRkVSX0hFSUdIVDogMzYxNjMsXG5cdFJFTkRFUkJVRkZFUl9JTlRFUk5BTF9GT1JNQVQ6IDM2MTY0LFxuXHRSRU5ERVJCVUZGRVJfUkVEX1NJWkU6IDM2MTc2LFxuXHRSRU5ERVJCVUZGRVJfU1RFTkNJTF9TSVpFOiAzNjE4MSxcblx0UkVOREVSQlVGRkVSX1dJRFRIOiAzNjE2Mixcblx0UkVOREVSRVI6IDc5MzcsXG5cdFJFUEVBVDogMTA0OTcsXG5cdFJFUExBQ0U6IDc2ODEsXG5cdFJHQjogNjQwNyxcblx0UkdCNV9BMTogMzI4NTUsXG5cdFJHQjU2NTogMzYxOTQsXG5cdFJHQkE6IDY0MDgsXG5cdFJHQkE0OiAzMjg1NCxcblx0U0FNUExFUl8yRDogMzU2NzgsXG5cdFNBTVBMRVJfQ1VCRTogMzU2ODAsXG5cdFNBTVBMRVM6IDMyOTM3LFxuXHRTQU1QTEVfQUxQSEFfVE9fQ09WRVJBR0U6IDMyOTI2LFxuXHRTQU1QTEVfQlVGRkVSUzogMzI5MzYsXG5cdFNBTVBMRV9DT1ZFUkFHRTogMzI5MjgsXG5cdFNBTVBMRV9DT1ZFUkFHRV9JTlZFUlQ6IDMyOTM5LFxuXHRTQU1QTEVfQ09WRVJBR0VfVkFMVUU6IDMyOTM4LFxuXHRTQ0lTU09SX0JPWDogMzA4OCxcblx0U0NJU1NPUl9URVNUOiAzMDg5LFxuXHRTSEFERVJfQ09NUElMRVI6IDM2MzQ2LFxuXHRTSEFERVJfU09VUkNFX0xFTkdUSDogMzU3MjAsXG5cdFNIQURFUl9UWVBFOiAzNTY2Myxcblx0U0hBRElOR19MQU5HVUFHRV9WRVJTSU9OOiAzNTcyNCxcblx0U0hPUlQ6IDUxMjIsXG5cdFNSQ19BTFBIQTogNzcwLFxuXHRTUkNfQUxQSEFfU0FUVVJBVEU6IDc3Nixcblx0U1JDX0NPTE9SOiA3NjgsXG5cdFNUQVRJQ19EUkFXOiAzNTA0NCxcblx0U1RFTkNJTF9BVFRBQ0hNRU5UOiAzNjEyOCxcblx0U1RFTkNJTF9CQUNLX0ZBSUw6IDM0ODE3LFxuXHRTVEVOQ0lMX0JBQ0tfRlVOQzogMzQ4MTYsXG5cdFNURU5DSUxfQkFDS19QQVNTX0RFUFRIX0ZBSUw6IDM0ODE4LFxuXHRTVEVOQ0lMX0JBQ0tfUEFTU19ERVBUSF9QQVNTOiAzNDgxOSxcblx0U1RFTkNJTF9CQUNLX1JFRjogMzYwMDMsXG5cdFNURU5DSUxfQkFDS19WQUxVRV9NQVNLOiAzNjAwNCxcblx0U1RFTkNJTF9CQUNLX1dSSVRFTUFTSzogMzYwMDUsXG5cdFNURU5DSUxfQklUUzogMzQxNSxcblx0U1RFTkNJTF9CVUZGRVJfQklUOiAxMDI0LFxuXHRTVEVOQ0lMX0NMRUFSX1ZBTFVFOiAyOTYxLFxuXHRTVEVOQ0lMX0ZBSUw6IDI5NjQsXG5cdFNURU5DSUxfRlVOQzogMjk2Mixcblx0U1RFTkNJTF9JTkRFWDogNjQwMSxcblx0U1RFTkNJTF9JTkRFWDg6IDM2MTY4LFxuXHRTVEVOQ0lMX1BBU1NfREVQVEhfRkFJTDogMjk2NSxcblx0U1RFTkNJTF9QQVNTX0RFUFRIX1BBU1M6IDI5NjYsXG5cdFNURU5DSUxfUkVGOiAyOTY3LFxuXHRTVEVOQ0lMX1RFU1Q6IDI5NjAsXG5cdFNURU5DSUxfVkFMVUVfTUFTSzogMjk2Myxcblx0U1RFTkNJTF9XUklURU1BU0s6IDI5NjgsXG5cdFNUUkVBTV9EUkFXOiAzNTA0MCxcblx0U1VCUElYRUxfQklUUzogMzQwOCxcblx0VEVYVFVSRTogNTg5MCxcblx0VEVYVFVSRTA6IDMzOTg0LFxuXHRURVhUVVJFMTogMzM5ODUsXG5cdFRFWFRVUkUyOiAzMzk4Nixcblx0VEVYVFVSRTM6IDMzOTg3LFxuXHRURVhUVVJFNDogMzM5ODgsXG5cdFRFWFRVUkU1OiAzMzk4OSxcblx0VEVYVFVSRTY6IDMzOTkwLFxuXHRURVhUVVJFNzogMzM5OTEsXG5cdFRFWFRVUkU4OiAzMzk5Mixcblx0VEVYVFVSRTk6IDMzOTkzLFxuXHRURVhUVVJFMTA6IDMzOTk0LFxuXHRURVhUVVJFMTE6IDMzOTk1LFxuXHRURVhUVVJFMTI6IDMzOTk2LFxuXHRURVhUVVJFMTM6IDMzOTk3LFxuXHRURVhUVVJFMTQ6IDMzOTk4LFxuXHRURVhUVVJFMTU6IDMzOTk5LFxuXHRURVhUVVJFMTY6IDM0MDAwLFxuXHRURVhUVVJFMTc6IDM0MDAxLFxuXHRURVhUVVJFMTg6IDM0MDAyLFxuXHRURVhUVVJFMTk6IDM0MDAzLFxuXHRURVhUVVJFMjA6IDM0MDA0LFxuXHRURVhUVVJFMjE6IDM0MDA1LFxuXHRURVhUVVJFMjI6IDM0MDA2LFxuXHRURVhUVVJFMjM6IDM0MDA3LFxuXHRURVhUVVJFMjQ6IDM0MDA4LFxuXHRURVhUVVJFMjU6IDM0MDA5LFxuXHRURVhUVVJFMjY6IDM0MDEwLFxuXHRURVhUVVJFMjc6IDM0MDExLFxuXHRURVhUVVJFMjg6IDM0MDEyLFxuXHRURVhUVVJFMjk6IDM0MDEzLFxuXHRURVhUVVJFMzA6IDM0MDE0LFxuXHRURVhUVVJFMzE6IDM0MDE1LFxuXHRURVhUVVJFXzJEOiAzNTUzLFxuXHRURVhUVVJFX0JJTkRJTkdfMkQ6IDMyODczLFxuXHRURVhUVVJFX0JJTkRJTkdfQ1VCRV9NQVA6IDM0MDY4LFxuXHRURVhUVVJFX0NVQkVfTUFQOiAzNDA2Nyxcblx0VEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YOiAzNDA3MCxcblx0VEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZOiAzNDA3Mixcblx0VEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9aOiAzNDA3NCxcblx0VEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YOiAzNDA2OSxcblx0VEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9ZOiAzNDA3MSxcblx0VEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aOiAzNDA3Myxcblx0VEVYVFVSRV9NQUdfRklMVEVSOiAxMDI0MCxcblx0VEVYVFVSRV9NSU5fRklMVEVSOiAxMDI0MSxcblx0VEVYVFVSRV9XUkFQX1M6IDEwMjQyLFxuXHRURVhUVVJFX1dSQVBfVDogMTAyNDMsXG5cdFRSSUFOR0xFUzogNCxcblx0VFJJQU5HTEVfRkFOOiA2LFxuXHRUUklBTkdMRV9TVFJJUDogNSxcblx0VU5QQUNLX0FMSUdOTUVOVDogMzMxNyxcblx0VU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTDogMzc0NDMsXG5cdFVOUEFDS19GTElQX1lfV0VCR0w6IDM3NDQwLFxuXHRVTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0w6IDM3NDQxLFxuXHRVTlNJR05FRF9CWVRFOiA1MTIxLFxuXHRVTlNJR05FRF9JTlQ6IDUxMjUsXG5cdFVOU0lHTkVEX1NIT1JUOiA1MTIzLFxuXHRVTlNJR05FRF9TSE9SVF80XzRfNF80OiAzMjgxOSxcblx0VU5TSUdORURfU0hPUlRfNV81XzVfMTogMzI4MjAsXG5cdFVOU0lHTkVEX1NIT1JUXzVfNl81OiAzMzYzNSxcblx0VkFMSURBVEVfU1RBVFVTOiAzNTcxNSxcblx0VkVORE9SOiA3OTM2LFxuXHRWRVJTSU9OOiA3OTM4LFxuXHRWRVJURVhfQVRUUklCX0FSUkFZX0JVRkZFUl9CSU5ESU5HOiAzNDk3NSxcblx0VkVSVEVYX0FUVFJJQl9BUlJBWV9FTkFCTEVEOiAzNDMzOCxcblx0VkVSVEVYX0FUVFJJQl9BUlJBWV9OT1JNQUxJWkVEOiAzNDkyMixcblx0VkVSVEVYX0FUVFJJQl9BUlJBWV9QT0lOVEVSOiAzNDM3Myxcblx0VkVSVEVYX0FUVFJJQl9BUlJBWV9TSVpFOiAzNDMzOSxcblx0VkVSVEVYX0FUVFJJQl9BUlJBWV9TVFJJREU6IDM0MzQwLFxuXHRWRVJURVhfQVRUUklCX0FSUkFZX1RZUEU6IDM0MzQxLFxuXHRWRVJURVhfU0hBREVSOiAzNTYzMyxcblx0VklFV1BPUlQ6IDI5NzgsXG5cdFpFUk86IDAsXG5cdFI4OiAzMzMyMSxcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvV2ViZ2xDb25zdC5qcyIsIi8vIGdldEF0dHJpYkxvYy5qc1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoZ2wsIHNoYWRlclByb2dyYW0sIG5hbWUpIHtcblx0aWYoc2hhZGVyUHJvZ3JhbS5jYWNoZUF0dHJpYkxvYyA9PT0gdW5kZWZpbmVkKSB7XHRzaGFkZXJQcm9ncmFtLmNhY2hlQXR0cmliTG9jID0ge307XHR9XG5cdGlmKHNoYWRlclByb2dyYW0uY2FjaGVBdHRyaWJMb2NbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdHNoYWRlclByb2dyYW0uY2FjaGVBdHRyaWJMb2NbbmFtZV0gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihzaGFkZXJQcm9ncmFtLCBuYW1lKTtcblx0fVxuXG5cdHJldHVybiBzaGFkZXJQcm9ncmFtLmNhY2hlQXR0cmliTG9jW25hbWVdO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9nZXRBdHRyaWJMb2MuanMiLCIvLyBHTFRleHR1cmUuanNcblxuaW1wb3J0IEdMIGZyb20gJy4vR0xUb29sJztcbmltcG9ydCBXZWJnbE51bWJlciBmcm9tICcuL3V0aWxzL1dlYmdsTnVtYmVyJztcblxuZnVuY3Rpb24gaXNQb3dlck9mVHdvKHgpIHtcdFxuXHRyZXR1cm4gKHggIT09IDApICYmICghKHggJiAoeCAtIDEpKSk7XG59O1xuXG5mdW5jdGlvbiBpc1NvdXJjZVBvd2VyT2ZUd28ob2JqKSB7XHRcblx0Y29uc3QgdyA9IG9iai53aWR0aCB8fCBvYmoudmlkZW9XaWR0aDtcblx0Y29uc3QgaCA9IG9iai5oZWlnaHQgfHwgb2JqLnZpZGVvSGVpZ2h0O1xuXG5cdGlmKCF3IHx8ICFoKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHJldHVybiBpc1Bvd2VyT2ZUd28odykgJiYgaXNQb3dlck9mVHdvKGgpO1xufTtcblxubGV0IGdsO1xuXG5jbGFzcyBHTFRleHR1cmUge1xuXG5cdGNvbnN0cnVjdG9yKG1Tb3VyY2UsIGlzVGV4dHVyZSA9IGZhbHNlLCBtUGFyYW1ldGVycyA9IHt9KSB7XG5cdFx0Z2wgPSBHTC5nbDtcblxuXHRcdGlmKGlzVGV4dHVyZSkge1xuXHRcdFx0dGhpcy5fdGV4dHVyZSA9IG1Tb3VyY2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX21Tb3VyY2UgID0gbVNvdXJjZTtcblx0XHRcdHRoaXMuX3RleHR1cmUgID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXHRcdFx0dGhpcy5faXNWaWRlbyAgPSAobVNvdXJjZS50YWdOYW1lID09PSAnVklERU8nKTtcblx0XHRcdHRoaXMuX3ByZW11bHRpcGx5QWxwaGEgPSB0cnVlO1xuXHRcdFx0dGhpcy5fbWFnRmlsdGVyID0gbVBhcmFtZXRlcnMubWFnRmlsdGVyIHx8IGdsLkxJTkVBUjtcblx0XHRcdHRoaXMuX21pbkZpbHRlciA9IG1QYXJhbWV0ZXJzLm1pbkZpbHRlciB8fCBnbC5ORUFSRVNUX01JUE1BUF9MSU5FQVI7XG5cdFx0XHRcblx0XHRcdHRoaXMuX3dyYXBTICAgICA9IG1QYXJhbWV0ZXJzLndyYXBTIHx8IGdsLk1JUlJPUkVEX1JFUEVBVDtcblx0XHRcdHRoaXMuX3dyYXBUICAgICA9IG1QYXJhbWV0ZXJzLndyYXBUIHx8IGdsLk1JUlJPUkVEX1JFUEVBVDtcblx0XHRcdGNvbnN0IHdpZHRoICAgID0gbVNvdXJjZS53aWR0aCB8fCBtU291cmNlLnZpZGVvV2lkdGg7XG5cblx0XHRcdGlmKHdpZHRoKSB7XG5cdFx0XHRcdGlmKCFpc1NvdXJjZVBvd2VyT2ZUd28obVNvdXJjZSkpIHtcblx0XHRcdFx0XHR0aGlzLl93cmFwUyA9IHRoaXMuX3dyYXBUID0gZ2wuQ0xBTVBfVE9fRURHRTtcblx0XHRcdFx0XHRpZih0aGlzLl9taW5GaWx0ZXIgPT09IGdsLk5FQVJFU1RfTUlQTUFQX0xJTkVBUikge1xuXHRcdFx0XHRcdFx0dGhpcy5fbWluRmlsdGVyID0gZ2wuTElORUFSO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBcdFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fd3JhcFMgPSB0aGlzLl93cmFwVCA9IGdsLkNMQU1QX1RPX0VER0U7XG5cdFx0XHRcdGlmKHRoaXMuX21pbkZpbHRlciA9PT0gZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSKSB7XG5cdFx0XHRcdFx0dGhpcy5fbWluRmlsdGVyID0gZ2wuTElORUFSO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmUpO1xuXHRcdFx0Z2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XG5cblx0XHRcdGlmKG1Tb3VyY2UuZXhwb3N1cmUpIHtcblx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBtU291cmNlLnNoYXBlWzBdLCBtU291cmNlLnNoYXBlWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgbVNvdXJjZS5kYXRhKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbVNvdXJjZSk7XHRcblx0XHRcdFx0Ly8gZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0aGlzLl9tYWdGaWx0ZXIpO1xuXHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRoaXMuX21pbkZpbHRlcik7XG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLl93cmFwUyk7XG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLl93cmFwVCk7XG5cblx0XHRcdC8vIGNvbnNvbGUubG9nKCdUZXh0dXJlIE1pbiA6JywgV2ViZ2xOdW1iZXJbdGhpcy5fbWluRmlsdGVyXSk7XG5cdFx0XHQvLyBjb25zb2xlLmxvZygnVGV4dHVyZSBNYWcgOicsIFdlYmdsTnVtYmVyW3RoaXMuX21hZ0ZpbHRlcl0pO1xuXG5cdFx0XHRjb25zdCBleHQgPSBHTC5nZXRFeHRlbnNpb24oJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycpO1xuXHRcdFx0aWYoZXh0KSB7XG5cdFx0XHRcdGNvbnN0IG1heCA9IGdsLmdldFBhcmFtZXRlcihleHQuTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUKTtcblx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyZihnbC5URVhUVVJFXzJELCBleHQuVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIG1heCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmKHRoaXMuX2NhbkdlbmVyYXRlTWlwbWFwKCkpIHtcblx0XHRcdFx0Z2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG5cdFx0XHR9XG5cblx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuXHRcdH1cblx0fVxuXG5cdGdlbmVyYXRlTWlwbWFwKCkge1xuXHRcdGlmICghdGhpcy5fY2FuR2VuZXJhdGVNaXBtYXAoKSkgeyByZXR1cm47IH1cblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKTtcblx0XHRnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblx0fVxuXG5cblx0Ly9cdE1JUE1BUCBGSUxURVJcblxuXHRzZXQgbWluRmlsdGVyKG1WYWx1ZSkge1xuXHRcdGlmKG1WYWx1ZSAhPT0gZ2wuTElORUFSXG5cdFx0XHQmJiBtVmFsdWUgIT09IGdsLk5FQVJFU1QgXG5cdFx0XHQmJiBtVmFsdWUgIT09IGdsLk5FQVJFU1RfTUlQTUFQX0xJTkVBUlxuXHRcdFx0JiYgbVZhbHVlICE9PSBnbC5ORUFSRVNUX01JUE1BUF9MSU5FQVJcblx0XHRcdCYmIG1WYWx1ZSAhPT0gZ2wuTElORUFSX01JUE1BUF9MSU5FQVJcblx0XHRcdCYmIG1WYWx1ZSAhPT0gZ2wuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVFxuXHRcdCkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHRoaXMuX21pbkZpbHRlciA9IG1WYWx1ZTtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5fbWluRmlsdGVyKTtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblx0fVxuXG5cdGdldCBtaW5GaWx0ZXIoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21pbkZpbHRlcjtcblx0fVxuXG5cdHNldCBtYWdGaWx0ZXIobVZhbHVlKSB7XG5cdFx0aWYobVZhbHVlICE9PSBnbC5MSU5FQVIgJiYgbVZhbHVlICE9PSBnbC5ORUFSRVNUKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dGhpcy5fbWFnRmlsdGVyID0gbVZhbHVlO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmUpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0aGlzLl9tYWdGaWx0ZXIpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuXHR9XG5cblx0Z2V0IG1hZ0ZpbHRlcigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWFnRmlsdGVyO1xuXHR9XG5cblxuXHQvL1x0V1JBUFxuXG5cdHNldCB3cmFwUyhtVmFsdWUpIHtcblx0XHRpZihtVmFsdWUgIT09IGdsLkNMQU1QX1RPX0VER0UgJiYgbVZhbHVlICE9PSBnbC5SRVBFQVQgJiYgbVZhbHVlICE9PSBnbC5NSVJST1JFRF9SRVBFQVQpIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR0aGlzLl93cmFwUyA9IG1WYWx1ZTtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLl93cmFwUyk7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cdH1cblxuXHRnZXQgd3JhcFMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3dyYXBTO1xuXHR9XG5cblx0c2V0IHdyYXBUKG1WYWx1ZSkge1xuXHRcdGlmKG1WYWx1ZSAhPT0gZ2wuQ0xBTVBfVE9fRURHRSAmJiBtVmFsdWUgIT09IGdsLlJFUEVBVCAmJiBtVmFsdWUgIT09IGdsLk1JUlJPUkVEX1JFUEVBVCkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHRoaXMuX3dyYXBUID0gbVZhbHVlO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmUpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMuX3dyYXBUKTtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblx0fVxuXG5cdGdldCB3cmFwVCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fd3JhcFQ7XG5cdH1cblxuXG5cdC8vXHRQUkVNVUxUSVBMWSBBTFBIQVxuXG5cdHNldCBwcmVtdWx0aXBseUFscGhhKG1WYWx1ZSkge1xuXHRcdHRoaXMuX3ByZW11bHRpcGx5QWxwaGEgPSBtVmFsdWU7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZSk7XG5cdFx0Y29uc29sZS5sb2coJ3ByZW11bHRpcGx5QWxwaGE6JywgbVZhbHVlKTtcblx0XHRnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRoaXMuX3ByZW11bHRpcGx5QWxwaGEpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuXG5cdH1cblxuXHRnZXQgcHJlbXVsdGlwbHlBbHBoYSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcHJlbXVsdGlwbHlBbHBoYTtcblx0fVxuXG5cdC8vXHRVUERBVEUgVEVYVFVSRVxuXG5cdHVwZGF0ZVRleHR1cmUobVNvdXJjZSkge1xuXHRcdGlmKG1Tb3VyY2UpIHsgdGhpcy5fbVNvdXJjZSA9IG1Tb3VyY2U7IH1cblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKTtcblx0XHRnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0cnVlKTtcblx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuX21Tb3VyY2UpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0aGlzLl9tYWdGaWx0ZXIpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLl9taW5GaWx0ZXIpO1xuXHRcdGlmKHRoaXMuX2NhbkdlbmVyYXRlTWlwbWFwKCkpIHtcblx0XHRcdGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpO1xuXHRcdH1cblxuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuXHR9XG5cblxuXHRiaW5kKGluZGV4KSB7XG5cdFx0aWYoaW5kZXggPT09IHVuZGVmaW5lZCkgeyBpbmRleCA9IDA7IH1cblx0XHRpZighR0wuc2hhZGVyKSB7IHJldHVybjsgfVxuXG5cdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGluZGV4KTtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKTtcblx0XHR0aGlzLl9iaW5kSW5kZXggPSBpbmRleDtcblx0fVxuXG5cdF9jYW5HZW5lcmF0ZU1pcG1hcCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWluRmlsdGVyID09PSBnbC5MSU5FQVJfTUlQTUFQX05FQVJFU1QgXG5cdFx0XHRcdHx8IHRoaXMuX21pbkZpbHRlciA9PT0gZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSIFxuXHRcdFx0XHR8fCB0aGlzLl9taW5GaWx0ZXIgPT09IGdsLkxJTkVBUl9NSVBNQVBfTElORUFSIFxuXHRcdFx0XHR8fCB0aGlzLl9taW5GaWx0ZXIgPT09IGdsLk5FQVJFU1RfTUlQTUFQX05FQVJFU1Q7XG5cdH1cblxuXHQvL1x0R0VUVEVSXG5cblx0Z2V0IHRleHR1cmUoKSB7XHRyZXR1cm4gdGhpcy5fdGV4dHVyZTtcdH1cbn1cblxuXG5sZXQgX3doaXRlVGV4dHVyZSwgX2dyZXlUZXh0dXJlLCBfYmxhY2tUZXh0dXJlO1xuXG5HTFRleHR1cmUud2hpdGVUZXh0dXJlID0gZnVuY3Rpb24gd2hpdGVUZXh0dXJlKCkge1xuXHRpZihfd2hpdGVUZXh0dXJlID09PSB1bmRlZmluZWQpIHtcblx0XHRjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0XHRjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gNDtcblx0XHRjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRjdHguZmlsbFN0eWxlID0gJyNmZmYnO1xuXHRcdGN0eC5maWxsUmVjdCgwLCAwLCA0LCA0KTtcblx0XHRfd2hpdGVUZXh0dXJlID0gbmV3IEdMVGV4dHVyZShjYW52YXMpO1xuXHR9XG5cdFxuXHRyZXR1cm4gX3doaXRlVGV4dHVyZTtcbn07XG5cbkdMVGV4dHVyZS5ncmV5VGV4dHVyZSA9IGZ1bmN0aW9uIGdyZXlUZXh0dXJlKCkge1xuXHRpZihfZ3JleVRleHR1cmUgPT09IHVuZGVmaW5lZCkge1xuXHRcdGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXHRcdGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSA0O1xuXHRcdGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdGN0eC5maWxsU3R5bGUgPSAncmdiKDEyNywgMTI3LCAxMjcpJztcblx0XHRjdHguZmlsbFJlY3QoMCwgMCwgNCwgNCk7XG5cdFx0X2dyZXlUZXh0dXJlID0gbmV3IEdMVGV4dHVyZShjYW52YXMpO1xuXHR9XG5cdHJldHVybiBfZ3JleVRleHR1cmU7XG59O1xuXG5HTFRleHR1cmUuYmxhY2tUZXh0dXJlID0gZnVuY3Rpb24gYmxhY2tUZXh0dXJlKCkge1xuXHRpZihfYmxhY2tUZXh0dXJlID09PSB1bmRlZmluZWQpIHtcblx0XHRjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0XHRjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gNDtcblx0XHRjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRjdHguZmlsbFN0eWxlID0gJ3JnYigxMjcsIDEyNywgMTI3KSc7XG5cdFx0Y3R4LmZpbGxSZWN0KDAsIDAsIDQsIDQpO1xuXHRcdF9ibGFja1RleHR1cmUgPSBuZXcgR0xUZXh0dXJlKGNhbnZhcyk7XG5cdH1cblx0cmV0dXJuIF9ibGFja1RleHR1cmU7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBHTFRleHR1cmU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvR0xUZXh0dXJlLmpzIiwiLy8gR0xUZXh0dXJlMi5qc1xuXG5pbXBvcnQgZ2V0VGV4dHVyZVBhcmFtZXRlcnMgZnJvbSAnLi91dGlscy9nZXRUZXh0dXJlUGFyYW1ldGVycyc7XG5pbXBvcnQgV2ViZ2xOdW1iZXIgZnJvbSAnLi91dGlscy9XZWJnbE51bWJlcic7XG5pbXBvcnQgR0wgZnJvbSAnLi9HTFRvb2wnO1xuaW1wb3J0IFNjaGVkdWxlciBmcm9tICdzY2hlZHVsaW5nJztcblxubGV0IGdsO1xuXG5jbGFzcyBHTFRleHR1cmUge1xuXG5cdGNvbnN0cnVjdG9yKG1Tb3VyY2UsIG1QYXJhbSA9IHt9LCBtV2lkdGggPSAwLCBtSGVpZ2h0ID0gMCkge1xuXHRcdGdsID0gR0wuZ2w7XG5cblx0XHR0aGlzLl9zb3VyY2UgPSBtU291cmNlO1xuXHRcdHRoaXMuX2dldERpbWVuc2lvbihtU291cmNlLCBtV2lkdGgsIG1IZWlnaHQpO1xuXHRcdHRoaXMuX3NvdXJjZVR5cGUgPSBtUGFyYW0udHlwZSB8fCBnZXRTb3VyY2VUeXBlKG1Tb3VyY2UpO1xuXHRcdHRoaXMuX2NoZWNrU291cmNlKCk7XG5cdFx0dGhpcy5fdGV4ZWxUeXBlID0gdGhpcy5fZ2V0VGV4ZWxUeXBlKCk7XG5cdFx0dGhpcy5faXNUZXh0dXJlUmVhZHkgPSB0cnVlO1xuXG5cdFx0dGhpcy5fcGFyYW1zID0gZ2V0VGV4dHVyZVBhcmFtZXRlcnMobVBhcmFtLCBtU291cmNlLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcblx0XHR0aGlzLl9jaGVja01pcG1hcCgpO1xuXHRcdHRoaXMuX2NoZWNrV3JhcHBpbmcoKTtcblxuXHRcdC8vXHRzZXR1cCB0ZXh0dXJlXG5cdFx0dGhpcy5fdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblxuXHRcdGlmKHRoaXMuX3NvdXJjZVR5cGUgPT09ICd2aWRlbycpIHtcblx0XHRcdHRoaXMuX2lzVGV4dHVyZVJlYWR5ID0gZmFsc2U7XG5cdFx0XHRTY2hlZHVsZXIuYWRkRUYoKCk9PnRoaXMuX2xvb3AoKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3VwbG9hZFRleHR1cmUoKTtcdFxuXHRcdH1cblx0XHRcblx0fVxuXG5cdF9sb29wKCkge1xuXHRcdGlmKHRoaXMuX3NvdXJjZS5yZWFkeVN0YXRlID09IDQpIHtcblx0XHRcdHRoaXMuX2lzVGV4dHVyZVJlYWR5ID0gdHJ1ZTtcblx0XHRcdHRoaXMuX3VwbG9hZFRleHR1cmUoKTtcblx0XHR9XG5cdH1cblxuXG5cdF91cGxvYWRUZXh0dXJlKCkge1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmUpO1xuXHRcdGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xuXG5cdFx0aWYodGhpcy5faXNTb3VyY2VIdG1sRWxlbWVudCgpKSB7XG5cdFx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuX3BhcmFtcy5pbnRlcm5hbEZvcm1hdCwgdGhpcy5fcGFyYW1zLmZvcm1hdCwgdGhpcy5fdGV4ZWxUeXBlLCB0aGlzLl9zb3VyY2UpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuX3BhcmFtcy5pbnRlcm5hbEZvcm1hdCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCwgMCwgdGhpcy5fcGFyYW1zLmZvcm1hdCwgdGhpcy5fdGV4ZWxUeXBlLCB0aGlzLl9zb3VyY2UpO1x0XG5cdFx0fVxuXHRcdFxuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0aGlzLl9wYXJhbXMubWFnRmlsdGVyKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5fcGFyYW1zLm1pbkZpbHRlcik7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgdGhpcy5fcGFyYW1zLndyYXBTKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLl9wYXJhbXMud3JhcFQpO1xuXHRcdGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGhpcy5fcGFyYW1zLnByZW11bHRpcGx5QWxwaGEpO1xuXG5cdFx0aWYodGhpcy5fcGFyYW1zLmFuaXNvdHJvcHkgPiAwKSB7XG5cdFx0XHRjb25zdCBleHQgPSBHTC5nZXRFeHRlbnNpb24oJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycpO1xuXHRcdFx0aWYoZXh0KSB7XG5cdFx0XHRcdGNvbnN0IG1heCA9IGdsLmdldFBhcmFtZXRlcihleHQuTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUKTtcblx0XHRcdFx0Y29uc3QgbGV2ZWwgPSBNYXRoLm1pbihtYXgsIHRoaXMuX3BhcmFtcy5hbmlzb3Ryb3B5KTtcblx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyZihnbC5URVhUVVJFXzJELCBleHQuVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIGxldmVsKTtcblx0XHRcdH1cdFxuXHRcdH1cblx0XHRcblxuXHRcdGlmKHRoaXMuX2dlbmVyYXRlTWlwbWFwKSB7XHRnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcdH1cblxuXHRcdC8vXHR1bmJpbmQgdGV4dHVyZVxuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuXHR9XG5cblxuXHRiaW5kKGluZGV4KSB7XG5cdFx0aWYoaW5kZXggPT09IHVuZGVmaW5lZCkgeyBpbmRleCA9IDA7IH1cblx0XHRpZighR0wuc2hhZGVyKSB7IHJldHVybjsgfVxuXG5cdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGluZGV4KTtcblx0XHRpZih0aGlzLl9pc1RleHR1cmVSZWFkeSkge1xuXHRcdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZSk7XHRcblx0XHR9IGVsc2Uge1xuXHRcdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgR0xUZXh0dXJlLmJsYWNrVGV4dHVyZSgpLnRleHR1cmUpO1xuXHRcdH1cblx0XHRcblx0XHR0aGlzLl9iaW5kSW5kZXggPSBpbmRleDtcblx0fVxuXG5cblx0dXBkYXRlVGV4dHVyZShtU291cmNlKSB7XG5cdFx0dGhpcy5fc291cmNlID0gbVNvdXJjZTtcblx0XHR0aGlzLl9jaGVja1NvdXJjZSgpO1xuXHRcdHRoaXMuX3VwbG9hZFRleHR1cmUoKTtcblx0fVxuXG5cblx0Z2VuZXJhdGVNaXBtYXAoKSB7XG5cdFx0aWYgKCF0aGlzLl9nZW5lcmF0ZU1pcG1hcCkgeyByZXR1cm47IH1cblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKTtcblx0XHRnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblx0fVxuXG5cdHNob3dQYXJhbWV0ZXJzKCkge1xuXHRcdGNvbnNvbGUubG9nKCdTb3VyY2UgdHlwZSA6ICcsIFdlYmdsTnVtYmVyW3RoaXMuX3NvdXJjZVR5cGVdIHx8IHRoaXMuX3NvdXJjZVR5cGUpO1xuXHRcdGNvbnNvbGUubG9nKCdUZXhlbCB0eXBlOicsIFdlYmdsTnVtYmVyW3RoaXMudGV4ZWxUeXBlXSk7XG5cdFx0Y29uc29sZS5sb2coJ0RpbWVuc2lvbiA6JywgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XG5cdFx0Zm9yKGNvbnN0IHMgaW4gdGhpcy5fcGFyYW1zKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhzLCBXZWJnbE51bWJlclt0aGlzLl9wYXJhbXNbc11dIHx8IHRoaXMuX3BhcmFtc1tzXSk7XG5cdFx0fVxuXG5cdFx0Y29uc29sZS5sb2coJ01pcG1hcHBpbmcgOicsIHRoaXMuX2dlbmVyYXRlTWlwbWFwKTtcblx0fVxuXG5cdF9nZXREaW1lbnNpb24obVNvdXJjZSwgbVdpZHRoLCBtSGVpZ2h0KSB7XG5cdFx0aWYobVNvdXJjZSkge1xuXHRcdFx0Ly9cdGZvciBodG1sIGltYWdlIC8gdmlkZW8gZWxlbWVudFxuXHRcdFx0dGhpcy5fd2lkdGggPSBtU291cmNlLndpZHRoIHx8IG1Tb3VyY2UudmlkZW9XaWR0aDtcblx0XHRcdHRoaXMuX2hlaWdodCA9IG1Tb3VyY2UuaGVpZ2h0IHx8IG1Tb3VyY2UudmlkZW9XaWR0aDtcblxuXHRcdFx0Ly9cdGZvciBtYW51YWwgd2lkdGggLyBoZWlnaHQgc2V0dGluZ3Ncblx0XHRcdHRoaXMuX3dpZHRoID0gdGhpcy5fd2lkdGggfHwgbVdpZHRoO1xuXHRcdFx0dGhpcy5faGVpZ2h0ID0gdGhpcy5faGVpZ2h0IHx8IG1IZWlnaHQ7XG5cblx0XHRcdC8vXHRhdXRvIGRldGVjdCAoIGRhdGEgYXJyYXkpID8gbm90IHN1cmUgaXMgZ29vZCBpZGVhID8gXG5cdFx0XHQvL1x0dG9kbyA6IGNoZWNrIEhEUiBcblx0XHRcdGlmKCF0aGlzLl93aWR0aCB8fCAhdGhpcy5faGVpZ2h0KSB7XG5cdFx0XHRcdHRoaXMuX3dpZHRoID0gdGhpcy5faGVpZ2h0ID0gTWF0aC5zcXJ0KG1Tb3VyY2UubGVuZ3RoIC8gNCk7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdBdXRvIGRldGVjdCwgZGF0YSBkaW1lbnNpb24gOiAnLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcdFxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3dpZHRoID0gbVdpZHRoO1xuXHRcdFx0dGhpcy5faGVpZ2h0ID0gbUhlaWdodDtcblx0XHR9XG5cdH1cblxuXHRfY2hlY2tTb3VyY2UoKSB7XG5cdFx0aWYoIXRoaXMuX3NvdXJjZSkge1x0cmV0dXJuOyB9XG5cblx0XHRpZih0aGlzLl9zb3VyY2VUeXBlID09PSBHTC5VTlNJR05FRF9CWVRFKSB7XG5cdFx0XHRpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZygnQ29udmVydGluZyB0byBVaW50OEFycmF5Jyk7XG5cdFx0XHRcdHRoaXMuX3NvdXJjZSA9IG5ldyBVaW50OEFycmF5KHRoaXMuX3NvdXJjZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmKHRoaXMuX3NvdXJjZVR5cGUgPT09IEdMLkZMT0FUKSB7XG5cdFx0XHRpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdDb252ZXJ0aW5nIHRvIEZsb2F0MzJBcnJheScpO1xuXHRcdFx0XHR0aGlzLl9zb3VyY2UgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuX3NvdXJjZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH1cblxuXHRfZ2V0VGV4ZWxUeXBlKCkge1xuXHRcdGlmKHRoaXMuX2lzU291cmNlSHRtbEVsZW1lbnQoKSkge1xuXHRcdFx0cmV0dXJuIEdMLlVOU0lHTkVEX0JZVEU7XHRcblx0XHR9XG5cblx0XHQvL1x0YmFkIGNvZGUgaGVyZSwgaWYgdGhlIHR5cGUgaXMgbm90IG9uIHRoZSB3ZWJnbE51bWJlciBsaXN0LCBpdCBkb2Vzbid0IHdvcmtcblx0XHRyZXR1cm4gR0xbV2ViZ2xOdW1iZXJbdGhpcy5fc291cmNlVHlwZV1dIHx8IHRoaXMuX3NvdXJjZVR5cGU7XG5cdH1cblxuXHRfY2hlY2tNaXBtYXAoKSB7XG5cdFx0dGhpcy5fZ2VuZXJhdGVNaXBtYXAgPSB0aGlzLl9wYXJhbXMubWlwbWFwO1xuXG5cdFx0aWYoIShpc1Bvd2VyT2ZUd28odGhpcy5fd2lkdGgpICYmIGlzUG93ZXJPZlR3byh0aGlzLl9oZWlnaHQpKSkge1xuXHRcdFx0dGhpcy5fZ2VuZXJhdGVNaXBtYXAgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRjb25zdCBtaW5GaWx0ZXIgPSBXZWJnbE51bWJlclt0aGlzLl9wYXJhbXMubWluRmlsdGVyXTtcblx0XHRpZihtaW5GaWx0ZXIuaW5kZXhPZignTUlQTUFQJykgPT0gLTEpIHtcblx0XHRcdHRoaXMuX2dlbmVyYXRlTWlwbWFwID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0X2NoZWNrV3JhcHBpbmcoKSB7XG5cdFx0aWYoIXRoaXMuX2dlbmVyYXRlTWlwbWFwKSB7XG5cdFx0XHR0aGlzLl9wYXJhbXMud3JhcFMgPSBHTC5DTEFNUF9UT19FREdFO1xuXHRcdFx0dGhpcy5fcGFyYW1zLndyYXBUID0gR0wuQ0xBTVBfVE9fRURHRTtcblx0XHR9XG5cdH1cblxuXHRfaXNTb3VyY2VIdG1sRWxlbWVudCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc291cmNlVHlwZSA9PT0gJ2ltYWdlJyB8fCB0aGlzLl9zb3VyY2VUeXBlID09PSAndmlkZW8nIHx8IHRoaXMuX3NvdXJjZVR5cGUgPT09ICdjYW52YXMnO1xuXHR9XG5cblxuXHRnZXQgbWluRmlsdGVyKCkge1x0cmV0dXJuIHRoaXMuX3BhcmFtcy5taW5GaWx0ZXI7XHR9XG5cblx0c2V0IG1pbkZpbHRlcihtVmFsdWUpIHtcblx0XHR0aGlzLl9wYXJhbXMubWluRmlsdGVyID0gbVZhbHVlO1xuXHRcdHRoaXMuX2NoZWNrTWlwbWFwKCk7XG5cblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5fcGFyYW1zLm1pbkZpbHRlcik7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cblx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwKCk7XG5cdH1cblxuXHRnZXQgbWFnRmlsdGVyKCkge1x0cmV0dXJuIHRoaXMuX3BhcmFtcy5taW5GaWx0ZXI7XHR9XG5cblx0c2V0IG1hZ0ZpbHRlcihtVmFsdWUpIHtcblx0XHR0aGlzLl9wYXJhbXMubWFnRmlsdGVyID0gbVZhbHVlO1xuXG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZSk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIHRoaXMuX3BhcmFtcy5tYWdGaWx0ZXIpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuXHR9XG5cblxuXHRnZXQgd3JhcFMoKSB7XHRyZXR1cm4gdGhpcy5fcGFyYW1zLndyYXBTO1x0fVxuXG5cdHNldCB3cmFwUyhtVmFsdWUpIHtcblx0XHR0aGlzLl9wYXJhbXMud3JhcFMgPSBtVmFsdWU7XG5cdFx0dGhpcy5fY2hlY2tXcmFwcGluZygpO1xuXG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZSk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgdGhpcy5fcGFyYW1zLndyYXBTKTtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblx0fVxuXG5cblx0Z2V0IHdyYXBUKCkge1x0cmV0dXJuIHRoaXMuX3BhcmFtcy53cmFwVDtcdH1cblxuXHRzZXQgd3JhcFQobVZhbHVlKSB7XG5cdFx0dGhpcy5fcGFyYW1zLndyYXBUID0gbVZhbHVlO1xuXHRcdHRoaXMuX2NoZWNrV3JhcHBpbmcoKTtcblxuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmUpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMuX3BhcmFtcy53cmFwVCk7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cdH1cblxuXHRnZXQgdGV4ZWxUeXBlKCkge1x0cmV0dXJuIHRoaXMuX3RleGVsVHlwZTtcdH1cblxuXHRnZXQgd2lkdGgoKSB7XHRyZXR1cm4gdGhpcy5fd2lkdGg7XHR9XG5cblx0Z2V0IGhlaWdodCgpIHtcdHJldHVybiB0aGlzLl9oZWlnaHQ7XHR9XG5cblx0Z2V0IHRleHR1cmUoKSB7XHRyZXR1cm4gdGhpcy5fdGV4dHVyZTtcdH1cblxuXHRnZXQgaXNUZXh0dXJlUmVhZHkoKSB7XHRyZXR1cm4gdGhpcy5faXNUZXh0dXJlUmVhZHk7XHR9XG5cbn1cblxuXG5mdW5jdGlvbiBpc1Bvd2VyT2ZUd28oeCkge1x0XG5cdHJldHVybiAoeCAhPT0gMCkgJiYgKCEoeCAmICh4IC0gMSkpKTtcbn07XG5cbmZ1bmN0aW9uIGdldFNvdXJjZVR5cGUobVNvdXJjZSkge1xuXHQvL1x0cG9zc2libGUgc291cmNlIHR5cGUgOiBJbWFnZSAvIFZpZGVvIC8gVW5pdDhBcnJheSAvIEZsb2F0MzJBcnJheVxuXHQvL1x0dGhpcyBsaXN0IG11c3QgYmUgZmxleGlibGVcblxuXHRsZXQgdHlwZSA9IEdMLlVOU0lHTkVEX0JZVEU7XG5cblx0aWYobVNvdXJjZSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0dHlwZSA9IEdMLlVOU0lHTkVEX0JZVEU7XG5cdH0gZWxzZSBpZihtU291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuXHRcdHR5cGUgPSBHTC5VTlNJR05FRF9CWVRFO1xuXHR9IGVsc2UgaWYobVNvdXJjZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xuXHRcdHR5cGUgPSBHTC5GTE9BVDtcblx0fSBlbHNlIGlmKG1Tb3VyY2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG5cdFx0dHlwZSA9ICdpbWFnZSc7XG5cdH0gZWxzZSBpZihtU291cmNlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcblx0XHR0eXBlID0gJ2NhbnZhcyc7XG5cdH0gZWxzZSBpZihtU291cmNlIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xuXHRcdHR5cGUgPSAndmlkZW8nO1xuXHR9XG5cdHJldHVybiB0eXBlO1xufVxuXG5sZXQgX3doaXRlVGV4dHVyZSwgX2dyZXlUZXh0dXJlLCBfYmxhY2tUZXh0dXJlO1xuXG5HTFRleHR1cmUud2hpdGVUZXh0dXJlID0gZnVuY3Rpb24gd2hpdGVUZXh0dXJlKCkge1xuXHRpZihfd2hpdGVUZXh0dXJlID09PSB1bmRlZmluZWQpIHtcblx0XHRjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0XHRjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMjtcblx0XHRjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRjdHguZmlsbFN0eWxlID0gJyNmZmYnO1xuXHRcdGN0eC5maWxsUmVjdCgwLCAwLCAyLCAyKTtcblx0XHRfd2hpdGVUZXh0dXJlID0gbmV3IEdMVGV4dHVyZShjYW52YXMpO1xuXHR9XG5cdFxuXHRyZXR1cm4gX3doaXRlVGV4dHVyZTtcbn07XG5cbkdMVGV4dHVyZS5ncmV5VGV4dHVyZSA9IGZ1bmN0aW9uIGdyZXlUZXh0dXJlKCkge1xuXHRpZihfZ3JleVRleHR1cmUgPT09IHVuZGVmaW5lZCkge1xuXHRcdGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXHRcdGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAyO1xuXHRcdGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdGN0eC5maWxsU3R5bGUgPSAncmdiKDEyNywgMTI3LCAxMjcpJztcblx0XHRjdHguZmlsbFJlY3QoMCwgMCwgMiwgMik7XG5cdFx0X2dyZXlUZXh0dXJlID0gbmV3IEdMVGV4dHVyZShjYW52YXMpO1xuXHR9XG5cdHJldHVybiBfZ3JleVRleHR1cmU7XG59O1xuXG5HTFRleHR1cmUuYmxhY2tUZXh0dXJlID0gZnVuY3Rpb24gYmxhY2tUZXh0dXJlKCkge1xuXHRpZihfYmxhY2tUZXh0dXJlID09PSB1bmRlZmluZWQpIHtcblx0XHRjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0XHRjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMjtcblx0XHRjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRjdHguZmlsbFN0eWxlID0gJ3JnYigwLCAwLCAwKSc7XG5cdFx0Y3R4LmZpbGxSZWN0KDAsIDAsIDIsIDIpO1xuXHRcdF9ibGFja1RleHR1cmUgPSBuZXcgR0xUZXh0dXJlKGNhbnZhcyk7XG5cdH1cblx0cmV0dXJuIF9ibGFja1RleHR1cmU7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBHTFRleHR1cmU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvR0xUZXh0dXJlMi5qcyIsIi8vIEdMQ3ViZVRleHR1cmUuanNcblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgR0wgZnJvbSAnLi9HTFRvb2wnO1xuaW1wb3J0IHBhcnNlIGZyb20gJ3BhcnNlLWRkcyc7XG5sZXQgZ2w7XG5jb25zdCBERFNEX01JUE1BUENPVU5UID0gMHgyMDAwMDtcbmNvbnN0IE9GRl9NSVBNQVBDT1VOVCA9IDc7XG5jb25zdCBoZWFkZXJMZW5ndGhJbnQgPSAzMTtcblxuY2xhc3MgR0xDdWJlVGV4dHVyZSB7XG5cdGNvbnN0cnVjdG9yKG1Tb3VyY2UsIG1QYXJhbWV0ZXJzID0ge30sIGlzQ3ViZVRleHR1cmUgPSBmYWxzZSkge1xuXHRcdGdsID0gR0wuZ2w7XG5cblx0XHRpZihpc0N1YmVUZXh0dXJlKSB7XG5cdFx0XHR0aGlzLnRleHR1cmUgPSBtU291cmNlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGxldCBoYXNNaXBtYXBzID0gbVNvdXJjZS5sZW5ndGggPiA2O1xuXHRcdGlmKG1Tb3VyY2VbMF0ubWlwbWFwQ291bnQpIHtcblx0XHRcdGhhc01pcG1hcHMgPSBtU291cmNlWzBdLm1pcG1hcENvdW50ID4gMTtcblx0XHR9XG5cblx0XHR0aGlzLnRleHR1cmUgICA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblx0XHR0aGlzLm1hZ0ZpbHRlciA9IG1QYXJhbWV0ZXJzLm1hZ0ZpbHRlciB8fCBnbC5MSU5FQVI7XG5cdFx0dGhpcy5taW5GaWx0ZXIgPSBtUGFyYW1ldGVycy5taW5GaWx0ZXIgfHwgZ2wuTElORUFSX01JUE1BUF9MSU5FQVI7XG5cdFx0dGhpcy53cmFwUyAgICAgPSBtUGFyYW1ldGVycy53cmFwUyB8fCBnbC5DTEFNUF9UT19FREdFO1xuXHRcdHRoaXMud3JhcFQgICAgID0gbVBhcmFtZXRlcnMud3JhcFQgfHwgZ2wuQ0xBTVBfVE9fRURHRTtcblxuXHRcdGlmKCFoYXNNaXBtYXBzICYmIHRoaXMubWluRmlsdGVyID09IGdsLkxJTkVBUl9NSVBNQVBfTElORUFSKSB7XG5cdFx0XHR0aGlzLm1pbkZpbHRlciA9IGdsLkxJTkVBUjtcblx0XHR9XG5cblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFX0NVQkVfTUFQLCB0aGlzLnRleHR1cmUpO1xuXHRcdGNvbnN0IHRhcmdldHMgPSBbXG5cdFx0XHRnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gsIGdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWCwgXG5cdFx0XHRnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ksIGdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWSwgXG5cdFx0XHRnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1osIGdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWiBcblx0XHRdO1xuXG5cdFx0XG5cdFx0bGV0IG51bUxldmVscyA9IDE7XG5cdFx0bGV0IGluZGV4ID0gMDtcblx0XHRudW1MZXZlbHMgPSBtU291cmNlLmxlbmd0aCAvIDY7XG5cdFx0dGhpcy5udW1MZXZlbHMgPSBudW1MZXZlbHM7XG5cblx0XHRpZiAoaGFzTWlwbWFwcykge1xuXHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCA2OyBqKyspIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBudW1MZXZlbHM7IGkrKykge1xuXHRcdFx0XHRcdGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcblx0XHRcdFx0XG5cdFx0XHRcdFx0aW5kZXggPSBqICogbnVtTGV2ZWxzICsgaTtcblx0XHRcdFx0XHRpZihtU291cmNlW2luZGV4XS5zaGFwZSkge1xuXHRcdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRCh0YXJnZXRzW2pdLCBpLCBnbC5SR0JBLCBtU291cmNlW2luZGV4XS5zaGFwZVswXSwgbVNvdXJjZVtpbmRleF0uc2hhcGVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBtU291cmNlW2luZGV4XS5kYXRhKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRCh0YXJnZXRzW2pdLCBpLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBtU291cmNlW2luZGV4XSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX1dSQVBfUywgdGhpcy53cmFwUyk7XG5cdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX1dSQVBfVCwgdGhpcy53cmFwVCk7XG5cdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01BR19GSUxURVIsIHRoaXMubWFnRmlsdGVyKTtcblx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5taW5GaWx0ZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IDY7IGorKykge1xuXHRcdFx0XHRpbmRleCA9IGogKiBudW1MZXZlbHM7XG5cdFx0XHRcdGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcblx0XHRcdFx0aWYobVNvdXJjZVtpbmRleF0uc2hhcGUpIHtcblx0XHRcdFx0XHRnbC50ZXhJbWFnZTJEKHRhcmdldHNbal0sIDAsIGdsLlJHQkEsIG1Tb3VyY2VbaW5kZXhdLnNoYXBlWzBdLCBtU291cmNlW2luZGV4XS5zaGFwZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG1Tb3VyY2VbaW5kZXhdLmRhdGEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGdsLnRleEltYWdlMkQodGFyZ2V0c1tqXSwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbVNvdXJjZVtpbmRleF0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMud3JhcFMpO1xuXHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLndyYXBUKTtcblx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01BR19GSUxURVIsIHRoaXMubWFnRmlsdGVyKTtcblx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRoaXMubWluRmlsdGVyKTtcblx0XHRcdH1cblxuXHRcdFx0Z2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV9DVUJFX01BUCk7XG5cdFx0fVxuXG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgbnVsbCk7XG5cdH1cblxuXHRcblxuXHQvL1x0UFVCTElDIE1FVEhPRFxuXG5cdGJpbmQoaW5kZXggPSAwKSB7XG5cdFx0aWYoIUdMLnNoYWRlcikgeyByZXR1cm47IH1cblxuXHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyBpbmRleCk7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGhpcy50ZXh0dXJlKTtcblx0XHRnbC51bmlmb3JtMWkoR0wuc2hhZGVyLnVuaWZvcm1UZXh0dXJlc1tpbmRleF0sIGluZGV4KTtcblx0XHR0aGlzLl9iaW5kSW5kZXggPSBpbmRleDtcblx0fVxuXG5cdHVuYmluZCgpIHtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFX0NVQkVfTUFQLCBudWxsKTtcdFxuXHR9XG59XG5cblxuR0xDdWJlVGV4dHVyZS5wYXJzZUREUyA9IGZ1bmN0aW9uIHBhcnNlRERTKG1BcnJheUJ1ZmZlcikge1xuXG5cdGZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuXHRcdGlmIChtaW4gPiBtYXgpIHtcblx0XHRcdHJldHVybiBjbGFtcCh2YWx1ZSwgbWF4LCBtaW4pO1xuXHRcdH1cblxuXHRcdGlmICh2YWx1ZSA8IG1pbikgcmV0dXJuIG1pbjtcblx0XHRlbHNlIGlmICh2YWx1ZSA+IG1heCkgcmV0dXJuIG1heDtcblx0XHRlbHNlIHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdC8vXHRDSEVDS0lORyBNSVAgTUFQIExFVkVMU1xuXHRjb25zdCBkZHNJbmZvcyA9IHBhcnNlKG1BcnJheUJ1ZmZlcik7XG5cdGNvbnN0IHsgZmxhZ3MgfSA9IGRkc0luZm9zO1xuXHRjb25zdCBoZWFkZXIgPSBuZXcgSW50MzJBcnJheShtQXJyYXlCdWZmZXIsIDAsIGhlYWRlckxlbmd0aEludCk7XG5cdGxldCBtaXBtYXBDb3VudCA9IDE7XG5cdGlmIChmbGFncyAmIEREU0RfTUlQTUFQQ09VTlQpIHtcblx0XHRtaXBtYXBDb3VudCA9IE1hdGgubWF4KDEsIGhlYWRlcltPRkZfTUlQTUFQQ09VTlRdKTtcblx0fVxuXHRjb25zdCBzb3VyY2VzID0gZGRzSW5mb3MuaW1hZ2VzLm1hcCgoaW1nKSA9PiB7XG5cdFx0Y29uc3QgZmFjZURhdGEgPSBuZXcgRmxvYXQzMkFycmF5KG1BcnJheUJ1ZmZlci5zbGljZShpbWcub2Zmc2V0LCBpbWcub2Zmc2V0ICsgaW1nLmxlbmd0aCkpO1xuXHRcdHJldHVybiB7XG5cdFx0XHRkYXRhOiBmYWNlRGF0YSxcblx0XHRcdHNoYXBlOiBpbWcuc2hhcGUsXG5cdFx0XHRtaXBtYXBDb3VudCxcblx0XHR9O1xuXHR9KTtcblxuXHRyZXR1cm4gbmV3IEdMQ3ViZVRleHR1cmUoc291cmNlcyk7XG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IEdMQ3ViZVRleHR1cmU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvR0xDdWJlVGV4dHVyZS5qcyIsIi8vIEV2ZW50RGlzcGF0Y2hlci5qc1xuXG5sZXQgc3VwcG9ydHNDdXN0b21FdmVudHMgPSB0cnVlO1xudHJ5IHtcblx0bGV0IG5ld1Rlc3RDdXN0b21FdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuXHRuZXdUZXN0Q3VzdG9tRXZlbnQgPSBudWxsO1xufSBjYXRjaChlKSB7XG5cdHN1cHBvcnRzQ3VzdG9tRXZlbnRzID0gZmFsc2U7XG59XG5cbmNsYXNzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSB7fTtcblx0fVxuXG5cblx0YWRkRXZlbnRMaXN0ZW5lcihhRXZlbnRUeXBlLCBhRnVuY3Rpb24pIHtcblxuXHRcdGlmKHRoaXMuX2V2ZW50TGlzdGVuZXJzID09PSBudWxsIHx8IHRoaXMuX2V2ZW50TGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuX2V2ZW50TGlzdGVuZXJzID0ge307XG5cdFx0fVxuXG5cdFx0aWYoIXRoaXMuX2V2ZW50TGlzdGVuZXJzW2FFdmVudFR5cGVdKSB7XG5cdFx0XHR0aGlzLl9ldmVudExpc3RlbmVyc1thRXZlbnRUeXBlXSA9IFtdO1xuXHRcdH1cblx0XHR0aGlzLl9ldmVudExpc3RlbmVyc1thRXZlbnRUeXBlXS5wdXNoKGFGdW5jdGlvbik7XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG9uKGFFdmVudFR5cGUsIGFGdW5jdGlvbikge1x0cmV0dXJuIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihhRXZlbnRUeXBlLCBhRnVuY3Rpb24pO1x0fVxuXG5cdHJlbW92ZUV2ZW50TGlzdGVuZXIoYUV2ZW50VHlwZSwgYUZ1bmN0aW9uKSB7XG5cdFx0aWYodGhpcy5fZXZlbnRMaXN0ZW5lcnMgPT09IG51bGwgfHwgdGhpcy5fZXZlbnRMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSB7fTtcblx0XHR9XG5cdFx0Y29uc3QgY3VycmVudEFycmF5ID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnNbYUV2ZW50VHlwZV07XG5cdFx0XG5cdFx0aWYgKHR5cGVvZihjdXJyZW50QXJyYXkpID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdFxuXHRcdGxldCBjdXJyZW50QXJyYXlMZW5ndGggPSBjdXJyZW50QXJyYXkubGVuZ3RoO1xuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCBjdXJyZW50QXJyYXlMZW5ndGg7IGkrKykge1xuXHRcdFx0aWYoY3VycmVudEFycmF5W2ldID09PSBhRnVuY3Rpb24pIHtcblx0XHRcdFx0Y3VycmVudEFycmF5LnNwbGljZShpLCAxKTtcblx0XHRcdFx0aS0tO1xuXHRcdFx0XHRjdXJyZW50QXJyYXlMZW5ndGgtLTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRvZmYoYUV2ZW50VHlwZSwgYUZ1bmN0aW9uKSB7XHRyZXR1cm4gdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGFFdmVudFR5cGUsIGFGdW5jdGlvbik7XHR9XG5cblx0ZGlzcGF0Y2hFdmVudChhRXZlbnQpIHtcblx0XHRpZih0aGlzLl9ldmVudExpc3RlbmVycyA9PT0gbnVsbCB8fCB0aGlzLl9ldmVudExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLl9ldmVudExpc3RlbmVycyA9IHt9O1xuXHRcdH1cblx0XHRjb25zdCBldmVudFR5cGUgPSBhRXZlbnQudHlwZTtcblx0XHRcblx0XHR0cnkge1xuXHRcdFx0aWYoYUV2ZW50LnRhcmdldCA9PT0gbnVsbCkge1xuXHRcdFx0XHRhRXZlbnQudGFyZ2V0ID0gdGhpcztcblx0XHRcdH1cblx0XHRcdGFFdmVudC5jdXJyZW50VGFyZ2V0ID0gdGhpcztcblx0XHR9IGNhdGNoKHRoZUVycm9yKSB7XG5cdFx0XHRjb25zdCBuZXdFdmVudCA9IHsgdHlwZTogZXZlbnRUeXBlLCBkZXRhaWw6IGFFdmVudC5kZXRhaWwsIGRpc3BhdGNoZXI6IHRoaXMgfTtcblx0XHRcdHJldHVybiB0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuXHRcdH1cblx0XHRcblx0XHRjb25zdCBjdXJyZW50RXZlbnRMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudExpc3RlbmVyc1tldmVudFR5cGVdO1xuXHRcdGlmKGN1cnJlbnRFdmVudExpc3RlbmVycyAhPT0gbnVsbCAmJiBjdXJyZW50RXZlbnRMaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y29uc3QgY3VycmVudEFycmF5ID0gdGhpcy5fY29weUFycmF5KGN1cnJlbnRFdmVudExpc3RlbmVycyk7XG5cdFx0XHRjb25zdCBjdXJyZW50QXJyYXlMZW5ndGggPSBjdXJyZW50QXJyYXkubGVuZ3RoO1xuXHRcdFx0Zm9yKGxldCBpID0gMDsgaSA8IGN1cnJlbnRBcnJheUxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGN1cnJlbnRGdW5jdGlvbiA9IGN1cnJlbnRBcnJheVtpXTtcblx0XHRcdFx0Y3VycmVudEZ1bmN0aW9uLmNhbGwodGhpcywgYUV2ZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRkaXNwYXRjaEN1c3RvbUV2ZW50KGFFdmVudFR5cGUsIGFEZXRhaWwpIHtcblx0XHRsZXQgbmV3RXZlbnQ7XG5cdFx0aWYgKHN1cHBvcnRzQ3VzdG9tRXZlbnRzKSB7XG5cdFx0XHRuZXdFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuXHRcdFx0bmV3RXZlbnQuZGlzcGF0Y2hlciA9IHRoaXM7XG5cdFx0XHRuZXdFdmVudC5pbml0Q3VzdG9tRXZlbnQoYUV2ZW50VHlwZSwgZmFsc2UsIGZhbHNlLCBhRGV0YWlsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV3RXZlbnQgPSB7IHR5cGU6IGFFdmVudFR5cGUsIGRldGFpbDogYURldGFpbCwgZGlzcGF0Y2hlcjogdGhpcyB9O1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcblx0fVxuXG5cdHRyaWdnZXIoYUV2ZW50VHlwZSwgYURldGFpbCkge1x0cmV0dXJuIHRoaXMuZGlzcGF0Y2hDdXN0b21FdmVudChhRXZlbnRUeXBlLCBhRGV0YWlsKTtcdH1cblxuXHRfZGVzdHJveSgpIHtcblx0XHRpZih0aGlzLl9ldmVudExpc3RlbmVycyAhPT0gbnVsbCkge1xuXHRcdFx0Zm9yKGNvbnN0IG9iamVjdE5hbWUgaW4gdGhpcy5fZXZlbnRMaXN0ZW5lcnMpIHtcblx0XHRcdFx0aWYodGhpcy5fZXZlbnRMaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkob2JqZWN0TmFtZSkpIHtcblx0XHRcdFx0XHRjb25zdCBjdXJyZW50QXJyYXkgPSB0aGlzLl9ldmVudExpc3RlbmVyc1tvYmplY3ROYW1lXTtcblx0XHRcdFx0XHRjb25zdCBjdXJyZW50QXJyYXlMZW5ndGggPSBjdXJyZW50QXJyYXkubGVuZ3RoO1xuXHRcdFx0XHRcdGZvcihsZXQgaSA9IDA7IGkgPCBjdXJyZW50QXJyYXlMZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0Y3VycmVudEFycmF5W2ldID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50TGlzdGVuZXJzW29iamVjdE5hbWVdO1x0XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX2V2ZW50TGlzdGVuZXJzID0gbnVsbDtcblx0XHR9XG5cdH1cblxuXHRfY29weUFycmF5KGFBcnJheSkge1xuXHRcdGNvbnN0IGN1cnJlbnRBcnJheSA9IG5ldyBBcnJheShhQXJyYXkubGVuZ3RoKTtcblx0XHRjb25zdCBjdXJyZW50QXJyYXlMZW5ndGggPSBjdXJyZW50QXJyYXkubGVuZ3RoO1xuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCBjdXJyZW50QXJyYXlMZW5ndGg7IGkrKykge1xuXHRcdFx0Y3VycmVudEFycmF5W2ldID0gYUFycmF5W2ldO1xuXHRcdH1cblx0XHRyZXR1cm4gY3VycmVudEFycmF5O1xuXHR9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgRXZlbnREaXNwYXRjaGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL0V2ZW50RGlzcGF0Y2hlci5qcyIsIi8vIE9yYml0YWxDb250cm9sLmpzXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBFYXNlTnVtYmVyIGZyb20gJy4vRWFzZU51bWJlcic7XG5pbXBvcnQgU2NoZWR1bGVyIGZyb20gICdzY2hlZHVsaW5nJztcbmltcG9ydCB7IHZlYzMgfSBmcm9tICdnbC1tYXRyaXgnO1xuXG5jb25zdCBnZXRNb3VzZSA9IGZ1bmN0aW9uIChtRXZlbnQsIG1UYXJnZXQpIHtcblxuXHRjb25zdCBvID0gbVRhcmdldCB8fCB7fTtcblx0aWYobUV2ZW50LnRvdWNoZXMpIHtcblx0XHRvLnggPSBtRXZlbnQudG91Y2hlc1swXS5wYWdlWDtcblx0XHRvLnkgPSBtRXZlbnQudG91Y2hlc1swXS5wYWdlWTtcblx0fSBlbHNlIHtcblx0XHRvLnggPSBtRXZlbnQuY2xpZW50WDtcblx0XHRvLnkgPSBtRXZlbnQuY2xpZW50WTtcblx0fVxuXG5cdHJldHVybiBvO1xufTtcblxuY2xhc3MgT3JiaXRhbENvbnRyb2wge1xuXG5cdGNvbnN0cnVjdG9yKG1UYXJnZXQsIG1MaXN0ZW5lclRhcmdldCA9IHdpbmRvdywgbVJhZGl1cyA9IDUwMCkge1xuXHRcdHRoaXMuX3RhcmdldCAgICAgICAgID0gbVRhcmdldDtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldCA9IG1MaXN0ZW5lclRhcmdldDtcblx0XHR0aGlzLl9tb3VzZSAgICAgICAgICA9IHt9O1xuXHRcdHRoaXMuX3ByZU1vdXNlICAgICAgID0ge307XG5cdFx0dGhpcy5jZW50ZXIgICAgICAgICAgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdHRoaXMuX3VwICAgICAgICAgICAgID0gdmVjMy5mcm9tVmFsdWVzKDAsIDEsIDApO1xuXHRcdHRoaXMucmFkaXVzICAgICAgICAgID0gbmV3IEVhc2VOdW1iZXIobVJhZGl1cyk7XG5cdFx0dGhpcy5wb3NpdGlvbiAgICAgICAgPSB2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgdGhpcy5yYWRpdXMudmFsdWUpO1xuXHRcdHRoaXMucG9zaXRpb25PZmZzZXQgID0gdmVjMy5jcmVhdGUoKTtcblx0XHR0aGlzLl9yeCAgICAgICAgICAgICA9IG5ldyBFYXNlTnVtYmVyKDApO1xuXHRcdHRoaXMuX3J4LmxpbWl0KC1NYXRoLlBJIC8gMiwgTWF0aC5QSSAvIDIpO1xuXHRcdHRoaXMuX3J5ICAgICAgICAgICAgID0gbmV3IEVhc2VOdW1iZXIoMCk7XG5cdFx0dGhpcy5fcHJlUlggICAgICAgICAgPSAwO1xuXHRcdHRoaXMuX3ByZVJZICAgICAgICAgID0gMDtcblx0XHRcblx0XHR0aGlzLl9pc0xvY2tab29tICAgICA9IGZhbHNlO1xuXHRcdHRoaXMuX2lzTG9ja1JvdGF0aW9uID0gZmFsc2U7XG5cdFx0dGhpcy5faXNJbnZlcnQgICAgICAgPSBmYWxzZTtcblx0XHR0aGlzLnNlbnNpdGl2aXR5XHQgPSAxLjA7XG5cblxuXHRcdHRoaXMuX3doZWVsQmluZCA9IChlKSA9PiB0aGlzLl9vbldoZWVsKGUpO1xuXHRcdHRoaXMuX2Rvd25CaW5kID0gKGUpID0+IHRoaXMuX29uRG93bihlKTtcblx0XHR0aGlzLl9tb3ZlQmluZCA9IChlKSA9PiB0aGlzLl9vbk1vdmUoZSk7XG5cdFx0dGhpcy5fdXBCaW5kID0gKCkgPT4gdGhpcy5fb25VcCgpO1xuXHRcblx0XHR0aGlzLmNvbm5lY3QoKTtcdFx0XG5cdFx0U2NoZWR1bGVyLmFkZEVGKCgpID0+IHRoaXMuX2xvb3AoKSk7XG5cdH1cblxuXHRjb25uZWN0KCkge1xuXHRcdHRoaXMuZGlzY29ubmVjdCgpO1xuXG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMuX3doZWVsQmluZCk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCB0aGlzLl93aGVlbEJpbmQpO1xuXG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fZG93bkJpbmQpO1xuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9kb3duQmluZCk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fbW92ZUJpbmQpO1xuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX21vdmVCaW5kKTtcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl91cEJpbmQpO1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fdXBCaW5kKTtcblx0fVxuXG5cdGRpc2Nvbm5lY3QoKSB7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMuX3doZWVsQmluZCk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCB0aGlzLl93aGVlbEJpbmQpO1xuXG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fZG93bkJpbmQpO1xuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9kb3duQmluZCk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fbW92ZUJpbmQpO1xuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX21vdmVCaW5kKTtcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl91cEJpbmQpO1xuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fdXBCaW5kKTtcblx0fVxuXG5cblx0Ly9cdFBVQkxJQyBNRVRIT0RTXG5cblx0bG9jayhtVmFsdWUgPSB0cnVlKSB7XG5cdFx0dGhpcy5faXNMb2NrWm9vbSA9IG1WYWx1ZTtcblx0XHR0aGlzLl9pc0xvY2tSb3RhdGlvbiA9IG1WYWx1ZTtcblx0XHR0aGlzLl9pc01vdXNlRG93biA9IGZhbHNlO1xuXHR9XG5cblx0bG9ja1pvb20obVZhbHVlID0gdHJ1ZSkge1xuXHRcdHRoaXMuX2lzTG9ja1pvb20gPSBtVmFsdWU7XG5cdH1cblxuXG5cdGxvY2tSb3RhdGlvbihtVmFsdWUgPSB0cnVlKSB7XG5cdFx0dGhpcy5faXNMb2NrUm90YXRpb24gPSBtVmFsdWU7XG5cdH1cblxuXG5cdGludmVyc2VDb250cm9sKGlzSW52ZXJ0ID0gdHJ1ZSkge1xuXHRcdHRoaXMuX2lzSW52ZXJ0ID0gaXNJbnZlcnQ7XG5cdH1cblxuXG5cdC8vXHRFVkVOVCBIQU5ETEVSRVNcblx0X29uRG93bihtRXZlbnQpIHtcblx0XHRpZih0aGlzLl9pc0xvY2tSb3RhdGlvbikgeyByZXR1cm47IH1cblx0XHR0aGlzLl9pc01vdXNlRG93biA9IHRydWU7XG5cdFx0Z2V0TW91c2UobUV2ZW50LCB0aGlzLl9tb3VzZSk7XG5cdFx0Z2V0TW91c2UobUV2ZW50LCB0aGlzLl9wcmVNb3VzZSk7XG5cdFx0dGhpcy5fcHJlUlggPSB0aGlzLl9yeC50YXJnZXRWYWx1ZTtcblx0XHR0aGlzLl9wcmVSWSA9IHRoaXMuX3J5LnRhcmdldFZhbHVlO1xuXHR9XG5cblxuXHRfb25Nb3ZlKG1FdmVudCkge1xuXHRcdGlmKHRoaXMuX2lzTG9ja1JvdGF0aW9uKSB7IHJldHVybjsgfVxuXHRcdGdldE1vdXNlKG1FdmVudCwgdGhpcy5fbW91c2UpO1xuXHRcdGlmKG1FdmVudC50b3VjaGVzKSB7IG1FdmVudC5wcmV2ZW50RGVmYXVsdCgpOyB9XG5cblx0XHRpZih0aGlzLl9pc01vdXNlRG93bikge1xuXHRcdFx0bGV0IGRpZmZYID0gLSh0aGlzLl9tb3VzZS54IC0gdGhpcy5fcHJlTW91c2UueCk7XG5cdFx0XHRpZih0aGlzLl9pc0ludmVydCkgeyBkaWZmWCAqPSAtMTsgfVxuXHRcdFx0dGhpcy5fcnkudmFsdWUgPSB0aGlzLl9wcmVSWSAtIGRpZmZYICogMC4wMSAqIHRoaXMuc2Vuc2l0aXZpdHk7XG5cblx0XHRcdGxldCBkaWZmWSA9IC0odGhpcy5fbW91c2UueSAtIHRoaXMuX3ByZU1vdXNlLnkpO1xuXHRcdFx0aWYodGhpcy5faXNJbnZlcnQpIHsgZGlmZlkgKj0gLTE7IH1cblx0XHRcdHRoaXMuX3J4LnZhbHVlID0gdGhpcy5fcHJlUlggLSBkaWZmWSAqIDAuMDEgKiB0aGlzLnNlbnNpdGl2aXR5O1xuXHRcdH1cblx0fVxuXG5cblx0X29uVXAoKSB7XG5cdFx0aWYodGhpcy5faXNMb2NrUm90YXRpb24pIHsgcmV0dXJuOyB9XG5cdFx0dGhpcy5faXNNb3VzZURvd24gPSBmYWxzZTtcblx0fVxuXG5cblx0X29uV2hlZWwobUV2ZW50KSB7XG5cdFx0aWYodGhpcy5faXNMb2NrWm9vbSkge1x0cmV0dXJuO1x0fVxuXHRcdGNvbnN0IHcgPSBtRXZlbnQud2hlZWxEZWx0YTtcblx0XHRjb25zdCBkID0gbUV2ZW50LmRldGFpbDtcblx0XHRsZXQgdmFsdWUgPSAwO1xuXHRcdGlmIChkKSB7XG5cdFx0XHRpZiAodykge1xuXHRcdFx0XHR2YWx1ZSA9IHcgLyBkIC8gNDAgKiBkID4gMCA/IDEgOiAtMTsgLy8gT3BlcmFcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbHVlID0gLWQgLyAzOyAgICAgICAgICAgICAgLy8gRmlyZWZveDsgICAgICAgICBUT0RPOiBkbyBub3QgLzMgZm9yIE9TIFhcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFsdWUgPSB3IC8gMTIwOyBcblx0XHR9XG5cblx0XHR0aGlzLnJhZGl1cy5hZGQoLXZhbHVlICogMik7XG5cdH1cblxuXG5cdC8vXHRQUklWQVRFIE1FVEhPRFNcblxuXHRfbG9vcCgpIHtcblxuXHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG5cblx0XHRpZih0aGlzLl90YXJnZXQpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZUNhbWVyYSgpO1xuXHRcdH1cblx0fVxuXG5cblx0X3VwZGF0ZVBvc2l0aW9uKCkge1xuXHRcdHRoaXMucG9zaXRpb25bMV0gPSBNYXRoLnNpbih0aGlzLl9yeC52YWx1ZSkgKiB0aGlzLnJhZGl1cy52YWx1ZTtcblx0XHRjb25zdCB0ciA9IE1hdGguY29zKHRoaXMuX3J4LnZhbHVlKSAqIHRoaXMucmFkaXVzLnZhbHVlO1xuXHRcdHRoaXMucG9zaXRpb25bMF0gPSBNYXRoLmNvcyh0aGlzLl9yeS52YWx1ZSArIE1hdGguUEkgKiAwLjUpICogdHI7XG5cdFx0dGhpcy5wb3NpdGlvblsyXSA9IE1hdGguc2luKHRoaXMuX3J5LnZhbHVlICsgTWF0aC5QSSAqIDAuNSkgKiB0cjtcblx0XHR2ZWMzLmFkZCh0aGlzLnBvc2l0aW9uLCB0aGlzLnBvc2l0aW9uLCB0aGlzLnBvc2l0aW9uT2Zmc2V0KTtcblx0fVxuXG5cblx0X3VwZGF0ZUNhbWVyYSgpIHtcblx0XHR0aGlzLl90YXJnZXQubG9va0F0KHRoaXMucG9zaXRpb24sIHRoaXMuY2VudGVyLCB0aGlzLl91cCk7XG5cdH1cblxuXG5cdC8vXHRHRVRURVIgLyBTRVRURVJcblxuXG5cdGdldCByeCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcng7XG5cdH1cblxuXG5cdGdldCByeSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcnk7XG5cdH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBPcmJpdGFsQ29udHJvbDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9PcmJpdGFsQ29udHJvbC5qcyIsIi8vIENhbWVyYU9ydGhvLmpzXG5cbmltcG9ydCBDYW1lcmEgZnJvbSAnLi9DYW1lcmEnO1xuaW1wb3J0IHsgdmVjMyB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmNsYXNzIENhbWVyYU9ydGhvIGV4dGVuZHMgQ2FtZXJhIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdGNvbnN0IGV5ZSAgICA9IHZlYzMuY2xvbmUoWzAsIDAsIDE1XSk7XG5cdFx0Y29uc3QgY2VudGVyID0gdmVjMy5jcmVhdGUoKTtcblx0XHRjb25zdCB1cCAgICAgPSB2ZWMzLmNsb25lKFswLCAtMSwgMF0pO1xuXHRcdHRoaXMubG9va0F0KGV5ZSwgY2VudGVyLCB1cCk7XG5cdFx0dGhpcy5vcnRobygxLCAtMSwgMSwgLTEpO1xuXHR9XG5cblxuXHRzZXRCb3VuZGFyeShsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXI9MC4xLCBmYXI9MTAwKSB7XG5cdFx0dGhpcy5vcnRobyhsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhcik7XG5cdH1cblxuXG5cdG9ydGhvKGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhcj0wLjEsIGZhcj0xMDApIHtcblx0XHR0aGlzLmxlZnQgICA9IGxlZnQ7XG5cdFx0dGhpcy5yaWdodCAgPSByaWdodDtcblx0XHR0aGlzLnRvcCAgICA9IHRvcDtcblx0XHR0aGlzLmJvdHRvbSA9IGJvdHRvbTtcblx0XHRtYXQ0Lm9ydGhvKHRoaXMuX3Byb2plY3Rpb24sIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyKTtcblx0fVxuXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgQ2FtZXJhT3J0aG87XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvY2FtZXJhcy9DYW1lcmFPcnRoby5qcyIsIi8vIE9iamVjdDNELmpzXG5cbmltcG9ydCB7IHZlYzMsIG1hdDQsIHF1YXQgfSBmcm9tICdnbC1tYXRyaXgnO1xuXG5jbGFzcyBPYmplY3QzRCB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IHRydWU7XG5cblx0XHR0aGlzLl94ID0gMDtcblx0XHR0aGlzLl95ID0gMDtcblx0XHR0aGlzLl96ID0gMDtcblxuXHRcdHRoaXMuX3N4ID0gMTtcblx0XHR0aGlzLl9zeSA9IDE7XG5cdFx0dGhpcy5fc3ogPSAxO1xuXG5cdFx0dGhpcy5fcnggPSAwO1xuXHRcdHRoaXMuX3J5ID0gMDtcblx0XHR0aGlzLl9yeiA9IDA7XG5cblx0XHR0aGlzLl9wb3NpdGlvbiA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0dGhpcy5fc2NhbGUgPSB2ZWMzLmZyb21WYWx1ZXMoMSwgMSwgMSk7XG5cdFx0dGhpcy5fcm90YXRpb24gPSB2ZWMzLmNyZWF0ZSgpO1xuXG5cdFx0dGhpcy5fbWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcblx0XHR0aGlzLl9tYXRyaXhSb3RhdGlvbiA9IG1hdDQuY3JlYXRlKCk7XG5cdFx0dGhpcy5fbWF0cml4U2NhbGUgPSBtYXQ0LmNyZWF0ZSgpO1xuXHRcdHRoaXMuX21hdHJpeFRyYW5zbGF0aW9uID0gbWF0NC5jcmVhdGUoKTtcblx0XHR0aGlzLl9tYXRyaXhRdWF0ZXJuaW9uID0gbWF0NC5jcmVhdGUoKTtcblx0XHR0aGlzLl9xdWF0ID0gcXVhdC5jcmVhdGUoKTtcblx0fVxuXG5cdF91cGRhdGUoKSB7XG5cdFx0dmVjMy5zZXQodGhpcy5fc2NhbGUsIHRoaXMuX3N4LCB0aGlzLl9zeSwgdGhpcy5fc3opO1xuXHRcdHZlYzMuc2V0KHRoaXMuX3JvdGF0aW9uLCB0aGlzLl9yeCwgdGhpcy5fcnksIHRoaXMuX3J6KTtcblx0XHR2ZWMzLnNldCh0aGlzLl9wb3NpdGlvbiwgdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feik7XG5cblx0XHRtYXQ0LmlkZW50aXR5KHRoaXMuX21hdHJpeFRyYW5zbGF0aW9uLCB0aGlzLl9tYXRyaXhUcmFuc2xhdGlvbik7XG5cdFx0bWF0NC5pZGVudGl0eSh0aGlzLl9tYXRyaXhTY2FsZSwgdGhpcy5fbWF0cml4U2NhbGUpO1xuXHRcdG1hdDQuaWRlbnRpdHkodGhpcy5fbWF0cml4Um90YXRpb24sIHRoaXMuX21hdHJpeFJvdGF0aW9uKTtcblxuXHRcdG1hdDQucm90YXRlWCh0aGlzLl9tYXRyaXhSb3RhdGlvbiwgdGhpcy5fbWF0cml4Um90YXRpb24sIHRoaXMuX3J4KTtcblx0XHRtYXQ0LnJvdGF0ZVkodGhpcy5fbWF0cml4Um90YXRpb24sIHRoaXMuX21hdHJpeFJvdGF0aW9uLCB0aGlzLl9yeSk7XG5cdFx0bWF0NC5yb3RhdGVaKHRoaXMuX21hdHJpeFJvdGF0aW9uLCB0aGlzLl9tYXRyaXhSb3RhdGlvbiwgdGhpcy5fcnopO1xuXG5cblx0XHRtYXQ0LmZyb21RdWF0KHRoaXMuX21hdHJpeFF1YXRlcm5pb24sIHRoaXMuX3F1YXQpO1xuXHRcdG1hdDQubXVsKHRoaXMuX21hdHJpeFJvdGF0aW9uLCB0aGlzLl9tYXRyaXhRdWF0ZXJuaW9uLCB0aGlzLl9tYXRyaXhSb3RhdGlvbik7XG5cblx0XHRtYXQ0LnNjYWxlKHRoaXMuX21hdHJpeFNjYWxlLCB0aGlzLl9tYXRyaXhTY2FsZSwgdGhpcy5fc2NhbGUpO1xuXHRcdG1hdDQudHJhbnNsYXRlKHRoaXMuX21hdHJpeFRyYW5zbGF0aW9uLCB0aGlzLl9tYXRyaXhUcmFuc2xhdGlvbiwgdGhpcy5fcG9zaXRpb24pO1xuXG5cdFx0bWF0NC5tdWwodGhpcy5fbWF0cml4LCB0aGlzLl9tYXRyaXhUcmFuc2xhdGlvbiwgdGhpcy5fbWF0cml4Um90YXRpb24pO1xuXHRcdG1hdDQubXVsKHRoaXMuX21hdHJpeCwgdGhpcy5fbWF0cml4LCB0aGlzLl9tYXRyaXhTY2FsZSk7XG5cblx0XHR0aGlzLl9uZWVkVXBkYXRlID0gZmFsc2U7XG5cdH1cblxuXG5cdHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24obVF1YXQpIHtcblx0XHRxdWF0LmNvcHkodGhpcy5fcXVhdCwgbVF1YXQpO1xuXHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXHR9XG5cblxuXHRnZXQgbWF0cml4KCkge1xuXHRcdGlmKHRoaXMuX25lZWRVcGRhdGUpIHtcdHRoaXMuX3VwZGF0ZSgpO1x0fVxuXHRcdHJldHVybiB0aGlzLl9tYXRyaXg7XG5cdH1cblxuXHRnZXQgeCgpIHtcdHJldHVybiB0aGlzLl94O1x0fVxuXHRzZXQgeChtVmFsdWUpIHtcblx0XHR0aGlzLl9uZWVkVXBkYXRlID0gdHJ1ZTtcblx0XHR0aGlzLl94ID0gbVZhbHVlO1xuXHR9XG5cblx0Z2V0IHkoKSB7XHRyZXR1cm4gdGhpcy5feTtcdH1cblx0c2V0IHkobVZhbHVlKSB7XG5cdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5feSA9IG1WYWx1ZTtcblx0fVxuXG5cdGdldCB6KCkge1x0cmV0dXJuIHRoaXMuX3o7XHR9XG5cdHNldCB6KG1WYWx1ZSkge1xuXHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMuX3ogPSBtVmFsdWU7XG5cdH1cblxuXHRcblx0Z2V0IHNjYWxlWCgpIHtcdHJldHVybiB0aGlzLl9zeDtcdH1cblx0c2V0IHNjYWxlWChtVmFsdWUpIHtcblx0XHR0aGlzLl9uZWVkVXBkYXRlID0gdHJ1ZTtcblx0XHR0aGlzLl9zeCA9IG1WYWx1ZTtcblx0fVxuXG5cdGdldCBzY2FsZVkoKSB7XHRyZXR1cm4gdGhpcy5fc3k7XHR9XG5cdHNldCBzY2FsZVkobVZhbHVlKSB7XG5cdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5fc3kgPSBtVmFsdWU7XG5cdH1cblxuXHRnZXQgc2NhbGVaKCkge1x0cmV0dXJuIHRoaXMuX3N6O1x0fVxuXHRzZXQgc2NhbGVaKG1WYWx1ZSkge1xuXHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMuX3N6ID0gbVZhbHVlO1xuXHR9XG5cblxuXHRnZXQgcm90YXRpb25YKCkge1x0cmV0dXJuIHRoaXMuX3J4O1x0fVxuXHRzZXQgcm90YXRpb25YKG1WYWx1ZSkge1xuXHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMuX3J4ID0gbVZhbHVlO1xuXHR9XG5cblx0Z2V0IHJvdGF0aW9uWSgpIHtcdHJldHVybiB0aGlzLl9yeTtcdH1cblx0c2V0IHJvdGF0aW9uWShtVmFsdWUpIHtcblx0XHR0aGlzLl9uZWVkVXBkYXRlID0gdHJ1ZTtcblx0XHR0aGlzLl9yeSA9IG1WYWx1ZTtcblx0fVxuXG5cdGdldCByb3RhdGlvblooKSB7XHRyZXR1cm4gdGhpcy5fcno7XHR9XG5cdHNldCByb3RhdGlvbloobVZhbHVlKSB7XG5cdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5fcnogPSBtVmFsdWU7XG5cdH1cblxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IE9iamVjdDNEO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL29iamVjdHMvT2JqZWN0M0QuanMiLCIvLyBTaGFkZXJMYnMuanNcblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgc2ltcGxlQ29sb3JGcmFnIGZyb20gJy4uL3NoYWRlcnMvc2ltcGxlQ29sb3IuZnJhZyc7XG5pbXBvcnQgYmlnVHJpYW5nbGVWZXJ0IGZyb20gJy4uL3NoYWRlcnMvYmlnVHJpYW5nbGUudmVydCc7XG5pbXBvcnQgZ2VuZXJhbFZlcnQgZnJvbSAnLi4vc2hhZGVycy9nZW5lcmFsLnZlcnQnO1xuaW1wb3J0IGNvcHlGcmFnIGZyb20gJy4uL3NoYWRlcnMvY29weS5mcmFnJztcbmltcG9ydCBiYXNpY1ZlcnQgZnJvbSAnLi4vc2hhZGVycy9iYXNpYy52ZXJ0JztcbmltcG9ydCBza3lib3hWZXJ0IGZyb20gJy4uL3NoYWRlcnMvc2t5Ym94LnZlcnQnO1xuaW1wb3J0IHNreWJveEZyYWcgZnJvbSAnLi4vc2hhZGVycy9za3lib3guZnJhZyc7XG5cbmNvbnN0IFNoYWRlckxpYnMgPSB7XG5cdHNpbXBsZUNvbG9yRnJhZyxcblx0YmlnVHJpYW5nbGVWZXJ0LFxuXHRnZW5lcmFsVmVydCxcblx0Y29weUZyYWcsXG5cdGJhc2ljVmVydCxcblx0c2t5Ym94VmVydCxcblx0c2t5Ym94RnJhZyxcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgU2hhZGVyTGlicztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9TaGFkZXJMaWJzLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vIGdlbmVyYWxXaXRoTm9ybWFsLnZlcnRcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIEdFTkVSQUxfVkVSVEVYXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuYXR0cmlidXRlIHZlYzMgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuYXR0cmlidXRlIHZlYzMgYU5vcm1hbDtcXG5cXG51bmlmb3JtIG1hdDQgdU1vZGVsTWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1Vmlld01hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVByb2plY3Rpb25NYXRyaXg7XFxudW5pZm9ybSBtYXQzIHVOb3JtYWxNYXRyaXg7XFxuXFxudW5pZm9ybSB2ZWMzIHBvc2l0aW9uO1xcbnVuaWZvcm0gdmVjMyBzY2FsZTtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcdHZlYzMgcG9zICAgICAgPSBhVmVydGV4UG9zaXRpb24gKiBzY2FsZTtcXG5cXHRwb3MgICAgICAgICAgICs9IHBvc2l0aW9uO1xcblxcdGdsX1Bvc2l0aW9uICAgPSB1UHJvamVjdGlvbk1hdHJpeCAqIHVWaWV3TWF0cml4ICogdU1vZGVsTWF0cml4ICogdmVjNChwb3MsIDEuMCk7XFxuXFx0XFxuXFx0dlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxuXFx0dk5vcm1hbCAgICAgICA9IG5vcm1hbGl6ZSh1Tm9ybWFsTWF0cml4ICogYU5vcm1hbCk7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9zaGFkZXJzL2dlbmVyYWwudmVydFxuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gYmFzaWMudmVydFxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgU0tZQk9YX1ZFUlRFWFxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbmF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcbmF0dHJpYnV0ZSB2ZWMzIGFOb3JtYWw7XFxuXFxudW5pZm9ybSBtYXQ0IHVNb2RlbE1hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjMyB2VmVydGV4O1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFx0bWF0NCBtYXRWaWV3ID0gdVZpZXdNYXRyaXg7XFxuXFx0bWF0Vmlld1szXVswXSA9IDAuMDtcXG5cXHRtYXRWaWV3WzNdWzFdID0gMC4wO1xcblxcdG1hdFZpZXdbM11bMl0gPSAwLjA7XFxuXFx0XFxuXFx0Z2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIG1hdFZpZXcgKiB1TW9kZWxNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKTtcXG5cXHR2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXG5cXHRcXG5cXHR2VmVydGV4ID0gYVZlcnRleFBvc2l0aW9uO1xcblxcdHZOb3JtYWwgPSBhTm9ybWFsO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9za3lib3gudmVydFxuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gYmFzaWMuZnJhZ1xcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgU0tZQk9YX0ZSQUdNRU5UXFxuXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG51bmlmb3JtIHNhbXBsZXJDdWJlIHRleHR1cmU7XFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyB2ZWMzIHZWZXJ0ZXg7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZUN1YmUodGV4dHVyZSwgdlZlcnRleCk7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9zaGFkZXJzL3NreWJveC5mcmFnXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIFBhc3NNYWNyby5qc1xuXG5jbGFzcyBQYXNzTWFjcm8ge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLl9wYXNzZXMgPSBbXTtcblx0fVxuXG5cdGFkZFBhc3MocGFzcykge1xuXHRcdHRoaXMuX3Bhc3Nlcy5wdXNoKHBhc3MpO1xuXHR9XG5cblx0Z2V0IHBhc3NlcygpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFzc2VzO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhc3NNYWNybztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9wb3N0L1Bhc3NNYWNyby5qcyIsIi8vIFBhc3NWQmx1ci5qc1xuXG5pbXBvcnQgUGFzc0JsdXJCYXNlIGZyb20gJy4vUGFzc0JsdXJCYXNlJztcblxuY2xhc3MgUGFzc1ZCbHVyIGV4dGVuZHMgUGFzc0JsdXJCYXNlIHtcblx0Y29uc3RydWN0b3IobVF1YWxpdHkgPSA5LCBtV2lkdGgsIG1IZWlnaHQsIG1QYXJhbXMpIHtcblx0XHRzdXBlcihtUXVhbGl0eSwgWzAsIDFdLCBtV2lkdGgsIG1IZWlnaHQsIG1QYXJhbXMpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhc3NWQmx1cjtcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvcG9zdC9QYXNzVkJsdXIuanMiLCIvLyBQYXNzQmx1ckJhc2UuanNcblxuaW1wb3J0IEdMIGZyb20gJy4uL0dMVG9vbCc7XG5pbXBvcnQgUGFzcyBmcm9tICcuL1Bhc3MnO1xuXG5jb25zdCBmc0JsdXI1ID0gcmVxdWlyZSgnLi4vc2hhZGVycy9ibHVyNS5mcmFnJyk7XG5jb25zdCBmc0JsdXI5ID0gcmVxdWlyZSgnLi4vc2hhZGVycy9ibHVyOS5mcmFnJyk7XG5jb25zdCBmc0JsdXIxMyA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvYmx1cjEzLmZyYWcnKTtcblxuY2xhc3MgUGFzc0JsdXJCYXNlIGV4dGVuZHMgUGFzcyB7XG5cdGNvbnN0cnVjdG9yKG1RdWFsaXR5ID0gOSwgbURpcmVjdGlvbiwgbVdpZHRoLCBtSGVpZ2h0LCBtUGFyYW1zID0ge30pIHtcblx0XHRsZXQgZnM7XG5cdFx0c3dpdGNoKG1RdWFsaXR5KSB7XG5cdFx0Y2FzZSA1OlxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRmcyA9IGZzQmx1cjU7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDkgOiBcblx0XHRcdGZzID0gZnNCbHVyOTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMTMgOiBcblx0XHRcdGZzID0gZnNCbHVyMTM7XG5cdFx0XHRicmVhaztcblxuXHRcdH1cblx0XHRzdXBlcihmcywgbVdpZHRoLCBtSGVpZ2h0LCBtUGFyYW1zKTtcblx0XHR0aGlzLnVuaWZvcm0oJ3VEaXJlY3Rpb24nLCBtRGlyZWN0aW9uKTtcblx0XHR0aGlzLnVuaWZvcm0oJ3VSZXNvbHV0aW9uJywgW0dMLndpZHRoLCBHTC5oZWlnaHRdKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBQYXNzQmx1ckJhc2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9wb3N0L1Bhc3NCbHVyQmFzZS5qcyIsIi8vIFBhc3NIQmx1ci5qc1xuXG5pbXBvcnQgUGFzc0JsdXJCYXNlIGZyb20gJy4vUGFzc0JsdXJCYXNlJztcblxuY2xhc3MgUGFzc0hCbHVyIGV4dGVuZHMgUGFzc0JsdXJCYXNlIHtcblx0Y29uc3RydWN0b3IobVF1YWxpdHkgPSA5LCBtV2lkdGgsIG1IZWlnaHQsIG1QYXJhbXMpIHtcblx0XHRzdXBlcihtUXVhbGl0eSwgWzEsIDBdLCBtV2lkdGgsIG1IZWlnaHQsIG1QYXJhbXMpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhc3NIQmx1cjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3Bvc3QvUGFzc0hCbHVyLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vIGZ4YWEuZnJhZ1xcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgRlhBQVxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmU7XFxudW5pZm9ybSB2ZWMyIHVSZXNvbHV0aW9uO1xcblxcblxcbmZsb2F0IEZYQUFfU1VCUElYX1NISUZUID0gMS4wLzQuMDtcXG4jZGVmaW5lIEZYQUFfUkVEVUNFX01JTiAgICgxLjAvIDEyOC4wKVxcbiNkZWZpbmUgRlhBQV9SRURVQ0VfTVVMICAgKDEuMCAvIDguMClcXG4jZGVmaW5lIEZYQUFfU1BBTl9NQVggICAgIDguMFxcblxcblxcbnZlYzQgYXBwbHlGWEFBKHNhbXBsZXIyRCB0ZXgpIHtcXG4gICAgdmVjNCBjb2xvcjtcXG4gICAgdmVjMiBmcmFnQ29vcmQgPSBnbF9GcmFnQ29vcmQueHk7XFxuICAgIHZlYzMgcmdiTlcgPSB0ZXh0dXJlMkQodGV4LCAoZnJhZ0Nvb3JkICsgdmVjMigtMS4wLCAtMS4wKSkgKiB1UmVzb2x1dGlvbikueHl6O1xcbiAgICB2ZWMzIHJnYk5FID0gdGV4dHVyZTJEKHRleCwgKGZyYWdDb29yZCArIHZlYzIoMS4wLCAtMS4wKSkgKiB1UmVzb2x1dGlvbikueHl6O1xcbiAgICB2ZWMzIHJnYlNXID0gdGV4dHVyZTJEKHRleCwgKGZyYWdDb29yZCArIHZlYzIoLTEuMCwgMS4wKSkgKiB1UmVzb2x1dGlvbikueHl6O1xcbiAgICB2ZWMzIHJnYlNFID0gdGV4dHVyZTJEKHRleCwgKGZyYWdDb29yZCArIHZlYzIoMS4wLCAxLjApKSAqIHVSZXNvbHV0aW9uKS54eXo7XFxuICAgIHZlYzMgcmdiTSAgPSB0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgICogdVJlc29sdXRpb24pLnh5ejtcXG4gICAgdmVjMyBsdW1hID0gdmVjMygwLjI5OSwgMC41ODcsIDAuMTE0KTtcXG4gICAgZmxvYXQgbHVtYU5XID0gZG90KHJnYk5XLCBsdW1hKTtcXG4gICAgZmxvYXQgbHVtYU5FID0gZG90KHJnYk5FLCBsdW1hKTtcXG4gICAgZmxvYXQgbHVtYVNXID0gZG90KHJnYlNXLCBsdW1hKTtcXG4gICAgZmxvYXQgbHVtYVNFID0gZG90KHJnYlNFLCBsdW1hKTtcXG4gICAgZmxvYXQgbHVtYU0gID0gZG90KHJnYk0sICBsdW1hKTtcXG4gICAgZmxvYXQgbHVtYU1pbiA9IG1pbihsdW1hTSwgbWluKG1pbihsdW1hTlcsIGx1bWFORSksIG1pbihsdW1hU1csIGx1bWFTRSkpKTtcXG4gICAgZmxvYXQgbHVtYU1heCA9IG1heChsdW1hTSwgbWF4KG1heChsdW1hTlcsIGx1bWFORSksIG1heChsdW1hU1csIGx1bWFTRSkpKTtcXG5cXG4gICAgdmVjMiBkaXI7XFxuICAgIGRpci54ID0gLSgobHVtYU5XICsgbHVtYU5FKSAtIChsdW1hU1cgKyBsdW1hU0UpKTtcXG4gICAgZGlyLnkgPSAgKChsdW1hTlcgKyBsdW1hU1cpIC0gKGx1bWFORSArIGx1bWFTRSkpO1xcblxcbiAgICBmbG9hdCBkaXJSZWR1Y2UgPSBtYXgoKGx1bWFOVyArIGx1bWFORSArIGx1bWFTVyArIGx1bWFTRSkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKDAuMjUgKiBGWEFBX1JFRFVDRV9NVUwpLCBGWEFBX1JFRFVDRV9NSU4pO1xcblxcbiAgICBmbG9hdCByY3BEaXJNaW4gPSAxLjAgLyAobWluKGFicyhkaXIueCksIGFicyhkaXIueSkpICsgZGlyUmVkdWNlKTtcXG4gICAgZGlyID0gbWluKHZlYzIoRlhBQV9TUEFOX01BWCwgRlhBQV9TUEFOX01BWCksXFxuICAgICAgICAgICAgICBtYXgodmVjMigtRlhBQV9TUEFOX01BWCwgLUZYQUFfU1BBTl9NQVgpLFxcbiAgICAgICAgICAgICAgZGlyICogcmNwRGlyTWluKSkgKiB1UmVzb2x1dGlvbjtcXG5cXG4gICAgdmVjMyByZ2JBID0gMC41ICogKFxcbiAgICAgICAgdGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogdVJlc29sdXRpb24gKyBkaXIgKiAoMS4wIC8gMy4wIC0gMC41KSkueHl6ICtcXG4gICAgICAgIHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIHVSZXNvbHV0aW9uICsgZGlyICogKDIuMCAvIDMuMCAtIDAuNSkpLnh5eik7XFxuICAgIHZlYzMgcmdiQiA9IHJnYkEgKiAwLjUgKyAwLjI1ICogKFxcbiAgICAgICAgdGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogdVJlc29sdXRpb24gKyBkaXIgKiAtMC41KS54eXogK1xcbiAgICAgICAgdGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogdVJlc29sdXRpb24gKyBkaXIgKiAwLjUpLnh5eik7XFxuXFxuICAgIGZsb2F0IGx1bWFCID0gZG90KHJnYkIsIGx1bWEpO1xcbiAgICBpZiAoKGx1bWFCIDwgbHVtYU1pbikgfHwgKGx1bWFCID4gbHVtYU1heCkpXFxuICAgICAgICBjb2xvciA9IHZlYzQocmdiQSwgMS4wKTtcXG4gICAgZWxzZVxcbiAgICAgICAgY29sb3IgPSB2ZWM0KHJnYkIsIDEuMCk7XFxuICAgIHJldHVybiBjb2xvcjtcXG59XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gXFx0dmVjNCBjb2xvciA9IGFwcGx5RlhBQSh0ZXh0dXJlKTtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9zaGFkZXJzL2Z4YWEuZnJhZ1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxuaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uXCJcblxuLyoqXG4gKiAyeDIgTWF0cml4XG4gKiBAbW9kdWxlIG1hdDJcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0MlxuICpcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDIgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2V0IGEgbWF0MiB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBtYXQyIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMylcbiAqIEByZXR1cm5zIHttYXQyfSBvdXQgQSBuZXcgMngyIG1hdHJpeFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyhtMDAsIG0wMSwgbTEwLCBtMTEpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTEwO1xuICBvdXRbM10gPSBtMTE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgbWF0MiB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMylcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIG0wMCwgbTAxLCBtMTAsIG0xMSkge1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTEwO1xuICBvdXRbM10gPSBtMTE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlXG4gIC8vIHNvbWUgdmFsdWVzXG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICBsZXQgYTEgPSBhWzFdO1xuICAgIG91dFsxXSA9IGFbMl07XG4gICAgb3V0WzJdID0gYTE7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzJdO1xuICAgIG91dFsyXSA9IGFbMV07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIGxldCBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM107XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICBsZXQgZGV0ID0gYTAgKiBhMyAtIGEyICogYTE7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgb3V0WzBdID0gIGEzICogZGV0O1xuICBvdXRbMV0gPSAtYTEgKiBkZXQ7XG4gIG91dFsyXSA9IC1hMiAqIGRldDtcbiAgb3V0WzNdID0gIGEwICogZGV0O1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRqb2ludChvdXQsIGEpIHtcbiAgLy8gQ2FjaGluZyB0aGlzIHZhbHVlIGlzIG5lc3NlY2FyeSBpZiBvdXQgPT0gYVxuICBsZXQgYTAgPSBhWzBdO1xuICBvdXRbMF0gPSAgYVszXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICBvdXRbM10gPSAgYTA7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgcmV0dXJuIGFbMF0gKiBhWzNdIC0gYVsyXSAqIGFbMV07XG59XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MidzXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIGxldCBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM107XG4gIGxldCBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM107XG4gIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxO1xuICBvdXRbMV0gPSBhMSAqIGIwICsgYTMgKiBiMTtcbiAgb3V0WzJdID0gYTAgKiBiMiArIGEyICogYjM7XG4gIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQyIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQpIHtcbiAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXTtcbiAgbGV0IHMgPSBNYXRoLnNpbihyYWQpO1xuICBsZXQgYyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGEwICogIGMgKyBhMiAqIHM7XG4gIG91dFsxXSA9IGExICogIGMgKyBhMyAqIHM7XG4gIG91dFsyXSA9IGEwICogLXMgKyBhMiAqIGM7XG4gIG91dFszXSA9IGExICogLXMgKyBhMyAqIGM7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQyIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXTtcbiAgbGV0IHYwID0gdlswXSwgdjEgPSB2WzFdO1xuICBvdXRbMF0gPSBhMCAqIHYwO1xuICBvdXRbMV0gPSBhMSAqIHYwO1xuICBvdXRbMl0gPSBhMiAqIHYxO1xuICBvdXRbM10gPSBhMyAqIHYxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0Mi5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQyLnJvdGF0ZShkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IG1hdDIgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCByYWQpIHtcbiAgbGV0IHMgPSBNYXRoLnNpbihyYWQpO1xuICBsZXQgYyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IHM7XG4gIG91dFsyXSA9IC1zO1xuICBvdXRbM10gPSBjO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0Mi5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQyLnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgbWF0MiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gdlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuICdtYXQyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJyknO1xufVxuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybihNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikpKVxufVxuXG4vKipcbiAqIFJldHVybnMgTCwgRCBhbmQgVSBtYXRyaWNlcyAoTG93ZXIgdHJpYW5ndWxhciwgRGlhZ29uYWwgYW5kIFVwcGVyIHRyaWFuZ3VsYXIpIGJ5IGZhY3Rvcml6aW5nIHRoZSBpbnB1dCBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gTCB0aGUgbG93ZXIgdHJpYW5ndWxhciBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gRCB0aGUgZGlhZ29uYWwgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IFUgdGhlIHVwcGVyIHRyaWFuZ3VsYXIgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGlucHV0IG1hdHJpeCB0byBmYWN0b3JpemVcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gTERVKEwsIEQsIFUsIGEpIHtcbiAgTFsyXSA9IGFbMl0vYVswXTtcbiAgVVswXSA9IGFbMF07XG4gIFVbMV0gPSBhWzFdO1xuICBVWzNdID0gYVszXSAtIExbMl0gKiBVWzFdO1xuICByZXR1cm4gW0wsIEQsIFVdO1xufVxuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDInc1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQyfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHttYXQyfSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge21hdDJ9IGIgVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICBsZXQgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdO1xuICBsZXQgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdO1xuICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkpO1xufVxuXG4vKipcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDIncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIncyBlbGVtZW50cyBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhckFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICBvdXRbMl0gPSBhWzJdICsgKGJbMl0gKiBzY2FsZSk7XG4gIG91dFszXSA9IGFbM10gKyAoYlszXSAqIHNjYWxlKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDIubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IG11bCA9IG11bHRpcGx5O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0Mi5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc3ViID0gc3VidHJhY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQyLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbmltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vblwiO1xuXG4vKipcbiAqIDJ4MyBNYXRyaXhcbiAqIEBtb2R1bGUgbWF0MmRcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEEgbWF0MmQgY29udGFpbnMgc2l4IGVsZW1lbnRzIGRlZmluZWQgYXM6XG4gKiA8cHJlPlxuICogW2EsIGMsIHR4LFxuICogIGIsIGQsIHR5XVxuICogPC9wcmU+XG4gKiBUaGlzIGlzIGEgc2hvcnQgZm9ybSBmb3IgdGhlIDN4MyBtYXRyaXg6XG4gKiA8cHJlPlxuICogW2EsIGMsIHR4LFxuICogIGIsIGQsIHR5LFxuICogIDAsIDAsIDFdXG4gKiA8L3ByZT5cbiAqIFRoZSBsYXN0IHJvdyBpcyBpZ25vcmVkIHNvIHRoZSBhcnJheSBpcyBzaG9ydGVyIGFuZCBvcGVyYXRpb25zIGFyZSBmYXN0ZXIuXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDJkXG4gKlxuICogQHJldHVybnMge21hdDJkfSBhIG5ldyAyeDMgbWF0cml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg2KTtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDJkIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQyZH0gYSBuZXcgMngzIG1hdHJpeFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNik7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDJkIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCBhIG1hdDJkIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWF0MmQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGEgQ29tcG9uZW50IEEgKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gYiBDb21wb25lbnQgQiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjIENvbXBvbmVudCBDIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IGQgQ29tcG9uZW50IEQgKGluZGV4IDMpXG4gKiBAcGFyYW0ge051bWJlcn0gdHggQ29tcG9uZW50IFRYIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IHR5IENvbXBvbmVudCBUWSAoaW5kZXggNSlcbiAqIEByZXR1cm5zIHttYXQyZH0gQSBuZXcgbWF0MmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMoYSwgYiwgYywgZCwgdHgsIHR5KSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg2KTtcbiAgb3V0WzBdID0gYTtcbiAgb3V0WzFdID0gYjtcbiAgb3V0WzJdID0gYztcbiAgb3V0WzNdID0gZDtcbiAgb3V0WzRdID0gdHg7XG4gIG91dFs1XSA9IHR5O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDJkIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIENvbXBvbmVudCBBIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgQ29tcG9uZW50IEIgKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gYyBDb21wb25lbnQgQyAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBkIENvbXBvbmVudCBEIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IHR4IENvbXBvbmVudCBUWCAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eSBDb21wb25lbnQgVFkgKGluZGV4IDUpXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgYSwgYiwgYywgZCwgdHgsIHR5KSB7XG4gIG91dFswXSA9IGE7XG4gIG91dFsxXSA9IGI7XG4gIG91dFsyXSA9IGM7XG4gIG91dFszXSA9IGQ7XG4gIG91dFs0XSA9IHR4O1xuICBvdXRbNV0gPSB0eTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIGxldCBhYSA9IGFbMF0sIGFiID0gYVsxXSwgYWMgPSBhWzJdLCBhZCA9IGFbM107XG4gIGxldCBhdHggPSBhWzRdLCBhdHkgPSBhWzVdO1xuXG4gIGxldCBkZXQgPSBhYSAqIGFkIC0gYWIgKiBhYztcbiAgaWYoIWRldCl7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gIG91dFswXSA9IGFkICogZGV0O1xuICBvdXRbMV0gPSAtYWIgKiBkZXQ7XG4gIG91dFsyXSA9IC1hYyAqIGRldDtcbiAgb3V0WzNdID0gYWEgKiBkZXQ7XG4gIG91dFs0XSA9IChhYyAqIGF0eSAtIGFkICogYXR4KSAqIGRldDtcbiAgb3V0WzVdID0gKGFiICogYXR4IC0gYWEgKiBhdHkpICogZGV0O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIHJldHVybiBhWzBdICogYVszXSAtIGFbMV0gKiBhWzJdO1xufVxuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDJkJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0MmR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIGxldCBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdO1xuICBsZXQgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdLCBiNCA9IGJbNF0sIGI1ID0gYls1XTtcbiAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjE7XG4gIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xuICBvdXRbMl0gPSBhMCAqIGIyICsgYTIgKiBiMztcbiAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjM7XG4gIG91dFs0XSA9IGEwICogYjQgKyBhMiAqIGI1ICsgYTQ7XG4gIG91dFs1XSA9IGExICogYjQgKyBhMyAqIGI1ICsgYTU7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDJkIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQpIHtcbiAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV07XG4gIGxldCBzID0gTWF0aC5zaW4ocmFkKTtcbiAgbGV0IGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBhMCAqICBjICsgYTIgKiBzO1xuICBvdXRbMV0gPSBhMSAqICBjICsgYTMgKiBzO1xuICBvdXRbMl0gPSBhMCAqIC1zICsgYTIgKiBjO1xuICBvdXRbM10gPSBhMSAqIC1zICsgYTMgKiBjO1xuICBvdXRbNF0gPSBhNDtcbiAgb3V0WzVdID0gYTU7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQyZCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIGxldCBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdO1xuICBsZXQgdjAgPSB2WzBdLCB2MSA9IHZbMV07XG4gIG91dFswXSA9IGEwICogdjA7XG4gIG91dFsxXSA9IGExICogdjA7XG4gIG91dFsyXSA9IGEyICogdjE7XG4gIG91dFszXSA9IGEzICogdjE7XG4gIG91dFs0XSA9IGE0O1xuICBvdXRbNV0gPSBhNTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGVzIHRoZSBtYXQyZCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHRyYW5zbGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV07XG4gIGxldCB2MCA9IHZbMF0sIHYxID0gdlsxXTtcbiAgb3V0WzBdID0gYTA7XG4gIG91dFsxXSA9IGExO1xuICBvdXRbMl0gPSBhMjtcbiAgb3V0WzNdID0gYTM7XG4gIG91dFs0XSA9IGEwICogdjAgKyBhMiAqIHYxICsgYTQ7XG4gIG91dFs1XSA9IGExICogdjAgKyBhMyAqIHYxICsgYTU7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQyZC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQyZC5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIGxldCBzID0gTWF0aC5zaW4ocmFkKSwgYyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IHM7XG4gIG91dFsyXSA9IC1zO1xuICBvdXRbM10gPSBjO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0MmQuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21TY2FsaW5nKG91dCwgdikge1xuICBvdXRbMF0gPSB2WzBdO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSB2WzFdO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDJkLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDJkLnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCBtYXQyZCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21UcmFuc2xhdGlvbihvdXQsIHYpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgb3V0WzRdID0gdlswXTtcbiAgb3V0WzVdID0gdlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gJ21hdDJkKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgK1xuICAgICAgICAgIGFbM10gKyAnLCAnICsgYVs0XSArICcsICcgKyBhWzVdICsgJyknO1xufVxuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9iKGEpIHtcbiAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyAxKSlcbn1cblxuLyoqXG4gKiBBZGRzIHR3byBtYXQyZCdzXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBNdWx0aXBseSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhci5cbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgb3V0WzRdID0gYVs0XSAqIGI7XG4gIG91dFs1XSA9IGFbNV0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDJkJ3MgYWZ0ZXIgbXVsdGlwbHlpbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0MmR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiJ3MgZWxlbWVudHMgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgb3V0WzNdID0gYVszXSArIChiWzNdICogc2NhbGUpO1xuICBvdXRbNF0gPSBhWzRdICsgKGJbNF0gKiBzY2FsZSk7XG4gIG91dFs1XSA9IGFbNV0gKyAoYls1XSAqIHNjYWxlKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQyZH0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM10gJiYgYVs0XSA9PT0gYls0XSAmJiBhWzVdID09PSBiWzVdO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge21hdDJkfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV07XG4gIGxldCBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM10sIGI0ID0gYls0XSwgYjUgPSBiWzVdO1xuICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTQpLCBNYXRoLmFicyhiNCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTUgLSBiNSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE1KSwgTWF0aC5hYnMoYjUpKSk7XG59XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyZC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgbXVsID0gbXVsdGlwbHk7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyZC5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc3ViID0gc3VidHJhY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQyZC5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG5pbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb25cIjtcblxuLyoqXG4gKiA0eDQgTWF0cml4XG4gKiBAbW9kdWxlIG1hdDRcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0NFxuICpcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDE7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAxO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQ0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgb3V0WzldID0gYVs5XTtcbiAgb3V0WzEwXSA9IGFbMTBdO1xuICBvdXRbMTFdID0gYVsxMV07XG4gIG91dFsxMl0gPSBhWzEyXTtcbiAgb3V0WzEzXSA9IGFbMTNdO1xuICBvdXRbMTRdID0gYVsxNF07XG4gIG91dFsxNV0gPSBhWzE1XTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0NCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgb3V0WzldID0gYVs5XTtcbiAgb3V0WzEwXSA9IGFbMTBdO1xuICBvdXRbMTFdID0gYVsxMV07XG4gIG91dFsxMl0gPSBhWzEyXTtcbiAgb3V0WzEzXSA9IGFbMTNdO1xuICBvdXRbMTRdID0gYVsxNF07XG4gIG91dFsxNV0gPSBhWzE1XTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWF0NCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAzIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDMgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDQpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDUpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDIgcG9zaXRpb24gKGluZGV4IDYpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEzIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDMgcG9zaXRpb24gKGluZGV4IDcpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDgpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDkpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDEwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMyBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzAgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMTIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMxIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDEgcG9zaXRpb24gKGluZGV4IDEzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMiBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzMgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTUpXG4gKiBAcmV0dXJucyB7bWF0NH0gQSBuZXcgbWF0NFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyhtMDAsIG0wMSwgbTAyLCBtMDMsIG0xMCwgbTExLCBtMTIsIG0xMywgbTIwLCBtMjEsIG0yMiwgbTIzLCBtMzAsIG0zMSwgbTMyLCBtMzMpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0wMjtcbiAgb3V0WzNdID0gbTAzO1xuICBvdXRbNF0gPSBtMTA7XG4gIG91dFs1XSA9IG0xMTtcbiAgb3V0WzZdID0gbTEyO1xuICBvdXRbN10gPSBtMTM7XG4gIG91dFs4XSA9IG0yMDtcbiAgb3V0WzldID0gbTIxO1xuICBvdXRbMTBdID0gbTIyO1xuICBvdXRbMTFdID0gbTIzO1xuICBvdXRbMTJdID0gbTMwO1xuICBvdXRbMTNdID0gbTMxO1xuICBvdXRbMTRdID0gbTMyO1xuICBvdXRbMTVdID0gbTMzO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDQgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAzIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDMgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDQpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDUpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDIgcG9zaXRpb24gKGluZGV4IDYpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEzIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDMgcG9zaXRpb24gKGluZGV4IDcpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDgpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDkpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDEwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMyBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzAgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMTIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMxIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDEgcG9zaXRpb24gKGluZGV4IDEzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMiBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzMgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTUpXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCBtMDAsIG0wMSwgbTAyLCBtMDMsIG0xMCwgbTExLCBtMTIsIG0xMywgbTIwLCBtMjEsIG0yMiwgbTIzLCBtMzAsIG0zMSwgbTMyLCBtMzMpIHtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0wMjtcbiAgb3V0WzNdID0gbTAzO1xuICBvdXRbNF0gPSBtMTA7XG4gIG91dFs1XSA9IG0xMTtcbiAgb3V0WzZdID0gbTEyO1xuICBvdXRbN10gPSBtMTM7XG4gIG91dFs4XSA9IG0yMDtcbiAgb3V0WzldID0gbTIxO1xuICBvdXRbMTBdID0gbTIyO1xuICBvdXRbMTFdID0gbTIzO1xuICBvdXRbMTJdID0gbTMwO1xuICBvdXRbMTNdID0gbTMxO1xuICBvdXRbMTRdID0gbTMyO1xuICBvdXRbMTVdID0gbTMzO1xuICByZXR1cm4gb3V0O1xufVxuXG5cbi8qKlxuICogU2V0IGEgbWF0NCB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zcG9zZShvdXQsIGEpIHtcbiAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICBpZiAob3V0ID09PSBhKSB7XG4gICAgbGV0IGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM107XG4gICAgbGV0IGExMiA9IGFbNl0sIGExMyA9IGFbN107XG4gICAgbGV0IGEyMyA9IGFbMTFdO1xuXG4gICAgb3V0WzFdID0gYVs0XTtcbiAgICBvdXRbMl0gPSBhWzhdO1xuICAgIG91dFszXSA9IGFbMTJdO1xuICAgIG91dFs0XSA9IGEwMTtcbiAgICBvdXRbNl0gPSBhWzldO1xuICAgIG91dFs3XSA9IGFbMTNdO1xuICAgIG91dFs4XSA9IGEwMjtcbiAgICBvdXRbOV0gPSBhMTI7XG4gICAgb3V0WzExXSA9IGFbMTRdO1xuICAgIG91dFsxMl0gPSBhMDM7XG4gICAgb3V0WzEzXSA9IGExMztcbiAgICBvdXRbMTRdID0gYTIzO1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVs0XTtcbiAgICBvdXRbMl0gPSBhWzhdO1xuICAgIG91dFszXSA9IGFbMTJdO1xuICAgIG91dFs0XSA9IGFbMV07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzldO1xuICAgIG91dFs3XSA9IGFbMTNdO1xuICAgIG91dFs4XSA9IGFbMl07XG4gICAgb3V0WzldID0gYVs2XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTRdO1xuICAgIG91dFsxMl0gPSBhWzNdO1xuICAgIG91dFsxM10gPSBhWzddO1xuICAgIG91dFsxNF0gPSBhWzExXTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEludmVydHMgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICBsZXQgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXTtcbiAgbGV0IGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN107XG4gIGxldCBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV07XG4gIGxldCBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XTtcblxuICBsZXQgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICBsZXQgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICBsZXQgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICBsZXQgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICBsZXQgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICBsZXQgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICBsZXQgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICBsZXQgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICBsZXQgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICBsZXQgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICBsZXQgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICBsZXQgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyO1xuXG4gIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgbGV0IGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGRldCA9IDEuMCAvIGRldDtcblxuICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgb3V0WzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICBvdXRbM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgb3V0WzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gIG91dFs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICBvdXRbNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgb3V0WzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gIG91dFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICBvdXRbOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgb3V0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICBvdXRbMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgb3V0WzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICBvdXRbMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gIGxldCBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdO1xuICBsZXQgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XTtcbiAgbGV0IGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXTtcbiAgbGV0IGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdO1xuXG4gIG91dFswXSAgPSAgKGExMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSk7XG4gIG91dFsxXSAgPSAtKGEwMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XG4gIG91dFsyXSAgPSAgKGEwMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTExICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gIG91dFszXSAgPSAtKGEwMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTExICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gIG91dFs0XSAgPSAtKGExMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSk7XG4gIG91dFs1XSAgPSAgKGEwMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XG4gIG91dFs2XSAgPSAtKGEwMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTEwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gIG91dFs3XSAgPSAgKGEwMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTEwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gIG91dFs4XSAgPSAgKGExMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKSk7XG4gIG91dFs5XSAgPSAtKGEwMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSk7XG4gIG91dFsxMF0gPSAgKGEwMCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gIG91dFsxMV0gPSAtKGEwMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gIG91dFsxMl0gPSAtKGExMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSk7XG4gIG91dFsxM10gPSAgKGEwMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSk7XG4gIG91dFsxNF0gPSAtKGEwMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XG4gIG91dFsxNV0gPSAgKGEwMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIGxldCBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdO1xuICBsZXQgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XTtcbiAgbGV0IGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXTtcbiAgbGV0IGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdO1xuXG4gIGxldCBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIGxldCBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7XG4gIGxldCBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XG4gIGxldCBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIGxldCBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTE7XG4gIGxldCBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XG4gIGxldCBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzA7XG4gIGxldCBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzA7XG4gIGxldCBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7XG4gIGxldCBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzE7XG4gIGxldCBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7XG4gIGxldCBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICByZXR1cm4gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xufVxuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIGxldCBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdO1xuICBsZXQgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XTtcbiAgbGV0IGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXTtcbiAgbGV0IGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdO1xuXG4gIC8vIENhY2hlIG9ubHkgdGhlIGN1cnJlbnQgbGluZSBvZiB0aGUgc2Vjb25kIG1hdHJpeFxuICBsZXQgYjAgID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTtcbiAgb3V0WzBdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICBvdXRbMV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gIG91dFsyXSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgb3V0WzNdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gIGIwID0gYls0XTsgYjEgPSBiWzVdOyBiMiA9IGJbNl07IGIzID0gYls3XTtcbiAgb3V0WzRdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICBvdXRbNV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gIG91dFs2XSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgb3V0WzddID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gIGIwID0gYls4XTsgYjEgPSBiWzldOyBiMiA9IGJbMTBdOyBiMyA9IGJbMTFdO1xuICBvdXRbOF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gIG91dFs5XSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgb3V0WzEwXSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgb3V0WzExXSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICBiMCA9IGJbMTJdOyBiMSA9IGJbMTNdOyBiMiA9IGJbMTRdOyBiMyA9IGJbMTVdO1xuICBvdXRbMTJdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICBvdXRbMTNdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICBvdXRbMTRdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICBvdXRbMTVdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZSBhIG1hdDQgYnkgdGhlIGdpdmVuIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjM30gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gIGxldCB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdO1xuICBsZXQgYTAwLCBhMDEsIGEwMiwgYTAzO1xuICBsZXQgYTEwLCBhMTEsIGExMiwgYTEzO1xuICBsZXQgYTIwLCBhMjEsIGEyMiwgYTIzO1xuXG4gIGlmIChhID09PSBvdXQpIHtcbiAgICBvdXRbMTJdID0gYVswXSAqIHggKyBhWzRdICogeSArIGFbOF0gKiB6ICsgYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMV0gKiB4ICsgYVs1XSAqIHkgKyBhWzldICogeiArIGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzJdICogeCArIGFbNl0gKiB5ICsgYVsxMF0gKiB6ICsgYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbM10gKiB4ICsgYVs3XSAqIHkgKyBhWzExXSAqIHogKyBhWzE1XTtcbiAgfSBlbHNlIHtcbiAgICBhMDAgPSBhWzBdOyBhMDEgPSBhWzFdOyBhMDIgPSBhWzJdOyBhMDMgPSBhWzNdO1xuICAgIGExMCA9IGFbNF07IGExMSA9IGFbNV07IGExMiA9IGFbNl07IGExMyA9IGFbN107XG4gICAgYTIwID0gYVs4XTsgYTIxID0gYVs5XTsgYTIyID0gYVsxMF07IGEyMyA9IGFbMTFdO1xuXG4gICAgb3V0WzBdID0gYTAwOyBvdXRbMV0gPSBhMDE7IG91dFsyXSA9IGEwMjsgb3V0WzNdID0gYTAzO1xuICAgIG91dFs0XSA9IGExMDsgb3V0WzVdID0gYTExOyBvdXRbNl0gPSBhMTI7IG91dFs3XSA9IGExMztcbiAgICBvdXRbOF0gPSBhMjA7IG91dFs5XSA9IGEyMTsgb3V0WzEwXSA9IGEyMjsgb3V0WzExXSA9IGEyMztcblxuICAgIG91dFsxMl0gPSBhMDAgKiB4ICsgYTEwICogeSArIGEyMCAqIHogKyBhWzEyXTtcbiAgICBvdXRbMTNdID0gYTAxICogeCArIGExMSAqIHkgKyBhMjEgKiB6ICsgYVsxM107XG4gICAgb3V0WzE0XSA9IGEwMiAqIHggKyBhMTIgKiB5ICsgYTIyICogeiArIGFbMTRdO1xuICAgIG91dFsxNV0gPSBhMDMgKiB4ICsgYTEzICogeSArIGEyMyAqIHogKyBhWzE1XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQ0IGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMzIG5vdCB1c2luZyB2ZWN0b3JpemF0aW9uXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdGhlIHZlYzMgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICBsZXQgeCA9IHZbMF0sIHkgPSB2WzFdLCB6ID0gdlsyXTtcblxuICBvdXRbMF0gPSBhWzBdICogeDtcbiAgb3V0WzFdID0gYVsxXSAqIHg7XG4gIG91dFsyXSA9IGFbMl0gKiB4O1xuICBvdXRbM10gPSBhWzNdICogeDtcbiAgb3V0WzRdID0gYVs0XSAqIHk7XG4gIG91dFs1XSA9IGFbNV0gKiB5O1xuICBvdXRbNl0gPSBhWzZdICogeTtcbiAgb3V0WzddID0gYVs3XSAqIHk7XG4gIG91dFs4XSA9IGFbOF0gKiB6O1xuICBvdXRbOV0gPSBhWzldICogejtcbiAgb3V0WzEwXSA9IGFbMTBdICogejtcbiAgb3V0WzExXSA9IGFbMTFdICogejtcbiAgb3V0WzEyXSA9IGFbMTJdO1xuICBvdXRbMTNdID0gYVsxM107XG4gIG91dFsxNF0gPSBhWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQ0IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIGdpdmVuIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCwgYXhpcykge1xuICBsZXQgeCA9IGF4aXNbMF0sIHkgPSBheGlzWzFdLCB6ID0gYXhpc1syXTtcbiAgbGV0IGxlbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xuICBsZXQgcywgYywgdDtcbiAgbGV0IGEwMCwgYTAxLCBhMDIsIGEwMztcbiAgbGV0IGExMCwgYTExLCBhMTIsIGExMztcbiAgbGV0IGEyMCwgYTIxLCBhMjIsIGEyMztcbiAgbGV0IGIwMCwgYjAxLCBiMDI7XG4gIGxldCBiMTAsIGIxMSwgYjEyO1xuICBsZXQgYjIwLCBiMjEsIGIyMjtcblxuICBpZiAoTWF0aC5hYnMobGVuKSA8IGdsTWF0cml4LkVQU0lMT04pIHsgcmV0dXJuIG51bGw7IH1cblxuICBsZW4gPSAxIC8gbGVuO1xuICB4ICo9IGxlbjtcbiAgeSAqPSBsZW47XG4gIHogKj0gbGVuO1xuXG4gIHMgPSBNYXRoLnNpbihyYWQpO1xuICBjID0gTWF0aC5jb3MocmFkKTtcbiAgdCA9IDEgLSBjO1xuXG4gIGEwMCA9IGFbMF07IGEwMSA9IGFbMV07IGEwMiA9IGFbMl07IGEwMyA9IGFbM107XG4gIGExMCA9IGFbNF07IGExMSA9IGFbNV07IGExMiA9IGFbNl07IGExMyA9IGFbN107XG4gIGEyMCA9IGFbOF07IGEyMSA9IGFbOV07IGEyMiA9IGFbMTBdOyBhMjMgPSBhWzExXTtcblxuICAvLyBDb25zdHJ1Y3QgdGhlIGVsZW1lbnRzIG9mIHRoZSByb3RhdGlvbiBtYXRyaXhcbiAgYjAwID0geCAqIHggKiB0ICsgYzsgYjAxID0geSAqIHggKiB0ICsgeiAqIHM7IGIwMiA9IHogKiB4ICogdCAtIHkgKiBzO1xuICBiMTAgPSB4ICogeSAqIHQgLSB6ICogczsgYjExID0geSAqIHkgKiB0ICsgYzsgYjEyID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gIGIyMCA9IHggKiB6ICogdCArIHkgKiBzOyBiMjEgPSB5ICogeiAqIHQgLSB4ICogczsgYjIyID0geiAqIHogKiB0ICsgYztcblxuICAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICBvdXRbMF0gPSBhMDAgKiBiMDAgKyBhMTAgKiBiMDEgKyBhMjAgKiBiMDI7XG4gIG91dFsxXSA9IGEwMSAqIGIwMCArIGExMSAqIGIwMSArIGEyMSAqIGIwMjtcbiAgb3V0WzJdID0gYTAyICogYjAwICsgYTEyICogYjAxICsgYTIyICogYjAyO1xuICBvdXRbM10gPSBhMDMgKiBiMDAgKyBhMTMgKiBiMDEgKyBhMjMgKiBiMDI7XG4gIG91dFs0XSA9IGEwMCAqIGIxMCArIGExMCAqIGIxMSArIGEyMCAqIGIxMjtcbiAgb3V0WzVdID0gYTAxICogYjEwICsgYTExICogYjExICsgYTIxICogYjEyO1xuICBvdXRbNl0gPSBhMDIgKiBiMTAgKyBhMTIgKiBiMTEgKyBhMjIgKiBiMTI7XG4gIG91dFs3XSA9IGEwMyAqIGIxMCArIGExMyAqIGIxMSArIGEyMyAqIGIxMjtcbiAgb3V0WzhdID0gYTAwICogYjIwICsgYTEwICogYjIxICsgYTIwICogYjIyO1xuICBvdXRbOV0gPSBhMDEgKiBiMjAgKyBhMTEgKiBiMjEgKyBhMjEgKiBiMjI7XG4gIG91dFsxMF0gPSBhMDIgKiBiMjAgKyBhMTIgKiBiMjEgKyBhMjIgKiBiMjI7XG4gIG91dFsxMV0gPSBhMDMgKiBiMjAgKyBhMTMgKiBiMjEgKyBhMjMgKiBiMjI7XG5cbiAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVgob3V0LCBhLCByYWQpIHtcbiAgbGV0IHMgPSBNYXRoLnNpbihyYWQpO1xuICBsZXQgYyA9IE1hdGguY29zKHJhZCk7XG4gIGxldCBhMTAgPSBhWzRdO1xuICBsZXQgYTExID0gYVs1XTtcbiAgbGV0IGExMiA9IGFbNl07XG4gIGxldCBhMTMgPSBhWzddO1xuICBsZXQgYTIwID0gYVs4XTtcbiAgbGV0IGEyMSA9IGFbOV07XG4gIGxldCBhMjIgPSBhWzEwXTtcbiAgbGV0IGEyMyA9IGFbMTFdO1xuXG4gIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgIG91dFswXSAgPSBhWzBdO1xuICAgIG91dFsxXSAgPSBhWzFdO1xuICAgIG91dFsyXSAgPSBhWzJdO1xuICAgIG91dFszXSAgPSBhWzNdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgb3V0WzRdID0gYTEwICogYyArIGEyMCAqIHM7XG4gIG91dFs1XSA9IGExMSAqIGMgKyBhMjEgKiBzO1xuICBvdXRbNl0gPSBhMTIgKiBjICsgYTIyICogcztcbiAgb3V0WzddID0gYTEzICogYyArIGEyMyAqIHM7XG4gIG91dFs4XSA9IGEyMCAqIGMgLSBhMTAgKiBzO1xuICBvdXRbOV0gPSBhMjEgKiBjIC0gYTExICogcztcbiAgb3V0WzEwXSA9IGEyMiAqIGMgLSBhMTIgKiBzO1xuICBvdXRbMTFdID0gYTIzICogYyAtIGExMyAqIHM7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIHJhZCkge1xuICBsZXQgcyA9IE1hdGguc2luKHJhZCk7XG4gIGxldCBjID0gTWF0aC5jb3MocmFkKTtcbiAgbGV0IGEwMCA9IGFbMF07XG4gIGxldCBhMDEgPSBhWzFdO1xuICBsZXQgYTAyID0gYVsyXTtcbiAgbGV0IGEwMyA9IGFbM107XG4gIGxldCBhMjAgPSBhWzhdO1xuICBsZXQgYTIxID0gYVs5XTtcbiAgbGV0IGEyMiA9IGFbMTBdO1xuICBsZXQgYTIzID0gYVsxMV07XG5cbiAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgb3V0WzRdICA9IGFbNF07XG4gICAgb3V0WzVdICA9IGFbNV07XG4gICAgb3V0WzZdICA9IGFbNl07XG4gICAgb3V0WzddICA9IGFbN107XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9XG5cbiAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICBvdXRbMF0gPSBhMDAgKiBjIC0gYTIwICogcztcbiAgb3V0WzFdID0gYTAxICogYyAtIGEyMSAqIHM7XG4gIG91dFsyXSA9IGEwMiAqIGMgLSBhMjIgKiBzO1xuICBvdXRbM10gPSBhMDMgKiBjIC0gYTIzICogcztcbiAgb3V0WzhdID0gYTAwICogcyArIGEyMCAqIGM7XG4gIG91dFs5XSA9IGEwMSAqIHMgKyBhMjEgKiBjO1xuICBvdXRbMTBdID0gYTAyICogcyArIGEyMiAqIGM7XG4gIG91dFsxMV0gPSBhMDMgKiBzICsgYTIzICogYztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgcmFkKSB7XG4gIGxldCBzID0gTWF0aC5zaW4ocmFkKTtcbiAgbGV0IGMgPSBNYXRoLmNvcyhyYWQpO1xuICBsZXQgYTAwID0gYVswXTtcbiAgbGV0IGEwMSA9IGFbMV07XG4gIGxldCBhMDIgPSBhWzJdO1xuICBsZXQgYTAzID0gYVszXTtcbiAgbGV0IGExMCA9IGFbNF07XG4gIGxldCBhMTEgPSBhWzVdO1xuICBsZXQgYTEyID0gYVs2XTtcbiAgbGV0IGExMyA9IGFbN107XG5cbiAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgIG91dFs4XSAgPSBhWzhdO1xuICAgIG91dFs5XSAgPSBhWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9XG5cbiAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICBvdXRbMF0gPSBhMDAgKiBjICsgYTEwICogcztcbiAgb3V0WzFdID0gYTAxICogYyArIGExMSAqIHM7XG4gIG91dFsyXSA9IGEwMiAqIGMgKyBhMTIgKiBzO1xuICBvdXRbM10gPSBhMDMgKiBjICsgYTEzICogcztcbiAgb3V0WzRdID0gYTEwICogYyAtIGEwMCAqIHM7XG4gIG91dFs1XSA9IGExMSAqIGMgLSBhMDEgKiBzO1xuICBvdXRbNl0gPSBhMTIgKiBjIC0gYTAyICogcztcbiAgb3V0WzddID0gYTEzICogYyAtIGEwMyAqIHM7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21UcmFuc2xhdGlvbihvdXQsIHYpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXTtcbiAgb3V0WzEzXSA9IHZbMV07XG4gIG91dFsxNF0gPSB2WzJdO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjM30gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IHZbMV07XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSB2WzJdO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGUgYXJvdW5kIGEgZ2l2ZW4gYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkLCBheGlzKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHJhZCwgYXhpcykge1xuICBsZXQgeCA9IGF4aXNbMF0sIHkgPSBheGlzWzFdLCB6ID0gYXhpc1syXTtcbiAgbGV0IGxlbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xuICBsZXQgcywgYywgdDtcblxuICBpZiAoTWF0aC5hYnMobGVuKSA8IGdsTWF0cml4LkVQU0lMT04pIHsgcmV0dXJuIG51bGw7IH1cblxuICBsZW4gPSAxIC8gbGVuO1xuICB4ICo9IGxlbjtcbiAgeSAqPSBsZW47XG4gIHogKj0gbGVuO1xuXG4gIHMgPSBNYXRoLnNpbihyYWQpO1xuICBjID0gTWF0aC5jb3MocmFkKTtcbiAgdCA9IDEgLSBjO1xuXG4gIC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gIG91dFswXSA9IHggKiB4ICogdCArIGM7XG4gIG91dFsxXSA9IHkgKiB4ICogdCArIHogKiBzO1xuICBvdXRbMl0gPSB6ICogeCAqIHQgLSB5ICogcztcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0geCAqIHkgKiB0IC0geiAqIHM7XG4gIG91dFs1XSA9IHkgKiB5ICogdCArIGM7XG4gIG91dFs2XSA9IHogKiB5ICogdCArIHggKiBzO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB4ICogeiAqIHQgKyB5ICogcztcbiAgb3V0WzldID0geSAqIHogKiB0IC0geCAqIHM7XG4gIG91dFsxMF0gPSB6ICogeiAqIHQgKyBjO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5yb3RhdGVYKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21YUm90YXRpb24ob3V0LCByYWQpIHtcbiAgbGV0IHMgPSBNYXRoLnNpbihyYWQpO1xuICBsZXQgYyA9IE1hdGguY29zKHJhZCk7XG5cbiAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICBvdXRbMF0gID0gMTtcbiAgb3V0WzFdICA9IDA7XG4gIG91dFsyXSAgPSAwO1xuICBvdXRbM10gID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gYztcbiAgb3V0WzZdID0gcztcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gLXM7XG4gIG91dFsxMF0gPSBjO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5yb3RhdGVZKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21ZUm90YXRpb24ob3V0LCByYWQpIHtcbiAgbGV0IHMgPSBNYXRoLnNpbihyYWQpO1xuICBsZXQgYyA9IE1hdGguY29zKHJhZCk7XG5cbiAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICBvdXRbMF0gID0gYztcbiAgb3V0WzFdICA9IDA7XG4gIG91dFsyXSAgPSAtcztcbiAgb3V0WzNdICA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDE7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHM7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSBjO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5yb3RhdGVaKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21aUm90YXRpb24ob3V0LCByYWQpIHtcbiAgbGV0IHMgPSBNYXRoLnNpbihyYWQpO1xuICBsZXQgYyA9IE1hdGguY29zKHJhZCk7XG5cbiAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICBvdXRbMF0gID0gYztcbiAgb3V0WzFdICA9IHM7XG4gIG91dFsyXSAgPSAwO1xuICBvdXRbM10gID0gMDtcbiAgb3V0WzRdID0gLXM7XG4gIG91dFs1XSA9IGM7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAxO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiBhbmQgdmVjdG9yIHRyYW5zbGF0aW9uXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKG91dCwgcSwgdikge1xuICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgbGV0IHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdO1xuICBsZXQgeDIgPSB4ICsgeDtcbiAgbGV0IHkyID0geSArIHk7XG4gIGxldCB6MiA9IHogKyB6O1xuXG4gIGxldCB4eCA9IHggKiB4MjtcbiAgbGV0IHh5ID0geCAqIHkyO1xuICBsZXQgeHogPSB4ICogejI7XG4gIGxldCB5eSA9IHkgKiB5MjtcbiAgbGV0IHl6ID0geSAqIHoyO1xuICBsZXQgenogPSB6ICogejI7XG4gIGxldCB3eCA9IHcgKiB4MjtcbiAgbGV0IHd5ID0gdyAqIHkyO1xuICBsZXQgd3ogPSB3ICogejI7XG5cbiAgb3V0WzBdID0gMSAtICh5eSArIHp6KTtcbiAgb3V0WzFdID0geHkgKyB3ejtcbiAgb3V0WzJdID0geHogLSB3eTtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0geHkgLSB3ejtcbiAgb3V0WzVdID0gMSAtICh4eCArIHp6KTtcbiAgb3V0WzZdID0geXogKyB3eDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0geHogKyB3eTtcbiAgb3V0WzldID0geXogLSB3eDtcbiAgb3V0WzEwXSA9IDEgLSAoeHggKyB5eSk7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXTtcbiAgb3V0WzEzXSA9IHZbMV07XG4gIG91dFsxNF0gPSB2WzJdO1xuICBvdXRbMTVdID0gMTtcblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uIHZlY3RvciBjb21wb25lbnQgb2YgYSB0cmFuc2Zvcm1hdGlvblxuICogIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aCBmcm9tUm90YXRpb25UcmFuc2xhdGlvbixcbiAqICB0aGUgcmV0dXJuZWQgdmVjdG9yIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIHRyYW5zbGF0aW9uIHZlY3RvclxuICogIG9yaWdpbmFsbHkgc3VwcGxpZWQuXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXQgVmVjdG9yIHRvIHJlY2VpdmUgdHJhbnNsYXRpb24gY29tcG9uZW50XG4gKiBAcGFyYW0gIHttYXQ0fSBtYXQgTWF0cml4IHRvIGJlIGRlY29tcG9zZWQgKGlucHV0KVxuICogQHJldHVybiB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2xhdGlvbihvdXQsIG1hdCkge1xuICBvdXRbMF0gPSBtYXRbMTJdO1xuICBvdXRbMV0gPSBtYXRbMTNdO1xuICBvdXRbMl0gPSBtYXRbMTRdO1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2NhbGluZyBmYWN0b3IgY29tcG9uZW50IG9mIGEgdHJhbnNmb3JtYXRpb25cbiAqICBtYXRyaXguIElmIGEgbWF0cml4IGlzIGJ1aWx0IHdpdGggZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZVxuICogIHdpdGggYSBub3JtYWxpemVkIFF1YXRlcm5pb24gcGFyYW10ZXIsIHRoZSByZXR1cm5lZCB2ZWN0b3Igd2lsbCBiZVxuICogIHRoZSBzYW1lIGFzIHRoZSBzY2FsaW5nIHZlY3RvclxuICogIG9yaWdpbmFsbHkgc3VwcGxpZWQuXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXQgVmVjdG9yIHRvIHJlY2VpdmUgc2NhbGluZyBmYWN0b3IgY29tcG9uZW50XG4gKiBAcGFyYW0gIHttYXQ0fSBtYXQgTWF0cml4IHRvIGJlIGRlY29tcG9zZWQgKGlucHV0KVxuICogQHJldHVybiB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2FsaW5nKG91dCwgbWF0KSB7XG4gIGxldCBtMTEgPSBtYXRbMF07XG4gIGxldCBtMTIgPSBtYXRbMV07XG4gIGxldCBtMTMgPSBtYXRbMl07XG4gIGxldCBtMjEgPSBtYXRbNF07XG4gIGxldCBtMjIgPSBtYXRbNV07XG4gIGxldCBtMjMgPSBtYXRbNl07XG4gIGxldCBtMzEgPSBtYXRbOF07XG4gIGxldCBtMzIgPSBtYXRbOV07XG4gIGxldCBtMzMgPSBtYXRbMTBdO1xuXG4gIG91dFswXSA9IE1hdGguc3FydChtMTEgKiBtMTEgKyBtMTIgKiBtMTIgKyBtMTMgKiBtMTMpO1xuICBvdXRbMV0gPSBNYXRoLnNxcnQobTIxICogbTIxICsgbTIyICogbTIyICsgbTIzICogbTIzKTtcbiAgb3V0WzJdID0gTWF0aC5zcXJ0KG0zMSAqIG0zMSArIG0zMiAqIG0zMiArIG0zMyAqIG0zMyk7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcXVhdGVybmlvbiByZXByZXNlbnRpbmcgdGhlIHJvdGF0aW9uYWwgY29tcG9uZW50XG4gKiAgb2YgYSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguIElmIGEgbWF0cml4IGlzIGJ1aWx0IHdpdGhcbiAqICBmcm9tUm90YXRpb25UcmFuc2xhdGlvbiwgdGhlIHJldHVybmVkIHF1YXRlcm5pb24gd2lsbCBiZSB0aGVcbiAqICBzYW1lIGFzIHRoZSBxdWF0ZXJuaW9uIG9yaWdpbmFsbHkgc3VwcGxpZWQuXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBRdWF0ZXJuaW9uIHRvIHJlY2VpdmUgdGhlIHJvdGF0aW9uIGNvbXBvbmVudFxuICogQHBhcmFtIHttYXQ0fSBtYXQgTWF0cml4IHRvIGJlIGRlY29tcG9zZWQgKGlucHV0KVxuICogQHJldHVybiB7cXVhdH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3RhdGlvbihvdXQsIG1hdCkge1xuICAvLyBBbGdvcml0aG0gdGFrZW4gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuICBsZXQgdHJhY2UgPSBtYXRbMF0gKyBtYXRbNV0gKyBtYXRbMTBdO1xuICBsZXQgUyA9IDA7XG5cbiAgaWYgKHRyYWNlID4gMCkge1xuICAgIFMgPSBNYXRoLnNxcnQodHJhY2UgKyAxLjApICogMjtcbiAgICBvdXRbM10gPSAwLjI1ICogUztcbiAgICBvdXRbMF0gPSAobWF0WzZdIC0gbWF0WzldKSAvIFM7XG4gICAgb3V0WzFdID0gKG1hdFs4XSAtIG1hdFsyXSkgLyBTO1xuICAgIG91dFsyXSA9IChtYXRbMV0gLSBtYXRbNF0pIC8gUztcbiAgfSBlbHNlIGlmICgobWF0WzBdID4gbWF0WzVdKSYobWF0WzBdID4gbWF0WzEwXSkpIHtcbiAgICBTID0gTWF0aC5zcXJ0KDEuMCArIG1hdFswXSAtIG1hdFs1XSAtIG1hdFsxMF0pICogMjtcbiAgICBvdXRbM10gPSAobWF0WzZdIC0gbWF0WzldKSAvIFM7XG4gICAgb3V0WzBdID0gMC4yNSAqIFM7XG4gICAgb3V0WzFdID0gKG1hdFsxXSArIG1hdFs0XSkgLyBTO1xuICAgIG91dFsyXSA9IChtYXRbOF0gKyBtYXRbMl0pIC8gUztcbiAgfSBlbHNlIGlmIChtYXRbNV0gPiBtYXRbMTBdKSB7XG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBtYXRbNV0gLSBtYXRbMF0gLSBtYXRbMTBdKSAqIDI7XG4gICAgb3V0WzNdID0gKG1hdFs4XSAtIG1hdFsyXSkgLyBTO1xuICAgIG91dFswXSA9IChtYXRbMV0gKyBtYXRbNF0pIC8gUztcbiAgICBvdXRbMV0gPSAwLjI1ICogUztcbiAgICBvdXRbMl0gPSAobWF0WzZdICsgbWF0WzldKSAvIFM7XG4gIH0gZWxzZSB7XG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBtYXRbMTBdIC0gbWF0WzBdIC0gbWF0WzVdKSAqIDI7XG4gICAgb3V0WzNdID0gKG1hdFsxXSAtIG1hdFs0XSkgLyBTO1xuICAgIG91dFswXSA9IChtYXRbOF0gKyBtYXRbMl0pIC8gUztcbiAgICBvdXRbMV0gPSAobWF0WzZdICsgbWF0WzldKSAvIFM7XG4gICAgb3V0WzJdID0gMC4yNSAqIFM7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24sIHZlY3RvciB0cmFuc2xhdGlvbiBhbmQgdmVjdG9yIHNjYWxlXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIHNjYWxlKVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBzIFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlKG91dCwgcSwgdiwgcykge1xuICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgbGV0IHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdO1xuICBsZXQgeDIgPSB4ICsgeDtcbiAgbGV0IHkyID0geSArIHk7XG4gIGxldCB6MiA9IHogKyB6O1xuXG4gIGxldCB4eCA9IHggKiB4MjtcbiAgbGV0IHh5ID0geCAqIHkyO1xuICBsZXQgeHogPSB4ICogejI7XG4gIGxldCB5eSA9IHkgKiB5MjtcbiAgbGV0IHl6ID0geSAqIHoyO1xuICBsZXQgenogPSB6ICogejI7XG4gIGxldCB3eCA9IHcgKiB4MjtcbiAgbGV0IHd5ID0gdyAqIHkyO1xuICBsZXQgd3ogPSB3ICogejI7XG4gIGxldCBzeCA9IHNbMF07XG4gIGxldCBzeSA9IHNbMV07XG4gIGxldCBzeiA9IHNbMl07XG5cbiAgb3V0WzBdID0gKDEgLSAoeXkgKyB6eikpICogc3g7XG4gIG91dFsxXSA9ICh4eSArIHd6KSAqIHN4O1xuICBvdXRbMl0gPSAoeHogLSB3eSkgKiBzeDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gKHh5IC0gd3opICogc3k7XG4gIG91dFs1XSA9ICgxIC0gKHh4ICsgenopKSAqIHN5O1xuICBvdXRbNl0gPSAoeXogKyB3eCkgKiBzeTtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gKHh6ICsgd3kpICogc3o7XG4gIG91dFs5XSA9ICh5eiAtIHd4KSAqIHN6O1xuICBvdXRbMTBdID0gKDEgLSAoeHggKyB5eSkpICogc3o7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXTtcbiAgb3V0WzEzXSA9IHZbMV07XG4gIG91dFsxNF0gPSB2WzJdO1xuICBvdXRbMTVdID0gMTtcblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24sIHZlY3RvciB0cmFuc2xhdGlvbiBhbmQgdmVjdG9yIHNjYWxlLCByb3RhdGluZyBhbmQgc2NhbGluZyBhcm91bmQgdGhlIGdpdmVuIG9yaWdpblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBvcmlnaW4pO1xuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIHNjYWxlKVxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIG5lZ2F0aXZlT3JpZ2luKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gcyBTY2FsaW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBvIFRoZSBvcmlnaW4gdmVjdG9yIGFyb3VuZCB3aGljaCB0byBzY2FsZSBhbmQgcm90YXRlXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlT3JpZ2luKG91dCwgcSwgdiwgcywgbykge1xuICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgbGV0IHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdO1xuICBsZXQgeDIgPSB4ICsgeDtcbiAgbGV0IHkyID0geSArIHk7XG4gIGxldCB6MiA9IHogKyB6O1xuXG4gIGxldCB4eCA9IHggKiB4MjtcbiAgbGV0IHh5ID0geCAqIHkyO1xuICBsZXQgeHogPSB4ICogejI7XG4gIGxldCB5eSA9IHkgKiB5MjtcbiAgbGV0IHl6ID0geSAqIHoyO1xuICBsZXQgenogPSB6ICogejI7XG4gIGxldCB3eCA9IHcgKiB4MjtcbiAgbGV0IHd5ID0gdyAqIHkyO1xuICBsZXQgd3ogPSB3ICogejI7XG5cbiAgbGV0IHN4ID0gc1swXTtcbiAgbGV0IHN5ID0gc1sxXTtcbiAgbGV0IHN6ID0gc1syXTtcblxuICBsZXQgb3ggPSBvWzBdO1xuICBsZXQgb3kgPSBvWzFdO1xuICBsZXQgb3ogPSBvWzJdO1xuXG4gIG91dFswXSA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xuICBvdXRbMV0gPSAoeHkgKyB3eikgKiBzeDtcbiAgb3V0WzJdID0gKHh6IC0gd3kpICogc3g7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9ICh4eSAtIHd6KSAqIHN5O1xuICBvdXRbNV0gPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgb3V0WzZdID0gKHl6ICsgd3gpICogc3k7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9ICh4eiArIHd5KSAqIHN6O1xuICBvdXRbOV0gPSAoeXogLSB3eCkgKiBzejtcbiAgb3V0WzEwXSA9ICgxIC0gKHh4ICsgeXkpKSAqIHN6O1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF0gKyBveCAtIChvdXRbMF0gKiBveCArIG91dFs0XSAqIG95ICsgb3V0WzhdICogb3opO1xuICBvdXRbMTNdID0gdlsxXSArIG95IC0gKG91dFsxXSAqIG94ICsgb3V0WzVdICogb3kgKyBvdXRbOV0gKiBveik7XG4gIG91dFsxNF0gPSB2WzJdICsgb3ogLSAob3V0WzJdICogb3ggKyBvdXRbNl0gKiBveSArIG91dFsxMF0gKiBveik7XG4gIG91dFsxNV0gPSAxO1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBhIDR4NCBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gcXVhdGVybmlvblxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gcSBRdWF0ZXJuaW9uIHRvIGNyZWF0ZSBtYXRyaXggZnJvbVxuICpcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21RdWF0KG91dCwgcSkge1xuICBsZXQgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM107XG4gIGxldCB4MiA9IHggKyB4O1xuICBsZXQgeTIgPSB5ICsgeTtcbiAgbGV0IHoyID0geiArIHo7XG5cbiAgbGV0IHh4ID0geCAqIHgyO1xuICBsZXQgeXggPSB5ICogeDI7XG4gIGxldCB5eSA9IHkgKiB5MjtcbiAgbGV0IHp4ID0geiAqIHgyO1xuICBsZXQgenkgPSB6ICogeTI7XG4gIGxldCB6eiA9IHogKiB6MjtcbiAgbGV0IHd4ID0gdyAqIHgyO1xuICBsZXQgd3kgPSB3ICogeTI7XG4gIGxldCB3eiA9IHcgKiB6MjtcblxuICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgb3V0WzFdID0geXggKyB3ejtcbiAgb3V0WzJdID0genggLSB3eTtcbiAgb3V0WzNdID0gMDtcblxuICBvdXRbNF0gPSB5eCAtIHd6O1xuICBvdXRbNV0gPSAxIC0geHggLSB6ejtcbiAgb3V0WzZdID0genkgKyB3eDtcbiAgb3V0WzddID0gMDtcblxuICBvdXRbOF0gPSB6eCArIHd5O1xuICBvdXRbOV0gPSB6eSAtIHd4O1xuICBvdXRbMTBdID0gMSAtIHh4IC0geXk7XG4gIG91dFsxMV0gPSAwO1xuXG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgZnJ1c3R1bSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcnVzdHVtKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgbGV0IHJsID0gMSAvIChyaWdodCAtIGxlZnQpO1xuICBsZXQgdGIgPSAxIC8gKHRvcCAtIGJvdHRvbSk7XG4gIGxldCBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gIG91dFswXSA9IChuZWFyICogMikgKiBybDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gKG5lYXIgKiAyKSAqIHRiO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAocmlnaHQgKyBsZWZ0KSAqIHJsO1xuICBvdXRbOV0gPSAodG9wICsgYm90dG9tKSAqIHRiO1xuICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gIG91dFsxMV0gPSAtMTtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gKGZhciAqIG5lYXIgKiAyKSAqIG5mO1xuICBvdXRbMTVdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gZm92eSBWZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IGluIHJhZGlhbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBhc3BlY3QgQXNwZWN0IHJhdGlvLiB0eXBpY2FsbHkgdmlld3BvcnQgd2lkdGgvaGVpZ2h0XG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcGVyc3BlY3RpdmUob3V0LCBmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikge1xuICBsZXQgZiA9IDEuMCAvIE1hdGgudGFuKGZvdnkgLyAyKTtcbiAgbGV0IG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzBdID0gZiAvIGFzcGVjdDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gZjtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICBvdXRbMTFdID0gLTE7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9ICgyICogZmFyICogbmVhcikgKiBuZjtcbiAgb3V0WzE1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZmllbGQgb2Ygdmlldy5cbiAqIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWZ1bCBmb3IgZ2VuZXJhdGluZyBwcm9qZWN0aW9uIG1hdHJpY2VzIHRvIGJlIHVzZWRcbiAqIHdpdGggdGhlIHN0aWxsIGV4cGVyaWVtZW50YWwgV2ViVlIgQVBJLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7T2JqZWN0fSBmb3YgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyB2YWx1ZXM6IHVwRGVncmVlcywgZG93bkRlZ3JlZXMsIGxlZnREZWdyZWVzLCByaWdodERlZ3JlZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldyhvdXQsIGZvdiwgbmVhciwgZmFyKSB7XG4gIGxldCB1cFRhbiA9IE1hdGgudGFuKGZvdi51cERlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKTtcbiAgbGV0IGRvd25UYW4gPSBNYXRoLnRhbihmb3YuZG93bkRlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKTtcbiAgbGV0IGxlZnRUYW4gPSBNYXRoLnRhbihmb3YubGVmdERlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKTtcbiAgbGV0IHJpZ2h0VGFuID0gTWF0aC50YW4oZm92LnJpZ2h0RGVncmVlcyAqIE1hdGguUEkvMTgwLjApO1xuICBsZXQgeFNjYWxlID0gMi4wIC8gKGxlZnRUYW4gKyByaWdodFRhbik7XG4gIGxldCB5U2NhbGUgPSAyLjAgLyAodXBUYW4gKyBkb3duVGFuKTtcblxuICBvdXRbMF0gPSB4U2NhbGU7XG4gIG91dFsxXSA9IDAuMDtcbiAgb3V0WzJdID0gMC4wO1xuICBvdXRbM10gPSAwLjA7XG4gIG91dFs0XSA9IDAuMDtcbiAgb3V0WzVdID0geVNjYWxlO1xuICBvdXRbNl0gPSAwLjA7XG4gIG91dFs3XSA9IDAuMDtcbiAgb3V0WzhdID0gLSgobGVmdFRhbiAtIHJpZ2h0VGFuKSAqIHhTY2FsZSAqIDAuNSk7XG4gIG91dFs5XSA9ICgodXBUYW4gLSBkb3duVGFuKSAqIHlTY2FsZSAqIDAuNSk7XG4gIG91dFsxMF0gPSBmYXIgLyAobmVhciAtIGZhcik7XG4gIG91dFsxMV0gPSAtMS4wO1xuICBvdXRbMTJdID0gMC4wO1xuICBvdXRbMTNdID0gMC4wO1xuICBvdXRbMTRdID0gKGZhciAqIG5lYXIpIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMTVdID0gMC4wO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIG9ydGhvZ29uYWwgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvcnRobyhvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gIGxldCBsciA9IDEgLyAobGVmdCAtIHJpZ2h0KTtcbiAgbGV0IGJ0ID0gMSAvIChib3R0b20gLSB0b3ApO1xuICBsZXQgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMF0gPSAtMiAqIGxyO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAtMiAqIGJ0O1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gMiAqIG5mO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IChsZWZ0ICsgcmlnaHQpICogbHI7XG4gIG91dFsxM10gPSAodG9wICsgYm90dG9tKSAqIGJ0O1xuICBvdXRbMTRdID0gKGZhciArIG5lYXIpICogbmY7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGxvb2stYXQgbWF0cml4IHdpdGggdGhlIGdpdmVuIGV5ZSBwb3NpdGlvbiwgZm9jYWwgcG9pbnQsIGFuZCB1cCBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHt2ZWMzfSBleWUgUG9zaXRpb24gb2YgdGhlIHZpZXdlclxuICogQHBhcmFtIHt2ZWMzfSBjZW50ZXIgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XG4gKiBAcGFyYW0ge3ZlYzN9IHVwIHZlYzMgcG9pbnRpbmcgdXBcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvb2tBdChvdXQsIGV5ZSwgY2VudGVyLCB1cCkge1xuICBsZXQgeDAsIHgxLCB4MiwgeTAsIHkxLCB5MiwgejAsIHoxLCB6MiwgbGVuO1xuICBsZXQgZXlleCA9IGV5ZVswXTtcbiAgbGV0IGV5ZXkgPSBleWVbMV07XG4gIGxldCBleWV6ID0gZXllWzJdO1xuICBsZXQgdXB4ID0gdXBbMF07XG4gIGxldCB1cHkgPSB1cFsxXTtcbiAgbGV0IHVweiA9IHVwWzJdO1xuICBsZXQgY2VudGVyeCA9IGNlbnRlclswXTtcbiAgbGV0IGNlbnRlcnkgPSBjZW50ZXJbMV07XG4gIGxldCBjZW50ZXJ6ID0gY2VudGVyWzJdO1xuXG4gIGlmIChNYXRoLmFicyhleWV4IC0gY2VudGVyeCkgPCBnbE1hdHJpeC5FUFNJTE9OICYmXG4gICAgICBNYXRoLmFicyhleWV5IC0gY2VudGVyeSkgPCBnbE1hdHJpeC5FUFNJTE9OICYmXG4gICAgICBNYXRoLmFicyhleWV6IC0gY2VudGVyeikgPCBnbE1hdHJpeC5FUFNJTE9OKSB7XG4gICAgcmV0dXJuIG1hdDQuaWRlbnRpdHkob3V0KTtcbiAgfVxuXG4gIHowID0gZXlleCAtIGNlbnRlcng7XG4gIHoxID0gZXlleSAtIGNlbnRlcnk7XG4gIHoyID0gZXlleiAtIGNlbnRlcno7XG5cbiAgbGVuID0gMSAvIE1hdGguc3FydCh6MCAqIHowICsgejEgKiB6MSArIHoyICogejIpO1xuICB6MCAqPSBsZW47XG4gIHoxICo9IGxlbjtcbiAgejIgKj0gbGVuO1xuXG4gIHgwID0gdXB5ICogejIgLSB1cHogKiB6MTtcbiAgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyO1xuICB4MiA9IHVweCAqIHoxIC0gdXB5ICogejA7XG4gIGxlbiA9IE1hdGguc3FydCh4MCAqIHgwICsgeDEgKiB4MSArIHgyICogeDIpO1xuICBpZiAoIWxlbikge1xuICAgIHgwID0gMDtcbiAgICB4MSA9IDA7XG4gICAgeDIgPSAwO1xuICB9IGVsc2Uge1xuICAgIGxlbiA9IDEgLyBsZW47XG4gICAgeDAgKj0gbGVuO1xuICAgIHgxICo9IGxlbjtcbiAgICB4MiAqPSBsZW47XG4gIH1cblxuICB5MCA9IHoxICogeDIgLSB6MiAqIHgxO1xuICB5MSA9IHoyICogeDAgLSB6MCAqIHgyO1xuICB5MiA9IHowICogeDEgLSB6MSAqIHgwO1xuXG4gIGxlbiA9IE1hdGguc3FydCh5MCAqIHkwICsgeTEgKiB5MSArIHkyICogeTIpO1xuICBpZiAoIWxlbikge1xuICAgIHkwID0gMDtcbiAgICB5MSA9IDA7XG4gICAgeTIgPSAwO1xuICB9IGVsc2Uge1xuICAgIGxlbiA9IDEgLyBsZW47XG4gICAgeTAgKj0gbGVuO1xuICAgIHkxICo9IGxlbjtcbiAgICB5MiAqPSBsZW47XG4gIH1cblxuICBvdXRbMF0gPSB4MDtcbiAgb3V0WzFdID0geTA7XG4gIG91dFsyXSA9IHowO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4MTtcbiAgb3V0WzVdID0geTE7XG4gIG91dFs2XSA9IHoxO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB4MjtcbiAgb3V0WzldID0geTI7XG4gIG91dFsxMF0gPSB6MjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAtKHgwICogZXlleCArIHgxICogZXlleSArIHgyICogZXlleik7XG4gIG91dFsxM10gPSAtKHkwICogZXlleCArIHkxICogZXlleSArIHkyICogZXlleik7XG4gIG91dFsxNF0gPSAtKHowICogZXlleCArIHoxICogZXlleSArIHoyICogZXlleik7XG4gIG91dFsxNV0gPSAxO1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbWF0cml4IHRoYXQgbWFrZXMgc29tZXRoaW5nIGxvb2sgYXQgc29tZXRoaW5nIGVsc2UuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHt2ZWMzfSBleWUgUG9zaXRpb24gb2YgdGhlIHZpZXdlclxuICogQHBhcmFtIHt2ZWMzfSBjZW50ZXIgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XG4gKiBAcGFyYW0ge3ZlYzN9IHVwIHZlYzMgcG9pbnRpbmcgdXBcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRhcmdldFRvKG91dCwgZXllLCB0YXJnZXQsIHVwKSB7XG4gIGxldCBleWV4ID0gZXllWzBdLFxuICAgICAgZXlleSA9IGV5ZVsxXSxcbiAgICAgIGV5ZXogPSBleWVbMl0sXG4gICAgICB1cHggPSB1cFswXSxcbiAgICAgIHVweSA9IHVwWzFdLFxuICAgICAgdXB6ID0gdXBbMl07XG5cbiAgbGV0IHowID0gZXlleCAtIHRhcmdldFswXSxcbiAgICAgIHoxID0gZXlleSAtIHRhcmdldFsxXSxcbiAgICAgIHoyID0gZXlleiAtIHRhcmdldFsyXTtcblxuICBsZXQgbGVuID0gejAqejAgKyB6MSp6MSArIHoyKnoyO1xuICBpZiAobGVuID4gMCkge1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICB6MCAqPSBsZW47XG4gICAgejEgKj0gbGVuO1xuICAgIHoyICo9IGxlbjtcbiAgfVxuXG4gIGxldCB4MCA9IHVweSAqIHoyIC0gdXB6ICogejEsXG4gICAgICB4MSA9IHVweiAqIHowIC0gdXB4ICogejIsXG4gICAgICB4MiA9IHVweCAqIHoxIC0gdXB5ICogejA7XG5cbiAgb3V0WzBdID0geDA7XG4gIG91dFsxXSA9IHgxO1xuICBvdXRbMl0gPSB4MjtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gejEgKiB4MiAtIHoyICogeDE7XG4gIG91dFs1XSA9IHoyICogeDAgLSB6MCAqIHgyO1xuICBvdXRbNl0gPSB6MCAqIHgxIC0gejEgKiB4MDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gejA7XG4gIG91dFs5XSA9IHoxO1xuICBvdXRbMTBdID0gejI7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gZXlleDtcbiAgb3V0WzEzXSA9IGV5ZXk7XG4gIG91dFsxNF0gPSBleWV6O1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiAnbWF0NCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcsICcgK1xuICAgICAgICAgIGFbNF0gKyAnLCAnICsgYVs1XSArICcsICcgKyBhWzZdICsgJywgJyArIGFbN10gKyAnLCAnICtcbiAgICAgICAgICBhWzhdICsgJywgJyArIGFbOV0gKyAnLCAnICsgYVsxMF0gKyAnLCAnICsgYVsxMV0gKyAnLCAnICtcbiAgICAgICAgICBhWzEyXSArICcsICcgKyBhWzEzXSArICcsICcgKyBhWzE0XSArICcsICcgKyBhWzE1XSArICcpJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpICsgTWF0aC5wb3coYVs0XSwgMikgKyBNYXRoLnBvdyhhWzVdLCAyKSArIE1hdGgucG93KGFbNl0sIDIpICsgTWF0aC5wb3coYVs3XSwgMikgKyBNYXRoLnBvdyhhWzhdLCAyKSArIE1hdGgucG93KGFbOV0sIDIpICsgTWF0aC5wb3coYVsxMF0sIDIpICsgTWF0aC5wb3coYVsxMV0sIDIpICsgTWF0aC5wb3coYVsxMl0sIDIpICsgTWF0aC5wb3coYVsxM10sIDIpICsgTWF0aC5wb3coYVsxNF0sIDIpICsgTWF0aC5wb3coYVsxNV0sIDIpICkpXG59XG5cbi8qKlxuICogQWRkcyB0d28gbWF0NCdzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XTtcbiAgb3V0WzddID0gYVs3XSArIGJbN107XG4gIG91dFs4XSA9IGFbOF0gKyBiWzhdO1xuICBvdXRbOV0gPSBhWzldICsgYls5XTtcbiAgb3V0WzEwXSA9IGFbMTBdICsgYlsxMF07XG4gIG91dFsxMV0gPSBhWzExXSArIGJbMTFdO1xuICBvdXRbMTJdID0gYVsxMl0gKyBiWzEyXTtcbiAgb3V0WzEzXSA9IGFbMTNdICsgYlsxM107XG4gIG91dFsxNF0gPSBhWzE0XSArIGJbMTRdO1xuICBvdXRbMTVdID0gYVsxNV0gKyBiWzE1XTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgb3V0WzRdID0gYVs0XSAtIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gLSBiWzVdO1xuICBvdXRbNl0gPSBhWzZdIC0gYls2XTtcbiAgb3V0WzddID0gYVs3XSAtIGJbN107XG4gIG91dFs4XSA9IGFbOF0gLSBiWzhdO1xuICBvdXRbOV0gPSBhWzldIC0gYls5XTtcbiAgb3V0WzEwXSA9IGFbMTBdIC0gYlsxMF07XG4gIG91dFsxMV0gPSBhWzExXSAtIGJbMTFdO1xuICBvdXRbMTJdID0gYVsxMl0gLSBiWzEyXTtcbiAgb3V0WzEzXSA9IGFbMTNdIC0gYlsxM107XG4gIG91dFsxNF0gPSBhWzE0XSAtIGJbMTRdO1xuICBvdXRbMTVdID0gYVsxNV0gLSBiWzE1XTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBNdWx0aXBseSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhci5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgb3V0WzRdID0gYVs0XSAqIGI7XG4gIG91dFs1XSA9IGFbNV0gKiBiO1xuICBvdXRbNl0gPSBhWzZdICogYjtcbiAgb3V0WzddID0gYVs3XSAqIGI7XG4gIG91dFs4XSA9IGFbOF0gKiBiO1xuICBvdXRbOV0gPSBhWzldICogYjtcbiAgb3V0WzEwXSA9IGFbMTBdICogYjtcbiAgb3V0WzExXSA9IGFbMTFdICogYjtcbiAgb3V0WzEyXSA9IGFbMTJdICogYjtcbiAgb3V0WzEzXSA9IGFbMTNdICogYjtcbiAgb3V0WzE0XSA9IGFbMTRdICogYjtcbiAgb3V0WzE1XSA9IGFbMTVdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byBtYXQ0J3MgYWZ0ZXIgbXVsdGlwbHlpbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiJ3MgZWxlbWVudHMgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXJBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICBvdXRbM10gPSBhWzNdICsgKGJbM10gKiBzY2FsZSk7XG4gIG91dFs0XSA9IGFbNF0gKyAoYls0XSAqIHNjYWxlKTtcbiAgb3V0WzVdID0gYVs1XSArIChiWzVdICogc2NhbGUpO1xuICBvdXRbNl0gPSBhWzZdICsgKGJbNl0gKiBzY2FsZSk7XG4gIG91dFs3XSA9IGFbN10gKyAoYls3XSAqIHNjYWxlKTtcbiAgb3V0WzhdID0gYVs4XSArIChiWzhdICogc2NhbGUpO1xuICBvdXRbOV0gPSBhWzldICsgKGJbOV0gKiBzY2FsZSk7XG4gIG91dFsxMF0gPSBhWzEwXSArIChiWzEwXSAqIHNjYWxlKTtcbiAgb3V0WzExXSA9IGFbMTFdICsgKGJbMTFdICogc2NhbGUpO1xuICBvdXRbMTJdID0gYVsxMl0gKyAoYlsxMl0gKiBzY2FsZSk7XG4gIG91dFsxM10gPSBhWzEzXSArIChiWzEzXSAqIHNjYWxlKTtcbiAgb3V0WzE0XSA9IGFbMTRdICsgKGJbMTRdICogc2NhbGUpO1xuICBvdXRbMTVdID0gYVsxNV0gKyAoYlsxNV0gKiBzY2FsZSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQ0fSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXSAmJlxuICAgICAgICAgYVs0XSA9PT0gYls0XSAmJiBhWzVdID09PSBiWzVdICYmIGFbNl0gPT09IGJbNl0gJiYgYVs3XSA9PT0gYls3XSAmJlxuICAgICAgICAgYVs4XSA9PT0gYls4XSAmJiBhWzldID09PSBiWzldICYmIGFbMTBdID09PSBiWzEwXSAmJiBhWzExXSA9PT0gYlsxMV0gJiZcbiAgICAgICAgIGFbMTJdID09PSBiWzEyXSAmJiBhWzEzXSA9PT0gYlsxM10gJiYgYVsxNF0gPT09IGJbMTRdICYmIGFbMTVdID09PSBiWzE1XTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge21hdDR9IGIgVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICBsZXQgYTAgID0gYVswXSwgIGExICA9IGFbMV0sICBhMiAgPSBhWzJdLCAgYTMgID0gYVszXTtcbiAgbGV0IGE0ICA9IGFbNF0sICBhNSAgPSBhWzVdLCAgYTYgID0gYVs2XSwgIGE3ICA9IGFbN107XG4gIGxldCBhOCAgPSBhWzhdLCAgYTkgID0gYVs5XSwgIGExMCA9IGFbMTBdLCBhMTEgPSBhWzExXTtcbiAgbGV0IGExMiA9IGFbMTJdLCBhMTMgPSBhWzEzXSwgYTE0ID0gYVsxNF0sIGExNSA9IGFbMTVdO1xuXG4gIGxldCBiMCAgPSBiWzBdLCAgYjEgID0gYlsxXSwgIGIyICA9IGJbMl0sICBiMyAgPSBiWzNdO1xuICBsZXQgYjQgID0gYls0XSwgIGI1ICA9IGJbNV0sICBiNiAgPSBiWzZdLCAgYjcgID0gYls3XTtcbiAgbGV0IGI4ICA9IGJbOF0sICBiOSAgPSBiWzldLCAgYjEwID0gYlsxMF0sIGIxMSA9IGJbMTFdO1xuICBsZXQgYjEyID0gYlsxMl0sIGIxMyA9IGJbMTNdLCBiMTQgPSBiWzE0XSwgYjE1ID0gYlsxNV07XG5cbiAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTQgLSBiNCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE0KSwgTWF0aC5hYnMoYjQpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGE1IC0gYjUpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhNiAtIGI2KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTYpLCBNYXRoLmFicyhiNikpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTcgLSBiNykgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE3KSwgTWF0aC5hYnMoYjcpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGE4IC0gYjgpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhOCksIE1hdGguYWJzKGI4KSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhOSAtIGI5KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTkpLCBNYXRoLmFicyhiOSkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTEwIC0gYjEwKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEwKSwgTWF0aC5hYnMoYjEwKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMTEgLSBiMTEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTEpLCBNYXRoLmFicyhiMTEpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGExMiAtIGIxMikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMiksIE1hdGguYWJzKGIxMikpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTEzIC0gYjEzKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEzKSwgTWF0aC5hYnMoYjEzKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMTQgLSBiMTQpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTQpLCBNYXRoLmFicyhiMTQpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGExNSAtIGIxNSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExNSksIE1hdGguYWJzKGIxNSkpKTtcbn1cblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IG11bCA9IG11bHRpcGx5O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0NC5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc3ViID0gc3VidHJhY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQ0LmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbmltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vblwiXG5pbXBvcnQgKiBhcyBtYXQzIGZyb20gXCIuL21hdDNcIlxuaW1wb3J0ICogYXMgdmVjMyBmcm9tIFwiLi92ZWMzXCJcbmltcG9ydCAqIGFzIHZlYzQgZnJvbSBcIi4vdmVjNFwiXG5cbi8qKlxuICogUXVhdGVybmlvblxuICogQG1vZHVsZSBxdWF0XG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IHF1YXRcbiAqXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IDA7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2V0IGEgcXVhdCB0byB0aGUgaWRlbnRpdHkgcXVhdGVybmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDA7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2V0cyBhIHF1YXQgZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYW5kIHJvdGF0aW9uIGF4aXMsXG4gKiB0aGVuIHJldHVybnMgaXQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgYXJvdW5kIHdoaWNoIHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgaW4gcmFkaWFuc1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEF4aXNBbmdsZShvdXQsIGF4aXMsIHJhZCkge1xuICByYWQgPSByYWQgKiAwLjU7XG4gIGxldCBzID0gTWF0aC5zaW4ocmFkKTtcbiAgb3V0WzBdID0gcyAqIGF4aXNbMF07XG4gIG91dFsxXSA9IHMgKiBheGlzWzFdO1xuICBvdXRbMl0gPSBzICogYXhpc1syXTtcbiAgb3V0WzNdID0gTWF0aC5jb3MocmFkKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSByb3RhdGlvbiBheGlzIGFuZCBhbmdsZSBmb3IgYSBnaXZlblxuICogIHF1YXRlcm5pb24uIElmIGEgcXVhdGVybmlvbiBpcyBjcmVhdGVkIHdpdGhcbiAqICBzZXRBeGlzQW5nbGUsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIHRoZSBzYW1lXG4gKiAgdmFsdWVzIGFzIHByb3ZpZGllZCBpbiB0aGUgb3JpZ2luYWwgcGFyYW1ldGVyIGxpc3RcbiAqICBPUiBmdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKiBFeGFtcGxlOiBUaGUgcXVhdGVybmlvbiBmb3JtZWQgYnkgYXhpcyBbMCwgMCwgMV0gYW5kXG4gKiAgYW5nbGUgLTkwIGlzIHRoZSBzYW1lIGFzIHRoZSBxdWF0ZXJuaW9uIGZvcm1lZCBieVxuICogIFswLCAwLCAxXSBhbmQgMjcwLiBUaGlzIG1ldGhvZCBmYXZvcnMgdGhlIGxhdHRlci5cbiAqIEBwYXJhbSAge3ZlYzN9IG91dF9heGlzICBWZWN0b3IgcmVjZWl2aW5nIHRoZSBheGlzIG9mIHJvdGF0aW9uXG4gKiBAcGFyYW0gIHtxdWF0fSBxICAgICBRdWF0ZXJuaW9uIHRvIGJlIGRlY29tcG9zZWRcbiAqIEByZXR1cm4ge051bWJlcn0gICAgIEFuZ2xlLCBpbiByYWRpYW5zLCBvZiB0aGUgcm90YXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEF4aXNBbmdsZShvdXRfYXhpcywgcSkge1xuICBsZXQgcmFkID0gTWF0aC5hY29zKHFbM10pICogMi4wO1xuICBsZXQgcyA9IE1hdGguc2luKHJhZCAvIDIuMCk7XG4gIGlmIChzICE9IDAuMCkge1xuICAgIG91dF9heGlzWzBdID0gcVswXSAvIHM7XG4gICAgb3V0X2F4aXNbMV0gPSBxWzFdIC8gcztcbiAgICBvdXRfYXhpc1syXSA9IHFbMl0gLyBzO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIHMgaXMgemVybywgcmV0dXJuIGFueSBheGlzIChubyByb3RhdGlvbiAtIGF4aXMgZG9lcyBub3QgbWF0dGVyKVxuICAgIG91dF9heGlzWzBdID0gMTtcbiAgICBvdXRfYXhpc1sxXSA9IDA7XG4gICAgb3V0X2F4aXNbMl0gPSAwO1xuICB9XG4gIHJldHVybiByYWQ7XG59XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBsZXQgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdO1xuICBsZXQgYnggPSBiWzBdLCBieSA9IGJbMV0sIGJ6ID0gYlsyXSwgYncgPSBiWzNdO1xuXG4gIG91dFswXSA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnk7XG4gIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYno7XG4gIG91dFsyXSA9IGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYng7XG4gIG91dFszXSA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBYIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIHJhZCkge1xuICByYWQgKj0gMC41O1xuXG4gIGxldCBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM107XG4gIGxldCBieCA9IE1hdGguc2luKHJhZCksIGJ3ID0gTWF0aC5jb3MocmFkKTtcblxuICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieDtcbiAgb3V0WzFdID0gYXkgKiBidyArIGF6ICogYng7XG4gIG91dFsyXSA9IGF6ICogYncgLSBheSAqIGJ4O1xuICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFkgYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgcmFkKSB7XG4gIHJhZCAqPSAwLjU7XG5cbiAgbGV0IGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXTtcbiAgbGV0IGJ5ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gIG91dFswXSA9IGF4ICogYncgLSBheiAqIGJ5O1xuICBvdXRbMV0gPSBheSAqIGJ3ICsgYXcgKiBieTtcbiAgb3V0WzJdID0gYXogKiBidyArIGF4ICogYnk7XG4gIG91dFszXSA9IGF3ICogYncgLSBheSAqIGJ5O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWiBheGlzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCByYWQpIHtcbiAgcmFkICo9IDAuNTtcblxuICBsZXQgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdO1xuICBsZXQgYnogPSBNYXRoLnNpbihyYWQpLCBidyA9IE1hdGguY29zKHJhZCk7XG5cbiAgb3V0WzBdID0gYXggKiBidyArIGF5ICogYno7XG4gIG91dFsxXSA9IGF5ICogYncgLSBheCAqIGJ6O1xuICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBiejtcbiAgb3V0WzNdID0gYXcgKiBidyAtIGF6ICogYno7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgVyBjb21wb25lbnQgb2YgYSBxdWF0IGZyb20gdGhlIFgsIFksIGFuZCBaIGNvbXBvbmVudHMuXG4gKiBBc3N1bWVzIHRoYXQgcXVhdGVybmlvbiBpcyAxIHVuaXQgaW4gbGVuZ3RoLlxuICogQW55IGV4aXN0aW5nIFcgY29tcG9uZW50IHdpbGwgYmUgaWdub3JlZC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBXIGNvbXBvbmVudCBvZlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlVyhvdXQsIGEpIHtcbiAgbGV0IHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XG5cbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgb3V0WzNdID0gTWF0aC5zcXJ0KE1hdGguYWJzKDEuMCAtIHggKiB4IC0geSAqIHkgLSB6ICogeikpO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgc3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xlcnAob3V0LCBhLCBiLCB0KSB7XG4gIC8vIGJlbmNobWFya3M6XG4gIC8vICAgIGh0dHA6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tc2xlcnAtaW1wbGVtZW50YXRpb25zXG4gIGxldCBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM107XG4gIGxldCBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdLCBidyA9IGJbM107XG5cbiAgbGV0IG9tZWdhLCBjb3NvbSwgc2lub20sIHNjYWxlMCwgc2NhbGUxO1xuXG4gIC8vIGNhbGMgY29zaW5lXG4gIGNvc29tID0gYXggKiBieCArIGF5ICogYnkgKyBheiAqIGJ6ICsgYXcgKiBidztcbiAgLy8gYWRqdXN0IHNpZ25zIChpZiBuZWNlc3NhcnkpXG4gIGlmICggY29zb20gPCAwLjAgKSB7XG4gICAgY29zb20gPSAtY29zb207XG4gICAgYnggPSAtIGJ4O1xuICAgIGJ5ID0gLSBieTtcbiAgICBieiA9IC0gYno7XG4gICAgYncgPSAtIGJ3O1xuICB9XG4gIC8vIGNhbGN1bGF0ZSBjb2VmZmljaWVudHNcbiAgaWYgKCAoMS4wIC0gY29zb20pID4gMC4wMDAwMDEgKSB7XG4gICAgLy8gc3RhbmRhcmQgY2FzZSAoc2xlcnApXG4gICAgb21lZ2EgID0gTWF0aC5hY29zKGNvc29tKTtcbiAgICBzaW5vbSAgPSBNYXRoLnNpbihvbWVnYSk7XG4gICAgc2NhbGUwID0gTWF0aC5zaW4oKDEuMCAtIHQpICogb21lZ2EpIC8gc2lub207XG4gICAgc2NhbGUxID0gTWF0aC5zaW4odCAqIG9tZWdhKSAvIHNpbm9tO1xuICB9IGVsc2Uge1xuICAgIC8vIFwiZnJvbVwiIGFuZCBcInRvXCIgcXVhdGVybmlvbnMgYXJlIHZlcnkgY2xvc2VcbiAgICAvLyAgLi4uIHNvIHdlIGNhbiBkbyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgc2NhbGUwID0gMS4wIC0gdDtcbiAgICBzY2FsZTEgPSB0O1xuICB9XG4gIC8vIGNhbGN1bGF0ZSBmaW5hbCB2YWx1ZXNcbiAgb3V0WzBdID0gc2NhbGUwICogYXggKyBzY2FsZTEgKiBieDtcbiAgb3V0WzFdID0gc2NhbGUwICogYXkgKyBzY2FsZTEgKiBieTtcbiAgb3V0WzJdID0gc2NhbGUwICogYXogKyBzY2FsZTEgKiBiejtcbiAgb3V0WzNdID0gc2NhbGUwICogYXcgKyBzY2FsZTEgKiBidztcblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGludmVyc2Ugb2YgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgaW52ZXJzZSBvZlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICBsZXQgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdO1xuICBsZXQgZG90ID0gYTAqYTAgKyBhMSphMSArIGEyKmEyICsgYTMqYTM7XG4gIGxldCBpbnZEb3QgPSBkb3QgPyAxLjAvZG90IDogMDtcblxuICAvLyBUT0RPOiBXb3VsZCBiZSBmYXN0ZXIgdG8gcmV0dXJuIFswLDAsMCwwXSBpbW1lZGlhdGVseSBpZiBkb3QgPT0gMFxuXG4gIG91dFswXSA9IC1hMCppbnZEb3Q7XG4gIG91dFsxXSA9IC1hMSppbnZEb3Q7XG4gIG91dFsyXSA9IC1hMippbnZEb3Q7XG4gIG91dFszXSA9IGEzKmludkRvdDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBjb25qdWdhdGUgb2YgYSBxdWF0XG4gKiBJZiB0aGUgcXVhdGVybmlvbiBpcyBub3JtYWxpemVkLCB0aGlzIGZ1bmN0aW9uIGlzIGZhc3RlciB0aGFuIHF1YXQuaW52ZXJzZSBhbmQgcHJvZHVjZXMgdGhlIHNhbWUgcmVzdWx0LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIGNvbmp1Z2F0ZSBvZlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uanVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBxdWF0ZXJuaW9uIGZyb20gdGhlIGdpdmVuIDN4MyByb3RhdGlvbiBtYXRyaXguXG4gKlxuICogTk9URTogVGhlIHJlc3VsdGFudCBxdWF0ZXJuaW9uIGlzIG5vdCBub3JtYWxpemVkLCBzbyB5b3Ugc2hvdWxkIGJlIHN1cmVcbiAqIHRvIHJlbm9ybWFsaXplIHRoZSBxdWF0ZXJuaW9uIHlvdXJzZWxmIHdoZXJlIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7bWF0M30gbSByb3RhdGlvbiBtYXRyaXhcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbU1hdDMob3V0LCBtKSB7XG4gIC8vIEFsZ29yaXRobSBpbiBLZW4gU2hvZW1ha2UncyBhcnRpY2xlIGluIDE5ODcgU0lHR1JBUEggY291cnNlIG5vdGVzXG4gIC8vIGFydGljbGUgXCJRdWF0ZXJuaW9uIENhbGN1bHVzIGFuZCBGYXN0IEFuaW1hdGlvblwiLlxuICBsZXQgZlRyYWNlID0gbVswXSArIG1bNF0gKyBtWzhdO1xuICBsZXQgZlJvb3Q7XG5cbiAgaWYgKCBmVHJhY2UgPiAwLjAgKSB7XG4gICAgLy8gfHd8ID4gMS8yLCBtYXkgYXMgd2VsbCBjaG9vc2UgdyA+IDEvMlxuICAgIGZSb290ID0gTWF0aC5zcXJ0KGZUcmFjZSArIDEuMCk7ICAvLyAyd1xuICAgIG91dFszXSA9IDAuNSAqIGZSb290O1xuICAgIGZSb290ID0gMC41L2ZSb290OyAgLy8gMS8oNHcpXG4gICAgb3V0WzBdID0gKG1bNV0tbVs3XSkqZlJvb3Q7XG4gICAgb3V0WzFdID0gKG1bNl0tbVsyXSkqZlJvb3Q7XG4gICAgb3V0WzJdID0gKG1bMV0tbVszXSkqZlJvb3Q7XG4gIH0gZWxzZSB7XG4gICAgLy8gfHd8IDw9IDEvMlxuICAgIGxldCBpID0gMDtcbiAgICBpZiAoIG1bNF0gPiBtWzBdIClcbiAgICAgIGkgPSAxO1xuICAgIGlmICggbVs4XSA+IG1baSozK2ldIClcbiAgICAgIGkgPSAyO1xuICAgIGxldCBqID0gKGkrMSklMztcbiAgICBsZXQgayA9IChpKzIpJTM7XG5cbiAgICBmUm9vdCA9IE1hdGguc3FydChtW2kqMytpXS1tW2oqMytqXS1tW2sqMytrXSArIDEuMCk7XG4gICAgb3V0W2ldID0gMC41ICogZlJvb3Q7XG4gICAgZlJvb3QgPSAwLjUgLyBmUm9vdDtcbiAgICBvdXRbM10gPSAobVtqKjMra10gLSBtW2sqMytqXSkgKiBmUm9vdDtcbiAgICBvdXRbal0gPSAobVtqKjMraV0gKyBtW2kqMytqXSkgKiBmUm9vdDtcbiAgICBvdXRba10gPSAobVtrKjMraV0gKyBtW2kqMytrXSkgKiBmUm9vdDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHF1YXRlcm5pb24gZnJvbSB0aGUgZ2l2ZW4gZXVsZXIgYW5nbGUgeCwgeSwgei5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7eH0gQW5nbGUgdG8gcm90YXRlIGFyb3VuZCBYIGF4aXMgaW4gZGVncmVlcy5cbiAqIEBwYXJhbSB7eX0gQW5nbGUgdG8gcm90YXRlIGFyb3VuZCBZIGF4aXMgaW4gZGVncmVlcy5cbiAqIEBwYXJhbSB7en0gQW5nbGUgdG8gcm90YXRlIGFyb3VuZCBaIGF4aXMgaW4gZGVncmVlcy5cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUV1bGVyKG91dCwgeCwgeSwgeikge1xuICAgIGxldCBoYWxmVG9SYWQgPSAwLjUgKiBNYXRoLlBJIC8gMTgwLjA7XG4gICAgeCAqPSBoYWxmVG9SYWQ7XG4gICAgeSAqPSBoYWxmVG9SYWQ7XG4gICAgeiAqPSBoYWxmVG9SYWQ7XG5cbiAgICBsZXQgc3ggPSBNYXRoLnNpbih4KTtcbiAgICBsZXQgY3ggPSBNYXRoLmNvcyh4KTtcbiAgICBsZXQgc3kgPSBNYXRoLnNpbih5KTtcbiAgICBsZXQgY3kgPSBNYXRoLmNvcyh5KTtcbiAgICBsZXQgc3ogPSBNYXRoLnNpbih6KTtcbiAgICBsZXQgY3ogPSBNYXRoLmNvcyh6KTtcblxuICAgIG91dFswXSA9IHN4ICogY3kgKiBjeiAtIGN4ICogc3kgKiBzejtcbiAgICBvdXRbMV0gPSBjeCAqIHN5ICogY3ogKyBzeCAqIGN5ICogc3o7XG4gICAgb3V0WzJdID0gY3ggKiBjeSAqIHN6IC0gc3ggKiBzeSAqIGN6O1xuICAgIG91dFszXSA9IGN4ICogY3kgKiBjeiArIHN4ICogc3kgKiBzejtcblxuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHF1YXRlbmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuICdxdWF0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJyknO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcXVhdCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHF1YXRlcm5pb25cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdGVybmlvbiB0byBjbG9uZVxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgY2xvbmUgPSB2ZWM0LmNsb25lO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcXVhdCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZnJvbVZhbHVlcyA9IHZlYzQuZnJvbVZhbHVlcztcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgcXVhdCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIHNvdXJjZSBxdWF0ZXJuaW9uXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGNvcHkgPSB2ZWM0LmNvcHk7XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgcXVhdCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzZXQgPSB2ZWM0LnNldDtcblxuLyoqXG4gKiBBZGRzIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBhZGQgPSB2ZWM0LmFkZDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IG11bCA9IG11bHRpcGx5O1xuXG4vKipcbiAqIFNjYWxlcyBhIHF1YXQgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzY2FsZSA9IHZlYzQuc2NhbGU7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBkb3QgPSB2ZWM0LmRvdDtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGxlcnAgPSB2ZWM0LmxlcnA7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xuZXhwb3J0IGNvbnN0IGxlbmd0aCA9IHZlYzQubGVuZ3RoO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGxlbiA9IGxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzcXVhcmVkTGVuZ3RoID0gdmVjNC5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0ZXJuaW9uIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBub3JtYWxpemUgPSB2ZWM0Lm5vcm1hbGl6ZTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBxdWF0ZXJuaW9ucyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIFRoZSBmaXJzdCBxdWF0ZXJuaW9uLlxuICogQHBhcmFtIHtxdWF0fSBiIFRoZSBzZWNvbmQgcXVhdGVybmlvbi5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgY29uc3QgZXhhY3RFcXVhbHMgPSB2ZWM0LmV4YWN0RXF1YWxzO1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHF1YXRlcm5pb25zIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7cXVhdH0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgY29uc3QgZXF1YWxzID0gdmVjNC5lcXVhbHM7XG5cbi8qKlxuICogU2V0cyBhIHF1YXRlcm5pb24gdG8gcmVwcmVzZW50IHRoZSBzaG9ydGVzdCByb3RhdGlvbiBmcm9tIG9uZVxuICogdmVjdG9yIHRvIGFub3RoZXIuXG4gKlxuICogQm90aCB2ZWN0b3JzIGFyZSBhc3N1bWVkIHRvIGJlIHVuaXQgbGVuZ3RoLlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvbi5cbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgaW5pdGlhbCB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgZGVzdGluYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbmV4cG9ydCBjb25zdCByb3RhdGlvblRvID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgdG1wdmVjMyA9IHZlYzMuY3JlYXRlKCk7XG4gIGxldCB4VW5pdFZlYzMgPSB2ZWMzLmZyb21WYWx1ZXMoMSwwLDApO1xuICBsZXQgeVVuaXRWZWMzID0gdmVjMy5mcm9tVmFsdWVzKDAsMSwwKTtcblxuICByZXR1cm4gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgbGV0IGRvdCA9IHZlYzMuZG90KGEsIGIpO1xuICAgIGlmIChkb3QgPCAtMC45OTk5OTkpIHtcbiAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgeFVuaXRWZWMzLCBhKTtcbiAgICAgIGlmICh2ZWMzLmxlbih0bXB2ZWMzKSA8IDAuMDAwMDAxKVxuICAgICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIHlVbml0VmVjMywgYSk7XG4gICAgICB2ZWMzLm5vcm1hbGl6ZSh0bXB2ZWMzLCB0bXB2ZWMzKTtcbiAgICAgIHNldEF4aXNBbmdsZShvdXQsIHRtcHZlYzMsIE1hdGguUEkpO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9IGVsc2UgaWYgKGRvdCA+IDAuOTk5OTk5KSB7XG4gICAgICBvdXRbMF0gPSAwO1xuICAgICAgb3V0WzFdID0gMDtcbiAgICAgIG91dFsyXSA9IDA7XG4gICAgICBvdXRbM10gPSAxO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCBhLCBiKTtcbiAgICAgIG91dFswXSA9IHRtcHZlYzNbMF07XG4gICAgICBvdXRbMV0gPSB0bXB2ZWMzWzFdO1xuICAgICAgb3V0WzJdID0gdG1wdmVjM1syXTtcbiAgICAgIG91dFszXSA9IDEgKyBkb3Q7XG4gICAgICByZXR1cm4gbm9ybWFsaXplKG91dCwgb3V0KTtcbiAgICB9XG4gIH07XG59KSgpO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgc3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYyB0aGUgdGhpcmQgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBkIHRoZSBmb3VydGggb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGNvbnN0IHNxbGVycCA9IChmdW5jdGlvbiAoKSB7XG4gIGxldCB0ZW1wMSA9IGNyZWF0ZSgpO1xuICBsZXQgdGVtcDIgPSBjcmVhdGUoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICAgIHNsZXJwKHRlbXAxLCBhLCBkLCB0KTtcbiAgICBzbGVycCh0ZW1wMiwgYiwgYywgdCk7XG4gICAgc2xlcnAob3V0LCB0ZW1wMSwgdGVtcDIsIDIgKiB0ICogKDEgLSB0KSk7XG5cbiAgICByZXR1cm4gb3V0O1xuICB9O1xufSgpKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzcGVjaWZpZWQgcXVhdGVybmlvbiB3aXRoIHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlblxuICogYXhlcy4gRWFjaCBheGlzIGlzIGEgdmVjMyBhbmQgaXMgZXhwZWN0ZWQgdG8gYmUgdW5pdCBsZW5ndGggYW5kXG4gKiBwZXJwZW5kaWN1bGFyIHRvIGFsbCBvdGhlciBzcGVjaWZpZWQgYXhlcy5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IHZpZXcgIHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSB2aWV3aW5nIGRpcmVjdGlvblxuICogQHBhcmFtIHt2ZWMzfSByaWdodCB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYWwgXCJyaWdodFwiIGRpcmVjdGlvblxuICogQHBhcmFtIHt2ZWMzfSB1cCAgICB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYWwgXCJ1cFwiIGRpcmVjdGlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5leHBvcnQgY29uc3Qgc2V0QXhlcyA9IChmdW5jdGlvbigpIHtcbiAgbGV0IG1hdHIgPSBtYXQzLmNyZWF0ZSgpO1xuXG4gIHJldHVybiBmdW5jdGlvbihvdXQsIHZpZXcsIHJpZ2h0LCB1cCkge1xuICAgIG1hdHJbMF0gPSByaWdodFswXTtcbiAgICBtYXRyWzNdID0gcmlnaHRbMV07XG4gICAgbWF0cls2XSA9IHJpZ2h0WzJdO1xuXG4gICAgbWF0clsxXSA9IHVwWzBdO1xuICAgIG1hdHJbNF0gPSB1cFsxXTtcbiAgICBtYXRyWzddID0gdXBbMl07XG5cbiAgICBtYXRyWzJdID0gLXZpZXdbMF07XG4gICAgbWF0cls1XSA9IC12aWV3WzFdO1xuICAgIG1hdHJbOF0gPSAtdmlld1syXTtcblxuICAgIHJldHVybiBub3JtYWxpemUob3V0LCBmcm9tTWF0MyhvdXQsIG1hdHIpKTtcbiAgfTtcbn0pKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9xdWF0LmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbmltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vblwiO1xuXG4vKipcbiAqIDIgRGltZW5zaW9uYWwgVmVjdG9yXG4gKiBAbW9kdWxlIHZlYzJcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzJcbiAqXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgb3V0WzBdID0gMDtcbiAgb3V0WzFdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHkpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMyIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzIgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIHgsIHkpIHtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjZWlsXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBmbG9vclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXgob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byByb3VuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm91bmQgKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMyIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzIncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgeSA9IGJbMV0gLSBhWzFdO1xuICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSk7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgeSA9IGJbMV0gLSBhWzFdO1xuICByZXR1cm4geCp4ICsgeSp5O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgIHkgPSBhWzFdO1xuICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSk7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkTGVuZ3RoIChhKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICB5ID0gYVsxXTtcbiAgcmV0dXJuIHgqeCArIHkqeTtcbn07XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV07XG4gIHZhciBsZW4gPSB4KnggKyB5Knk7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKiBOb3RlIHRoYXQgdGhlIGNyb3NzIHByb2R1Y3QgbXVzdCBieSBkZWZpbml0aW9uIHByb2R1Y2UgYSAzRCB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcm9zcyhvdXQsIGEsIGIpIHtcbiAgdmFyIHogPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xuICBvdXRbMF0gPSBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSB6O1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgYXkgPSBhWzFdO1xuICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb20ob3V0LCBzY2FsZSkge1xuICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcbiAgdmFyIHIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gIG91dFswXSA9IE1hdGguY29zKHIpICogc2NhbGU7XG4gIG91dFsxXSA9IE1hdGguc2luKHIpICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDJ9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQyKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHk7XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHk7XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQyZH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDJkKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0M1xuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDN9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVszXSAqIHkgKyBtWzZdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bNF0gKiB5ICsgbVs3XTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0NFxuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMCdcbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgbGV0IHggPSBhWzBdO1xuICBsZXQgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzEyXTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bMTNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiAndmVjMignICsgYVswXSArICcsICcgKyBhWzFdICsgJyknO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgZXhhY3RseSBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMyfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV07XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIGxldCBhMCA9IGFbMF0sIGExID0gYVsxXTtcbiAgbGV0IGIwID0gYlswXSwgYjEgPSBiWzFdO1xuICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpKTtcbn1cblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBsZW4gPSBsZW5ndGg7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzdWIgPSBzdWJ0cmFjdDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IG11bCA9IG11bHRpcGx5O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGRpdiA9IGRpdmlkZTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuZGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGRpc3QgPSBkaXN0YW5jZTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzcXJEaXN0ID0gc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMyLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjMnMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBmb3JFYWNoID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgdmVjID0gY3JlYXRlKCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgIGxldCBpLCBsO1xuICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgIHN0cmlkZSA9IDI7XG4gICAgfVxuXG4gICAgaWYoIW9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG5cbiAgICBpZihjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbCA9IGEubGVuZ3RoO1xuICAgIH1cblxuICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHZlY1swXSA9IGFbaV07IHZlY1sxXSA9IGFbaSsxXTtcbiAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9O1xufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzIuanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gVmVydGV4QXJyYXlPYmplY3QuanNcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QW5kQXBwbHlFeHRlbnNpb24oZ2wsIG5hbWUpIHtcblx0Y29uc3QgZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKG5hbWUpO1xuXHRpZiAoIWV4dCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRjb25zdCBzdWZmaXggPSBuYW1lLnNwbGl0KCdfJylbMF07XG5cdGNvbnN0IHN1ZmZpeFJFID0gbmV3IFJlZ0V4cChgJHtzdWZmaXh9JGApO1xuXG5cdGZvciAoY29uc3Qga2V5IGluIGV4dCkge1xuXHRcdGNvbnN0IHZhbCA9IGV4dFtrZXldO1xuXHRcdGlmICh0eXBlb2YodmFsKSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y29uc3QgdW5zdWZmaXhlZEtleSA9IGtleS5yZXBsYWNlKHN1ZmZpeFJFLCAnJyk7XG5cdFx0XHRpZiAoa2V5LnN1YnN0cmluZykge1xuXHRcdFx0XHRnbFt1bnN1ZmZpeGVkS2V5XSA9IGV4dFtrZXldLmJpbmQoZXh0KTtcdFxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZygnUmVwbGFjaW5nIDonLCBrZXksICc9PicsIHVuc3VmZml4ZWRLZXkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL2dldEFuZEFwcGx5RXh0ZW5zaW9uLmpzIiwiLy8gZXhwb3NlQXR0cmlidXRlcy5qc1xuXG5pbXBvcnQgR0wgZnJvbSAnLi4vR0xUb29sJztcbmltcG9ydCBXZWJnbENvbnN0IGZyb20gJy4vV2ViZ2xDb25zdCc7XG5cbmNvbnN0IGV4cG9zZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG5cdC8vIEdMLlZFUlRFWF9TSEFERVIgICAgICAgICA9IEdMLmdsLlZFUlRFWF9TSEFERVI7XG5cdC8vIEdMLkZSQUdNRU5UX1NIQURFUiAgICAgICA9IEdMLmdsLkZSQUdNRU5UX1NIQURFUjtcblx0Ly8gR0wuQ09NUElMRV9TVEFUVVMgICAgICAgID0gR0wuZ2wuQ09NUElMRV9TVEFUVVM7XG5cdC8vIEdMLkRFUFRIX1RFU1QgICAgICAgICAgICA9IEdMLmdsLkRFUFRIX1RFU1Q7XG5cdC8vIEdMLkNVTExfRkFDRSAgICAgICAgICAgICA9IEdMLmdsLkNVTExfRkFDRTtcblx0Ly8gR0wuQkxFTkQgICAgICAgICAgICAgICAgID0gR0wuZ2wuQkxFTkQ7XG5cdC8vIEdMLlBPSU5UUyAgICAgICAgICAgICAgICA9IEdMLmdsLlBPSU5UUztcblx0Ly8gR0wuTElORVMgICAgICAgICAgICAgICAgID0gR0wuZ2wuTElORVM7XG5cdC8vIEdMLlRSSUFOR0xFUyAgICAgICAgICAgICA9IEdMLmdsLlRSSUFOR0xFUztcblx0XG5cdC8vIEdMLkxJTkVBUiAgICAgICAgICAgICAgICBcdD0gR0wuZ2wuTElORUFSO1xuXHQvLyBHTC5ORUFSRVNUICAgICAgICAgICAgICAgXHQ9IEdMLmdsLk5FQVJFU1Q7XG5cdC8vIEdMLkxJTkVBUl9NSVBNQVBfTkVBUkVTVCBcdD0gR0wuZ2wuTElORUFSX01JUE1BUF9ORUFSRVNUO1xuXHQvLyBHTC5ORUFSRVNUX01JUE1BUF9MSU5FQVIgXHQ9IEdMLmdsLk5FQVJFU1RfTUlQTUFQX0xJTkVBUjtcblx0Ly8gR0wuTElORUFSX01JUE1BUF9MSU5FQVIgXHQ9IEdMLmdsLkxJTkVBUl9NSVBNQVBfTElORUFSO1xuXHQvLyBHTC5ORUFSRVNUX01JUE1BUF9ORUFSRVNUIFx0PSBHTC5nbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNUO1xuXHQvLyBHTC5NSVJST1JFRF9SRVBFQVQgICAgICAgXHQ9IEdMLmdsLk1JUlJPUkVEX1JFUEVBVDtcblx0Ly8gR0wuQ0xBTVBfVE9fRURHRSAgICAgICAgIFx0PSBHTC5nbC5DTEFNUF9UT19FREdFO1xuXHQvLyBHTC5TQ0lTU09SX1RFU1RcdFx0ICAgXHQgXHQ9IEdMLmdsLlNDSVNTT1JfVEVTVDtcblx0Ly8gR0wuVU5TSUdORURfQllURVx0XHQgXHQ9IEdMLmdsLlVOU0lHTkVEX0JZVEU7XG5cdGZvciAoY29uc3QgcyBpbiBXZWJnbENvbnN0KSB7XG5cdFx0aWYoIUdMW3NdKSB7XG5cdFx0XHRHTFtzXSA9IFdlYmdsQ29uc3Rbc107XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUubG9nKCdhbHJlYWR5IGV4aXN0IDogJywgcyk7XG5cdFx0fVxuXHRcdFxuXHR9XG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IGV4cG9zZUF0dHJpYnV0ZXM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvZXhwb3NlQXR0cmlidXRlcy5qcyIsIi8vIGdldEZsb2F0LmpzXG5cbmltcG9ydCBHTCBmcm9tICcuLi9HTFRvb2wnO1xuXG5sZXQgaGFzQ2hlY2tlZCA9IGZhbHNlO1xubGV0IF9mbG9hdDtcblxuXG5mdW5jdGlvbiBjaGVja0Zsb2F0KCkge1xuXHRpZihHTC53ZWJnbDIpIHtcblx0XHRyZXR1cm4gR0wuZ2wuRkxPQVQ7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc3QgZXh0RmxvYXQgPSBHTC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0Jyk7XG5cdFx0aWYoZXh0RmxvYXQpIHtcblx0XHRcdHJldHVybiBHTC5nbC5GTE9BVDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS53YXJuKCdVU0lORyBGTE9BVCBCVVQgT0VTX3RleHR1cmVfZmxvYXQgTk9UIFNVUFBPUlRFRCcpO1xuXHRcdFx0cmV0dXJuIEdMLmdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0fVxuXHR9XG5cblx0aGFzQ2hlY2tlZCA9IHRydWU7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG5cdGlmKCFoYXNDaGVja2VkKSB7XG5cdFx0X2Zsb2F0ID0gY2hlY2tGbG9hdCgpO1xuXHR9XG5cblxuXHRyZXR1cm4gX2Zsb2F0O1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL2dldEZsb2F0LmpzIiwiLy8gZ2V0SGFsZkZsb2F0LmpzXG5cbmltcG9ydCBHTCBmcm9tICcuLi9HTFRvb2wnO1xuXG5sZXQgaGFzQ2hlY2tlZCA9IGZhbHNlO1xubGV0IGhhbGZGbG9hdDtcblxuZnVuY3Rpb24gY2hlY2tIYWxmRmxvYXQoKSB7XG5cdGlmKEdMLndlYmdsMikge1xuXHRcdHJldHVybiBHTC5nbC5IQUxGX0ZMT0FUO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnN0IGV4dEhhbGZGbG9hdCA9IEdMLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcpO1xuXHRcdGlmKGV4dEhhbGZGbG9hdCkge1xuXHRcdFx0cmV0dXJuIGV4dEhhbGZGbG9hdC5IQUxGX0ZMT0FUX09FUztcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS53YXJuKCdVU0lORyBIQUxGIEZMT0FUIEJVVCBPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0IE5PVCBTVVBQT1JURUQnKTtcblx0XHRcdHJldHVybiBHTC5nbC5VTlNJR05FRF9CWVRFO1xuXHRcdH1cblx0fVxuXG5cdGhhc0NoZWNrZWQgPSB0cnVlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuXHRpZighaGFzQ2hlY2tlZCkge1xuXHRcdGhhbGZGbG9hdCA9IGNoZWNrSGFsZkZsb2F0KCk7XG5cdH1cblxuXHRyZXR1cm4gaGFsZkZsb2F0O1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL2dldEhhbGZGbG9hdC5qcyIsIi8vIEV4dGVuc2lvbnNMaXN0LmpzXG5cbmV4cG9ydCBkZWZhdWx0IFtcblx0J0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QnLCBcblx0J0VYVF9zUkdCJywgXG5cdCdFWFRfZnJhZ19kZXB0aCcsIFxuXHQnT0VTX3RleHR1cmVfZmxvYXQnLCBcblx0J09FU190ZXh0dXJlX2hhbGZfZmxvYXQnLCBcblx0J09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicsIFxuXHQnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInLCBcblx0J09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycsIFxuXHQnV0VCR0xfZGVwdGhfdGV4dHVyZScsIFxuXHQnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJywgXG5cdCdPRVNfdmVydGV4X2FycmF5X29iamVjdCcsIFxuXHQnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycsIFxuXHQnV0VCR0xfZHJhd19idWZmZXJzJ1xuXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9FeHRlbnNpb25zTGlzdC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3RyaW5ncykge1xuICBpZiAodHlwZW9mIHN0cmluZ3MgPT09ICdzdHJpbmcnKSBzdHJpbmdzID0gW3N0cmluZ3NdXG4gIHZhciBleHBycyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpXG4gIHZhciBwYXJ0cyA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5ncy5sZW5ndGgtMTsgaSsrKSB7XG4gICAgcGFydHMucHVzaChzdHJpbmdzW2ldLCBleHByc1tpXSB8fCAnJylcbiAgfVxuICBwYXJ0cy5wdXNoKHN0cmluZ3NbaV0pXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2xzbGlmeS9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0gXCIvLyBiYXNpYy5mcmFnXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBCQVNJQ19GUkFHTUVOVFxcblxcbnByZWNpc2lvbiBsb3dwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudW5pZm9ybSBmbG9hdCB0aW1lO1xcbi8vIHVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmU7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2VGV4dHVyZUNvb3JkLCBzaW4odGltZSkgKiAuNSArIC41LCAxLjApO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9iYXNpYy5mcmFnXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIGdldFRleHR1cmVQYXJhbWV0ZXJzLmpzXG5cbmltcG9ydCBHTCBmcm9tICcuLi9HTFRvb2wnO1xuXG5mdW5jdGlvbiBpc1Bvd2VyT2ZUd28oeCkge1x0XG5cdHJldHVybiAoeCAhPT0gMCkgJiYgKCEoeCAmICh4IC0gMSkpKTtcbn07XG5cbmNvbnN0IGdldFRleHR1cmVQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG1QYXJhbXMsIG1Tb3VyY2UsIG1XaWR0aCwgbUhlaWdodCkge1xuXHRpZighbVBhcmFtcy5taW5GaWx0ZXIpIHtcblx0XHRsZXQgbWluRmlsdGVyID0gR0wuTElORUFSO1xuXHRcdGlmKG1XaWR0aCAmJiBtV2lkdGgpIHtcblx0XHRcdGlmKGlzUG93ZXJPZlR3byhtV2lkdGgpICYmIGlzUG93ZXJPZlR3byhtSGVpZ2h0KSkge1xuXHRcdFx0XHRtaW5GaWx0ZXIgPSBHTC5ORUFSRVNUX01JUE1BUF9MSU5FQVI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bVBhcmFtcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXI7XG5cdH0gXG5cblxuXHRtUGFyYW1zLm1pcG1hcCA9IG1QYXJhbXMubWlwbWFwIHx8IHRydWU7XG5cdG1QYXJhbXMubWFnRmlsdGVyID0gbVBhcmFtcy5tYWdGaWx0ZXIgfHwgR0wuTElORUFSO1xuXHRtUGFyYW1zLndyYXBTID0gbVBhcmFtcy53cmFwUyB8fCBHTC5DTEFNUF9UT19FREdFO1xuXHRtUGFyYW1zLndyYXBUID0gbVBhcmFtcy53cmFwVCB8fCBHTC5DTEFNUF9UT19FREdFO1xuXHRtUGFyYW1zLmludGVybmFsRm9ybWF0ID0gbVBhcmFtcy5pbnRlcm5hbEZvcm1hdCB8fCBHTC5SR0JBO1xuXHRtUGFyYW1zLmZvcm1hdCA9IG1QYXJhbXMuZm9ybWF0IHx8IEdMLlJHQkE7XG5cdG1QYXJhbXMucHJlbXVsdGlwbHlBbHBoYSA9IG1QYXJhbXMucHJlbXVsdGlwbHlBbHBoYSB8fCBmYWxzZTtcblx0bVBhcmFtcy5sZXZlbCA9IG1QYXJhbXMubGV2ZWwgfHwgMDtcblx0bVBhcmFtcy5hbmlzb3Ryb3B5ID0gbVBhcmFtcy5hbmlzb3Ryb3B5IHx8IDA7XG5cdHJldHVybiBtUGFyYW1zO1xufTtcblxuXG5leHBvcnQgZGVmYXVsdCBnZXRUZXh0dXJlUGFyYW1ldGVycztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9nZXRUZXh0dXJlUGFyYW1ldGVycy5qcyIsIi8vIEFsbCB2YWx1ZXMgYW5kIHN0cnVjdHVyZXMgcmVmZXJlbmNlZCBmcm9tOlxuLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2JiOTQzOTkxLmFzcHgvXG4vL1xuLy8gRFgxMCBDdWJlbWFwIHN1cHBvcnQgYmFzZWQgb25cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJpb21hbmVza3UvY21mdC9pc3N1ZXMvNyNpc3N1ZWNvbW1lbnQtNjk1MTY4NDRcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9kZXNrdG9wL2JiOTQzOTgzKHY9dnMuODUpLmFzcHhcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbGF5Y2FudmFzL2VuZ2luZS9ibG9iL21hc3Rlci9zcmMvcmVzb3VyY2VzL3Jlc291cmNlc190ZXh0dXJlLmpzXG5cbnZhciBERFNfTUFHSUMgPSAweDIwNTM0NDQ0XG52YXIgRERTRF9NSVBNQVBDT1VOVCA9IDB4MjAwMDBcbnZhciBERFBGX0ZPVVJDQyA9IDB4NFxuXG52YXIgRk9VUkNDX0RYVDEgPSBmb3VyQ0NUb0ludDMyKCdEWFQxJylcbnZhciBGT1VSQ0NfRFhUMyA9IGZvdXJDQ1RvSW50MzIoJ0RYVDMnKVxudmFyIEZPVVJDQ19EWFQ1ID0gZm91ckNDVG9JbnQzMignRFhUNScpXG52YXIgRk9VUkNDX0RYMTAgPSBmb3VyQ0NUb0ludDMyKCdEWDEwJylcbnZhciBGT1VSQ0NfRlAzMkYgPSAxMTYgLy8gRFhHSV9GT1JNQVRfUjMyRzMyQjMyQTMyX0ZMT0FUXG5cbnZhciBERFNDQVBTMl9DVUJFTUFQID0gMHgyMDBcbnZhciBEM0QxMF9SRVNPVVJDRV9ESU1FTlNJT05fVEVYVFVSRTJEID0gM1xudmFyIERYR0lfRk9STUFUX1IzMkczMkIzMkEzMl9GTE9BVCA9IDJcblxuLy8gVGhlIGhlYWRlciBsZW5ndGggaW4gMzIgYml0IGludHNcbnZhciBoZWFkZXJMZW5ndGhJbnQgPSAzMVxuXG4vLyBPZmZzZXRzIGludG8gdGhlIGhlYWRlciBhcnJheVxudmFyIG9mZl9tYWdpYyA9IDBcbnZhciBvZmZfc2l6ZSA9IDFcbnZhciBvZmZfZmxhZ3MgPSAyXG52YXIgb2ZmX2hlaWdodCA9IDNcbnZhciBvZmZfd2lkdGggPSA0XG52YXIgb2ZmX21pcG1hcENvdW50ID0gN1xudmFyIG9mZl9wZkZsYWdzID0gMjBcbnZhciBvZmZfcGZGb3VyQ0MgPSAyMVxudmFyIG9mZl9jYXBzMiA9IDI4XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VIZWFkZXJzXG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVycyAoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIGhlYWRlciA9IG5ldyBJbnQzMkFycmF5KGFycmF5QnVmZmVyLCAwLCBoZWFkZXJMZW5ndGhJbnQpXG5cbiAgaWYgKGhlYWRlcltvZmZfbWFnaWNdICE9PSBERFNfTUFHSUMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWFnaWMgbnVtYmVyIGluIEREUyBoZWFkZXInKVxuICB9XG5cbiAgaWYgKCFoZWFkZXJbb2ZmX3BmRmxhZ3NdICYgRERQRl9GT1VSQ0MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGZvcm1hdCwgbXVzdCBjb250YWluIGEgRm91ckNDIGNvZGUnKVxuICB9XG5cbiAgdmFyIGJsb2NrQnl0ZXNcbiAgdmFyIGZvcm1hdFxuICB2YXIgZm91ckNDID0gaGVhZGVyW29mZl9wZkZvdXJDQ11cbiAgc3dpdGNoIChmb3VyQ0MpIHtcbiAgICBjYXNlIEZPVVJDQ19EWFQxOlxuICAgICAgYmxvY2tCeXRlcyA9IDhcbiAgICAgIGZvcm1hdCA9ICdkeHQxJ1xuICAgICAgYnJlYWtcbiAgICBjYXNlIEZPVVJDQ19EWFQzOlxuICAgICAgYmxvY2tCeXRlcyA9IDE2XG4gICAgICBmb3JtYXQgPSAnZHh0MydcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBGT1VSQ0NfRFhUNTpcbiAgICAgIGJsb2NrQnl0ZXMgPSAxNlxuICAgICAgZm9ybWF0ID0gJ2R4dDUnXG4gICAgICBicmVha1xuICAgIGNhc2UgRk9VUkNDX0ZQMzJGOlxuICAgICAgZm9ybWF0ID0gJ3JnYmEzMmYnXG4gICAgICBicmVha1xuICAgIGNhc2UgRk9VUkNDX0RYMTA6XG4gICAgICB2YXIgZHgxMEhlYWRlciA9IG5ldyBVaW50MzJBcnJheShhcnJheUJ1ZmZlci5zbGljZSgxMjgsIDEyOCArIDIwKSlcbiAgICAgIGZvcm1hdCA9IGR4MTBIZWFkZXJbMF1cbiAgICAgIHZhciByZXNvdXJjZURpbWVuc2lvbiA9IGR4MTBIZWFkZXJbMV1cbiAgICAgIHZhciBtaXNjRmxhZyA9IGR4MTBIZWFkZXJbMl1cbiAgICAgIHZhciBhcnJheVNpemUgPSBkeDEwSGVhZGVyWzNdXG4gICAgICB2YXIgbWlzY0ZsYWdzMiA9IGR4MTBIZWFkZXJbNF1cblxuICAgICAgaWYgKHJlc291cmNlRGltZW5zaW9uID09PSBEM0QxMF9SRVNPVVJDRV9ESU1FTlNJT05fVEVYVFVSRTJEICYmIGZvcm1hdCA9PT0gRFhHSV9GT1JNQVRfUjMyRzMyQjMyQTMyX0ZMT0FUKSB7XG4gICAgICAgIGZvcm1hdCA9ICdyZ2JhMzJmJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBEWDEwIHRleHR1cmUgZm9ybWF0ICcgKyBmb3JtYXQpXG4gICAgICB9XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIEZvdXJDQyBjb2RlOiAnICsgaW50MzJUb0ZvdXJDQyhmb3VyQ0MpKVxuICB9XG5cbiAgdmFyIGZsYWdzID0gaGVhZGVyW29mZl9mbGFnc11cbiAgdmFyIG1pcG1hcENvdW50ID0gMVxuXG4gIGlmIChmbGFncyAmIEREU0RfTUlQTUFQQ09VTlQpIHtcbiAgICBtaXBtYXBDb3VudCA9IE1hdGgubWF4KDEsIGhlYWRlcltvZmZfbWlwbWFwQ291bnRdKVxuICB9XG5cbiAgdmFyIGN1YmVtYXAgPSBmYWxzZVxuICB2YXIgY2FwczIgPSBoZWFkZXJbb2ZmX2NhcHMyXVxuICBpZiAoY2FwczIgJiBERFNDQVBTMl9DVUJFTUFQKSB7XG4gICAgY3ViZW1hcCA9IHRydWVcbiAgfVxuXG4gIHZhciB3aWR0aCA9IGhlYWRlcltvZmZfd2lkdGhdXG4gIHZhciBoZWlnaHQgPSBoZWFkZXJbb2ZmX2hlaWdodF1cbiAgdmFyIGRhdGFPZmZzZXQgPSBoZWFkZXJbb2ZmX3NpemVdICsgNFxuICB2YXIgdGV4V2lkdGggPSB3aWR0aFxuICB2YXIgdGV4SGVpZ2h0ID0gaGVpZ2h0XG4gIHZhciBpbWFnZXMgPSBbXVxuICB2YXIgZGF0YUxlbmd0aFxuXG4gIGlmIChmb3VyQ0MgPT09IEZPVVJDQ19EWDEwKSB7XG4gICAgZGF0YU9mZnNldCArPSAyMFxuICB9XG5cbiAgaWYgKGN1YmVtYXApIHtcbiAgICBmb3IgKHZhciBmID0gMDsgZiA8IDY7IGYrKykge1xuICAgICAgaWYgKGZvcm1hdCAhPT0gJ3JnYmEzMmYnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBSR0JBMzJmIGN1YmVtYXBzIGFyZSBzdXBwb3J0ZWQnKVxuICAgICAgfVxuICAgICAgdmFyIGJwcCA9IDQgKiAzMiAvIDhcblxuICAgICAgd2lkdGggPSB0ZXhXaWR0aFxuICAgICAgaGVpZ2h0ID0gdGV4SGVpZ2h0XG5cbiAgICAgIC8vIGN1YmVtYXAgc2hvdWxkIGhhdmUgYWxsIG1pcG1hcCBsZXZlbHMgZGVmaW5lZFxuICAgICAgLy8gTWF0aC5sb2cyKHdpZHRoKSArIDFcbiAgICAgIHZhciByZXF1aXJlZE1pcExldmVscyA9IE1hdGgubG9nKHdpZHRoKSAvIE1hdGgubG9nKDIpICsgMVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcXVpcmVkTWlwTGV2ZWxzOyBpKyspIHtcbiAgICAgICAgZGF0YUxlbmd0aCA9IHdpZHRoICogaGVpZ2h0ICogYnBwXG4gICAgICAgIGltYWdlcy5wdXNoKHtcbiAgICAgICAgICBvZmZzZXQ6IGRhdGFPZmZzZXQsXG4gICAgICAgICAgbGVuZ3RoOiBkYXRhTGVuZ3RoLFxuICAgICAgICAgIHNoYXBlOiBbIHdpZHRoLCBoZWlnaHQgXVxuICAgICAgICB9KVxuICAgICAgICAvLyBSZXVzZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzIGxldmVsIGlmIHdlIGFyZSBiZXlvbmQgbWlwbWFwQ291bnRcbiAgICAgICAgLy8gVGhpcyBpcyBoYWNrIGZvciBDTUZUIG5vdCBwdWJsaXNoaW5nIGZ1bGwgbWlwbWFwIGNoYWluIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJpb21hbmVza3UvY21mdC9pc3N1ZXMvMTBcbiAgICAgICAgaWYgKGkgPCBtaXBtYXBDb3VudCkge1xuICAgICAgICAgIGRhdGFPZmZzZXQgKz0gZGF0YUxlbmd0aFxuICAgICAgICB9XG4gICAgICAgIHdpZHRoID0gTWF0aC5mbG9vcih3aWR0aCAvIDIpXG4gICAgICAgIGhlaWdodCA9IE1hdGguZmxvb3IoaGVpZ2h0IC8gMilcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXBtYXBDb3VudDsgaSsrKSB7XG4gICAgICBkYXRhTGVuZ3RoID0gTWF0aC5tYXgoNCwgd2lkdGgpIC8gNCAqIE1hdGgubWF4KDQsIGhlaWdodCkgLyA0ICogYmxvY2tCeXRlc1xuXG4gICAgICBpbWFnZXMucHVzaCh7XG4gICAgICAgIG9mZnNldDogZGF0YU9mZnNldCxcbiAgICAgICAgbGVuZ3RoOiBkYXRhTGVuZ3RoLFxuICAgICAgICBzaGFwZTogWyB3aWR0aCwgaGVpZ2h0IF1cbiAgICAgIH0pXG4gICAgICBkYXRhT2Zmc2V0ICs9IGRhdGFMZW5ndGhcbiAgICAgIHdpZHRoID0gTWF0aC5mbG9vcih3aWR0aCAvIDIpXG4gICAgICBoZWlnaHQgPSBNYXRoLmZsb29yKGhlaWdodCAvIDIpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzaGFwZTogWyB0ZXhXaWR0aCwgdGV4SGVpZ2h0IF0sXG4gICAgaW1hZ2VzOiBpbWFnZXMsXG4gICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgZmxhZ3M6IGZsYWdzLFxuICAgIGN1YmVtYXA6IGN1YmVtYXBcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3VyQ0NUb0ludDMyICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuY2hhckNvZGVBdCgwKSArXG4gICAgKHZhbHVlLmNoYXJDb2RlQXQoMSkgPDwgOCkgK1xuICAgICh2YWx1ZS5jaGFyQ29kZUF0KDIpIDw8IDE2KSArXG4gICAgKHZhbHVlLmNoYXJDb2RlQXQoMykgPDwgMjQpXG59XG5cbmZ1bmN0aW9uIGludDMyVG9Gb3VyQ0MgKHZhbHVlKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgIHZhbHVlICYgMHhmZixcbiAgICAodmFsdWUgPj4gOCkgJiAweGZmLFxuICAgICh2YWx1ZSA+PiAxNikgJiAweGZmLFxuICAgICh2YWx1ZSA+PiAyNCkgJiAweGZmXG4gIClcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3BhcnNlLWRkcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBDdWJlRnJhbWVCdWZmZXIuanNcblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgR0wgZnJvbSAnLi9HTFRvb2wnO1xuaW1wb3J0IEdMQ3ViZVRleHR1cmUgZnJvbSAnLi9HTEN1YmVUZXh0dXJlJztcblxubGV0IGdsO1xuXG5cbmNsYXNzIEN1YmVGcmFtZUJ1ZmZlciB7XG5cblx0Y29uc3RydWN0b3Ioc2l6ZSwgbVBhcmFtZXRlcnMgPSB7fSkge1xuXHRcdGdsID0gR0wuZ2w7XG5cdFx0dGhpcy5fc2l6ZSA9IHNpemU7XG5cdFx0dGhpcy5tYWdGaWx0ZXIgPSBtUGFyYW1ldGVycy5tYWdGaWx0ZXIgfHwgZ2wuTElORUFSO1xuXHRcdHRoaXMubWluRmlsdGVyID0gbVBhcmFtZXRlcnMubWluRmlsdGVyIHx8IGdsLkxJTkVBUjtcblx0XHR0aGlzLndyYXBTICAgICA9IG1QYXJhbWV0ZXJzLndyYXBTIHx8IGdsLkNMQU1QX1RPX0VER0U7XG5cdFx0dGhpcy53cmFwVCAgICAgPSBtUGFyYW1ldGVycy53cmFwVCB8fCBnbC5DTEFNUF9UT19FREdFO1xuXG5cdFx0dGhpcy5faW5pdCgpO1xuXHR9XG5cblxuXHRfaW5pdCgpIHtcblx0XHR0aGlzLnRleHR1cmUgICA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblx0XHR0aGlzLmdsVGV4dHVyZSA9IG5ldyBHTEN1YmVUZXh0dXJlKHRoaXMudGV4dHVyZSwge30sIHRydWUpO1xuXG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGhpcy50ZXh0dXJlKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGhpcy5tYWdGaWx0ZXIpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLm1pbkZpbHRlcik7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX1dSQVBfUywgdGhpcy53cmFwUyk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX1dSQVBfVCwgdGhpcy53cmFwVCk7XG5cblx0XHRjb25zdCB0YXJnZXRzID0gW1xuXHRcdFx0Z2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YLCBnbC5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1gsIFxuXHRcdFx0Z2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9ZLCBnbC5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1ksIFxuXHRcdFx0Z2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aLCBnbC5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1ogXG5cdFx0XTtcblxuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG5cdFx0XHRnbC50ZXhJbWFnZTJEKHRhcmdldHNbaV0sIDAsIGdsLlJHQkEsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgbnVsbCk7XG5cdFx0fVxuXG5cblx0XHR0aGlzLl9mcmFtZUJ1ZmZlcnMgPSBbXTtcblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgZnJhbWVCdWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuXHRcdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1ZmZlcik7XG5cdFx0XHRnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIHRhcmdldHNbaV0sIHRoaXMudGV4dHVyZSwgMCk7XG5cblx0XHRcdGNvbnN0IHN0YXR1cyA9IGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpO1xuXHRcdFx0aWYgKHN0YXR1cyAhPT0gZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coYCdnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKCkgcmV0dXJuZWQgJyR7c3RhdHVzfWApO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9mcmFtZUJ1ZmZlcnMucHVzaChmcmFtZUJ1ZmZlcik7XG5cdFx0fVxuXG5cdFx0Ly8gZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV9DVUJFX01BUCk7XG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblx0XHRnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgbnVsbCk7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgbnVsbCk7XG5cdH1cblxuXG5cdGJpbmQobVRhcmdldEluZGV4KSB7XG5cblx0XHQvLyBpZihNYXRoLnJhbmRvbSgpID4gLjk5KSBjb25zb2xlLmxvZygnYmluZCA6JywgbVRhcmdldEluZGV4LCB0aGlzLl9mcmFtZUJ1ZmZlcnNbbVRhcmdldEluZGV4XSk7XG5cdFx0R0wudmlld3BvcnQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5fZnJhbWVCdWZmZXJzW21UYXJnZXRJbmRleF0pO1xuXHR9XG5cblx0dW5iaW5kKCkge1xuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cdFx0R0wudmlld3BvcnQoMCwgMCwgR0wud2lkdGgsIEdMLmhlaWdodCk7XG5cdH1cblxuXHQvL1x0VEVYVFVSRVNcblxuXHRnZXRUZXh0dXJlKCkge1xuXHRcdHJldHVybiB0aGlzLmdsVGV4dHVyZTtcblx0fVxuXG5cdC8vXHRHRVRURVJTIEFORCBTRVRURVJTXG5cblx0Z2V0IHdpZHRoKCkge1xuXHRcdHJldHVybiB0aGlzLl9zaXplO1xuXHR9XG5cblx0Z2V0IGhlaWdodCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZTtcblx0fVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IEN1YmVGcmFtZUJ1ZmZlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9DdWJlRnJhbWVCdWZmZXIuanMiLCIvLyBNdWx0aXNhbXBsZUZyYW1lQnVmZmVyLmpzXG5cbmltcG9ydCBHTCBmcm9tICcuL0dMVG9vbCc7XG5pbXBvcnQgR0xUZXh0dXJlIGZyb20gJy4vR0xUZXh0dXJlJztcblxubGV0IGdsO1xuXG5mdW5jdGlvbiBpc1Bvd2VyT2ZUd28oeCkge1x0XG5cdHJldHVybiAoeCAhPT0gMCkgJiYgKCEoeCAmICh4IC0gMSkpKTtcbn07XG5cbmNsYXNzIE11bHRpc2FtcGxlRnJhbWVCdWZmZXIge1xuXHRjb25zdHJ1Y3RvcihtV2lkdGgsIG1IZWlnaHQsIG1QYXJhbWV0ZXJzID0ge30pIHtcblx0XHRnbCA9IEdMLmdsO1xuXG5cdFx0dGhpcy53aWR0aCAgICAgICAgICAgID0gbVdpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ICAgICAgICAgICA9IG1IZWlnaHQ7XG5cblx0XHR0aGlzLm1hZ0ZpbHRlciAgPSBtUGFyYW1ldGVycy5tYWdGaWx0ZXIgXHR8fCBnbC5MSU5FQVI7XG5cdFx0dGhpcy5taW5GaWx0ZXIgID0gbVBhcmFtZXRlcnMubWluRmlsdGVyIFx0fHwgZ2wuTElORUFSO1xuXHRcdHRoaXMud3JhcFMgICAgICA9IG1QYXJhbWV0ZXJzLndyYXBTIFx0XHR8fCBnbC5DTEFNUF9UT19FREdFO1xuXHRcdHRoaXMud3JhcFQgICAgICA9IG1QYXJhbWV0ZXJzLndyYXBUIFx0XHR8fCBnbC5DTEFNUF9UT19FREdFO1xuXHRcdHRoaXMudXNlRGVwdGggICA9IG1QYXJhbWV0ZXJzLnVzZURlcHRoIFx0XHR8fCB0cnVlO1xuXHRcdHRoaXMudXNlU3RlbmNpbCA9IG1QYXJhbWV0ZXJzLnVzZVN0ZW5jaWwgXHR8fCBmYWxzZTtcblx0XHR0aGlzLnRleGVsVHlwZSBcdD0gbVBhcmFtZXRlcnMudHlwZTtcblx0XHR0aGlzLl9udW1TYW1wbGUgPSBtUGFyYW1ldGVycy5udW1TYW1wbGUgXHR8fCA4O1xuXG5cdFx0aWYoIWlzUG93ZXJPZlR3byh0aGlzLndpZHRoKSB8fCAhaXNQb3dlck9mVHdvKHRoaXMuaGVpZ2h0KSkge1xuXHRcdFx0dGhpcy53cmFwUyA9IHRoaXMud3JhcFQgPSBnbC5DTEFNUF9UT19FREdFO1xuXG5cdFx0XHRpZih0aGlzLm1pbkZpbHRlciA9PT0gZ2wuTElORUFSX01JUE1BUF9ORUFSRVNUKSB7XG5cdFx0XHRcdHRoaXMubWluRmlsdGVyID0gZ2wuTElORUFSO1xuXHRcdFx0fVxuXHRcdH0gXG5cblx0XHR0aGlzLl9pbml0KCk7XG5cdH1cblxuXHRfaW5pdCgpIHtcblx0XHRsZXQgdGV4ZWxUeXBlID0gZ2wuVU5TSUdORURfQllURTtcblx0XHRpZiAodGhpcy50ZXhlbFR5cGUpIHtcblx0XHRcdHRleGVsVHlwZSA9IHRoaXMudGV4ZWxUeXBlO1xuXHRcdH1cblxuXHRcdHRoaXMudGV4ZWxUeXBlID0gdGV4ZWxUeXBlO1xuXG5cdFx0dGhpcy5mcmFtZUJ1ZmZlciAgICAgICAgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1x0XG5cdFx0dGhpcy5mcmFtZUJ1ZmZlckNvbG9yICAgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1x0XG5cdFx0dGhpcy5yZW5kZXJCdWZmZXJDb2xvciAgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcblx0XHR0aGlzLnJlbmRlckJ1ZmZlckRlcHRoICA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuXHRcdHRoaXMuZ2xUZXh0dXJlIFx0XHRcdD0gdGhpcy5fY3JlYXRlVGV4dHVyZSgpO1xuXHRcdHRoaXMuZ2xEZXB0aFRleHR1cmUgXHQ9IHRoaXMuX2NyZWF0ZVRleHR1cmUoZ2wuREVQVEhfQ09NUE9ORU5UMTYsIGdsLlVOU0lHTkVEX1NIT1JULCBnbC5ERVBUSF9DT01QT05FTlQsIHRydWUpO1xuXG5cdFx0Z2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIHRoaXMucmVuZGVyQnVmZmVyQ29sb3IpO1xuXHRcdGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZShnbC5SRU5ERVJCVUZGRVIsIHRoaXMuX251bVNhbXBsZSwgZ2wuUkdCQTgsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuXHRcdGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCB0aGlzLnJlbmRlckJ1ZmZlckRlcHRoKTtcblx0XHRnbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoZ2wuUkVOREVSQlVGRkVSLCB0aGlzLl9udW1TYW1wbGUsIGdsLkRFUFRIX0NPTVBPTkVOVDE2LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVCdWZmZXIpO1xuXHRcdGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuUkVOREVSQlVGRkVSLCB0aGlzLnJlbmRlckJ1ZmZlckNvbG9yKTtcblx0XHRnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfQVRUQUNITUVOVCwgZ2wuUkVOREVSQlVGRkVSLCB0aGlzLnJlbmRlckJ1ZmZlckRlcHRoKTtcblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lQnVmZmVyQ29sb3IpO1xuXHRcdGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbFRleHR1cmUudGV4dHVyZSwgMCk7XG5cdFx0Ly8gZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlRFWFRVUkVfMkQsIHRoaXMuZ2xEZXB0aFRleHR1cmUudGV4dHVyZSwgMCk7XG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblxuXHRcdC8vIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZUJ1ZmZlckRlcHRoKTtcblx0XHQvLyBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfQVRUQUNITUVOVCwgZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbERlcHRoVGV4dHVyZS50ZXh0dXJlLCAwKTtcblx0XHQvLyBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXHR9XG5cblx0X2NyZWF0ZVRleHR1cmUobUludGVybmFsZm9ybWF0LCBtVGV4ZWxUeXBlLCBtRm9ybWF0LCBmb3JjZU5lYXJlc3QgPSBmYWxzZSkge1xuXHRcdGlmKG1JbnRlcm5hbGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XHRtSW50ZXJuYWxmb3JtYXQgPSBnbC5SR0JBO1x0fVxuXHRcdGlmKG1UZXhlbFR5cGUgPT09IHVuZGVmaW5lZCkge1x0bVRleGVsVHlwZSA9IHRoaXMudGV4ZWxUeXBlO1x0fVxuXHRcdGlmKCFtRm9ybWF0KSB7XHRtRm9ybWF0ID0gbUludGVybmFsZm9ybWF0OyB9XG5cblx0XHRjb25zdCB0ID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXHRcdGNvbnN0IGdsdCA9IG5ldyBHTFRleHR1cmUodCwgdHJ1ZSk7XG5cdFx0Y29uc3QgbWFnRmlsdGVyID0gZm9yY2VOZWFyZXN0ID8gR0wuTkVBUkVTVCA6IHRoaXMubWFnRmlsdGVyO1xuXHRcdGNvbnN0IG1pbkZpbHRlciA9IGZvcmNlTmVhcmVzdCA/IEdMLk5FQVJFU1QgOiB0aGlzLm1pbkZpbHRlcjtcblxuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHQpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBtYWdGaWx0ZXIpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBtaW5GaWx0ZXIpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMud3JhcFMpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMud3JhcFQpO1xuXHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgbUludGVybmFsZm9ybWF0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgbUZvcm1hdCwgbVRleGVsVHlwZSwgbnVsbCk7XHRcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblxuXHRcdHJldHVybiBnbHQ7XG5cdH1cblxuXG5cdGJpbmQobUF1dG9TZXRWaWV3cG9ydD10cnVlKSB7XG5cdFx0aWYobUF1dG9TZXRWaWV3cG9ydCkge1xuXHRcdFx0R0wudmlld3BvcnQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1x0XG5cdFx0fVxuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZUJ1ZmZlcik7XG5cdH1cblxuXG5cdHVuYmluZChtQXV0b1NldFZpZXdwb3J0PXRydWUpIHtcblx0XHRpZihtQXV0b1NldFZpZXdwb3J0KSB7XG5cdFx0XHRHTC52aWV3cG9ydCgwLCAwLCBHTC53aWR0aCwgR0wuaGVpZ2h0KTtcdFxuXHRcdH1cblxuXHRcdGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcztcblxuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuUkVBRF9GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZUJ1ZmZlcik7XG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkRSQVdfRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVCdWZmZXJDb2xvcik7XG5cdFx0Z2wuY2xlYXJCdWZmZXJmdihnbC5DT0xPUiwgMCwgWzAuMCwgMC4wLCAwLjAsIDAuMF0pO1xuXHRcdGdsLmJsaXRGcmFtZWJ1ZmZlcihcblx0XHRcdDAsIDAsIHdpZHRoLCBoZWlnaHQsXG5cdFx0XHQwLCAwLCB3aWR0aCwgaGVpZ2h0LFxuXHRcdFx0Z2wuQ09MT1JfQlVGRkVSX0JJVCwgR0wuTkVBUkVTVFxuXHRcdCk7XG5cdFx0Ly8gZ2wuYmxpdEZyYW1lYnVmZmVyKFxuXHRcdC8vIFx0MCwgMCwgd2lkdGgsIGhlaWdodCxcblx0XHQvLyBcdDAsIDAsIHdpZHRoLCBoZWlnaHQsXG5cdFx0Ly8gXHRnbC5DT0xPUl9CVUZGRVJfQklUfGdsLkRFUFRIX1NURU5DSUwsIEdMLk5FQVJFU1Rcblx0XHQvLyApO1xuXG5cdFx0Ly8gZ2wuYmluZEZyYW1lYnVmZmVyKGdsLlJFQURfRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVCdWZmZXIpO1xuXHRcdC8vIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5EUkFXX0ZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lQnVmZmVyRGVwdGgpO1xuXHRcdC8vIGdsLmNsZWFyQnVmZmVyZmkoZ2wuREVQVEhfU1RFTkNJTCwgMCwgMS4wLCAwKTtcblx0XHQvLyBnbC5ibGl0RnJhbWVidWZmZXIoXG5cdFx0Ly8gXHQwLCAwLCB3aWR0aCwgaGVpZ2h0LFxuXHRcdC8vIFx0MCwgMCwgd2lkdGgsIGhlaWdodCxcblx0XHQvLyBcdGdsLkRFUFRIX0JVRkZFUl9CSVQsIGdsLk5FQVJFU1Rcblx0XHQvLyApO1xuXG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblx0fVxuXG5cblx0Z2V0VGV4dHVyZShtSW5kZXggPSAwKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2xUZXh0dXJlO1xuXHR9XG5cblxuXHRnZXREZXB0aFRleHR1cmUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2xEZXB0aFRleHR1cmU7XG5cdH1cblxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IE11bHRpc2FtcGxlRnJhbWVCdWZmZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvTXVsdGlzYW1wbGVGcmFtZUJ1ZmZlci5qcyIsIi8vIFRyYW5zZm9ybUZlZWRiYWNrT2JqZWN0LmpzXG5cbmltcG9ydCBHTCBmcm9tICcuL0dMVG9vbCc7XG5pbXBvcnQgR0xTaGFkZXIgZnJvbSAnLi9HTFNoYWRlcic7XG5pbXBvcnQgTWVzaCBmcm9tICcuL01lc2gnO1xuXG5sZXQgZ2w7XG5cbmNsYXNzIFRyYW5zZm9ybUZlZWRiYWNrT2JqZWN0IHtcblxuXG5cdGNvbnN0cnVjdG9yKHN0clZlcnRleFNoYWRlciwgc3RyRnJhZ21lbnRTaGFkZXIpIHtcblx0XHRnbCA9IEdMLmdsO1xuXHRcdHRoaXMuX3ZzID0gc3RyVmVydGV4U2hhZGVyO1xuXHRcdHRoaXMuX2ZzID0gc3RyRnJhZ21lbnRTaGFkZXI7XG5cdFx0XG5cdFx0dGhpcy5faW5pdCgpO1xuXHR9XG5cblxuXHRfaW5pdCgpIHtcblx0XHR0aGlzLl9tZXNoQ3VycmVudCA9IG5ldyBNZXNoKCk7XG5cdFx0dGhpcy5fbWVzaFRhcmdldCA9IG5ldyBNZXNoKCk7XG5cdFx0dGhpcy5fbnVtUG9pbnRzID0gLTE7XG5cblx0XHR0aGlzLl92YXJ5aW5ncyA9IFtdO1xuXHRcdHRoaXMudHJhbnNmb3JtRmVlZGJhY2sgPSBnbC5jcmVhdGVUcmFuc2Zvcm1GZWVkYmFjaygpO1xuXHR9XG5cblxuXHRidWZmZXJEYXRhKG1EYXRhLCBtTmFtZSwgbVZhcnlpbmdOYW1lKSB7XG5cdFx0Y29uc3QgaXNUcmFuc2Zvcm1GZWVkYmFjayA9ICEhbVZhcnlpbmdOYW1lO1xuXHRcdGNvbnNvbGUubG9nKCdpcyBUcmFuc2Zvcm0gZmVlZGJhY2sgPycsIG1OYW1lLCBpc1RyYW5zZm9ybUZlZWRiYWNrKTtcblx0XHR0aGlzLl9tZXNoQ3VycmVudC5idWZmZXJEYXRhKG1EYXRhLCBtTmFtZSwgbnVsbCwgZ2wuU1RSRUFNX0NPUFksIGZhbHNlKTtcblx0XHR0aGlzLl9tZXNoVGFyZ2V0LmJ1ZmZlckRhdGEobURhdGEsIG1OYW1lLCBudWxsLCBnbC5TVFJFQU1fQ09QWSwgZmFsc2UpO1xuXG5cdFx0aWYoaXNUcmFuc2Zvcm1GZWVkYmFjaykge1xuXHRcdFx0dGhpcy5fdmFyeWluZ3MucHVzaChtVmFyeWluZ05hbWUpO1xuXG5cdFx0XHRpZih0aGlzLl9udW1Qb2ludHMgPCAwKSB7XG5cdFx0XHRcdHRoaXMuX251bVBvaW50cyA9IG1EYXRhLmxlbmd0aDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRidWZmZXJJbmRleChtQXJyYXlJbmRpY2VzKSB7XG5cdFx0dGhpcy5fbWVzaEN1cnJlbnQuYnVmZmVySW5kZXgobUFycmF5SW5kaWNlcyk7XG5cdFx0dGhpcy5fbWVzaFRhcmdldC5idWZmZXJJbmRleChtQXJyYXlJbmRpY2VzKTtcblx0fVxuXG5cblx0dW5pZm9ybShtTmFtZSwgbVR5cGUsIG1WYWx1ZSkge1xuXHRcdGlmKHRoaXMuc2hhZGVyKSB7XG5cdFx0XHR0aGlzLnNoYWRlci51bmlmb3JtKG1OYW1lLCBtVHlwZSwgbVZhbHVlKTtcdFxuXHRcdH1cblx0XHRcblx0fVxuXG5cdGdlbmVyYXRlKCkge1xuXHRcdHRoaXMuc2hhZGVyID0gbmV3IEdMU2hhZGVyKHRoaXMuX3ZzLCB0aGlzLl9mcywgdGhpcy5fdmFyeWluZ3MpO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdGlmKCF0aGlzLnNoYWRlcikge1x0dGhpcy5nZW5lcmF0ZSgpO1x0fVxuXG5cdFx0dGhpcy5zaGFkZXIuYmluZCgpO1xuXHRcdEdMLmRyYXdUcmFuc2Zvcm1GZWVkYmFjayh0aGlzKTtcblxuXHRcdHRoaXMuX3N3YXAoKTtcblx0fVxuXG5cdF9zd2FwKCkge1xuXHRcdGNvbnN0IHRtcCAgICAgICAgICA9IHRoaXMuX21lc2hDdXJyZW50O1xuXHRcdHRoaXMuX21lc2hDdXJyZW50ID0gdGhpcy5fbWVzaFRhcmdldDtcblx0XHR0aGlzLl9tZXNoVGFyZ2V0ICA9IHRtcDtcblx0fVxuXG5cdGdldCBudW1Qb2ludHMoKSB7XHRyZXR1cm4gdGhpcy5fbnVtUG9pbnRzO1x0fVxuXHRnZXQgbWVzaEN1cnJlbnQoKSB7XHRyZXR1cm4gdGhpcy5fbWVzaEN1cnJlbnQ7XHR9XG5cdGdldCBtZXNoVGFyZ2V0KCkge1x0cmV0dXJuIHRoaXMuX21lc2hUYXJnZXQ7XHR9XG5cdGdldCBtZXNoU291cmNlKCkge1x0cmV0dXJuIHRoaXMuX21lc2hDdXJyZW50O1x0fVxuXHRnZXQgbWVzaERlc3RpbmF0aW9uKCkge1x0cmV0dXJuIHRoaXMuX21lc2hUYXJnZXQ7XHR9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgVHJhbnNmb3JtRmVlZGJhY2tPYmplY3Q7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvVHJhbnNmb3JtRmVlZGJhY2tPYmplY3QuanMiLCIvLyBUd2Vlbk51bWJlci5qc1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBTY2hlZHVsZXIgZnJvbSAnc2NoZWR1bGluZyc7XG5cbmNvbnN0IEVhc2luZyA9IHtcblx0TGluZWFyOiB7XG5cdFx0Tm9uZShrKSB7XG5cdFx0XHRyZXR1cm4gaztcblx0XHR9XG5cdH0sXG5cdFF1YWRyYXRpYzoge1xuXHRcdEluKGspIHtcblx0XHRcdHJldHVybiBrICogaztcblx0XHR9LFxuXHRcdE91dChrKSB7XG5cdFx0XHRyZXR1cm4gayAqICgyIC0gayk7XG5cdFx0fSxcblx0XHRJbk91dChrKSB7XG5cdFx0XHRpZiAoKGsgKj0gMikgPCAxKSB7XG5cdFx0XHRcdHJldHVybiAwLjUgKiBrICogaztcblx0XHRcdH1cblx0XHRcdHJldHVybiAtIDAuNSAqICgtLWsgKiAoayAtIDIpIC0gMSk7XG5cdFx0fVxuXHR9LFxuXHRDdWJpYzoge1xuXHRcdEluKGspIHtcblx0XHRcdHJldHVybiBrICogayAqIGs7XG5cdFx0fSxcblx0XHRPdXQoaykge1xuXHRcdFx0cmV0dXJuIC0tayAqIGsgKiBrICsgMTtcblx0XHR9LFxuXHRcdEluT3V0KGspIHtcblx0XHRcdGlmICgoayAqPSAyKSA8IDEpIHtcblx0XHRcdFx0cmV0dXJuIDAuNSAqIGsgKiBrICogaztcblx0XHRcdH1cblx0XHRcdHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayArIDIpO1xuXHRcdH1cblx0fSxcblx0UXVhcnRpYzoge1xuXHRcdEluKGspIHtcblx0XHRcdHJldHVybiBrICogayAqIGsgKiBrO1xuXHRcdH0sXG5cdFx0T3V0KGspIHtcblx0XHRcdHJldHVybiAxIC0gKC0tayAqIGsgKiBrICogayk7XG5cdFx0fSxcblx0XHRJbk91dChrKSB7XG5cdFx0XHRpZiAoKGsgKj0gMikgPCAxKSB7XG5cdFx0XHRcdHJldHVybiAwLjUgKiBrICogayAqIGsgKiBrO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIC0gMC41ICogKChrIC09IDIpICogayAqIGsgKiBrIC0gMik7XG5cdFx0fVxuXHR9LFxuXHRRdWludGljOiB7XG5cdFx0SW4oaykge1xuXHRcdFx0cmV0dXJuIGsgKiBrICogayAqIGsgKiBrO1xuXHRcdH0sXG5cdFx0T3V0KGspIHtcblx0XHRcdHJldHVybiAtLWsgKiBrICogayAqIGsgKiBrICsgMTtcblx0XHR9LFxuXHRcdEluT3V0KGspIHtcblx0XHRcdGlmICgoayAqPSAyKSA8IDEpIHtcblx0XHRcdFx0cmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGsgKiBrO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICogayAqIGsgKyAyKTtcblx0XHR9XG5cdH0sXG5cdFNpbnVzb2lkYWw6IHtcblx0XHRJbihrKSB7XG5cdFx0XHRyZXR1cm4gMSAtIE1hdGguY29zKGsgKiBNYXRoLlBJIC8gMik7XG5cdFx0fSxcblx0XHRPdXQoaykge1xuXHRcdFx0cmV0dXJuIE1hdGguc2luKGsgKiBNYXRoLlBJIC8gMik7XG5cdFx0fSxcblx0XHRJbk91dChrKSB7XG5cdFx0XHRyZXR1cm4gMC41ICogKDEgLSBNYXRoLmNvcyhNYXRoLlBJICogaykpO1xuXHRcdH1cblx0fSxcblx0RXhwb25lbnRpYWw6IHtcblx0XHRJbihrKSB7XG5cdFx0XHRyZXR1cm4gayA9PT0gMCA/IDAgOiBNYXRoLnBvdygxMDI0LCBrIC0gMSk7XG5cdFx0fSxcblx0XHRPdXQoaykge1xuXHRcdFx0cmV0dXJuIGsgPT09IDEgPyAxIDogMSAtIE1hdGgucG93KDIsIC0gMTAgKiBrKTtcblx0XHR9LFxuXHRcdEluT3V0KGspIHtcblx0XHRcdGlmIChrID09PSAwKSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGsgPT09IDEpIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoKGsgKj0gMikgPCAxKSB7XG5cdFx0XHRcdHJldHVybiAwLjUgKiBNYXRoLnBvdygxMDI0LCBrIC0gMSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gMC41ICogKC0gTWF0aC5wb3coMiwgLSAxMCAqIChrIC0gMSkpICsgMik7XG5cdFx0fVxuXHR9LFxuXHRDaXJjdWxhcjoge1xuXHRcdEluKGspIHtcblx0XHRcdHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSBrICogayk7XG5cdFx0fSxcblx0XHRPdXQoaykge1xuXHRcdFx0cmV0dXJuIE1hdGguc3FydCgxIC0gKC0tayAqIGspKTtcblx0XHR9LFxuXHRcdEluT3V0KGspIHtcblx0XHRcdGlmICgoayAqPSAyKSA8IDEpIHtcblx0XHRcdFx0cmV0dXJuIC0gMC41ICogKE1hdGguc3FydCgxIC0gayAqIGspIC0gMSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKGsgLT0gMikgKiBrKSArIDEpO1xuXHRcdH1cblx0fSxcblx0RWxhc3RpYzoge1xuXHRcdEluKGspIHtcblx0XHRcdGxldCBzO1xuXHRcdFx0bGV0IGEgPSAwLjE7XG5cdFx0XHRjb25zdCBwID0gMC40O1xuXHRcdFx0aWYgKGsgPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoayA9PT0gMSkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblx0XHRcdGlmICghYSB8fCBhIDwgMSkge1xuXHRcdFx0XHRhID0gMTtcblx0XHRcdFx0cyA9IHAgLyA0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cyA9IHAgKiBNYXRoLmFzaW4oMSAvIGEpIC8gKDIgKiBNYXRoLlBJKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAtIChhICogTWF0aC5wb3coMiwgMTAgKiAoayAtPSAxKSkgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcblx0XHR9LFxuXHRcdE91dChrKSB7XG5cdFx0XHRsZXQgcztcblx0XHRcdGxldCBhID0gMC4xO1xuXHRcdFx0Y29uc3QgcCA9IDAuNDtcblx0XHRcdGlmIChrID09PSAwKSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGsgPT09IDEpIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWEgfHwgYSA8IDEpIHtcblx0XHRcdFx0YSA9IDE7XG5cdFx0XHRcdHMgPSBwIC8gNDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHMgPSBwICogTWF0aC5hc2luKDEgLyBhKSAvICgyICogTWF0aC5QSSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKGEgKiBNYXRoLnBvdygyLCAtIDEwICogaykgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICsgMSk7XG5cdFx0fSxcblx0XHRJbk91dChrKSB7XG5cdFx0XHRsZXQgcztcblx0XHRcdGxldCBhID0gMC4xO1xuXHRcdFx0Y29uc3QgcCA9IDAuNDtcblx0XHRcdGlmIChrID09PSAwKSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGsgPT09IDEpIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWEgfHwgYSA8IDEpIHtcblx0XHRcdFx0YSA9IDE7XG5cdFx0XHRcdHMgPSBwIC8gNDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHMgPSBwICogTWF0aC5hc2luKDEgLyBhKSAvICgyICogTWF0aC5QSSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoKGsgKj0gMikgPCAxKSB7XG5cdFx0XHRcdHJldHVybiAtIDAuNSAqIChhICogTWF0aC5wb3coMiwgMTAgKiAoayAtPSAxKSkgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogKGsgLT0gMSkpICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSAqIDAuNSArIDE7XG5cdFx0fVxuXHR9LFxuXHRCYWNrOiB7XG5cdFx0SW4oaykge1xuXHRcdFx0Y29uc3QgcyA9IDEuNzAxNTg7XG5cdFx0XHRyZXR1cm4gayAqIGsgKiAoKHMgKyAxKSAqIGsgLSBzKTtcblx0XHR9LFxuXHRcdE91dChrKSB7XG5cdFx0XHRjb25zdCBzID0gMS43MDE1ODtcblx0XHRcdHJldHVybiAtLWsgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAxO1xuXHRcdH0sXG5cdFx0SW5PdXQoaykge1xuXHRcdFx0Y29uc3QgcyA9IDEuNzAxNTggKiAxLjUyNTtcblx0XHRcdGlmICgoayAqPSAyKSA8IDEpIHtcblx0XHRcdFx0cmV0dXJuIDAuNSAqIChrICogayAqICgocyArIDEpICogayAtIHMpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAyKTtcblx0XHR9XG5cdH0sXG5cdEJvdW5jZToge1xuXHRcdGluKGspIHtcblx0XHRcdHJldHVybiAxIC0gRWFzaW5nLkJvdW5jZS5vdXQoMSAtIGspO1xuXHRcdH0sXG5cdFx0b3V0KGspIHtcblx0XHRcdGlmIChrIDwgKDEgLyAyLjc1KSkge1xuXHRcdFx0XHRyZXR1cm4gNy41NjI1ICogayAqIGs7XG5cdFx0XHR9IGVsc2UgaWYgKGsgPCAoMiAvIDIuNzUpKSB7XG5cdFx0XHRcdHJldHVybiA3LjU2MjUgKiAoayAtPSAoMS41IC8gMi43NSkpICogayArIDAuNzU7XG5cdFx0XHR9IGVsc2UgaWYgKGsgPCAoMi41IC8gMi43NSkpIHtcblx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIChrIC09ICgyLjI1IC8gMi43NSkpICogayArIDAuOTM3NTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiA3LjU2MjUgKiAoayAtPSAoMi42MjUgLyAyLjc1KSkgKiBrICsgMC45ODQzNzU7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRpbk91dChrKSB7XG5cdFx0XHRpZiAoayA8IDAuNSkge1xuXHRcdFx0XHRyZXR1cm4gRWFzaW5nLkJvdW5jZS5pbihrICogMikgKiAwLjU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gRWFzaW5nLkJvdW5jZS5vdXQoayAqIDIgLSAxKSAqIDAuNSArIDAuNTtcblx0XHR9XG5cdH1cbn07XG5cbmZ1bmN0aW9uIGdldEZ1bmMobUVhc2luZykge1xuXHRzd2l0Y2ggKG1FYXNpbmcpIHtcblx0ZGVmYXVsdDpcblx0Y2FzZSAnbGluZWFyJyA6XG5cdFx0cmV0dXJuIEVhc2luZy5MaW5lYXIuTm9uZTtcblx0Y2FzZSAnZXhwSW4nIDpcblx0XHRyZXR1cm4gRWFzaW5nLkV4cG9uZW50aWFsLkluO1xuXHRjYXNlICdleHBPdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLkV4cG9uZW50aWFsLk91dDtcblx0Y2FzZSAnZXhwSW5PdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLkV4cG9uZW50aWFsLkluT3V0O1xuXG5cdGNhc2UgJ2N1YmljSW4nIDpcblx0XHRyZXR1cm4gRWFzaW5nLkN1YmljLkluO1xuXHRjYXNlICdjdWJpY091dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuQ3ViaWMuT3V0O1xuXHRjYXNlICdjdWJpY0luT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5DdWJpYy5Jbk91dDtcblxuXHRjYXNlICdxdWFydGljSW4nIDpcblx0XHRyZXR1cm4gRWFzaW5nLlF1YXJ0aWMuSW47XG5cdGNhc2UgJ3F1YXJ0aWNPdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLlF1YXJ0aWMuT3V0O1xuXHRjYXNlICdxdWFydGljSW5PdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLlF1YXJ0aWMuSW5PdXQ7XG5cblx0Y2FzZSAncXVpbnRpY0luJyA6XG5cdFx0cmV0dXJuIEVhc2luZy5RdWludGljLkluO1xuXHRjYXNlICdxdWludGljT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5RdWludGljLk91dDtcblx0Y2FzZSAncXVpbnRpY0luT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5RdWludGljLkluT3V0O1xuXG5cdGNhc2UgJ3NpbnVzb2lkYWxJbicgOlxuXHRcdHJldHVybiBFYXNpbmcuU2ludXNvaWRhbC5Jbjtcblx0Y2FzZSAnc2ludXNvaWRhbE91dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuU2ludXNvaWRhbC5PdXQ7XG5cdGNhc2UgJ3NpbnVzb2lkYWxJbk91dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuU2ludXNvaWRhbC5Jbk91dDtcblxuXHRjYXNlICdjaXJjdWxhckluJyA6XG5cdFx0cmV0dXJuIEVhc2luZy5DaXJjdWxhci5Jbjtcblx0Y2FzZSAnY2lyY3VsYXJPdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLkNpcmN1bGFyLk91dDtcblx0Y2FzZSAnY2lyY3VsYXJJbk91dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuQ2lyY3VsYXIuSW5PdXQ7XG5cblx0Y2FzZSAnZWxhc3RpY0luJyA6XG5cdFx0cmV0dXJuIEVhc2luZy5FbGFzdGljLkluO1xuXHRjYXNlICdlbGFzdGljT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5FbGFzdGljLk91dDtcblx0Y2FzZSAnZWxhc3RpY0luT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5FbGFzdGljLkluT3V0O1xuXG5cdGNhc2UgJ2JhY2tJbicgOlxuXHRcdHJldHVybiBFYXNpbmcuQmFjay5Jbjtcblx0Y2FzZSAnYmFja091dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuQmFjay5PdXQ7XG5cdGNhc2UgJ2JhY2tJbk91dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuQmFjay5Jbk91dDtcblxuXHRjYXNlICdib3VuY2VJbicgOlxuXHRcdHJldHVybiBFYXNpbmcuQm91bmNlLmluO1xuXHRjYXNlICdib3VuY2VPdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLkJvdW5jZS5vdXQ7XG5cdGNhc2UgJ2JvdW5jZUluT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5Cb3VuY2UuaW5PdXQ7XG5cdH1cbn1cblxuY2xhc3MgVHdlZW5OdW1iZXIge1xuXHRjb25zdHJ1Y3RvcihtVmFsdWUsIG1FYXNpbmcgPSAnZXhwT3V0JywgbVNwZWVkID0gMC4wMSkge1xuXHRcdHRoaXMuX3ZhbHVlID0gbVZhbHVlO1xuXHRcdHRoaXMuX3N0YXJ0VmFsdWUgPSBtVmFsdWU7XG5cdFx0dGhpcy5fdGFyZ2V0VmFsdWUgPSBtVmFsdWU7XG5cdFx0dGhpcy5fY291bnRlciA9IDE7XG5cdFx0dGhpcy5zcGVlZCA9IG1TcGVlZDtcblx0XHR0aGlzLmVhc2luZyA9IG1FYXNpbmc7XG5cdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IHRydWU7XG5cblx0XHR0aGlzLl9lZkluZGV4ICAgICA9IFNjaGVkdWxlci5hZGRFRigoKT0+IHRoaXMuX3VwZGF0ZSgpKTtcblx0fVxuXG5cblx0X3VwZGF0ZSgpIHtcblx0XHRsZXQgbmV3Q291bnRlciA9IHRoaXMuX2NvdW50ZXIgKyB0aGlzLnNwZWVkO1xuXHRcdGlmKG5ld0NvdW50ZXIgPiAxKSB7IG5ld0NvdW50ZXIgPSAxOyB9XG5cdFx0aWYodGhpcy5fY291bnRlciA9PT0gbmV3Q291bnRlcikge1xuXHRcdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NvdW50ZXIgPSBuZXdDb3VudGVyO1xuXHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXHR9XG5cblxuXHRsaW1pdChtTWluLCBtTWF4KSB7XG5cdFx0aWYobU1pbiA+IG1NYXgpIHtcblx0XHRcdHRoaXMubGltaXQobU1heCwgbU1pbik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fbWluID0gbU1pbjtcblx0XHR0aGlzLl9tYXggPSBtTWF4O1xuXG5cdFx0dGhpcy5fY2hlY2tMaW1pdCgpO1xuXHR9XG5cblx0c2V0VG8obVZhbHVlKSB7XG5cdFx0dGhpcy5fdmFsdWUgPSBtVmFsdWU7XG5cdFx0dGhpcy5fdGFyZ2V0VmFsdWUgPSBtVmFsdWU7XG5cdFx0dGhpcy5fY291bnRlciA9IDE7XG5cdH1cblxuXG5cdF9jaGVja0xpbWl0KCkge1xuXHRcdGlmKHRoaXMuX21pbiAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX3RhcmdldFZhbHVlIDwgdGhpcy5fbWluKSB7XG5cdFx0XHR0aGlzLl90YXJnZXRWYWx1ZSA9IHRoaXMuX21pbjtcblx0XHR9IFxuXG5cdFx0aWYodGhpcy5fbWF4ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fdGFyZ2V0VmFsdWUgPiB0aGlzLl9tYXgpIHtcblx0XHRcdHRoaXMuX3RhcmdldFZhbHVlID0gdGhpcy5fbWF4O1xuXHRcdH0gXG5cdH1cblxuXG5cdGRlc3Ryb3koKSB7XG5cdFx0U2NoZWR1bGVyLnJlbW92ZUVGKHRoaXMuX2VmSW5kZXgpO1xuXHR9XG5cblx0Ly9cdEdFVFRFUlMgLyBTRVRURVJTXG5cblx0c2V0IHZhbHVlKG1WYWx1ZSkge1xuXHRcdHRoaXMuX3N0YXJ0VmFsdWUgPSB0aGlzLl92YWx1ZTtcblx0XHR0aGlzLl90YXJnZXRWYWx1ZSA9IG1WYWx1ZTtcblx0XHR0aGlzLl9jaGVja0xpbWl0KCk7XG5cdFx0dGhpcy5fY291bnRlciA9IDA7XG5cdH1cblxuXHRnZXQgdmFsdWUoKSB7XG5cdFx0aWYodGhpcy5fbmVlZFVwZGF0ZSkge1xuXHRcdFx0Y29uc3QgZiA9IGdldEZ1bmModGhpcy5lYXNpbmcpO1xuXHRcdFx0Y29uc3QgcCA9IGYodGhpcy5fY291bnRlcik7XG5cdFx0XHR0aGlzLl92YWx1ZSA9IHRoaXMuX3N0YXJ0VmFsdWUgKyBwICogKHRoaXMuX3RhcmdldFZhbHVlIC0gdGhpcy5fc3RhcnRWYWx1ZSk7XG5cdFx0XHR0aGlzLl9uZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl92YWx1ZTtcblx0fVxuXG5cdGdldCB0YXJnZXRWYWx1ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdGFyZ2V0VmFsdWU7XG5cdH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBUd2Vlbk51bWJlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9Ud2Vlbk51bWJlci5qcyIsIi8vIFF1YXRSb3RhdGlvbi5qc1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBnbG0gZnJvbSAnZ2wtbWF0cml4JztcbmltcG9ydCBFYXNlTnVtYmVyIGZyb20gJy4vRWFzZU51bWJlcic7XG5pbXBvcnQgU2NoZWR1bGVyIGZyb20gJ3NjaGVkdWxpbmcnO1xuXG5jb25zdCBnZXRNb3VzZSA9IGZ1bmN0aW9uIChtRXZlbnQsIG1UYXJnZXQpIHtcblxuXHRjb25zdCBvID0gbVRhcmdldCB8fCB7fTtcblx0aWYobUV2ZW50LnRvdWNoZXMpIHtcblx0XHRvLnggPSBtRXZlbnQudG91Y2hlc1swXS5wYWdlWDtcblx0XHRvLnkgPSBtRXZlbnQudG91Y2hlc1swXS5wYWdlWTtcblx0fSBlbHNlIHtcblx0XHRvLnggPSBtRXZlbnQuY2xpZW50WDtcblx0XHRvLnkgPSBtRXZlbnQuY2xpZW50WTtcblx0fVxuXG5cdHJldHVybiBvO1xufTtcblxuY2xhc3MgUXVhdFJvdGF0aW9uIHtcblx0Y29uc3RydWN0b3IobVRhcmdldCwgbUxpc3RlbmVyVGFyZ2V0ID0gd2luZG93LCBtRWFzaW5nID0gMC4xKSB7XG5cblx0XHR0aGlzLl90YXJnZXQgICAgICAgICA9IG1UYXJnZXQ7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQgPSBtTGlzdGVuZXJUYXJnZXQ7XG5cdFx0XG5cdFx0dGhpcy5tYXRyaXggICAgICAgICAgPSBnbG0ubWF0NC5jcmVhdGUoKTtcblx0XHR0aGlzLm0gICAgICAgICAgICAgICA9IGdsbS5tYXQ0LmNyZWF0ZSgpO1xuXHRcdHRoaXMuX3ZaYXhpcyAgICAgICAgID0gZ2xtLnZlYzMuY2xvbmUoWzAsIDAsIDBdKTtcblx0XHR0aGlzLl96QXhpcyAgICAgICAgICA9IGdsbS52ZWMzLmNsb25lKFswLCAwLCAxXSk7XG5cdFx0dGhpcy5wcmVNb3VzZSAgICAgICAgPSB7IHg6MCwgeTowIH07XG5cdFx0dGhpcy5tb3VzZSAgICAgICAgICAgPSB7IHg6MCwgeTowIH07XG5cdFx0dGhpcy5faXNNb3VzZURvd24gICAgPSBmYWxzZTtcblx0XHR0aGlzLl9yb3RhdGlvbiAgICAgICA9IGdsbS5xdWF0LmNyZWF0ZSgpO1xuXHRcdHRoaXMudGVtcFJvdGF0aW9uICAgID0gZ2xtLnF1YXQuY3JlYXRlKCk7XG5cdFx0dGhpcy5fcm90YXRlWk1hcmdpbiAgPSAwO1xuXHRcdHRoaXMuX29mZnNldCAgICAgICAgID0gMC4wMDQ7XG5cdFx0dGhpcy5fc2xlcnAgICAgICAgICAgPSAtMTtcblx0XHR0aGlzLl9pc0xvY2tlZCAgICAgICA9IGZhbHNlO1xuXHRcdFxuXHRcdHRoaXMuX2RpZmZYICAgICAgICAgID0gbmV3IEVhc2VOdW1iZXIoMCwgbUVhc2luZyk7XG5cdFx0dGhpcy5fZGlmZlkgICAgICAgICAgPSBuZXcgRWFzZU51bWJlcigwLCBtRWFzaW5nKTtcblxuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIChlKSA9PiB0aGlzLl9vbkRvd24oZSkpO1xuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCAoZSkgPT4gdGhpcy5fb25Eb3duKGUpKTtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCAoZSkgPT4gdGhpcy5fb25Nb3ZlKGUpKTtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCAoZSkgPT4gdGhpcy5fb25Nb3ZlKGUpKTtcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCAoKSA9PiB0aGlzLl9vblVwKCkpO1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgKCkgPT4gdGhpcy5fb25VcCgpKTtcblxuXHRcdFNjaGVkdWxlci5hZGRFRigoKSA9PiB0aGlzLl9sb29wKCkpO1xuXHR9XG5cblx0Ly8gXHRQVUJMSUMgTUVUSE9EU1xuXG5cdGludmVyc2VDb250cm9sKGlzSW52ZXJ0ID0gdHJ1ZSkge1xuXHRcdHRoaXMuX2lzSW52ZXJ0ID0gaXNJbnZlcnQ7XG5cdH1cblxuXHRsb2NrKG1WYWx1ZSA9IHRydWUpIHtcblx0XHR0aGlzLl9pc0xvY2tlZCA9IG1WYWx1ZTtcblx0fVx0XG5cblx0c2V0Q2FtZXJhUG9zKG1RdWF0LCBzcGVlZCA9IDAuMSkge1xuXHRcdHRoaXMuZWFzaW5nID0gc3BlZWQ7XG5cdFx0aWYodGhpcy5fc2xlcnAgPiAwKSB7IHJldHVybjsgfVxuXHRcdFxuXHRcdGNvbnN0IHRlbXBSb3RhdGlvbiAgPSBnbG0ucXVhdC5jbG9uZSh0aGlzLl9yb3RhdGlvbik7XG5cdFx0dGhpcy5fdXBkYXRlUm90YXRpb24odGVtcFJvdGF0aW9uKTtcblx0XHR0aGlzLl9yb3RhdGlvbiAgICA9IGdsbS5xdWF0LmNsb25lKHRlbXBSb3RhdGlvbik7XG5cdFx0dGhpcy5fY3VyckRpZmZYICAgPSB0aGlzLmRpZmZYID0gMDtcblx0XHR0aGlzLl9jdXJyRGlmZlkgICA9IHRoaXMuZGlmZlkgPSAwO1xuXHRcdFxuXHRcdHRoaXMuX2lzTW91c2VEb3duID0gZmFsc2U7XG5cdFx0dGhpcy5faXNSb3RhdGVaICAgPSAwO1xuXHRcdFxuXHRcdHRoaXMuX3RhcmdldFF1YXQgID0gZ2xtLnF1YXQuY2xvbmUobVF1YXQpO1xuXHRcdHRoaXMuX3NsZXJwICAgICAgID0gMTtcblx0fVxuXG5cdHJlc2V0UXVhdCgpIHtcblx0XHR0aGlzLl9yb3RhdGlvbiAgICA9IGdsbS5xdWF0LmNsb25lKFswLCAwLCAxLCAwXSk7XG5cdFx0dGhpcy50ZW1wUm90YXRpb24gPSBnbG0ucXVhdC5jbG9uZShbMCwgMCwgMCwgMF0pO1xuXHRcdHRoaXMuX3RhcmdldFF1YXQgID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuX3NsZXJwICAgICAgID0gLTE7XG5cdH1cblxuXHQvL1x0RVZFTlQgSEFORExFUlxuXG5cdF9vbkRvd24obUV2ZW50KSB7XG5cdFx0aWYodGhpcy5faXNMb2NrZWQpIHsgcmV0dXJuOyB9XG5cblx0XHRjb25zdCBtb3VzZSA9IGdldE1vdXNlKG1FdmVudCk7XG5cdFx0Y29uc3QgdGVtcFJvdGF0aW9uID0gZ2xtLnF1YXQuY2xvbmUodGhpcy5fcm90YXRpb24pO1xuXHRcdHRoaXMuX3VwZGF0ZVJvdGF0aW9uKHRlbXBSb3RhdGlvbik7XG5cdFx0dGhpcy5fcm90YXRpb24gPSB0ZW1wUm90YXRpb247XG5cblx0XHR0aGlzLl9pc01vdXNlRG93biA9IHRydWU7XG5cdFx0dGhpcy5faXNSb3RhdGVaID0gMDtcblx0XHR0aGlzLnByZU1vdXNlID0geyB4Om1vdXNlLngsIHk6bW91c2UueSB9O1xuXG5cdFx0aWYobW91c2UueSA8IHRoaXMuX3JvdGF0ZVpNYXJnaW4gfHwgbW91c2UueSA+ICh3aW5kb3cuaW5uZXJIZWlnaHQgLSB0aGlzLl9yb3RhdGVaTWFyZ2luKSkge1x0XG5cdFx0XHR0aGlzLl9pc1JvdGF0ZVogPSAxO1x0XG5cdFx0fSBlbHNlIGlmKG1vdXNlLnggPCB0aGlzLl9yb3RhdGVaTWFyZ2luIHx8IG1vdXNlLnggPiAod2luZG93LmlubmVyV2lkdGggLSB0aGlzLl9yb3RhdGVaTWFyZ2luKSkge1x0XG5cdFx0XHR0aGlzLl9pc1JvdGF0ZVogPSAyO1x0XG5cdFx0fVxuXG5cdFx0dGhpcy5fZGlmZlguc2V0VG8oMCk7XG5cdFx0dGhpcy5fZGlmZlkuc2V0VG8oMCk7XG5cdH1cblxuXG5cdF9vbk1vdmUobUV2ZW50KSB7XG5cdFx0aWYodGhpcy5faXNMb2NrZWQpIHsgcmV0dXJuOyB9XG5cdFx0Z2V0TW91c2UobUV2ZW50LCB0aGlzLm1vdXNlKTtcblx0fVxuXG5cblx0X29uVXAoKSB7XG5cdFx0aWYodGhpcy5faXNMb2NrZWQpIHsgcmV0dXJuOyB9XG5cdFx0dGhpcy5faXNNb3VzZURvd24gPSBmYWxzZTtcblx0fVxuXG5cblx0Ly9cdFBSSVZBVEUgTUVUSE9EU1xuXG5cdF91cGRhdGVSb3RhdGlvbihtVGVtcFJvdGF0aW9uKSB7XG5cdFx0aWYodGhpcy5faXNNb3VzZURvd24gJiYgIXRoaXMuX2lzTG9ja2VkKSB7XG5cdFx0XHR0aGlzLl9kaWZmWC52YWx1ZSA9IC0odGhpcy5tb3VzZS54IC0gdGhpcy5wcmVNb3VzZS54KTtcblx0XHRcdHRoaXMuX2RpZmZZLnZhbHVlID0gICh0aGlzLm1vdXNlLnkgLSB0aGlzLnByZU1vdXNlLnkpO1xuXG5cdFx0XHRpZih0aGlzLl9pc0ludmVydCkge1xuXHRcdFx0XHR0aGlzLl9kaWZmWC52YWx1ZSA9IC10aGlzLl9kaWZmWC50YXJnZXRWYWx1ZTtcblx0XHRcdFx0dGhpcy5fZGlmZlkudmFsdWUgPSAtdGhpcy5fZGlmZlkudGFyZ2V0VmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdGxldCBhbmdsZSwgX3F1YXQ7XG5cblx0XHRpZih0aGlzLl9pc1JvdGF0ZVogPiAwKSB7XG5cdFx0XHRpZih0aGlzLl9pc1JvdGF0ZVogPT09IDEpIHtcblx0XHRcdFx0YW5nbGUgPSAtdGhpcy5fZGlmZlgudmFsdWUgKiB0aGlzLl9vZmZzZXQ7IFxuXHRcdFx0XHRhbmdsZSAqPSAodGhpcy5wcmVNb3VzZS55IDwgdGhpcy5fcm90YXRlWk1hcmdpbikgPyAtMSA6IDE7XG5cdFx0XHRcdF9xdWF0ID0gZ2xtLnF1YXQuY2xvbmUoWzAsIDAsIE1hdGguc2luKGFuZ2xlKSwgTWF0aC5jb3MoYW5nbGUpXSk7XG5cdFx0XHRcdGdsbS5xdWF0Lm11bHRpcGx5KF9xdWF0LCBtVGVtcFJvdGF0aW9uLCBfcXVhdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhbmdsZSA9IC10aGlzLl9kaWZmWS52YWx1ZSAqIHRoaXMuX29mZnNldDsgXG5cdFx0XHRcdGFuZ2xlICo9ICh0aGlzLnByZU1vdXNlLnggPCB0aGlzLl9yb3RhdGVaTWFyZ2luKSA/IDEgOiAtMTtcblx0XHRcdFx0X3F1YXQgPSBnbG0ucXVhdC5jbG9uZShbMCwgMCwgTWF0aC5zaW4oYW5nbGUpLCBNYXRoLmNvcyhhbmdsZSldKTtcblx0XHRcdFx0Z2xtLnF1YXQubXVsdGlwbHkoX3F1YXQsIG1UZW1wUm90YXRpb24sIF9xdWF0KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgdiA9IGdsbS52ZWMzLmNsb25lKFt0aGlzLl9kaWZmWC52YWx1ZSwgdGhpcy5fZGlmZlkudmFsdWUsIDBdKTtcblx0XHRcdGNvbnN0IGF4aXMgPSBnbG0udmVjMy5jcmVhdGUoKTtcblx0XHRcdGdsbS52ZWMzLmNyb3NzKGF4aXMsIHYsIHRoaXMuX3pBeGlzKTtcblx0XHRcdGdsbS52ZWMzLm5vcm1hbGl6ZShheGlzLCBheGlzKTtcblx0XHRcdGFuZ2xlID0gZ2xtLnZlYzMubGVuZ3RoKHYpICogdGhpcy5fb2Zmc2V0O1xuXHRcdFx0X3F1YXQgPSBnbG0ucXVhdC5jbG9uZShbTWF0aC5zaW4oYW5nbGUpICogYXhpc1swXSwgTWF0aC5zaW4oYW5nbGUpICogYXhpc1sxXSwgTWF0aC5zaW4oYW5nbGUpICogYXhpc1syXSwgTWF0aC5jb3MoYW5nbGUpXSk7XG5cdFx0XHRnbG0ucXVhdC5tdWx0aXBseShtVGVtcFJvdGF0aW9uLCBfcXVhdCwgbVRlbXBSb3RhdGlvbik7XG5cdFx0fVxuXHR9XG5cblx0X2xvb3AoKSB7XG5cdFx0Z2xtLm1hdDQuaWRlbnRpdHkodGhpcy5tKTtcblxuXHRcdGlmKHRoaXMuX3RhcmdldFF1YXQgPT09IHVuZGVmaW5lZCkgeyBcblx0XHRcdGdsbS5xdWF0LnNldCh0aGlzLnRlbXBSb3RhdGlvbiwgdGhpcy5fcm90YXRpb25bMF0sIHRoaXMuX3JvdGF0aW9uWzFdLCB0aGlzLl9yb3RhdGlvblsyXSwgdGhpcy5fcm90YXRpb25bM10pO1xuXHRcdFx0dGhpcy5fdXBkYXRlUm90YXRpb24odGhpcy50ZW1wUm90YXRpb24pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9zbGVycCArPSAoMCAtIHRoaXMuX3NsZXJwKSAqIDAuMTtcblxuXHRcdFx0aWYodGhpcy5fc2xlcnAgPCAwLjAwMDUpIHtcblx0XHRcdFx0Z2xtLnF1YXQuY29weSh0aGlzLl9yb3RhdGlvbiwgdGhpcy5fdGFyZ2V0UXVhdCk7XG5cdFx0XHRcdGdsbS5xdWF0LmNvcHkodGhpcy50ZW1wUm90YXRpb24sIHRoaXMuX3RhcmdldFF1YXQpO1xuXHRcdFx0XHR0aGlzLl90YXJnZXRRdWF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR0aGlzLl9kaWZmWC5zZXRUbygwKTtcblx0XHRcdFx0dGhpcy5fZGlmZlkuc2V0VG8oMCk7XG5cdFx0XHRcdHRoaXMuX3NsZXJwID0gLTE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRnbG0ucXVhdC5zZXQodGhpcy50ZW1wUm90YXRpb24sIDAsIDAsIDAsIDApO1xuXHRcdFx0XHRnbG0ucXVhdC5zbGVycCh0aGlzLnRlbXBSb3RhdGlvbiwgdGhpcy5fdGFyZ2V0UXVhdCwgdGhpcy5fcm90YXRpb24sIHRoaXMuX3NsZXJwKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRnbG0udmVjMy50cmFuc2Zvcm1RdWF0KHRoaXMuX3ZaYXhpcywgdGhpcy5fdlpheGlzLCB0aGlzLnRlbXBSb3RhdGlvbik7XG5cblx0XHRnbG0ubWF0NC5mcm9tUXVhdCh0aGlzLm1hdHJpeCwgdGhpcy50ZW1wUm90YXRpb24pO1xuXHR9XG5cblxuXHQvL1x0R0VUVEVSIEFORCBTRVRURVJcblxuXHRzZXQgZWFzaW5nKG1WYWx1ZSkge1xuXHRcdHRoaXMuX2RpZmZYLmVhc2luZyA9IG1WYWx1ZTtcblx0XHR0aGlzLl9kaWZmWS5lYXNpbmcgPSBtVmFsdWU7XG5cdH1cblxuXHRnZXQgZWFzaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLl9kaWZmWC5lYXNpbmc7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUXVhdFJvdGF0aW9uO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL1F1YXRSb3RhdGlvbi5qcyIsIi8vIFRvdWNoRGV0ZWN0b3IuanNcbmltcG9ydCBHTCBmcm9tICcuLi9HTFRvb2wnO1xuaW1wb3J0IEV2ZW50RGlzcGF0Y2hlciBmcm9tICcuL0V2ZW50RGlzcGF0Y2hlcic7XG5pbXBvcnQgUmF5IGZyb20gJy4uL21hdGgvUmF5JztcbmltcG9ydCBnZXRNb3VzZSBmcm9tICcuL2dldE1vdXNlJztcblxuZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuXHRjb25zdCBkeCA9IGEueCAtIGIueDtcblx0Y29uc3QgZHkgPSBhLnkgLSBiLnk7XG5cdHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xufVxuXG5jbGFzcyBUb3VjaERldGVjdG9yIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcblx0Y29uc3RydWN0b3IobU1lc2gsIG1DYW1lcmEsIG1Ta2lwTW92ZUNoZWNrPWZhbHNlLCBtTGlzdGVuZXJUYXJnZXQ9d2luZG93KSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuX21lc2ggPSBtTWVzaDtcblx0XHR0aGlzLl9tZXNoLmdlbmVyYXRlRmFjZXMoKTtcblx0XHR0aGlzLl9jYW1lcmEgPSBtQ2FtZXJhO1xuXHRcdHRoaXMuZmFjZVZlcnRpY2VzID0gbU1lc2guZmFjZXMubWFwKChmYWNlKT0+KGZhY2UudmVydGljZXMpKTtcblx0XHR0aGlzLmNsaWNrVG9sZXJhbmNlID0gODtcblxuXHRcdHRoaXMuX3JheSA9IG5ldyBSYXkoWzAsIDAsIDBdLCBbMCwgMCwgLTFdKTtcblx0XHR0aGlzLl9oaXQgPSB2ZWMzLmZyb21WYWx1ZXMoLTk5OSwgLTk5OSwgLTk5OSk7XG5cdFx0dGhpcy5fbGFzdFBvcztcblx0XHR0aGlzLl9maXJzdFBvcztcblx0XHR0aGlzLm10eE1vZGVsID0gbWF0NC5jcmVhdGUoKTtcblxuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0ID0gbUxpc3RlbmVyVGFyZ2V0O1xuXHRcdHRoaXMuX3NraXBwaW5nTW92ZSA9IG1Ta2lwTW92ZUNoZWNrO1xuXG5cdFx0dGhpcy5fb25Nb3ZlQmluZCA9IChlKSA9PiB0aGlzLl9vbk1vdmUoZSk7XG5cdFx0dGhpcy5fb25Eb3duQmluZCA9IChlKSA9PiB0aGlzLl9vbkRvd24oZSk7XG5cdFx0dGhpcy5fb25VcEJpbmQgPSAoKSA9PiB0aGlzLl9vblVwKCk7XG5cblx0XHR0aGlzLmNvbm5lY3QoKTtcblx0fVxuXG5cdGNvbm5lY3QoKSB7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Eb3duQmluZCk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3ZlQmluZCk7XHRcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25VcEJpbmQpO1xuXHR9XG5cblx0ZGlzY29ubmVjdCgpIHtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbkRvd25CaW5kKTtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdmVCaW5kKTtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25VcEJpbmQpO1xuXHR9XG5cblxuXHRfY2hlY2tIaXQobVR5cGU9J29uSGl0Jykge1xuXHRcdGNvbnN0IGNhbWVyYSA9IHRoaXMuX2NhbWVyYTtcblx0XHRpZighY2FtZXJhKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cblx0XHRjb25zdCBteCA9ICh0aGlzLl9sYXN0UG9zLnggLyBHTC53aWR0aCkgKiAyLjAgLSAxLjA7XG5cdFx0Y29uc3QgbXkgPSAtICh0aGlzLl9sYXN0UG9zLnkgLyBHTC5oZWlnaHQpICogMi4wICsgMS4wO1xuXG5cdFx0Y2FtZXJhLmdlbmVyYXRlUmF5KFtteCwgbXksIDBdLCB0aGlzLl9yYXkpO1xuXG5cdFx0bGV0IGhpdDtcblx0XHRjb25zdCB2MCA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0Y29uc3QgdjEgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdGNvbnN0IHYyID0gdmVjMy5jcmVhdGUoKTtcblx0XHRsZXQgZGlzdCA9IDA7XG5cblx0XHRjb25zdCBnZXRWZWN0b3IgPSAodiwgdGFyZ2V0KSA9PiB7XG5cdFx0XHR2ZWMzLnRyYW5zZm9ybU1hdDQodGFyZ2V0LCB2LCB0aGlzLm10eE1vZGVsKTtcblx0XHR9O1xuXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHRoaXMuZmFjZVZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IHRoaXMuZmFjZVZlcnRpY2VzW2ldO1xuXHRcdFx0Z2V0VmVjdG9yKHZlcnRpY2VzWzBdLCB2MCk7IFxuXHRcdFx0Z2V0VmVjdG9yKHZlcnRpY2VzWzFdLCB2MSk7IFxuXHRcdFx0Z2V0VmVjdG9yKHZlcnRpY2VzWzJdLCB2Mik7IFxuXHRcdFx0Y29uc3QgdCA9IHRoaXMuX3JheS5pbnRlcnNlY3RUcmlhbmdsZSh2MCwgdjEsIHYyKTtcblxuXHRcdFx0aWYodCkge1xuXHRcdFx0XHRpZihoaXQpIHtcblx0XHRcdFx0XHRjb25zdCBkaXN0VG9DYW0gPSB2ZWMzLmRpc3QodCwgY2FtZXJhLnBvc2l0aW9uKTtcblx0XHRcdFx0XHRpZihkaXN0VG9DYW0gPCBkaXN0KSB7XG5cdFx0XHRcdFx0XHRoaXQgPSB2ZWMzLmNsb25lKHQpO1xuXHRcdFx0XHRcdFx0ZGlzdCA9IGRpc3RUb0NhbTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aGl0ID0gdmVjMy5jbG9uZSh0KTtcblx0XHRcdFx0XHRkaXN0ID0gdmVjMy5kaXN0KGhpdCwgY2FtZXJhLnBvc2l0aW9uKTtcblx0XHRcdFx0fVx0XG5cdFx0XHR9XG5cdFx0fVxuXG5cblx0XHRpZihoaXQpIHtcblx0XHRcdHRoaXMuX2hpdCA9IHZlYzMuY2xvbmUoaGl0KTtcblx0XHRcdHRoaXMuZGlzcGF0Y2hDdXN0b21FdmVudChtVHlwZSwgeyBoaXQgfSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZGlzcGF0Y2hDdXN0b21FdmVudCgnb25VcCcpO1xuXHRcdH1cblx0fVxuXG5cblx0X29uRG93bihlKSB7XG5cdFx0dGhpcy5fZmlyc3RQb3MgPSBnZXRNb3VzZShlKTtcblx0XHR0aGlzLl9sYXN0UG9zID0gZ2V0TW91c2UoZSk7XG5cdFx0dGhpcy5fY2hlY2tIaXQoJ29uRG93bicpO1xuXHR9XG5cblx0X29uTW92ZShlKSB7XG5cdFx0dGhpcy5fbGFzdFBvcyA9IGdldE1vdXNlKGUpO1xuXHRcdGlmKCF0aGlzLl9za2lwcGluZ01vdmUpIHtcblx0XHRcdHRoaXMuX2NoZWNrSGl0KCk7XG5cdFx0fVxuXHR9XG5cblx0X29uVXAoKSB7XG5cdFx0Y29uc3QgZGlzdCA9IGRpc3RhbmNlKHRoaXMuX2ZpcnN0UG9zLCB0aGlzLl9sYXN0UG9zKTtcblx0XHRpZihkaXN0IDwgdGhpcy5jbGlja1RvbGVyYW5jZSkge1xuXHRcdFx0dGhpcy5fY2hlY2tIaXQoKTtcdFxuXHRcdH1cblx0XHRcblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFRvdWNoRGV0ZWN0b3I7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvVG91Y2hEZXRlY3Rvci5qcyIsIi8vIGdldE1vdXNlLmpzXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChlKSB7XG5cdGxldCB4LCB5O1xuXG5cdGlmKGUudG91Y2hlcykge1xuXHRcdHggPSBlLnRvdWNoZXNbMF0ucGFnZVg7XG5cdFx0eSA9IGUudG91Y2hlc1swXS5wYWdlWTtcblx0fSBlbHNlIHtcblx0XHR4ID0gZS5jbGllbnRYO1xuXHRcdHkgPSBlLmNsaWVudFk7XG5cdH1cblxuXG5cdHJldHVybiB7XG5cdFx0eCwgeVxuXHR9O1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL2dldE1vdXNlLmpzIiwiLy8gQ2FtZXJhQ3ViZS5qc1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBDYW1lcmFQZXJzcGVjdGl2ZSBmcm9tICcuL0NhbWVyYVBlcnNwZWN0aXZlJztcbmltcG9ydCB7IHZlYzMgfSBmcm9tICdnbC1tYXRyaXgnO1xuXG5jb25zdCBDQU1FUkFfU0VUVElOR1MgPSBbXG5cdFt2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgMCksIHZlYzMuZnJvbVZhbHVlcygxLCAwLCAwKSwgdmVjMy5mcm9tVmFsdWVzKDAsIC0xLCAwKV0sXHRcdFxuXHRbdmVjMy5mcm9tVmFsdWVzKDAsIDAsIDApLCB2ZWMzLmZyb21WYWx1ZXMoLTEsIDAsIDApLCB2ZWMzLmZyb21WYWx1ZXMoMCwgLTEsIDApXSxcblx0W3ZlYzMuZnJvbVZhbHVlcygwLCAwLCAwKSwgdmVjMy5mcm9tVmFsdWVzKDAsICAxLCAwKSwgdmVjMy5mcm9tVmFsdWVzKDAsIDAsICAxKV0sXG5cdFt2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgMCksIHZlYzMuZnJvbVZhbHVlcygwLCAtMSwgMCksIHZlYzMuZnJvbVZhbHVlcygwLCAwLCAtMSldLFxuXHRbdmVjMy5mcm9tVmFsdWVzKDAsIDAsIDApLCB2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgIDEpLCB2ZWMzLmZyb21WYWx1ZXMoMCwgLTEsIDApXSxcblx0W3ZlYzMuZnJvbVZhbHVlcygwLCAwLCAwKSwgdmVjMy5mcm9tVmFsdWVzKDAsIDAsIC0xKSwgdmVjMy5mcm9tVmFsdWVzKDAsIC0xLCAwKV1cbl07XG5cbmNsYXNzIENhbWVyYUN1YmUgZXh0ZW5kcyBDYW1lcmFQZXJzcGVjdGl2ZSB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuc2V0UGVyc3BlY3RpdmUoTWF0aC5QSSAvIDIsIDEsIDAuMSwgMTAwMCk7XG5cdH1cblxuXG5cdGZhY2UobUluZGV4KSB7XG5cdFx0Y29uc3QgbyA9IENBTUVSQV9TRVRUSU5HU1ttSW5kZXhdO1xuXHRcdHRoaXMubG9va0F0KG9bMF0sIG9bMV0sIG9bMl0pO1xuXHR9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgQ2FtZXJhQ3ViZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9jYW1lcmFzL0NhbWVyYUN1YmUuanMiLCIvLyBPYmpMb2FkZXIuanNcblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQmluYXJ5TG9hZGVyIGZyb20gJy4vQmluYXJ5TG9hZGVyJztcbmltcG9ydCBNZXNoIGZyb20gJy4uL01lc2gnO1xuXG5jbGFzcyBPYmpMb2FkZXIgZXh0ZW5kcyBCaW5hcnlMb2FkZXIge1xuXG5cdGxvYWQodXJsLCBjYWxsYmFjaywgZHJhd1R5cGUgPSA0KSB7XG5cdFx0dGhpcy5fZHJhd1R5cGUgPSBkcmF3VHlwZTtcblx0XHRzdXBlci5sb2FkKHVybCwgY2FsbGJhY2spO1xuXHR9XG5cblx0X29uTG9hZGVkKCkge1xuXHRcdHRoaXMucGFyc2VPYmoodGhpcy5fcmVxLnJlc3BvbnNlKTtcblx0fVxuXG5cdHBhcnNlT2JqKG9ialN0cikge1xuXHRcdGNvbnN0IGxpbmVzID0gb2JqU3RyLnNwbGl0KCdcXG4nKTtcblxuXHRcdGNvbnN0IHBvc2l0aW9ucyAgICA9IFtdO1xuXHRcdGNvbnN0IGNvb3JkcyAgICAgICA9IFtdO1xuXHRcdGNvbnN0IGZpbmFsTm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHZlcnRpY2VzICAgICA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgICAgICA9IFtdO1xuXHRcdGNvbnN0IHV2cyAgICAgICAgICA9IFtdO1xuXHRcdGNvbnN0IGluZGljZXMgICAgICA9IFtdO1xuXHRcdGxldCBjb3VudCAgICAgICAgPSAwO1xuXHRcdGxldCByZXN1bHQ7XG5cblx0XHQvLyB2IGZsb2F0IGZsb2F0IGZsb2F0XG5cdFx0Y29uc3QgdmVydGV4UGF0dGVybiA9IC92KCArW1xcZHxcXC58XFwrfFxcLXxlfEVdKykoICtbXFxkfFxcLnxcXCt8XFwtfGV8RV0rKSggK1tcXGR8XFwufFxcK3xcXC18ZXxFXSspLztcblxuXHRcdC8vIHZuIGZsb2F0IGZsb2F0IGZsb2F0XG5cdFx0Y29uc3Qgbm9ybWFsUGF0dGVybiA9IC92biggK1tcXGR8XFwufFxcK3xcXC18ZXxFXSspKCArW1xcZHxcXC58XFwrfFxcLXxlfEVdKykoICtbXFxkfFxcLnxcXCt8XFwtfGV8RV0rKS87XG5cblx0XHQvLyB2dCBmbG9hdCBmbG9hdFxuXHRcdGNvbnN0IHV2UGF0dGVybiA9IC92dCggK1tcXGR8XFwufFxcK3xcXC18ZXxFXSspKCArW1xcZHxcXC58XFwrfFxcLXxlfEVdKykvO1xuXG5cdFx0Ly8gZiB2ZXJ0ZXggdmVydGV4IHZlcnRleCAuLi5cblx0XHRjb25zdCBmYWNlUGF0dGVybjEgPSAvZiggKy0/XFxkKykoICstP1xcZCspKCArLT9cXGQrKSggKy0/XFxkKyk/LztcblxuXHRcdC8vIGYgdmVydGV4L3V2IHZlcnRleC91diB2ZXJ0ZXgvdXYgLi4uXG5cdFx0Y29uc3QgZmFjZVBhdHRlcm4yID0gL2YoICsoLT9cXGQrKVxcLygtP1xcZCspKSggKygtP1xcZCspXFwvKC0/XFxkKykpKCArKC0/XFxkKylcXC8oLT9cXGQrKSkoICsoLT9cXGQrKVxcLygtP1xcZCspKT8vO1xuXG5cdFx0Ly8gZiB2ZXJ0ZXgvdXYvbm9ybWFsIHZlcnRleC91di9ub3JtYWwgdmVydGV4L3V2L25vcm1hbCAuLi5cblx0XHRjb25zdCBmYWNlUGF0dGVybjMgPSAvZiggKygtP1xcZCspXFwvKC0/XFxkKylcXC8oLT9cXGQrKSkoICsoLT9cXGQrKVxcLygtP1xcZCspXFwvKC0/XFxkKykpKCArKC0/XFxkKylcXC8oLT9cXGQrKVxcLygtP1xcZCspKSggKygtP1xcZCspXFwvKC0/XFxkKylcXC8oLT9cXGQrKSk/LztcblxuXHRcdC8vIGYgdmVydGV4Ly9ub3JtYWwgdmVydGV4Ly9ub3JtYWwgdmVydGV4Ly9ub3JtYWwgLi4uIFxuXHRcdGNvbnN0IGZhY2VQYXR0ZXJuNCA9IC9mKCArKC0/XFxkKylcXC9cXC8oLT9cXGQrKSkoICsoLT9cXGQrKVxcL1xcLygtP1xcZCspKSggKygtP1xcZCspXFwvXFwvKC0/XFxkKykpKCArKC0/XFxkKylcXC9cXC8oLT9cXGQrKSk/LztcblxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VWZXJ0ZXhJbmRleCh2YWx1ZSkge1xuXHRcdFx0Y29uc3QgaW5kZXggPSBwYXJzZUludCh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gKGluZGV4ID49IDAgPyBpbmRleCAtIDEgOiBpbmRleCArIHZlcnRpY2VzLmxlbmd0aCAvIDMpICogMztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZU5vcm1hbEluZGV4KHZhbHVlKSB7XG5cdFx0XHRjb25zdCBpbmRleCA9IHBhcnNlSW50KHZhbHVlKTtcblx0XHRcdHJldHVybiAoaW5kZXggPj0gMCA/IGluZGV4IC0gMSA6IGluZGV4ICsgbm9ybWFscy5sZW5ndGggLyAzKSAqIDM7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VVVkluZGV4KHZhbHVlKSB7XG5cdFx0XHRjb25zdCBpbmRleCA9IHBhcnNlSW50KHZhbHVlKTtcblx0XHRcdHJldHVybiAoaW5kZXggPj0gMCA/IGluZGV4IC0gMSA6IGluZGV4ICsgdXZzLmxlbmd0aCAvIDIpICogMjtcblx0XHR9XG5cblxuXHRcdGZ1bmN0aW9uIGFkZFZlcnRleChhLCBiLCBjKSB7XG5cdFx0XHRwb3NpdGlvbnMucHVzaChbdmVydGljZXNbYV0sIHZlcnRpY2VzW2EgKyAxXSwgdmVydGljZXNbYSArIDJdXSk7XG5cdFx0XHRwb3NpdGlvbnMucHVzaChbdmVydGljZXNbYl0sIHZlcnRpY2VzW2IgKyAxXSwgdmVydGljZXNbYiArIDJdXSk7XG5cdFx0XHRwb3NpdGlvbnMucHVzaChbdmVydGljZXNbY10sIHZlcnRpY2VzW2MgKyAxXSwgdmVydGljZXNbYyArIDJdXSk7XG5cblx0XHRcdGluZGljZXMucHVzaChjb3VudCAqIDMgKyAwKTtcblx0XHRcdGluZGljZXMucHVzaChjb3VudCAqIDMgKyAxKTtcblx0XHRcdGluZGljZXMucHVzaChjb3VudCAqIDMgKyAyKTtcblxuXHRcdFx0Y291bnQgKys7XG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiBhZGRVVihhLCBiLCBjKSB7XG5cdFx0XHRjb29yZHMucHVzaChbdXZzW2FdLCB1dnNbYSArIDFdXSk7XG5cdFx0XHRjb29yZHMucHVzaChbdXZzW2JdLCB1dnNbYiArIDFdXSk7XG5cdFx0XHRjb29yZHMucHVzaChbdXZzW2NdLCB1dnNbYyArIDFdXSk7XG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiBhZGROb3JtYWwoYSwgYiwgYykge1xuXHRcdFx0ZmluYWxOb3JtYWxzLnB1c2goW25vcm1hbHNbYV0sIG5vcm1hbHNbYSArIDFdLCBub3JtYWxzW2EgKyAyXV0pO1xuXHRcdFx0ZmluYWxOb3JtYWxzLnB1c2goW25vcm1hbHNbYl0sIG5vcm1hbHNbYiArIDFdLCBub3JtYWxzW2IgKyAyXV0pO1xuXHRcdFx0ZmluYWxOb3JtYWxzLnB1c2goW25vcm1hbHNbY10sIG5vcm1hbHNbYyArIDFdLCBub3JtYWxzW2MgKyAyXV0pO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZEZhY2UoYSwgYiwgYywgZCwgIHVhLCB1YiwgdWMsIHVkLCAgbmEsIG5iLCBuYywgbmQpIHtcblx0XHRcdGxldCBpYSA9IHBhcnNlVmVydGV4SW5kZXgoYSk7XG5cdFx0XHRsZXQgaWIgPSBwYXJzZVZlcnRleEluZGV4KGIpO1xuXHRcdFx0bGV0IGljID0gcGFyc2VWZXJ0ZXhJbmRleChjKTtcblx0XHRcdGxldCBpZDtcblxuXHRcdFx0aWYgKGQgPT09IHVuZGVmaW5lZCkge1xuXG5cdFx0XHRcdGFkZFZlcnRleChpYSwgaWIsIGljKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZCA9IHBhcnNlVmVydGV4SW5kZXgoZCk7XG5cblx0XHRcdFx0YWRkVmVydGV4KGlhLCBpYiwgaWQpO1xuXHRcdFx0XHRhZGRWZXJ0ZXgoaWIsIGljLCBpZCk7XG5cblx0XHRcdH1cblxuXG5cdFx0XHRpZiAodWEgIT09IHVuZGVmaW5lZCkge1xuXG5cdFx0XHRcdGlhID0gcGFyc2VVVkluZGV4KHVhKTtcblx0XHRcdFx0aWIgPSBwYXJzZVVWSW5kZXgodWIpO1xuXHRcdFx0XHRpYyA9IHBhcnNlVVZJbmRleCh1Yyk7XG5cblx0XHRcdFx0aWYgKGQgPT09IHVuZGVmaW5lZCkge1xuXG5cdFx0XHRcdFx0YWRkVVYoaWEsIGliLCBpYyk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGlkID0gcGFyc2VVVkluZGV4KHVkKTtcblxuXHRcdFx0XHRcdGFkZFVWKGlhLCBpYiwgaWQpO1xuXHRcdFx0XHRcdGFkZFVWKGliLCBpYywgaWQpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAobmEgIT09IHVuZGVmaW5lZCkge1xuXG5cdFx0XHRcdGlhID0gcGFyc2VOb3JtYWxJbmRleChuYSk7XG5cdFx0XHRcdGliID0gcGFyc2VOb3JtYWxJbmRleChuYik7XG5cdFx0XHRcdGljID0gcGFyc2VOb3JtYWxJbmRleChuYyk7XG5cblx0XHRcdFx0aWYgKGQgPT09IHVuZGVmaW5lZCkge1xuXG5cdFx0XHRcdFx0YWRkTm9ybWFsKGlhLCBpYiwgaWMpO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpZCA9IHBhcnNlTm9ybWFsSW5kZXgobmQpO1xuXG5cdFx0XHRcdFx0YWRkTm9ybWFsKGlhLCBpYiwgaWQpO1xuXHRcdFx0XHRcdGFkZE5vcm1hbChpYiwgaWMsIGlkKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9XG5cblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICsrKSB7XG5cdFx0XHRsZXQgbGluZSA9IGxpbmVzW2ldO1xuXHRcdFx0bGluZSA9IGxpbmUudHJpbSgpO1xuXG5cdFx0XHRpZiAobGluZS5sZW5ndGggPT09IDAgfHwgbGluZS5jaGFyQXQoMCkgPT09ICcjJykge1xuXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHR9IGVsc2UgaWYgKChyZXN1bHQgPSB2ZXJ0ZXhQYXR0ZXJuLmV4ZWMobGluZSkpICE9PSBudWxsKSB7XG5cblx0XHRcdFx0dmVydGljZXMucHVzaChcblx0XHRcdFx0XHRwYXJzZUZsb2F0KHJlc3VsdFsxXSksXG5cdFx0XHRcdFx0cGFyc2VGbG9hdChyZXN1bHRbMl0pLFxuXHRcdFx0XHRcdHBhcnNlRmxvYXQocmVzdWx0WzNdKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2UgaWYgKChyZXN1bHQgPSBub3JtYWxQYXR0ZXJuLmV4ZWMobGluZSkpICE9PSBudWxsKSB7XG5cblx0XHRcdFx0bm9ybWFscy5wdXNoKFxuXHRcdFx0XHRcdHBhcnNlRmxvYXQocmVzdWx0WzFdKSxcblx0XHRcdFx0XHRwYXJzZUZsb2F0KHJlc3VsdFsyXSksXG5cdFx0XHRcdFx0cGFyc2VGbG9hdChyZXN1bHRbM10pXG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAoKHJlc3VsdCA9IHV2UGF0dGVybi5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xuXG5cdFx0XHRcdHV2cy5wdXNoKFxuXHRcdFx0XHRcdHBhcnNlRmxvYXQocmVzdWx0WzFdKSxcblx0XHRcdFx0XHRwYXJzZUZsb2F0KHJlc3VsdFsyXSlcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIGlmICgocmVzdWx0ID0gZmFjZVBhdHRlcm4xLmV4ZWMobGluZSkpICE9PSBudWxsKSB7XG5cblx0XHRcdFx0YWRkRmFjZShcblx0XHRcdFx0XHRyZXN1bHRbMV0sIHJlc3VsdFsyXSwgcmVzdWx0WzNdLCByZXN1bHRbNF1cblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIGlmICgocmVzdWx0ID0gZmFjZVBhdHRlcm4yLmV4ZWMobGluZSkpICE9PSBudWxsKSB7XG5cblx0XHRcdFx0YWRkRmFjZShcblx0XHRcdFx0XHRyZXN1bHRbMl0sIHJlc3VsdFs1XSwgcmVzdWx0WzhdLCByZXN1bHRbMTFdLFxuXHRcdFx0XHRcdHJlc3VsdFszXSwgcmVzdWx0WzZdLCByZXN1bHRbOV0sIHJlc3VsdFsxMl1cblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIGlmICgocmVzdWx0ID0gZmFjZVBhdHRlcm4zLmV4ZWMobGluZSkpICE9PSBudWxsKSB7XG5cdFx0XHRcdGFkZEZhY2UoXG5cdFx0XHRcdFx0cmVzdWx0WzJdLCByZXN1bHRbNl0sIHJlc3VsdFsxMF0sIHJlc3VsdFsxNF0sXG5cdFx0XHRcdFx0cmVzdWx0WzNdLCByZXN1bHRbN10sIHJlc3VsdFsxMV0sIHJlc3VsdFsxNV0sXG5cdFx0XHRcdFx0cmVzdWx0WzRdLCByZXN1bHRbOF0sIHJlc3VsdFsxMl0sIHJlc3VsdFsxNl1cblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIGlmICgocmVzdWx0ID0gZmFjZVBhdHRlcm40LmV4ZWMobGluZSkpICE9PSBudWxsKSB7XG5cdFx0XHRcdGFkZEZhY2UoXG5cdFx0XHRcdFx0cmVzdWx0WzJdLCByZXN1bHRbNV0sIHJlc3VsdFs4XSwgcmVzdWx0WzExXSxcblx0XHRcdFx0XHR1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsXG5cdFx0XHRcdFx0cmVzdWx0WzNdLCByZXN1bHRbNl0sIHJlc3VsdFs5XSwgcmVzdWx0WzEyXVxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IFxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLl9nZW5lcmF0ZU1lc2hlcyh7XHRcblx0XHRcdHBvc2l0aW9ucyxcblx0XHRcdGNvb3Jkcyxcblx0XHRcdG5vcm1hbHM6ZmluYWxOb3JtYWxzLFxuXHRcdFx0aW5kaWNlc1xuXHRcdH0pO1xuXHRcdFxuXHR9XG5cblx0X2dlbmVyYXRlTWVzaGVzKG8pIHtcblx0XHRjb25zdCBtYXhOdW1WZXJ0aWNlcyA9IDY1NTM1O1xuXHRcdGNvbnN0IGhhc05vcm1hbHMgPSBvLm5vcm1hbHMubGVuZ3RoID4gMDtcblx0XHRjb25zdCBoYXNVVnMgPSBvLmNvb3Jkcy5sZW5ndGggPiAwO1xuXHRcdGxldCBtZXNoO1xuXG5cdFx0aWYoby5wb3NpdGlvbnMubGVuZ3RoID4gbWF4TnVtVmVydGljZXMpIHtcblx0XHRcdGNvbnN0IG1lc2hlcyA9IFtdO1xuXHRcdFx0bGV0IGxhc3RJbmRleCA9IDA7XG5cblx0XHRcdGNvbnN0IG9Db3B5ICAgICAgID0ge307XG5cdFx0XHRvQ29weS5wb3NpdGlvbnMgPSBvLnBvc2l0aW9ucy5jb25jYXQoKTtcblx0XHRcdG9Db3B5LmNvb3JkcyAgICA9IG8uY29vcmRzLmNvbmNhdCgpO1xuXHRcdFx0b0NvcHkuaW5kaWNlcyAgID0gby5pbmRpY2VzLmNvbmNhdCgpO1xuXHRcdFx0b0NvcHkubm9ybWFscyAgID0gby5ub3JtYWxzLmNvbmNhdCgpO1xuXG5cdFx0XHR3aGlsZShvLmluZGljZXMubGVuZ3RoID4gMCkge1xuXG5cdFx0XHRcdGNvbnN0IHNsaWNlTnVtICA9IE1hdGgubWluKG1heE51bVZlcnRpY2VzLCBvLnBvc2l0aW9ucy5sZW5ndGgpO1xuXHRcdFx0XHRjb25zdCBpbmRpY2VzICAgPSBvLmluZGljZXMuc3BsaWNlKDAsIHNsaWNlTnVtKTtcblx0XHRcdFx0Y29uc3QgcG9zaXRpb25zID0gW107XG5cdFx0XHRcdGNvbnN0IGNvb3JkcyAgICA9IFtdO1xuXHRcdFx0XHRjb25zdCBub3JtYWxzICAgPSBbXTtcblx0XHRcdFx0bGV0IGluZGV4LCB0bXBJbmRleCA9IDA7XG5cblx0XHRcdFx0Zm9yKGxldCBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZihpbmRpY2VzW2ldID4gdG1wSW5kZXgpIHtcblx0XHRcdFx0XHRcdHRtcEluZGV4ID0gaW5kaWNlc1tpXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpbmRleCA9IGluZGljZXNbaV07XG5cblx0XHRcdFx0XHRwb3NpdGlvbnMucHVzaChvQ29weS5wb3NpdGlvbnNbaW5kZXhdKTtcblx0XHRcdFx0XHRpZihoYXNVVnMpIHtcblx0XHRcdFx0XHRcdGNvb3Jkcy5wdXNoKG9Db3B5LmNvb3Jkc1tpbmRleF0pO1x0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKGhhc05vcm1hbHMpIHtcblx0XHRcdFx0XHRcdG5vcm1hbHMucHVzaChvQ29weS5ub3JtYWxzW2luZGV4XSk7XHRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aW5kaWNlc1tpXSAtPSBsYXN0SW5kZXg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsYXN0SW5kZXggPSB0bXBJbmRleCArIDE7XG5cblx0XHRcdFx0bWVzaCA9IG5ldyBNZXNoKHRoaXMuX2RyYXdUeXBlKTtcblx0XHRcdFx0bWVzaC5idWZmZXJWZXJ0ZXgocG9zaXRpb25zKTtcblx0XHRcdFx0aWYoaGFzVVZzKSB7XG5cdFx0XHRcdFx0bWVzaC5idWZmZXJUZXhDb29yZChjb29yZHMpO1x0XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdG1lc2guYnVmZmVySW5kZXgoaW5kaWNlcyk7XG5cdFx0XHRcdGlmKGhhc05vcm1hbHMpIHtcblx0XHRcdFx0XHRtZXNoLmJ1ZmZlck5vcm1hbChub3JtYWxzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1lc2hlcy5wdXNoKG1lc2gpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZih0aGlzLl9jYWxsYmFjaykge1xuXHRcdFx0XHR0aGlzLl9jYWxsYmFjayhtZXNoZXMsIG9Db3B5KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1lc2hlcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWVzaCA9IG5ldyBNZXNoKHRoaXMuX2RyYXdUeXBlKTtcblx0XHRcdG1lc2guYnVmZmVyVmVydGV4KG8ucG9zaXRpb25zKTtcblx0XHRcdGlmKGhhc1VWcykge1xuXHRcdFx0XHRtZXNoLmJ1ZmZlclRleENvb3JkKG8uY29vcmRzKTtcdFxuXHRcdFx0fVxuXHRcdFx0bWVzaC5idWZmZXJJbmRleChvLmluZGljZXMpO1xuXHRcdFx0aWYoaGFzTm9ybWFscykge1xuXHRcdFx0XHRtZXNoLmJ1ZmZlck5vcm1hbChvLm5vcm1hbHMpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZih0aGlzLl9jYWxsYmFjaykge1xuXHRcdFx0XHR0aGlzLl9jYWxsYmFjayhtZXNoLCBvKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1lc2g7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBudWxsO1xuXHR9XG59XG5cblxuT2JqTG9hZGVyLnBhcnNlID0gZnVuY3Rpb24gKG9ialN0cikge1xuXHRjb25zdCBsb2FkZXIgPSBuZXcgT2JqTG9hZGVyKCk7XG5cdHJldHVybiBsb2FkZXIucGFyc2VPYmoob2JqU3RyKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE9iakxvYWRlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9sb2FkZXJzL09iakxvYWRlci5qcyIsIi8vIEhEUkxvYWRlci5qc1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBCaW5hcnlMb2FkZXIgZnJvbSAnLi9CaW5hcnlMb2FkZXInO1xuaW1wb3J0IGhkclBhcnNlciBmcm9tICcuLi91dGlscy9IRFJQYXJzZXInO1xuXG5jbGFzcyBIRFJMb2FkZXIgZXh0ZW5kcyBCaW5hcnlMb2FkZXIge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcih0cnVlKTtcblx0fVxuXG5cdHBhcnNlKG1BcnJheUJ1ZmZlcikge1xuXHRcdHJldHVybiBoZHJQYXJzZXIobUFycmF5QnVmZmVyKTtcblx0fVxuXG5cdF9vbkxvYWRlZCgpIHtcblx0XHRjb25zdCBvID0gdGhpcy5wYXJzZSh0aGlzLl9yZXEucmVzcG9uc2UpO1xuXHRcdGlmKHRoaXMuX2NhbGxiYWNrKSB7XG5cdFx0XHR0aGlzLl9jYWxsYmFjayhvKTtcblx0XHR9XG5cdH1cblxufVxuXG5cbkhEUkxvYWRlci5wYXJzZSA9IGZ1bmN0aW9uIChtQXJyYXlCdWZmZXIpIHtcblx0cmV0dXJuIGhkclBhcnNlcihtQXJyYXlCdWZmZXIpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgSERSTG9hZGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2xvYWRlcnMvSERSTG9hZGVyLmpzIiwiLy8gSERSUGFyc2VyLmpzXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gQ29kZSBwb3J0ZWQgYnkgTWFyY2luIElnbmFjICgyMDE0KVxuLy8gQmFzZWQgb24gSmF2YSBpbXBsZW1lbnRhdGlvbiBmcm9tXG4vLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9yL2N5czEyMzQ1LXJlc2VhcmNoL3NvdXJjZS9icm93c2UvaGRyL2ltYWdlX3Byb2Nlc3Nvci9SR0JFLmphdmE/cj03ZDg0ZTlmZDg2NmIyNDA3OWRiZTYxZmEwYTk2NmNlODM2NWY1NzI2XG5jb25zdCByYWRpYW5jZVBhdHRlcm4gPSAnI1xcXFw/UkFESUFOQ0UnO1xuY29uc3QgY29tbWVudFBhdHRlcm4gPSAnIy4qJztcbi8vIGxldCBnYW1tYVBhdHRlcm4gPSAnR0FNTUE9JztcbmNvbnN0IGV4cG9zdXJlUGF0dGVybiA9ICdFWFBPU1VSRT1cXFxccyooWzAtOV0qWy5dWzAtOV0qKSc7XG5jb25zdCBmb3JtYXRQYXR0ZXJuID0gJ0ZPUk1BVD0zMi1iaXRfcmxlX3JnYmUnO1xuY29uc3Qgd2lkdGhIZWlnaHRQYXR0ZXJuID0gJy1ZIChbMC05XSspIFxcXFwrWCAoWzAtOV0rKSc7XG5cbi8vIGh0dHA6Ly9jcm9xdWV0d2Vhay5ibG9nc3BvdC5jby51ay8yMDE0LzA4L2RlY29uc3RydWN0aW5nLWZsb2F0cy1mcmV4cC1hbmQtbGRleHAuaHRtbFxuLy8gZnVuY3Rpb24gbGRleHAobWFudGlzc2EsIGV4cG9uZW50KSB7XG4vLyAgICAgcmV0dXJuIGV4cG9uZW50ID4gMTAyMyA/IG1hbnRpc3NhICogTWF0aC5wb3coMiwgMTAyMykgKiBNYXRoLnBvdygyLCBleHBvbmVudCAtIDEwMjMpIDogZXhwb25lbnQgPCAtMTA3NCA/IG1hbnRpc3NhICogTWF0aC5wb3coMiwgLTEwNzQpICogTWF0aC5wb3coMiwgZXhwb25lbnQgKyAxMDc0KSA6IG1hbnRpc3NhICogTWF0aC5wb3coMiwgZXhwb25lbnQpO1xuLy8gfVxuXG5mdW5jdGlvbiByZWFkUGl4ZWxzUmF3UkxFKGJ1ZmZlciwgZGF0YSwgb2Zmc2V0LCBmaWxlT2Zmc2V0LCBzY2FubGluZVdpZHRoLCBudW1TY2FubGluZXMpIHtcblx0Y29uc3QgcmdiZSA9IG5ldyBBcnJheSg0KTtcblx0bGV0IHNjYW5saW5lQnVmZmVyID0gbnVsbDtcblx0bGV0IHB0cjtcblx0bGV0IHB0ckVuZDtcblx0bGV0IGNvdW50O1xuXHRjb25zdCBidWYgPSBuZXcgQXJyYXkoMik7XG5cdGNvbnN0IGJ1ZmZlckxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG5cblx0ZnVuY3Rpb24gcmVhZEJ1ZihidWYpIHtcblx0XHRsZXQgYnl0ZXNSZWFkID0gMDtcblx0XHRkbyB7XG5cdFx0XHRidWZbYnl0ZXNSZWFkKytdID0gYnVmZmVyW2ZpbGVPZmZzZXRdO1xuXHRcdH0gd2hpbGUoKytmaWxlT2Zmc2V0IDwgYnVmZmVyTGVuZ3RoICYmIGJ5dGVzUmVhZCA8IGJ1Zi5sZW5ndGgpO1xuXHRcdHJldHVybiBieXRlc1JlYWQ7XG5cdH1cblxuXHRmdW5jdGlvbiByZWFkQnVmT2Zmc2V0KGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpIHtcblx0XHRsZXQgYnl0ZXNSZWFkID0gMDtcblx0XHRkbyB7XG5cdFx0XHRidWZbb2Zmc2V0ICsgYnl0ZXNSZWFkKytdID0gYnVmZmVyW2ZpbGVPZmZzZXRdO1xuXHRcdH0gd2hpbGUoKytmaWxlT2Zmc2V0IDwgYnVmZmVyTGVuZ3RoICYmIGJ5dGVzUmVhZCA8IGxlbmd0aCk7XG5cdFx0cmV0dXJuIGJ5dGVzUmVhZDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJlYWRQaXhlbHNSYXcoYnVmZmVyLCBkYXRhLCBvZmZzZXQsIG51bXBpeGVscykge1xuXHRcdGNvbnN0IG51bUV4cGVjdGVkID0gNCAqIG51bXBpeGVscztcblx0XHRjb25zdCBudW1SZWFkID0gcmVhZEJ1Zk9mZnNldChkYXRhLCBvZmZzZXQsIG51bUV4cGVjdGVkKTtcblx0XHRpZiAobnVtUmVhZCA8IG51bUV4cGVjdGVkKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHJlYWRpbmcgcmF3IHBpeGVsczogZ290ICR7bnVtUmVhZH0gYnl0ZXMsIGV4cGVjdGVkICR7bnVtRXhwZWN0ZWR9YCk7XG5cdFx0fVxuXHR9XG5cblx0d2hpbGUgKG51bVNjYW5saW5lcyA+IDApIHtcblx0XHRpZiAocmVhZEJ1ZihyZ2JlKSA8IHJnYmUubGVuZ3RoKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHJlYWRpbmcgYnl0ZXM6IGV4cGVjdGVkICR7cmdiZS5sZW5ndGh9YCk7XG5cdFx0fVxuXG5cdFx0aWYgKChyZ2JlWzBdICE9PSAyKSB8fCAocmdiZVsxXSAhPT0gMikgfHwgKChyZ2JlWzJdICYgMHg4MCkgIT09IDApKSB7XG5cdFx0XHQvLyB0aGlzIGZpbGUgaXMgbm90IHJ1biBsZW5ndGggZW5jb2RlZFxuXHRcdFx0ZGF0YVtvZmZzZXQrK10gPSByZ2JlWzBdO1xuXHRcdFx0ZGF0YVtvZmZzZXQrK10gPSByZ2JlWzFdO1xuXHRcdFx0ZGF0YVtvZmZzZXQrK10gPSByZ2JlWzJdO1xuXHRcdFx0ZGF0YVtvZmZzZXQrK10gPSByZ2JlWzNdO1xuXHRcdFx0cmVhZFBpeGVsc1JhdyhidWZmZXIsIGRhdGEsIG9mZnNldCwgc2NhbmxpbmVXaWR0aCAqIG51bVNjYW5saW5lcyAtIDEpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgoKChyZ2JlWzJdICYgMHhGRikgPDwgOCkgfCAocmdiZVszXSAmIDB4RkYpKSAhPT0gc2NhbmxpbmVXaWR0aCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBXcm9uZyBzY2FubGluZSB3aWR0aCAkeygoKHJnYmVbMl0gJiAweEZGKSA8PCA4KSB8IChyZ2JlWzNdICYgMHhGRikpfSwgZXhwZWN0ZWQgJHtzY2FubGluZVdpZHRofWApO1xuXHRcdH1cblxuXHRcdGlmIChzY2FubGluZUJ1ZmZlciA9PT0gbnVsbCkge1xuXHRcdFx0c2NhbmxpbmVCdWZmZXIgPSBuZXcgQXJyYXkoNCAqIHNjYW5saW5lV2lkdGgpO1xuXHRcdH1cblxuXHRcdHB0ciA9IDA7XG5cdFx0LyogcmVhZCBlYWNoIG9mIHRoZSBmb3VyIGNoYW5uZWxzIGZvciB0aGUgc2NhbmxpbmUgaW50byB0aGUgYnVmZmVyICovXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdHB0ckVuZCA9IChpICsgMSkgKiBzY2FubGluZVdpZHRoO1xuXHRcdFx0d2hpbGUocHRyIDwgcHRyRW5kKSB7XG5cdFx0XHRcdGlmIChyZWFkQnVmKGJ1ZikgPCBidWYubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFcnJvciByZWFkaW5nIDItYnl0ZSBidWZmZXInKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoKGJ1ZlswXSAmIDB4RkYpID4gMTI4KSB7XG5cdFx0XHRcdFx0LyogYSBydW4gb2YgdGhlIHNhbWUgdmFsdWUgKi9cblx0XHRcdFx0XHRjb3VudCA9IChidWZbMF0gJiAweEZGKSAtIDEyODtcblx0XHRcdFx0XHRpZiAoKGNvdW50ID09PSAwKSB8fCAoY291bnQgPiBwdHJFbmQgLSBwdHIpKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0JhZCBzY2FubGluZSBkYXRhJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlKGNvdW50LS0gPiAwKSB7XG5cdFx0XHRcdFx0XHRzY2FubGluZUJ1ZmZlcltwdHIrK10gPSBidWZbMV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8qIGEgbm9uLXJ1biAqL1xuXHRcdFx0XHRcdGNvdW50ID0gYnVmWzBdICYgMHhGRjtcblx0XHRcdFx0XHRpZiAoKGNvdW50ID09PSAwKSB8fCAoY291bnQgPiBwdHJFbmQgLSBwdHIpKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0JhZCBzY2FubGluZSBkYXRhJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNjYW5saW5lQnVmZmVyW3B0cisrXSA9IGJ1ZlsxXTtcblx0XHRcdFx0XHRpZiAoLS1jb3VudCA+IDApIHtcblx0XHRcdFx0XHRcdGlmIChyZWFkQnVmT2Zmc2V0KHNjYW5saW5lQnVmZmVyLCBwdHIsIGNvdW50KSA8IGNvdW50KSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignRXJyb3IgcmVhZGluZyBub24tcnVuIGRhdGEnKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHB0ciArPSBjb3VudDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKiBjb3B5IGJ5dGUgZGF0YSB0byBvdXRwdXQgKi9cblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgc2NhbmxpbmVXaWR0aDsgaSsrKSB7XG5cdFx0XHRkYXRhW29mZnNldCArIDBdID0gc2NhbmxpbmVCdWZmZXJbaV07XG5cdFx0XHRkYXRhW29mZnNldCArIDFdID0gc2NhbmxpbmVCdWZmZXJbaSArIHNjYW5saW5lV2lkdGhdO1xuXHRcdFx0ZGF0YVtvZmZzZXQgKyAyXSA9IHNjYW5saW5lQnVmZmVyW2kgKyAyICogc2NhbmxpbmVXaWR0aF07XG5cdFx0XHRkYXRhW29mZnNldCArIDNdID0gc2NhbmxpbmVCdWZmZXJbaSArIDMgKiBzY2FubGluZVdpZHRoXTtcblx0XHRcdG9mZnNldCArPSA0O1xuXHRcdH1cblxuXHRcdG51bVNjYW5saW5lcy0tO1xuXHR9XG5cbn1cblxuLy8gUmV0dXJucyBkYXRhIGFzIGZsb2F0cyBhbmQgZmxpcHBlZCBhbG9uZyBZIGJ5IGRlZmF1bHRcbmZ1bmN0aW9uIHBhcnNlSGRyKGJ1ZmZlcikge1xuXHRpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcblx0XHRidWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuXHR9XG5cblx0bGV0IGZpbGVPZmZzZXQgPSAwO1xuXHRjb25zdCBidWZmZXJMZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuXG5cdGNvbnN0IE5FV19MSU5FID0gMTA7XG5cblx0ZnVuY3Rpb24gcmVhZExpbmUoKSB7XG5cdFx0bGV0IGJ1ZiA9ICcnO1xuXHRcdGRvIHtcblx0XHRcdGNvbnN0IGIgPSBidWZmZXJbZmlsZU9mZnNldF07XG5cdFx0XHRpZiAoYiA9PT0gTkVXX0xJTkUpIHtcblx0XHRcdFx0KytmaWxlT2Zmc2V0O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGJ1ZiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGIpO1xuXHRcdH0gd2hpbGUoKytmaWxlT2Zmc2V0IDwgYnVmZmVyTGVuZ3RoKTtcblx0XHRyZXR1cm4gYnVmO1xuXHR9XG5cblx0bGV0IHdpZHRoID0gMDtcblx0bGV0IGhlaWdodCA9IDA7XG5cdGxldCBleHBvc3VyZSA9IDE7XG5cdGNvbnN0IGdhbW1hID0gMTtcblx0bGV0IHJsZSA9IGZhbHNlO1xuXG5cdGZvcihsZXQgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XG5cdFx0Y29uc3QgbGluZSA9IHJlYWRMaW5lKCk7XG5cdFx0bGV0IG1hdGNoO1xuXHRcdGlmIChtYXRjaCA9IGxpbmUubWF0Y2gocmFkaWFuY2VQYXR0ZXJuKSkge1xuXHRcdH0gZWxzZSBpZiAobWF0Y2ggPSBsaW5lLm1hdGNoKGZvcm1hdFBhdHRlcm4pKSB7XG5cdFx0XHRybGUgPSB0cnVlO1xuXHRcdH0gZWxzZSBpZiAobWF0Y2ggPSBsaW5lLm1hdGNoKGV4cG9zdXJlUGF0dGVybikpIHtcblx0XHRcdGV4cG9zdXJlID0gTnVtYmVyKG1hdGNoWzFdKTtcblx0XHR9IGVsc2UgaWYgKG1hdGNoID0gbGluZS5tYXRjaChjb21tZW50UGF0dGVybikpIHtcblx0XHR9IGVsc2UgaWYgKG1hdGNoID0gbGluZS5tYXRjaCh3aWR0aEhlaWdodFBhdHRlcm4pKSB7XG5cdFx0XHRoZWlnaHQgPSBOdW1iZXIobWF0Y2hbMV0pO1xuXHRcdFx0d2lkdGggPSBOdW1iZXIobWF0Y2hbMl0pO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCFybGUpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ZpbGUgaXMgbm90IHJ1biBsZW5ndGggZW5jb2RlZCEnKTtcblx0fVxuXG5cdGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuXHRjb25zdCBzY2FubGluZVdpZHRoID0gd2lkdGg7XG5cdGNvbnN0IG51bVNjYW5saW5lcyA9IGhlaWdodDtcblxuXHRyZWFkUGl4ZWxzUmF3UkxFKGJ1ZmZlciwgZGF0YSwgMCwgZmlsZU9mZnNldCwgc2NhbmxpbmVXaWR0aCwgbnVtU2NhbmxpbmVzKTtcblxuXHQvLyBUT0RPOiBTaG91bGQgYmUgRmxvYXQxNlxuXHRjb25zdCBmbG9hdERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG5cdGZvcihsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgZGF0YS5sZW5ndGg7IG9mZnNldCArPSA0KSB7XG5cdFx0bGV0IHIgPSBkYXRhW29mZnNldCArIDBdIC8gMjU1O1xuXHRcdGxldCBnID0gZGF0YVtvZmZzZXQgKyAxXSAvIDI1NTtcblx0XHRsZXQgYiA9IGRhdGFbb2Zmc2V0ICsgMl0gLyAyNTU7XG5cdFx0Y29uc3QgZSA9IGRhdGFbb2Zmc2V0ICsgM107XG5cdFx0Y29uc3QgZiA9IE1hdGgucG93KDIuMCwgZSAtIDEyOC4wKTtcblxuXHRcdHIgKj0gZjtcblx0XHRnICo9IGY7XG5cdFx0YiAqPSBmO1xuXG5cdFx0Y29uc3QgZmxvYXRPZmZzZXQgPSBvZmZzZXQ7XG5cblx0XHRmbG9hdERhdGFbZmxvYXRPZmZzZXQgKyAwXSA9IHI7XG5cdFx0ZmxvYXREYXRhW2Zsb2F0T2Zmc2V0ICsgMV0gPSBnO1xuXHRcdGZsb2F0RGF0YVtmbG9hdE9mZnNldCArIDJdID0gYjtcblx0XHRmbG9hdERhdGFbZmxvYXRPZmZzZXQgKyAzXSA9IDEuMDtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0c2hhcGU6IFt3aWR0aCwgaGVpZ2h0XSxcblx0XHRleHBvc3VyZSxcblx0XHRnYW1tYSxcblx0XHRkYXRhOiBmbG9hdERhdGFcblx0fTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBwYXJzZUhkcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9IRFJQYXJzZXIuanMiLCIvLyBDb2xsYWRhUGFyc2VyLmpzXG5cbmltcG9ydCBwYXJzZXIgZnJvbSAnY29sbGFkYS1wYXJzZXInO1xuaW1wb3J0IE1lc2ggZnJvbSAnLi4vTWVzaCc7XG5cblxuY29uc3QgZ2VuZXJhdGVNZXNoID0gZnVuY3Rpb24gKG1lc2hlcykge1xuXHRjb25zdCBjYWNoZXMgPSB7fTtcblxuXHRtZXNoZXMuZm9yRWFjaCgobWVzaCk9PiB7XG5cdFx0Y29uc3QgeyB2ZXJ0aWNlcywgbm9ybWFscywgY29vcmRzLCB0cmlhbmdsZXMsIG5hbWUgfSA9IG1lc2gubWVzaDtcblx0XHRpZighY2FjaGVzW25hbWVdKSB7XG5cdFx0XHRjb25zdCBnbE1lc2ggPSBuZXcgTWVzaCgpXG5cdFx0XHRcdC5idWZmZXJGbGF0dGVuRGF0YSh2ZXJ0aWNlcywgJ2FWZXJ0ZXhQb3NpdGlvbicsIDMpXG5cdFx0XHRcdC5idWZmZXJGbGF0dGVuRGF0YShjb29yZHMsICdhVGV4dHVyZUNvb3JkJywgMilcblx0XHRcdFx0LmJ1ZmZlckZsYXR0ZW5EYXRhKG5vcm1hbHMsICdhTm9ybWFsJywgMylcblx0XHRcdFx0LmJ1ZmZlckluZGV4KHRyaWFuZ2xlcyk7XG5cblx0XHRcdGNhY2hlc1tuYW1lXSA9IGdsTWVzaDtcblx0XHR9XG5cblx0XHRtZXNoLmdsTWVzaCA9IGNhY2hlc1tuYW1lXTtcblx0fSk7XG59O1xuXG5jb25zdCBwYXJzZSA9IGZ1bmN0aW9uIChtRGF0YSkge1xuXHRjb25zdCBtZXNoZXMgPSBwYXJzZXIucGFyc2UobURhdGEpO1xuXHRnZW5lcmF0ZU1lc2gobWVzaGVzKTtcblxuXHRyZXR1cm4gbWVzaGVzO1xufTtcblxuY29uc3QgbG9hZCA9IGZ1bmN0aW9uIChtUGF0aCwgbUNhbGxiYWNrKSB7XG5cdHBhcnNlci5sb2FkKG1QYXRoLCAobWVzaGVzKT0+IHtcblx0XHRnZW5lcmF0ZU1lc2gobWVzaGVzKTtcblx0XHRtQ2FsbGJhY2sobWVzaGVzKTtcblx0fSk7XG59O1xuXG5jb25zdCBDb2xsYWRhUGFyc2VyID0ge1xuXHRwYXJzZSxcblx0bG9hZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBDb2xsYWRhUGFyc2VyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2xvYWRlcnMvQ29sbGFkYVBhcnNlci5qcyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9Db2xsYWRhID0gcmVxdWlyZSgnLi9Db2xsYWRhJyk7XG5cbnZhciBfQ29sbGFkYTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db2xsYWRhKTtcblxudmFyIF9nbE1hdHJpeCA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBDb2xsYWRhUGFyc2VyLmpzXG5cbnZhciBwYXJzZURhdGEgPSBmdW5jdGlvbiBwYXJzZURhdGEobURhdGEpIHtcblx0dmFyIG1hdGVyaWFscyA9IG1EYXRhLm1hdGVyaWFscyxcblx0ICAgIG1lc2hlcyA9IG1EYXRhLm1lc2hlcztcblxuXG5cdHZhciBmaW5hbE1lc2hlcyA9IFtdO1xuXHR2YXIgbWVzaE9ianMgPSBbXTtcblx0dmFyIGFsbE1lc2hlcyA9IFtdO1xuXG5cdC8vXHRnZXR0aW5nIGFsbCBtZXNoZXMnIGJ1ZmZlcnNcblx0Zm9yICh2YXIgcyBpbiBtZXNoZXMpIHtcblx0XHR2YXIgb01lc2ggPSBtZXNoZXNbc107XG5cdFx0dmFyIHZlcnRpY2VzID0gb01lc2gudmVydGljZXMsXG5cdFx0ICAgIG5vcm1hbHMgPSBvTWVzaC5ub3JtYWxzLFxuXHRcdCAgICBjb29yZHMgPSBvTWVzaC5jb29yZHMsXG5cdFx0ICAgIHRyaWFuZ2xlcyA9IG9NZXNoLnRyaWFuZ2xlcztcblxuXHRcdHZhciBidWZmZXJzID0ge1xuXHRcdFx0dmVydGljZXM6IHZlcnRpY2VzLCBub3JtYWxzOiBub3JtYWxzLCBjb29yZHM6IGNvb3JkcywgdHJpYW5nbGVzOiB0cmlhbmdsZXNcblx0XHR9O1xuXHRcdGFsbE1lc2hlcy5wdXNoKHtcblx0XHRcdGlkOiBzLFxuXHRcdFx0YnVmZmVyczogYnVmZmVyc1xuXHRcdH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0TWF0ZXJpYWwoaWQpIHtcblx0XHR2YXIgbWF0ID0gdm9pZCAwO1xuXHRcdGZvciAodmFyIF9zIGluIG1hdGVyaWFscykge1xuXHRcdFx0aWYgKF9zID09PSBpZCkge1xuXHRcdFx0XHRtYXQgPSBtYXRlcmlhbHNbX3NdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBvTWF0ZXJpYWwgPSB7fTtcblx0XHRpZiAobWF0LmRpZmZ1c2UpIHtcblx0XHRcdG9NYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBtYXQuZGlmZnVzZTtcblx0XHR9XG5cblx0XHRvTWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gbWF0LmRpZmZ1c2UgfHwgWzAsIDAsIDBdO1xuXHRcdG9NYXRlcmlhbC5zaGluaW5lc3MgPSBtYXQuc2hpbmluZXNzIHx8IDA7XG5cdFx0aWYgKG1hdC50ZXh0dXJlcykge1xuXHRcdFx0aWYgKG1hdC50ZXh0dXJlcy5kaWZmdXNlKSB7XG5cdFx0XHRcdG9NYXRlcmlhbC5kaWZmdXNlTWFwSUQgPSBtYXQudGV4dHVyZXMuZGlmZnVzZS5tYXBfaWQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXQudGV4dHVyZXMubm9ybWFsKSB7XG5cdFx0XHRcdG9NYXRlcmlhbC5ub3JtYWxNYXBJRCA9IG1hdC50ZXh0dXJlcy5ub3JtYWwubWFwX2lkO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvTWF0ZXJpYWw7XG5cdH1cblxuXHRmdW5jdGlvbiB3YWxrKG5vZGUsIG10eFBhcmVudCkge1xuXHRcdHZhciBtID0gX2dsTWF0cml4Lm1hdDQuY3JlYXRlKCk7XG5cdFx0aWYgKG5vZGUubW9kZWwpIHtcblx0XHRcdF9nbE1hdHJpeC5tYXQ0Lm11bHRpcGx5KG0sIG10eFBhcmVudCwgbm9kZS5tb2RlbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdF9nbE1hdHJpeC5tYXQ0LmNvcHkobSwgbXR4UGFyZW50KTtcblx0XHR9XG5cblx0XHRpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG5cdFx0XHRub2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG5cdFx0XHRcdHdhbGsoY2hpbGQsIG0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKG5vZGUubWVzaCkge1xuXHRcdFx0dmFyIF9vTWVzaCA9IHt9O1xuXHRcdFx0X29NZXNoLm1vZGVsTWF0cml4ID0gbTtcblx0XHRcdF9vTWVzaC5tZXNoID0gbWVzaGVzW25vZGUubWVzaF07XG5cdFx0XHRfb01lc2guaWQgPSBub2RlLmlkO1xuXHRcdFx0X29NZXNoLm5hbWUgPSBub2RlLm5hbWU7XG5cdFx0XHRfb01lc2gubWF0ZXJpYWwgPSBnZXRNYXRlcmlhbChub2RlLm1hdGVyaWFsKTtcblx0XHRcdG1lc2hPYmpzLnB1c2goX29NZXNoKTtcblx0XHR9XG5cdH1cblxuXHR2YXIgbXR4ID0gX2dsTWF0cml4Lm1hdDQuY3JlYXRlKCk7XG5cdHdhbGsobURhdGEucm9vdCwgbXR4KTtcblxuXHRyZXR1cm4gbWVzaE9ianM7XG59O1xuXG52YXIgcGFyc2UgPSBmdW5jdGlvbiBwYXJzZShtRmlsZSkge1xuXHR2YXIgbyA9IF9Db2xsYWRhMi5kZWZhdWx0LnBhcnNlKG1GaWxlKTtcblx0cmV0dXJuIHBhcnNlRGF0YShvKTtcbn07XG5cbnZhciBsb2FkID0gZnVuY3Rpb24gbG9hZChtUGF0aCwgbUNhbGxCYWNrKSB7XG5cdF9Db2xsYWRhMi5kZWZhdWx0LmxvYWQobVBhdGgsIGZ1bmN0aW9uIChtRGF0YSkge1xuXHRcdG1DYWxsQmFjayhwYXJzZURhdGEobURhdGEpKTtcblx0fSk7XG59O1xuXG52YXIgQ29sbGFkYVBhcnNlciA9IHtcblx0bG9hZDogbG9hZCxcblx0cGFyc2U6IHBhcnNlXG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDb2xsYWRhUGFyc2VyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xsYWRhUGFyc2VyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvbGxhZGEtcGFyc2VyL2xpYi9Db2xsYWRhUGFyc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dsTWF0cml4ID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKTtcblxudmFyIGlzV29ya2VyID0gZ2xvYmFsLmRvY3VtZW50ID09PSB1bmRlZmluZWQ7IC8vIENvbGxhZGEuanNcblxudmFyIERFRzJSQUQgPSBNYXRoLlBJICogMiAvIDM2MDtcblxuLy9nbG9iYWwgdGVtcG9yYWwgdmFyaWFibGVzXG52YXIgdGVtcF9tYXQ0ID0gbnVsbDtcbnZhciB0ZW1wX3ZlYzIgPSBudWxsO1xudmFyIHRlbXBfdmVjMyA9IG51bGw7XG52YXIgdGVtcF92ZWM0ID0gbnVsbDtcbnZhciB0ZW1wX3F1YXQgPSBudWxsO1xuXG5mdW5jdGlvbiByZXF1ZXN0KHVybCwgY2FsbGJhY2spIHtcblx0dmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHRyZXEub25sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZXNwb25zZSA9IHRoaXMucmVzcG9uc2U7XG5cdFx0aWYgKHRoaXMuc3RhdHVzICE9IDIwMCkgcmV0dXJuO1xuXHRcdGlmIChjYWxsYmFjaykgY2FsbGJhY2sodGhpcy5yZXNwb25zZSk7XG5cdH07XG5cdHJlcS5vcGVuKFwiZ2V0XCIsIHVybCwgdHJ1ZSk7XG5cdHJlcS5zZW5kKCk7XG59XG5cbnZhciBDb2xsYWRhID0ge1xuXG5cdGxpYnNQYXRoOiBcIi4vXCIsXG5cdHdvcmtlclBhdGg6IFwiLi9cIixcblx0bm9fZmxpcDogdHJ1ZSxcblx0dXNlX3RyYW5zZmVyYWJsZXM6IHRydWUsIC8vZm9yIHdvcmtlcnNcblx0b25lcnJvcjogbnVsbCxcblx0dmVyYm9zZTogZmFsc2UsXG5cdGNvbmZpZzogeyBmb3JjZVBhcnNlcjogZmFsc2UgfSxcblxuXHRpbml0OiBmdW5jdGlvbiBpbml0KGNvbmZpZykge1xuXHRcdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblx0XHRmb3IgKHZhciBpIGluIGNvbmZpZykge1xuXHRcdFx0dGhpc1tpXSA9IGNvbmZpZ1tpXTtcblx0XHR9dGhpcy5jb25maWcgPSBjb25maWc7XG5cblx0XHRpZiAoaXNXb3JrZXIpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGltcG9ydFNjcmlwdHModGhpcy5saWJzUGF0aCArIFwiZ2wtbWF0cml4LW1pbi5qc1wiLCB0aGlzLmxpYnNQYXRoICsgXCJ0aW55eG1sLmpzXCIpO1xuXHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdENvbGxhZGEudGhyb3dFeGNlcHRpb24oQ29sbGFkYS5MSUJNSVNTSU5HX0VSUk9SKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvL2luaXQgZ2xNYXRyaXhcblx0XHR0ZW1wX21hdDQgPSBfZ2xNYXRyaXgubWF0NC5jcmVhdGUoKTtcblx0XHR0ZW1wX3ZlYzIgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdHRlbXBfdmVjMyA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0dGVtcF92ZWM0ID0gdmVjMy5jcmVhdGUoKTtcblx0XHR0ZW1wX3F1YXQgPSBfZ2xNYXRyaXgucXVhdC5jcmVhdGUoKTtcblxuXHRcdGlmIChpc1dvcmtlcikgY29uc29sZS5sb2coXCJDb2xsYWRhIHdvcmtlciByZWFkeVwiKTtcblx0fSxcblxuXHRsb2FkOiBmdW5jdGlvbiBsb2FkKHVybCwgY2FsbGJhY2spIHtcblx0XHRyZXF1ZXN0KHVybCwgZnVuY3Rpb24gKGRhdGEpIHtcblx0XHRcdGlmICghZGF0YSkgY2FsbGJhY2sobnVsbCk7ZWxzZSBjYWxsYmFjayhDb2xsYWRhLnBhcnNlKGRhdGEpKTtcblx0XHR9KTtcblx0fSxcblxuXHRfeG1scm9vdDogbnVsbCxcblx0X25vZGVzX2J5X2lkOiBudWxsLFxuXHRfdHJhbnNmZXJhYmxlczogbnVsbCxcblx0X2NvbnRyb2xsZXJzX2ZvdW5kOiBudWxsLFxuXHRfZ2VvbWV0cmllc19mb3VuZDogbnVsbCxcblxuXHRzYWZlU3RyaW5nOiBmdW5jdGlvbiBzYWZlU3RyaW5nKHN0cikge1xuXHRcdGlmICghc3RyKSByZXR1cm4gXCJcIjtcblxuXHRcdGlmICh0aGlzLmNvbnZlcnRJRCkgcmV0dXJuIHRoaXMuY29udmVydElEKHN0cik7XG5cblx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoLyAvZywgXCJfXCIpO1xuXHR9LFxuXG5cdExJQk1JU1NJTkdfRVJST1I6IFwiTGlicmFyaWVzIGxvYWRpbmcgZXJyb3IsIHdoZW4gdXNpbmcgd29ya2VycyByZW1lbWJlciB0byBwYXNzIHRoZSBVUkwgdG8gdGhlIHRpbnl4bWwuanMgaW4gdGhlIG9wdGlvbnMubGlic1BhdGhcIixcblx0Tk9YTUxQQVJTRVJfRVJST1I6IFwiVGlueVhNTCBub3QgZm91bmQsIHdoZW4gdXNpbmcgd29ya2VycyByZW1lbWJlciB0byBwYXNzIHRoZSBVUkwgdG8gdGhlIHRpbnl4bWwuanMgaW4gdGhlIG9wdGlvbnMubGlic1BhdGggKFdvcmtlcnMgZG8gbm90IGFsbG93IHRvIGFjY2VzcyB0aGUgbmF0aXZlIFhNTCBET01QYXJzZXIpXCIsXG5cdHRocm93RXhjZXB0aW9uOiBmdW5jdGlvbiB0aHJvd0V4Y2VwdGlvbihtc2cpIHtcblx0XHRpZiAoaXNXb3JrZXIpIHNlbGYucG9zdE1lc3NhZ2UoeyBhY3Rpb246IFwiZXhjZXB0aW9uXCIsIG1zZzogbXNnIH0pO2Vsc2UgaWYgKENvbGxhZGEub25lcnJvcikgQ29sbGFkYS5vbmVycm9yKG1zZyk7XG5cdFx0dGhyb3cgbXNnO1xuXHR9LFxuXG5cdGdldEZpbGVuYW1lOiBmdW5jdGlvbiBnZXRGaWxlbmFtZShmaWxlbmFtZSkge1xuXHRcdHZhciBwb3MgPSBmaWxlbmFtZS5sYXN0SW5kZXhPZihcIlxcXFxcIik7XG5cdFx0aWYgKHBvcyAhPSAtMSkgZmlsZW5hbWUgPSBmaWxlbmFtZS5zdWJzdHIocG9zICsgMSk7XG5cdFx0Ly9zdHJpcCB1bml4IHNsYXNoZXNcblx0XHRwb3MgPSBmaWxlbmFtZS5sYXN0SW5kZXhPZihcIi9cIik7XG5cdFx0aWYgKHBvcyAhPSAtMSkgZmlsZW5hbWUgPSBmaWxlbmFtZS5zdWJzdHIocG9zICsgMSk7XG5cdFx0cmV0dXJuIGZpbGVuYW1lO1xuXHR9LFxuXG5cdGxhc3RfbmFtZTogMCxcblxuXHRnZW5lcmF0ZU5hbWU6IGZ1bmN0aW9uIGdlbmVyYXRlTmFtZSh2KSB7XG5cdFx0diA9IHYgfHwgXCJuYW1lX1wiO1xuXHRcdHZhciBuYW1lID0gdiArIHRoaXMubGFzdF9uYW1lO1xuXHRcdHRoaXMubGFzdF9uYW1lKys7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH0sXG5cblx0cGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGRhdGEsIG9wdGlvbnMsIGZpbGVuYW1lKSB7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0ZmlsZW5hbWUgPSBmaWxlbmFtZSB8fCBcIl9kYWVfXCIgKyBEYXRlLm5vdygpICsgXCIuZGFlXCI7XG5cblx0XHQvL2NvbnNvbGUubG9nKFwiUGFyc2luZyBjb2xsYWRhXCIpO1xuXHRcdHZhciBmbGlwID0gZmFsc2U7XG5cblx0XHR2YXIgeG1scGFyc2VyID0gbnVsbDtcblx0XHR2YXIgcm9vdCA9IG51bGw7XG5cdFx0dGhpcy5fdHJhbnNmZXJhYmxlcyA9IFtdO1xuXG5cdFx0aWYgKHRoaXMudmVyYm9zZSkgY29uc29sZS5sb2coXCIgLSBYTUwgcGFyc2luZy4uLlwiKTtcblxuXHRcdGlmIChnbG9iYWxbXCJET01QYXJzZXJcIl0gJiYgIXRoaXMuY29uZmlnLmZvcmNlUGFyc2VyKSB7XG5cdFx0XHR4bWxwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG5cdFx0XHRyb290ID0geG1scGFyc2VyLnBhcnNlRnJvbVN0cmluZyhkYXRhLCBcInRleHQveG1sXCIpO1xuXHRcdFx0aWYgKHRoaXMudmVyYm9zZSkgY29uc29sZS5sb2coXCIgLSBYTUwgcGFyc2VkXCIpO1xuXHRcdH0gZWxzZSAvL1VTSU5HIEpTIFhNTCBQQVJTRVIgSU1QTEVNRU5UQVRJT04gKG11Y2ggc2xvd2VyKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIWdsb2JhbFtcIkRPTUltcGxlbWVudGF0aW9uXCJdKSByZXR1cm4gQ29sbGFkYS50aHJvd0V4Y2VwdGlvbihDb2xsYWRhLk5PWE1MUEFSU0VSX0VSUk9SKTtcblx0XHRcdFx0Ly91c2UgdGlueXhtbHBhcnNlclxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHhtbHBhcnNlciA9IG5ldyBET01JbXBsZW1lbnRhdGlvbigpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHRyZXR1cm4gQ29sbGFkYS50aHJvd0V4Y2VwdGlvbihDb2xsYWRhLk5PWE1MUEFSU0VSX0VSUk9SKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJvb3QgPSB4bWxwYXJzZXIubG9hZFhNTChkYXRhKTtcblx0XHRcdFx0aWYgKHRoaXMudmVyYm9zZSkgY29uc29sZS5sb2coXCIgLSBYTUwgcGFyc2VkXCIpO1xuXG5cdFx0XHRcdC8vZm9yIGV2ZXJ5IG5vZGUuLi5cblx0XHRcdFx0dmFyIGJ5X2lkcyA9IHJvb3QuX25vZGVzX2J5X2lkID0ge307XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcm9vdC5hbGwubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG5cdFx0XHRcdFx0dmFyIG5vZGUgPSByb290LmFsbFtpXTtcblx0XHRcdFx0XHRieV9pZHNbbm9kZS5pZF0gPSBub2RlO1xuXHRcdFx0XHRcdGlmIChub2RlLmdldEF0dHJpYnV0ZShcInNpZFwiKSkgYnlfaWRzW25vZGUuZ2V0QXR0cmlidXRlKFwic2lkXCIpXSA9IG5vZGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIXRoaXMuZXh0cmFfZnVuY3Rpb25zKSB7XG5cdFx0XHRcdFx0dGhpcy5leHRyYV9mdW5jdGlvbnMgPSB0cnVlO1xuXHRcdFx0XHRcdC8vdGhlc2UgbWV0aG9kcyBhcmUgbWlzc2luZyBzbyBoZXJlIGlzIGEgbG91c3kgaW1wbGVtZW50YXRpb25cblx0XHRcdFx0XHRET01Eb2N1bWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvciA9IERPTUVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcblx0XHRcdFx0XHRcdHZhciB0YWdzID0gc2VsZWN0b3Iuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdFx0dmFyIGN1cnJlbnRfZWxlbWVudCA9IHRoaXM7XG5cblx0XHRcdFx0XHRcdHdoaWxlICh0YWdzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgY3VycmVudCA9IHRhZ3Muc2hpZnQoKTtcblx0XHRcdFx0XHRcdFx0dmFyIHRva2VucyA9IGN1cnJlbnQuc3BsaXQoXCIjXCIpO1xuXHRcdFx0XHRcdFx0XHR2YXIgdGFnbmFtZSA9IHRva2Vuc1swXTtcblx0XHRcdFx0XHRcdFx0dmFyIGlkID0gdG9rZW5zWzFdO1xuXHRcdFx0XHRcdFx0XHR2YXIgZWxlbWVudHMgPSB0YWduYW1lID8gY3VycmVudF9lbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ25hbWUpIDogY3VycmVudF9lbGVtZW50LmNoaWxkTm9kZXM7XG5cdFx0XHRcdFx0XHRcdGlmICghaWQpIC8vbm8gaWQgZmlsdGVyXG5cdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHRhZ3MubGVuZ3RoID09IDApIHJldHVybiBlbGVtZW50cy5pdGVtKDApO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudF9lbGVtZW50ID0gZWxlbWVudHMuaXRlbSgwKTtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvL2hhcyBpZD8gY2hlY2sgZm9yIGFsbCB0byBzZWUgaWYgb25lIG1hdGNoZXMgdGhlIGlkXG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoZWxlbWVudHMuaXRlbShpKS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PSBpZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHRhZ3MubGVuZ3RoID09IDApIHJldHVybiBlbGVtZW50cy5pdGVtKGkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudF9lbGVtZW50ID0gZWxlbWVudHMuaXRlbShpKTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdERPTURvY3VtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsID0gRE9NRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuXHRcdFx0XHRcdFx0dmFyIHRhZ3MgPSBzZWxlY3Rvci5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0XHRpZiAodGFncy5sZW5ndGggPT0gMSkgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoc2VsZWN0b3IpO1xuXG5cdFx0XHRcdFx0XHR2YXIgY3VycmVudF9lbGVtZW50ID0gdGhpcztcblx0XHRcdFx0XHRcdHZhciByZXN1bHQgPSBbXTtcblxuXHRcdFx0XHRcdFx0aW5uZXIodGhpcywgdGFncyk7XG5cblx0XHRcdFx0XHRcdGZ1bmN0aW9uIGlubmVyKHJvb3QsIHRhZ3MpIHtcblx0XHRcdFx0XHRcdFx0aWYgKCF0YWdzKSByZXR1cm47XG5cblx0XHRcdFx0XHRcdFx0dmFyIGN1cnJlbnQgPSB0YWdzLnNoaWZ0KCk7XG5cdFx0XHRcdFx0XHRcdHZhciBlbGVtZW50cyA9IHJvb3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoY3VycmVudCk7XG5cdFx0XHRcdFx0XHRcdGlmICh0YWdzLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goZWxlbWVudHMuaXRlbShpKSk7XG5cdFx0XHRcdFx0XHRcdFx0fXJldHVybjtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRpbm5lcihlbGVtZW50cy5pdGVtKGkpLCB0YWdzLmNvbmNhdCgpKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2YXIgbGlzdCA9IG5ldyBET01Ob2RlTGlzdCh0aGlzLmRvY3VtZW50RWxlbWVudCk7XG5cdFx0XHRcdFx0XHRsaXN0Ll9ub2RlcyA9IHJlc3VsdDtcblx0XHRcdFx0XHRcdGxpc3QubGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGxpc3Q7XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShET01FbGVtZW50LnByb3RvdHlwZSwgXCJ0ZXh0Q29udGVudFwiLCB7XG5cdFx0XHRcdFx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG5vZGVzID0gdGhpcy5nZXRDaGlsZE5vZGVzKCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBub2Rlcy5pdGVtKDApLnRvU3RyaW5nKCk7XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0c2V0OiBmdW5jdGlvbiBzZXQoKSB7fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0dGhpcy5feG1scm9vdCA9IHJvb3Q7XG5cdFx0dmFyIHhtbGNvbGxhZGEgPSByb290LnF1ZXJ5U2VsZWN0b3IoXCJDT0xMQURBXCIpO1xuXHRcdGlmICh4bWxjb2xsYWRhKSB7XG5cdFx0XHR0aGlzLl9jdXJyZW50X0RBRV92ZXJzaW9uID0geG1sY29sbGFkYS5nZXRBdHRyaWJ1dGUoXCJ2ZXJzaW9uXCIpO1xuXHRcdFx0Y29uc29sZS5sb2coXCJEQUUgVmVyc2lvbjpcIiArIHRoaXMuX2N1cnJlbnRfREFFX3ZlcnNpb24pO1xuXHRcdH1cblxuXHRcdC8vdmFyIHhtbHZpc3VhbF9zY2VuZSA9IHJvb3QucXVlcnlTZWxlY3RvcihcInZpc3VhbF9zY2VuZVwiKTtcblx0XHR2YXIgeG1sdmlzdWFsX3NjZW5lID0gcm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInZpc3VhbF9zY2VuZVwiKS5pdGVtKDApO1xuXHRcdGlmICgheG1sdmlzdWFsX3NjZW5lKSB0aHJvdyBcInZpc3VhbF9zY2VuZSBYTUwgbm9kZSBub3QgZm91bmQgaW4gREFFXCI7XG5cblx0XHQvL2hhY2sgdG8gYXZvaWQgcHJvYmxlbXMgd2l0aCBib25lcyB3aXRoIHNwYWNlcyBpbiBuYW1lc1xuXHRcdHRoaXMuX25vZGVzX2J5X2lkID0ge307IC8vY2xlYXJcblx0XHR0aGlzLl9jb250cm9sbGVyc19mb3VuZCA9IHt9OyAvL3dlIG5lZWQgdG8gY2hlY2sgd2hhdCBjb250cm9sbGVycyBoYWQgYmVlbiBmb3VuZCwgaW4gY2FzZSB3ZSBtaXNzIG9uZSBhdCB0aGUgZW5kXG5cdFx0dGhpcy5fZ2VvbWV0cmllc19mb3VuZCA9IHt9O1xuXG5cdFx0Ly9DcmVhdGUgYSBzY2VuZSB0cmVlXG5cdFx0dmFyIHNjZW5lID0ge1xuXHRcdFx0b2JqZWN0X3R5cGU6IFwiU2NlbmVUcmVlXCIsXG5cdFx0XHRsaWdodDogbnVsbCxcblx0XHRcdG1hdGVyaWFsczoge30sXG5cdFx0XHRtZXNoZXM6IHt9LFxuXHRcdFx0cmVzb3VyY2VzOiB7fSwgLy91c2VkIHRvIHN0b3JlIGFuaW1hdGlvbiB0cmFja3Ncblx0XHRcdHJvb3Q6IHsgY2hpbGRyZW46IFtdIH0sXG5cdFx0XHRleHRlcm5hbF9maWxlczoge30gLy9zdG9yZSBpbmZvIGFib3V0IGV4dGVybmFsIGZpbGVzIG1lbnRpb25lZCBpbiB0aGlzIFxuXHRcdH07XG5cblx0XHQvL3NjZW5lIG1ldGFkYXRhIChsaWtlIGF1dGhvciwgdG9vbCwgdXAgdmVjdG9yLCBkYXRlcywgZXRjKVxuXHRcdHZhciB4bWxhc3NldCA9IHJvb3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJhc3NldFwiKVswXTtcblx0XHRpZiAoeG1sYXNzZXQpIHNjZW5lLm1ldGFkYXRhID0gdGhpcy5yZWFkQXNzZXQoeG1sYXNzZXQpO1xuXG5cdFx0Ly9wYXJzZSBub2RlcyB0cmVlIHRvIGV4dHJhY3QgbmFtZXMgYW5kIGllcmFyY2h5IG9ubHlcblx0XHR2YXIgeG1sbm9kZXMgPSB4bWx2aXN1YWxfc2NlbmUuY2hpbGROb2Rlcztcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbG5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoeG1sbm9kZXMuaXRlbShpKS5sb2NhbE5hbWUgIT0gXCJub2RlXCIpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgbm9kZSA9IHRoaXMucmVhZE5vZGVUcmVlKHhtbG5vZGVzLml0ZW0oaSksIHNjZW5lLCAwLCBmbGlwKTtcblx0XHRcdGlmIChub2RlKSBzY2VuZS5yb290LmNoaWxkcmVuLnB1c2gobm9kZSk7XG5cdFx0fVxuXG5cdFx0Ly9wYXJzZSBub2RlcyBjb250ZW50ICh0d28gc3RlcHMgc28gd2UgaGF2ZSBmaXJzdCBhbGwgdGhlIHNjZW5lIHRyZWUgaW5mbylcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbG5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoeG1sbm9kZXMuaXRlbShpKS5sb2NhbE5hbWUgIT0gXCJub2RlXCIpIGNvbnRpbnVlO1xuXHRcdFx0dGhpcy5yZWFkTm9kZUluZm8oeG1sbm9kZXMuaXRlbShpKSwgc2NlbmUsIDAsIGZsaXApO1xuXHRcdH1cblxuXHRcdC8vcmVhZCByZW1haW5pbmcgY29udHJvbGxlcnMgKGluIHNvbWUgY2FzZXMgc29tZSBjb250cm9sbGVycyBhcmUgbm90IGxpbmtlZCBmcm9tIHRoZSBub2RlcyBvciB0aGUgZ2VvbWV0cmllcylcblx0XHR0aGlzLnJlYWRMaWJyYXJ5Q29udHJvbGxlcnMoc2NlbmUpO1xuXG5cdFx0Ly9yZWFkIGFuaW1hdGlvbnNcblx0XHR2YXIgYW5pbWF0aW9ucyA9IHRoaXMucmVhZEFuaW1hdGlvbnMocm9vdCwgc2NlbmUpO1xuXHRcdGlmIChhbmltYXRpb25zKSB7XG5cdFx0XHR2YXIgYW5pbWF0aW9uc19uYW1lID0gXCIjYW5pbWF0aW9uc19cIiArIGZpbGVuYW1lLnN1YnN0cigwLCBmaWxlbmFtZS5pbmRleE9mKFwiLlwiKSk7XG5cdFx0XHRzY2VuZS5yZXNvdXJjZXNbYW5pbWF0aW9uc19uYW1lXSA9IGFuaW1hdGlvbnM7XG5cdFx0XHRzY2VuZS5yb290LmFuaW1hdGlvbnMgPSBhbmltYXRpb25zX25hbWU7XG5cdFx0fVxuXG5cdFx0Ly9yZWFkIGV4dGVybmFsIGZpbGVzIChpbWFnZXMpXG5cdFx0c2NlbmUuaW1hZ2VzID0gdGhpcy5yZWFkSW1hZ2VzKHJvb3QpO1xuXG5cdFx0Ly9jbGVhciBtZW1vcnlcblx0XHR0aGlzLl9ub2Rlc19ieV9pZCA9IHt9O1xuXHRcdHRoaXMuX2NvbnRyb2xsZXJzX2ZvdW5kID0ge307XG5cdFx0dGhpcy5fZ2VvbWV0cmllc19mb3VuZCA9IHt9O1xuXHRcdHRoaXMuX3htbHJvb3QgPSBudWxsO1xuXG5cdFx0Ly9jb25zb2xlLmxvZyhzY2VuZSk7XG5cdFx0cmV0dXJuIHNjZW5lO1xuXHR9LFxuXG5cdC8qIENvbGxlY3Qgbm9kZSBpZHMsIGluIGNhc2UgdGhlcmUgaXMgYm9uZXMgKHdpdGggc3BhY2VzIGluIG5hbWUpIEkgbmVlZCB0byBrbm93IHRoZSBub2RlbmFtZXMgaW4gYWR2YW5jZSAqL1xuXHQvKlxuIHJlYWRBbGxOb2RlTmFtZXM6IGZ1bmN0aW9uKHhtbG5vZGUpXG4ge1xuIFx0dmFyIG5vZGVfaWQgPSB0aGlzLnNhZmVTdHJpbmcoIHhtbG5vZGUuZ2V0QXR0cmlidXRlKFwiaWRcIikgKTtcbiBcdGlmKG5vZGVfaWQpXG4gXHRcdHRoaXMuX25vZGVzX2J5X2lkW25vZGVfaWRdID0gdHJ1ZTsgLy9ub2RlIGZvdW5kXG4gXHQvL25vZGVzIHNlZW0gdG8gaGF2ZSB0byBwb3NzaWJsZSBpZHMsIGlkIGFuZCBzaWQsIEkgZ3Vlc3Mgb25lIGlzIHVuaXF1ZSwgdGhlIG90aGVyIHVzZXItZGVmaW5lZFxuIFx0dmFyIG5vZGVfc2lkID0gdGhpcy5zYWZlU3RyaW5nKCB4bWxub2RlLmdldEF0dHJpYnV0ZShcInNpZFwiKSApO1xuIFx0aWYobm9kZV9zaWQpXG4gXHRcdHRoaXMuX25vZGVzX2J5X2lkW25vZGVfc2lkXSA9IHRydWU7IC8vbm9kZSBmb3VuZFxuIFxuIFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCB4bWxub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKysgKVxuIFx0e1xuIFx0XHR2YXIgeG1sY2hpbGQgPSB4bWxub2RlLmNoaWxkTm9kZXMuaXRlbShpKTtcbiBcdFx0XHQvL2NoaWxkcmVuXG4gXHRcdGlmKHhtbGNoaWxkLmxvY2FsTmFtZSAhPSBcIm5vZGVcIilcbiBcdFx0XHRjb250aW51ZTtcbiBcdFx0dGhpcy5yZWFkQWxsTm9kZU5hbWVzKHhtbGNoaWxkKTtcbiBcdH1cbiB9LFxuIFx0Ki9cblxuXHRyZWFkQXNzZXQ6IGZ1bmN0aW9uIHJlYWRBc3NldCh4bWxhc3NldCkge1xuXHRcdHZhciBtZXRhZGF0YSA9IHt9O1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWxhc3NldC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgeG1sY2hpbGQgPSB4bWxhc3NldC5jaGlsZE5vZGVzLml0ZW0oaSk7XG5cdFx0XHRpZiAoeG1sY2hpbGQubm9kZVR5cGUgIT0gMSkgLy9ub3QgdGFnXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0c3dpdGNoICh4bWxjaGlsZC5sb2NhbE5hbWUpIHtcblx0XHRcdFx0Y2FzZSBcImNvbnRyaWJ1dG9yXCI6XG5cdFx0XHRcdFx0dmFyIHRvb2wgPSB4bWxjaGlsZC5xdWVyeVNlbGVjdG9yKFwiYXV0aG9yaW5nX3Rvb2xcIik7XG5cdFx0XHRcdFx0aWYgKHRvb2wpIG1ldGFkYXRhW1wiYXV0aG9yaW5nX3Rvb2xcIl0gPSB0b29sLnRleHRDb250ZXh0O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwidW5pdFwiOlxuXHRcdFx0XHRcdG1ldGFkYXRhW1widW5pdFwiXSA9IHhtbGNoaWxkLmdldEF0dHJpYnV0ZShcIm5hbWVcIik7YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0bWV0YWRhdGFbeG1sY2hpbGQubG9jYWxOYW1lXSA9IHhtbGNoaWxkLnRleHRDb250ZW50O2JyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtZXRhZGF0YTtcblx0fSxcblxuXHRyZWFkTm9kZVRyZWU6IGZ1bmN0aW9uIHJlYWROb2RlVHJlZSh4bWxub2RlLCBzY2VuZSwgbGV2ZWwsIGZsaXApIHtcblx0XHR2YXIgbm9kZV9pZCA9IHRoaXMuc2FmZVN0cmluZyh4bWxub2RlLmdldEF0dHJpYnV0ZShcImlkXCIpKTtcblx0XHR2YXIgbm9kZV9zaWQgPSB0aGlzLnNhZmVTdHJpbmcoeG1sbm9kZS5nZXRBdHRyaWJ1dGUoXCJzaWRcIikpO1xuXG5cdFx0aWYgKCFub2RlX2lkICYmICFub2RlX3NpZCkgcmV0dXJuIG51bGw7XG5cblx0XHQvL2hlcmUgd2UgY3JlYXRlIHRoZSBub2RlXG5cdFx0dmFyIG5vZGUgPSB7XG5cdFx0XHRpZDogbm9kZV9zaWQgfHwgbm9kZV9pZCxcblx0XHRcdGNoaWxkcmVuOiBbXSxcblx0XHRcdF9kZXB0aDogbGV2ZWxcblx0XHR9O1xuXG5cdFx0dmFyIG5vZGVfdHlwZSA9IHhtbG5vZGUuZ2V0QXR0cmlidXRlKFwidHlwZVwiKTtcblx0XHRpZiAobm9kZV90eXBlKSBub2RlLnR5cGUgPSBub2RlX3R5cGU7XG5cblx0XHR2YXIgbm9kZV9uYW1lID0geG1sbm9kZS5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpO1xuXHRcdGlmIChub2RlX25hbWUpIG5vZGUubmFtZSA9IG5vZGVfbmFtZTtcblx0XHR0aGlzLl9ub2Rlc19ieV9pZFtub2RlLmlkXSA9IG5vZGU7XG5cdFx0aWYgKG5vZGVfaWQpIHRoaXMuX25vZGVzX2J5X2lkW25vZGVfaWRdID0gbm9kZTtcblx0XHRpZiAobm9kZV9zaWQpIHRoaXMuX25vZGVzX2J5X2lkW25vZGVfc2lkXSA9IG5vZGU7XG5cblx0XHQvL3RyYW5zZm9ybVxuXHRcdG5vZGUubW9kZWwgPSB0aGlzLnJlYWRUcmFuc2Zvcm0oeG1sbm9kZSwgbGV2ZWwsIGZsaXApO1xuXG5cdFx0Ly9ub2RlIGVsZW1lbnRzXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWxub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB4bWxjaGlsZCA9IHhtbG5vZGUuY2hpbGROb2Rlcy5pdGVtKGkpO1xuXHRcdFx0aWYgKHhtbGNoaWxkLm5vZGVUeXBlICE9IDEpIC8vbm90IHRhZ1xuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0Ly9jaGlsZHJlblxuXHRcdFx0aWYgKHhtbGNoaWxkLmxvY2FsTmFtZSA9PSBcIm5vZGVcIikge1xuXHRcdFx0XHR2YXIgY2hpbGRfbm9kZSA9IHRoaXMucmVhZE5vZGVUcmVlKHhtbGNoaWxkLCBzY2VuZSwgbGV2ZWwgKyAxLCBmbGlwKTtcblx0XHRcdFx0aWYgKGNoaWxkX25vZGUpIG5vZGUuY2hpbGRyZW4ucHVzaChjaGlsZF9ub2RlKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5vZGU7XG5cdH0sXG5cblx0cmVhZE5vZGVJbmZvOiBmdW5jdGlvbiByZWFkTm9kZUluZm8oeG1sbm9kZSwgc2NlbmUsIGxldmVsLCBmbGlwLCBwYXJlbnQpIHtcblx0XHR2YXIgbm9kZV9pZCA9IHRoaXMuc2FmZVN0cmluZyh4bWxub2RlLmdldEF0dHJpYnV0ZShcImlkXCIpKTtcblx0XHR2YXIgbm9kZV9zaWQgPSB0aGlzLnNhZmVTdHJpbmcoeG1sbm9kZS5nZXRBdHRyaWJ1dGUoXCJzaWRcIikpO1xuXG5cdFx0LypcbiAgaWYoIW5vZGVfaWQgJiYgIW5vZGVfc2lkKVxuICB7XG4gIFx0Y29uc29sZS53YXJuKFwiQ29sbGFkYTogbm9kZSB3aXRob3V0IGlkLCBjcmVhdGluZyBhIHJhbmRvbSBvbmVcIik7XG4gIFx0bm9kZV9pZCA9IHRoaXMuZ2VuZXJhdGVOYW1lKFwibm9kZV9cIik7XG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cbiAgKi9cblxuXHRcdHZhciBub2RlO1xuXHRcdGlmICghbm9kZV9pZCAmJiAhbm9kZV9zaWQpIHtcblx0XHRcdC8vaWYgdGhlcmUgaXMgbm8gaWQsIHRoZW4gZWl0aGVyIGFsbCBvZiB0aGlzIG5vZGUncyBwcm9wZXJ0aWVzIFxuXHRcdFx0Ly9zaG91bGQgYmUgYXNzaWduZWQgZGlyZWN0bHkgdG8gaXRzIHBhcmVudCBub2RlLCBvciB0aGUgbm9kZSBkb2Vzbid0XG5cdFx0XHQvL2hhdmUgYSBwYXJlbnQgbm9kZSwgaW4gd2hpY2ggY2FzZSBpdHMgYSBsaWdodCBvciBzb21ldGhpbmcuIFxuXHRcdFx0Ly9TbyB3ZSBnZXQgdGhlIHBhcmVudCBieSBpdHMgaWQsIGFuZCBpZiB0aGVyZSBpcyBubyBwYXJlbnQsIHdlIHJldHVybiBudWxsXG5cdFx0XHRpZiAocGFyZW50KSBub2RlID0gdGhpcy5fbm9kZXNfYnlfaWRbcGFyZW50LmlkIHx8IHBhcmVudC5zaWRdO2Vsc2UgcmV0dXJuIG51bGw7XG5cdFx0fSBlbHNlIG5vZGUgPSB0aGlzLl9ub2Rlc19ieV9pZFtub2RlX2lkIHx8IG5vZGVfc2lkXTtcblxuXHRcdGlmICghbm9kZSkge1xuXHRcdFx0Y29uc29sZS53YXJuKFwiQ29sbGFkYTogTm9kZSBub3QgZm91bmQgYnkgaWQ6IFwiICsgKG5vZGVfaWQgfHwgbm9kZV9zaWQpKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdC8vbm9kZSBlbGVtZW50c1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1sbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgeG1sY2hpbGQgPSB4bWxub2RlLmNoaWxkTm9kZXMuaXRlbShpKTtcblx0XHRcdGlmICh4bWxjaGlsZC5ub2RlVHlwZSAhPSAxKSAvL25vdCB0YWdcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdC8vY2hpbGRyZW5cblx0XHRcdGlmICh4bWxjaGlsZC5sb2NhbE5hbWUgPT0gXCJub2RlXCIpIHtcblx0XHRcdFx0Ly9wYXNzIHBhcmVudCBub2RlIGluIGNhc2UgY2hpbGQgbm9kZSBpcyBhICdkZWFkJyBub2RlIChoYXMgbm8gaWQgb3Igc2lkKVxuXHRcdFx0XHR0aGlzLnJlYWROb2RlSW5mbyh4bWxjaGlsZCwgc2NlbmUsIGxldmVsICsgMSwgZmxpcCwgeG1sbm9kZSk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvL2dlb21ldHJ5XG5cdFx0XHRpZiAoeG1sY2hpbGQubG9jYWxOYW1lID09IFwiaW5zdGFuY2VfZ2VvbWV0cnlcIikge1xuXHRcdFx0XHR2YXIgdXJsID0geG1sY2hpbGQuZ2V0QXR0cmlidXRlKFwidXJsXCIpO1xuXHRcdFx0XHR2YXIgbWVzaF9pZCA9IHVybC50b1N0cmluZygpLnN1YnN0cigxKTtcblx0XHRcdFx0bm9kZS5tZXNoID0gbWVzaF9pZDtcblxuXHRcdFx0XHRpZiAoIXNjZW5lLm1lc2hlc1t1cmxdKSB7XG5cdFx0XHRcdFx0dmFyIG1lc2hfZGF0YSA9IHRoaXMucmVhZEdlb21ldHJ5KHVybCwgZmxpcCk7XG5cdFx0XHRcdFx0aWYgKG1lc2hfZGF0YSkge1xuXHRcdFx0XHRcdFx0bWVzaF9kYXRhLm5hbWUgPSBtZXNoX2lkO1xuXHRcdFx0XHRcdFx0c2NlbmUubWVzaGVzW21lc2hfaWRdID0gbWVzaF9kYXRhO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vYmluZGVkIG1hdGVyaWFsXG5cdFx0XHRcdHZhciB4bWxtYXRlcmlhbHMgPSB4bWxjaGlsZC5xdWVyeVNlbGVjdG9yQWxsKFwiaW5zdGFuY2VfbWF0ZXJpYWxcIik7XG5cdFx0XHRcdGlmICh4bWxtYXRlcmlhbHMpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpTWF0ID0gMDsgaU1hdCA8IHhtbG1hdGVyaWFscy5sZW5ndGg7ICsraU1hdCkge1xuXHRcdFx0XHRcdFx0dmFyIHhtbG1hdGVyaWFsID0geG1sbWF0ZXJpYWxzLml0ZW0oaU1hdCk7XG5cdFx0XHRcdFx0XHRpZiAoIXhtbG1hdGVyaWFsKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybihcImluc3RhbmNlX21hdGVyaWFsIG5vdCBmb3VuZDogXCIgKyBpKTtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHZhciBtYXRuYW1lID0geG1sbWF0ZXJpYWwuZ2V0QXR0cmlidXRlKFwidGFyZ2V0XCIpLnRvU3RyaW5nKCkuc3Vic3RyKDEpO1xuXHRcdFx0XHRcdFx0Ly9tYXRuYW1lID0gbWF0bmFtZS5yZXBsYWNlKC8gL2csXCJfXCIpOyAvL25hbWVzIGNhbm5vdCBoYXZlIHNwYWNlc1xuXHRcdFx0XHRcdFx0aWYgKCFzY2VuZS5tYXRlcmlhbHNbbWF0bmFtZV0pIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSB0aGlzLnJlYWRNYXRlcmlhbChtYXRuYW1lKTtcblx0XHRcdFx0XHRcdFx0aWYgKG1hdGVyaWFsKSB7XG5cdFx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwuaWQgPSBtYXRuYW1lO1xuXHRcdFx0XHRcdFx0XHRcdHNjZW5lLm1hdGVyaWFsc1ttYXRlcmlhbC5pZF0gPSBtYXRlcmlhbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGlNYXQgPT0gMCkgbm9kZS5tYXRlcmlhbCA9IG1hdG5hbWU7ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmICghbm9kZS5tYXRlcmlhbHMpIG5vZGUubWF0ZXJpYWxzID0gW107XG5cdFx0XHRcdFx0XHRcdG5vZGUubWF0ZXJpYWxzLnB1c2gobWF0bmFtZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vdGhpcyBub2RlIGhhcyBhIGNvbnRyb2xsZXI6IHNraW5uaW5nLCBtb3JwaCB0YXJnZXRzIG9yIGV2ZW4gbXVsdGltYXRlcmlhbCBhcmUgY29udHJvbGxlcnNcblx0XHRcdC8vd2FybmluZzogSSBkZXRlY3RlZCB0aGF0IHNvbWUgbm9kZXMgY291bGQgaGF2ZSBhIGNvbnRyb2xsZXIgYnV0IHRoZXkgYXJlIG5vdCByZWZlcmVuY2VkIGhlcmUuICA/P1xuXHRcdFx0aWYgKHhtbGNoaWxkLmxvY2FsTmFtZSA9PSBcImluc3RhbmNlX2NvbnRyb2xsZXJcIikge1xuXHRcdFx0XHR2YXIgdXJsID0geG1sY2hpbGQuZ2V0QXR0cmlidXRlKFwidXJsXCIpO1xuXHRcdFx0XHR2YXIgeG1sY29udHJvbGxlciA9IHRoaXMuX3htbHJvb3QucXVlcnlTZWxlY3RvcihcImNvbnRyb2xsZXJcIiArIHVybCk7XG5cblx0XHRcdFx0aWYgKHhtbGNvbnRyb2xsZXIpIHtcblxuXHRcdFx0XHRcdHZhciBtZXNoX2RhdGEgPSB0aGlzLnJlYWRDb250cm9sbGVyKHhtbGNvbnRyb2xsZXIsIGZsaXAsIHNjZW5lKTtcblxuXHRcdFx0XHRcdC8vYmluZGVkIG1hdGVyaWFsc1xuXHRcdFx0XHRcdHZhciB4bWxiaW5kX21hdGVyaWFsID0geG1sY2hpbGQucXVlcnlTZWxlY3RvcihcImJpbmRfbWF0ZXJpYWxcIik7XG5cdFx0XHRcdFx0aWYgKHhtbGJpbmRfbWF0ZXJpYWwpIHtcblx0XHRcdFx0XHRcdC8vcmVtb3ZlZCByZWFkQmluZE1hdGVyaWFscyB1cCBoZXJlIGZvciBjb25zaXN0ZW5jeVxuXHRcdFx0XHRcdFx0dmFyIHhtbHRlY2huaXF1ZXMgPSB4bWxiaW5kX21hdGVyaWFsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJ0ZWNobmlxdWVfY29tbW9uXCIpO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaVRlYyA9IDA7IGlUZWMgPCB4bWx0ZWNobmlxdWVzLmxlbmd0aDsgaVRlYysrKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB4bWx0ZWNobmlxdWUgPSB4bWx0ZWNobmlxdWVzLml0ZW0oaVRlYyk7XG5cdFx0XHRcdFx0XHRcdHZhciB4bWxpbnN0YW5jZV9tYXRlcmlhbHMgPSB4bWx0ZWNobmlxdWUucXVlcnlTZWxlY3RvckFsbChcImluc3RhbmNlX21hdGVyaWFsXCIpO1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBpTWF0ID0gMDsgaU1hdCA8IHhtbGluc3RhbmNlX21hdGVyaWFscy5sZW5ndGg7IGlNYXQrKykge1xuXHRcdFx0XHRcdFx0XHRcdHZhciB4bWxpbnN0YW5jZV9tYXRlcmlhbCA9IHhtbGluc3RhbmNlX21hdGVyaWFscy5pdGVtKGlNYXQpO1xuXHRcdFx0XHRcdFx0XHRcdGlmICgheG1saW5zdGFuY2VfbWF0ZXJpYWwpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybihcImluc3RhbmNlX21hdGVyaWFsIGZvciBjb250cm9sbGVyIG5vdCBmb3VuZDogXCIgKyB4bWxpbnN0YW5jZV9tYXRlcmlhbCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0dmFyIG1hdG5hbWUgPSB4bWxpbnN0YW5jZV9tYXRlcmlhbC5nZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIikudG9TdHJpbmcoKS5zdWJzdHIoMSk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCFzY2VuZS5tYXRlcmlhbHNbbWF0bmFtZV0pIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIG1hdGVyaWFsID0gdGhpcy5yZWFkTWF0ZXJpYWwobWF0bmFtZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAobWF0ZXJpYWwpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwuaWQgPSBtYXRuYW1lO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRzY2VuZS5tYXRlcmlhbHNbbWF0ZXJpYWwuaWRdID0gbWF0ZXJpYWw7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmIChpTWF0ID09IDApIG5vZGUubWF0ZXJpYWwgPSBtYXRuYW1lO2Vsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCFub2RlLm1hdGVyaWFscykgbm9kZS5tYXRlcmlhbHMgPSBbXTtcblx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubWF0ZXJpYWxzLnB1c2gobWF0bmFtZSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKG1lc2hfZGF0YSkge1xuXHRcdFx0XHRcdFx0dmFyIG1lc2ggPSBtZXNoX2RhdGE7XG5cdFx0XHRcdFx0XHRpZiAobWVzaF9kYXRhLnR5cGUgPT0gXCJtb3JwaFwiKSB7XG5cdFx0XHRcdFx0XHRcdG1lc2ggPSBtZXNoX2RhdGEubWVzaDtcblx0XHRcdFx0XHRcdFx0bm9kZS5tb3JwaF90YXJnZXRzID0gbWVzaF9kYXRhLm1vcnBoX3RhcmdldHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG1lc2gubmFtZSA9IHVybC50b1N0cmluZygpO1xuXHRcdFx0XHRcdFx0bm9kZS5tZXNoID0gdXJsLnRvU3RyaW5nKCk7XG5cdFx0XHRcdFx0XHRzY2VuZS5tZXNoZXNbdXJsXSA9IG1lc2g7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vbGlnaHRcblx0XHRcdGlmICh4bWxjaGlsZC5sb2NhbE5hbWUgPT0gXCJpbnN0YW5jZV9saWdodFwiKSB7XG5cdFx0XHRcdHZhciB1cmwgPSB4bWxjaGlsZC5nZXRBdHRyaWJ1dGUoXCJ1cmxcIik7XG5cdFx0XHRcdHRoaXMucmVhZExpZ2h0KG5vZGUsIHVybCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vY2FtZXJhXG5cdFx0XHRpZiAoeG1sY2hpbGQubG9jYWxOYW1lID09IFwiaW5zdGFuY2VfY2FtZXJhXCIpIHtcblx0XHRcdFx0dmFyIHVybCA9IHhtbGNoaWxkLmdldEF0dHJpYnV0ZShcInVybFwiKTtcblx0XHRcdFx0dGhpcy5yZWFkQ2FtZXJhKG5vZGUsIHVybCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vb3RoZXIgcG9zc2libGUgdGFncz9cblx0XHR9XG5cdH0sXG5cblx0Ly9pZiB5b3Ugd2FudCB0byByZW5hbWUgc29tZSBtYXRlcmlhbCBuYW1lc1xuXHRtYXRlcmlhbF90cmFuc2xhdGVfdGFibGU6IHtcblx0XHQvKlxuICB0cmFuc3BhcmVuY3k6IFwib3BhY2l0eVwiLFxuICByZWZsZWN0aXZpdHk6IFwicmVmbGVjdGlvbl9mYWN0b3JcIixcbiAgc3BlY3VsYXI6IFwic3BlY3VsYXJfZmFjdG9yXCIsXG4gIHNoaW5pbmVzczogXCJzcGVjdWxhcl9nbG9zc1wiLFxuICBlbWlzc2lvbjogXCJlbWlzc2l2ZVwiLFxuICBkaWZmdXNlOiBcImNvbG9yXCJcbiAgKi9cblx0fSxcblxuXHRsaWdodF90cmFuc2xhdGVfdGFibGU6IHtcblxuXHRcdHBvaW50OiBcIm9tbmlcIixcblx0XHRkaXJlY3Rpb25hbDogXCJkaXJlY3Rpb25hbFwiLFxuXHRcdHNwb3Q6IFwic3BvdFwiXG5cdH0sXG5cblx0Y2FtZXJhX3RyYW5zbGF0ZV90YWJsZToge1xuXHRcdHhmb3Y6IFwiZm92XCIsXG5cdFx0YXNwZWN0X3JhdGlvOiBcImFzcGVjdFwiLFxuXHRcdHpuZWFyOiBcIm5lYXJcIixcblx0XHR6ZmFyOiBcImZhclwiXG5cdH0sXG5cblx0Ly91c2VkIHdoZW4gaWQgaGF2ZSBzcGFjZXMgKHJlZ3VsYXIgc2VsZWN0b3IgZG8gbm90IHN1cHBvcnQgc3BhY2VzKVxuXHRxdWVyeVNlbGVjdG9yQW5kSWQ6IGZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3JBbmRJZChyb290LCBzZWxlY3RvciwgaWQpIHtcblx0XHR2YXIgbm9kZXMgPSByb290LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBhdHRyX2lkID0gbm9kZXMuaXRlbShpKS5nZXRBdHRyaWJ1dGUoXCJpZFwiKTtcblx0XHRcdGlmICghYXR0cl9pZCkgY29udGludWU7XG5cdFx0XHRhdHRyX2lkID0gYXR0cl9pZC50b1N0cmluZygpO1xuXHRcdFx0aWYgKGF0dHJfaWQgPT0gaWQpIHJldHVybiBub2Rlcy5pdGVtKGkpO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHQvL3JldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBtYXRjaGVzIGEgdGFnIG5hbWUsIGlmIG5vdCB0YWduYW1lIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCB0YWcgZWxlbWVudFxuXHRnZXRGaXJzdENoaWxkRWxlbWVudDogZnVuY3Rpb24gZ2V0Rmlyc3RDaGlsZEVsZW1lbnQocm9vdCwgbG9jYWxOYW1lKSB7XG5cdFx0dmFyIGMgPSByb290LmNoaWxkTm9kZXM7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjLmxlbmd0aDsgKytpKSB7XG5cdFx0XHR2YXIgaXRlbSA9IGMuaXRlbShpKTtcblx0XHRcdGlmIChpdGVtLmxvY2FsTmFtZSAmJiAhbG9jYWxOYW1lIHx8IGxvY2FsTmFtZSAmJiBsb2NhbE5hbWUgPT0gaXRlbS5sb2NhbE5hbWUpIHJldHVybiBpdGVtO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRyZWFkTWF0ZXJpYWw6IGZ1bmN0aW9uIHJlYWRNYXRlcmlhbCh1cmwpIHtcblx0XHR2YXIgeG1sbWF0ZXJpYWwgPSB0aGlzLnF1ZXJ5U2VsZWN0b3JBbmRJZCh0aGlzLl94bWxyb290LCBcImxpYnJhcnlfbWF0ZXJpYWxzIG1hdGVyaWFsXCIsIHVybCk7XG5cblx0XHRpZiAoIXhtbG1hdGVyaWFsKSByZXR1cm4gbnVsbDtcblxuXHRcdC8vZ2V0IGVmZmVjdCBuYW1lXG5cdFx0dmFyIHhtbGVmZmVjdCA9IHhtbG1hdGVyaWFsLnF1ZXJ5U2VsZWN0b3IoXCJpbnN0YW5jZV9lZmZlY3RcIik7XG5cdFx0aWYgKCF4bWxlZmZlY3QpIHJldHVybiBudWxsO1xuXG5cdFx0dmFyIGVmZmVjdF91cmwgPSB4bWxlZmZlY3QuZ2V0QXR0cmlidXRlKFwidXJsXCIpLnN1YnN0cigxKTtcblxuXHRcdC8vZ2V0IGVmZmVjdFxuXHRcdHZhciB4bWxlZmZlY3RzID0gdGhpcy5xdWVyeVNlbGVjdG9yQW5kSWQodGhpcy5feG1scm9vdCwgXCJsaWJyYXJ5X2VmZmVjdHMgZWZmZWN0XCIsIGVmZmVjdF91cmwpO1xuXG5cdFx0aWYgKCF4bWxlZmZlY3RzKSByZXR1cm4gbnVsbDtcblxuXHRcdC8vZ2V0IGNvbW1vblxuXHRcdHZhciB4bWx0ZWNobmlxdWUgPSB4bWxlZmZlY3RzLnF1ZXJ5U2VsZWN0b3IoXCJ0ZWNobmlxdWVcIik7XG5cdFx0aWYgKCF4bWx0ZWNobmlxdWUpIHJldHVybiBudWxsO1xuXG5cdFx0Ly9nZXQgbmV3cGFyYW1zIGFuZCBjb252ZXJ0IHRvIGpzIG9iamVjdFxuXHRcdHZhciB4bWxuZXdwYXJhbXMgPSB4bWxlZmZlY3RzLnF1ZXJ5U2VsZWN0b3JBbGwoXCJuZXdwYXJhbVwiKTtcblx0XHR2YXIgbmV3cGFyYW1zID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWxuZXdwYXJhbXMubGVuZ3RoOyBpKyspIHtcblxuXHRcdFx0dmFyIGluaXRfZnJvbSA9IHhtbG5ld3BhcmFtc1tpXS5xdWVyeVNlbGVjdG9yKFwiaW5pdF9mcm9tXCIpO1xuXHRcdFx0dmFyIHBhcmVudDtcblx0XHRcdGlmIChpbml0X2Zyb20pIHBhcmVudCA9IGluaXRfZnJvbS5pbm5lckhUTUw7ZWxzZSB7XG5cdFx0XHRcdHZhciBzb3VyY2UgPSB4bWxuZXdwYXJhbXNbaV0ucXVlcnlTZWxlY3RvcihcInNvdXJjZVwiKTtcblx0XHRcdFx0cGFyZW50ID0gc291cmNlLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0bmV3cGFyYW1zW3htbG5ld3BhcmFtc1tpXS5nZXRBdHRyaWJ1dGUoXCJzaWRcIildID0ge1xuXHRcdFx0XHRwYXJlbnQ6IHBhcmVudFxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHR2YXIgbWF0ZXJpYWwgPSB7fTtcblxuXHRcdC8vcmVhZCB0aGUgaW1hZ2VzIGhlcmUgYmVjYXVzZSB3ZSBuZWVkIHRvIGFjY2VzcyB0aGVtIHRvIGFzc2lnbiB0ZXh0dXJlIG5hbWVzXG5cdFx0dmFyIGltYWdlcyA9IHRoaXMucmVhZEltYWdlcyh0aGlzLl94bWxyb290KTtcblxuXHRcdHZhciB4bWxwaG9uZyA9IHhtbHRlY2huaXF1ZS5xdWVyeVNlbGVjdG9yKFwicGhvbmdcIik7XG5cdFx0aWYgKCF4bWxwaG9uZykgeG1scGhvbmcgPSB4bWx0ZWNobmlxdWUucXVlcnlTZWxlY3RvcihcImJsaW5uXCIpO1xuXHRcdGlmICgheG1scGhvbmcpIHhtbHBob25nID0geG1sdGVjaG5pcXVlLnF1ZXJ5U2VsZWN0b3IoXCJsYW1iZXJ0XCIpO1xuXHRcdGlmICgheG1scGhvbmcpIHJldHVybiBudWxsO1xuXG5cdFx0Ly9mb3IgZXZlcnkgdGFnIG9mIHByb3BlcnRpZXNcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbHBob25nLmNoaWxkTm9kZXMubGVuZ3RoOyArK2kpIHtcblx0XHRcdHZhciB4bWxwYXJhbSA9IHhtbHBob25nLmNoaWxkTm9kZXMuaXRlbShpKTtcblxuXHRcdFx0aWYgKCF4bWxwYXJhbS5sb2NhbE5hbWUpIC8vdGV4dCB0YWdcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdC8vdHJhbnNsYXRlIG5hbWVcblx0XHRcdHZhciBwYXJhbV9uYW1lID0geG1scGFyYW0ubG9jYWxOYW1lLnRvU3RyaW5nKCk7XG5cdFx0XHRpZiAodGhpcy5tYXRlcmlhbF90cmFuc2xhdGVfdGFibGVbcGFyYW1fbmFtZV0pIHBhcmFtX25hbWUgPSB0aGlzLm1hdGVyaWFsX3RyYW5zbGF0ZV90YWJsZVtwYXJhbV9uYW1lXTtcblxuXHRcdFx0Ly92YWx1ZVxuXHRcdFx0dmFyIHhtbHBhcmFtX3ZhbHVlID0gdGhpcy5nZXRGaXJzdENoaWxkRWxlbWVudCh4bWxwYXJhbSk7XG5cdFx0XHRpZiAoIXhtbHBhcmFtX3ZhbHVlKSBjb250aW51ZTtcblxuXHRcdFx0aWYgKHhtbHBhcmFtX3ZhbHVlLmxvY2FsTmFtZS50b1N0cmluZygpID09IFwiY29sb3JcIikge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzLnJlYWRDb250ZW50QXNGbG9hdHMoeG1scGFyYW1fdmFsdWUpO1xuXHRcdFx0XHRpZiAoeG1scGFyYW0uZ2V0QXR0cmlidXRlKFwib3BhcXVlXCIpID09IFwiUkdCX1pFUk9cIikgbWF0ZXJpYWxbcGFyYW1fbmFtZV0gPSB2YWx1ZS5zdWJhcnJheSgwLCA0KTtlbHNlIG1hdGVyaWFsW3BhcmFtX25hbWVdID0gdmFsdWUuc3ViYXJyYXkoMCwgMyk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fSBlbHNlIGlmICh4bWxwYXJhbV92YWx1ZS5sb2NhbE5hbWUudG9TdHJpbmcoKSA9PSBcImZsb2F0XCIpIHtcblx0XHRcdFx0bWF0ZXJpYWxbcGFyYW1fbmFtZV0gPSB0aGlzLnJlYWRDb250ZW50QXNGbG9hdHMoeG1scGFyYW1fdmFsdWUpWzBdO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gZWxzZSBpZiAoeG1scGFyYW1fdmFsdWUubG9jYWxOYW1lLnRvU3RyaW5nKCkgPT0gXCJ0ZXh0dXJlXCIpIHtcblx0XHRcdFx0aWYgKCFtYXRlcmlhbC50ZXh0dXJlcykgbWF0ZXJpYWwudGV4dHVyZXMgPSB7fTtcblx0XHRcdFx0dmFyIG1hcF9pZCA9IHhtbHBhcmFtX3ZhbHVlLmdldEF0dHJpYnV0ZShcInRleHR1cmVcIik7XG5cdFx0XHRcdGlmICghbWFwX2lkKSBjb250aW51ZTtcblxuXHRcdFx0XHQvLyBpZiBtYXBfaWQgaXMgbm90IGEgZmlsZW5hbWUsIGxldHMgZ28gYW5kIGxvb2sgZm9yIGl0LlxuXHRcdFx0XHRpZiAobWFwX2lkLmluZGV4T2YoJy4nKSA9PT0gLTEpIHtcblx0XHRcdFx0XHQvL2NoZWNrIGVmZmVjdCBwYXJlbnRzXG5cdFx0XHRcdFx0bWFwX2lkID0gdGhpcy5nZXRQYXJlbnRQYXJhbShuZXdwYXJhbXMsIG1hcF9pZCk7XG5cblx0XHRcdFx0XHRpZiAoaW1hZ2VzW21hcF9pZF0pIG1hcF9pZCA9IGltYWdlc1ttYXBfaWRdLnBhdGg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL25vdyBnZXQgdGhlIHRleHR1cmUgZmlsZW5hbWUgZnJvbSBpbWFnZXNcblxuXHRcdFx0XHR2YXIgbWFwX2luZm8gPSB7IG1hcF9pZDogbWFwX2lkIH07XG5cdFx0XHRcdHZhciB1dnMgPSB4bWxwYXJhbV92YWx1ZS5nZXRBdHRyaWJ1dGUoXCJ0ZXhjb29yZFwiKTtcblx0XHRcdFx0bWFwX2luZm8udXZzID0gdXZzO1xuXHRcdFx0XHRtYXRlcmlhbC50ZXh0dXJlc1twYXJhbV9uYW1lXSA9IG1hcF9pbmZvO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG1hdGVyaWFsLm9iamVjdF90eXBlID0gXCJNYXRlcmlhbFwiO1xuXHRcdHJldHVybiBtYXRlcmlhbDtcblx0fSxcblxuXHRnZXRQYXJlbnRQYXJhbTogZnVuY3Rpb24gZ2V0UGFyZW50UGFyYW0obmV3cGFyYW1zLCBwYXJhbSkge1xuXHRcdGlmICghbmV3cGFyYW1zW3BhcmFtXSkgcmV0dXJuIHBhcmFtO1xuXG5cdFx0aWYgKG5ld3BhcmFtc1twYXJhbV0ucGFyZW50KSByZXR1cm4gdGhpcy5nZXRQYXJlbnRQYXJhbShuZXdwYXJhbXMsIG5ld3BhcmFtc1twYXJhbV0ucGFyZW50KTtlbHNlIHJldHVybiBwYXJhbTtcblx0fSxcblxuXHRyZWFkTGlnaHQ6IGZ1bmN0aW9uIHJlYWRMaWdodChub2RlLCB1cmwpIHtcblx0XHR2YXIgbGlnaHQgPSB7fTtcblxuXHRcdHZhciB4bWxub2RlID0gbnVsbDtcblxuXHRcdGlmICh1cmwubGVuZ3RoID4gMSkgLy93ZWlyZCBjYXNlcyB3aXRoIGlkID09ICNcblx0XHRcdHhtbG5vZGUgPSB0aGlzLl94bWxyb290LnF1ZXJ5U2VsZWN0b3IoXCJsaWJyYXJ5X2xpZ2h0cyBcIiArIHVybCk7ZWxzZSB7XG5cdFx0XHR2YXIgeG1sbGlibGlnaHRzID0gdGhpcy5feG1scm9vdC5xdWVyeVNlbGVjdG9yKFwibGlicmFyeV9saWdodHNcIik7XG5cdFx0XHR4bWxub2RlID0gdGhpcy5nZXRGaXJzdENoaWxkRWxlbWVudCh4bWxsaWJsaWdodHMsIFwibGlnaHRcIik7XG5cdFx0fVxuXG5cdFx0aWYgKCF4bWxub2RlKSByZXR1cm4gbnVsbDtcblxuXHRcdC8vcGFja1xuXHRcdHZhciBjaGlsZHJlbiA9IFtdO1xuXHRcdHZhciB4bWwgPSB4bWxub2RlLnF1ZXJ5U2VsZWN0b3IoXCJ0ZWNobmlxdWVfY29tbW9uXCIpO1xuXHRcdGlmICh4bWwpIGZvciAodmFyIGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh4bWwuY2hpbGROb2Rlcy5pdGVtKGkpLm5vZGVUeXBlID09IDEpIC8vdGFnXG5cdFx0XHRcdGNoaWxkcmVuLnB1c2goeG1sLmNoaWxkTm9kZXMuaXRlbShpKSk7XG5cdFx0fXZhciB4bWxzID0geG1sbm9kZS5xdWVyeVNlbGVjdG9yQWxsKFwidGVjaG5pcXVlXCIpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHhtbDIgPSB4bWxzLml0ZW0oaSk7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHhtbDIuY2hpbGROb2Rlcy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRpZiAoeG1sMi5jaGlsZE5vZGVzLml0ZW0oaikubm9kZVR5cGUgPT0gMSkgLy90YWdcblx0XHRcdFx0XHRjaGlsZHJlbi5wdXNoKHhtbDIuY2hpbGROb2Rlcy5pdGVtKGopKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvL2dldFxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB4bWwgPSBjaGlsZHJlbltpXTtcblx0XHRcdHN3aXRjaCAoeG1sLmxvY2FsTmFtZSkge1xuXHRcdFx0XHRjYXNlIFwicG9pbnRcIjpcblx0XHRcdFx0XHRsaWdodC50eXBlID0gdGhpcy5saWdodF90cmFuc2xhdGVfdGFibGVbeG1sLmxvY2FsTmFtZV07XG5cdFx0XHRcdFx0cGFyc2VfcGFyYW1zKGxpZ2h0LCB4bWwpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiZGlyZWN0aW9uYWxcIjpcblx0XHRcdFx0XHRsaWdodC50eXBlID0gdGhpcy5saWdodF90cmFuc2xhdGVfdGFibGVbeG1sLmxvY2FsTmFtZV07XG5cdFx0XHRcdFx0cGFyc2VfcGFyYW1zKGxpZ2h0LCB4bWwpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwic3BvdFwiOlxuXHRcdFx0XHRcdGxpZ2h0LnR5cGUgPSB0aGlzLmxpZ2h0X3RyYW5zbGF0ZV90YWJsZVt4bWwubG9jYWxOYW1lXTtcblx0XHRcdFx0XHRwYXJzZV9wYXJhbXMobGlnaHQsIHhtbCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBcImludGVuc2l0eVwiOlxuXHRcdFx0XHRcdGxpZ2h0LmludGVuc2l0eSA9IHRoaXMucmVhZENvbnRlbnRBc0Zsb2F0cyh4bWwpWzBdO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlX3BhcmFtcyhsaWdodCwgeG1sKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzLml0ZW0oaSk7XG5cdFx0XHRcdGlmICghY2hpbGQgfHwgY2hpbGQubm9kZVR5cGUgIT0gMSkgLy90YWdcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKGNoaWxkLmxvY2FsTmFtZSkge1xuXHRcdFx0XHRcdGNhc2UgXCJjb2xvclwiOlxuXHRcdFx0XHRcdFx0bGlnaHQuY29sb3IgPSBDb2xsYWRhLnJlYWRDb250ZW50QXNGbG9hdHMoY2hpbGQpO2JyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJmYWxsb2ZmX2FuZ2xlXCI6XG5cdFx0XHRcdFx0XHRsaWdodC5hbmdsZV9lbmQgPSBDb2xsYWRhLnJlYWRDb250ZW50QXNGbG9hdHMoY2hpbGQpWzBdO1xuXHRcdFx0XHRcdFx0bGlnaHQuYW5nbGUgPSBsaWdodC5hbmdsZV9lbmQgLSAxMDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG5vZGUubW9kZWwpIHtcblx0XHRcdC8vbGlnaHQgcG9zaXRpb24gaXMgZmluYWwgY29sdW1uIG9mIG1vZGVsXG5cdFx0XHRsaWdodC5wb3NpdGlvbiA9IFtub2RlLm1vZGVsWzEyXSwgbm9kZS5tb2RlbFsxM10sIG5vZGUubW9kZWxbMTRdXTtcblx0XHRcdC8vbGlnaHQgZm9yd2FyZCB2ZWN0b3IgaXMgcmV2ZXJzZSBvZiB0aGlyZCBjb2x1bW4gb2YgbW9kZWxcblx0XHRcdHZhciBmb3J3YXJkID0gWy1ub2RlLm1vZGVsWzhdLCAtbm9kZS5tb2RlbFs5XSwgLW5vZGUubW9kZWxbMTBdXTtcblx0XHRcdC8vc28gbGlnaHQgdGFyZ2V0IGlzIHBvc2l0aW9uICsgZm9yd2FyZFxuXHRcdFx0bGlnaHQudGFyZ2V0ID0gW2xpZ2h0LnBvc2l0aW9uWzBdICsgZm9yd2FyZFswXSwgbGlnaHQucG9zaXRpb25bMV0gKyBmb3J3YXJkWzFdLCBsaWdodC5wb3NpdGlvblsyXSArIGZvcndhcmRbMl1dO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgcmVhZCBsaWdodCBwb3NpdGlvbiBmb3IgbGlnaHQ6IFwiICsgbm9kZS5uYW1lICsgXCIuIFNldHRpbmcgZGVmYXVsdHMuXCIpO1xuXHRcdFx0bGlnaHQucG9zaXRpb24gPSBbMCwgMCwgMF07XG5cdFx0XHRsaWdodC50YXJnZXQgPSBbMCwgLTEsIDBdO1xuXHRcdH1cblxuXHRcdG5vZGUubGlnaHQgPSBsaWdodDtcblx0fSxcblxuXHRyZWFkQ2FtZXJhOiBmdW5jdGlvbiByZWFkQ2FtZXJhKG5vZGUsIHVybCkge1xuXHRcdHZhciBjYW1lcmEgPSB7fTtcblxuXHRcdHZhciB4bWxub2RlID0gdGhpcy5feG1scm9vdC5xdWVyeVNlbGVjdG9yKFwibGlicmFyeV9jYW1lcmFzIFwiICsgdXJsKTtcblx0XHRpZiAoIXhtbG5vZGUpIHJldHVybiBudWxsO1xuXG5cdFx0Ly9wYWNrXG5cdFx0dmFyIGNoaWxkcmVuID0gW107XG5cdFx0dmFyIHhtbCA9IHhtbG5vZGUucXVlcnlTZWxlY3RvcihcInRlY2huaXF1ZV9jb21tb25cIik7XG5cdFx0aWYgKHhtbCkgLy9ncmFiIGFsbCBpbnRlcm5hbCBzdHVmZlxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoeG1sLmNoaWxkTm9kZXMuaXRlbShpKS5ub2RlVHlwZSA9PSAxKSAvL3RhZ1xuXHRcdFx0XHRcdGNoaWxkcmVuLnB1c2goeG1sLmNoaWxkTm9kZXMuaXRlbShpKSk7XG5cdFx0XHR9IC8vXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHRhZyA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0cGFyc2VfcGFyYW1zKGNhbWVyYSwgdGFnKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZV9wYXJhbXMoY2FtZXJhLCB4bWwpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXMuaXRlbShpKTtcblx0XHRcdFx0aWYgKCFjaGlsZCB8fCBjaGlsZC5ub2RlVHlwZSAhPSAxKSAvL3RhZ1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR2YXIgdHJhbnNsYXRlZCA9IENvbGxhZGEuY2FtZXJhX3RyYW5zbGF0ZV90YWJsZVtjaGlsZC5sb2NhbE5hbWVdIHx8IGNoaWxkLmxvY2FsTmFtZTtcblx0XHRcdFx0Y2FtZXJhW3RyYW5zbGF0ZWRdID0gcGFyc2VGbG9hdChjaGlsZC50ZXh0Q29udGVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9wYXJzZSB0byBjb252ZXJ0IHlmb3YgdG8gc3RhbmRhcmQgKHgpIGZvdlxuXHRcdGlmIChjYW1lcmEueWZvdiAmJiAhY2FtZXJhLmZvdikge1xuXHRcdFx0aWYgKGNhbWVyYS5hc3BlY3QpIHtcblx0XHRcdFx0Y2FtZXJhLmZvdiA9IGNhbWVyYS55Zm92ICogY2FtZXJhLmFzcGVjdDtcblx0XHRcdH0gZWxzZSBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgY29udmVydCBjYW1lcmEgeWZvdiB0byB4Zm92IGJlY2F1c2UgYXNwZWN0IHJhdGlvIG5vdCBzZXRcIik7XG5cdFx0fVxuXG5cdFx0bm9kZS5jYW1lcmEgPSBjYW1lcmE7XG5cdH0sXG5cblx0cmVhZFRyYW5zZm9ybTogZnVuY3Rpb24gcmVhZFRyYW5zZm9ybSh4bWxub2RlLCBsZXZlbCwgZmxpcCkge1xuXHRcdC8vaWRlbnRpdHlcblx0XHR2YXIgbWF0cml4ID0gX2dsTWF0cml4Lm1hdDQuY3JlYXRlKCk7XG5cdFx0dmFyIHRlbXAgPSBfZ2xNYXRyaXgubWF0NC5jcmVhdGUoKTtcblx0XHR2YXIgdG1wcSA9IF9nbE1hdHJpeC5xdWF0LmNyZWF0ZSgpO1xuXG5cdFx0dmFyIGZsaXBfZml4ID0gZmFsc2U7XG5cblx0XHQvL3NlYXJjaCBmb3IgdGhlIG1hdHJpeFxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1sbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgeG1sID0geG1sbm9kZS5jaGlsZE5vZGVzLml0ZW0oaSk7XG5cdFx0XHRpZiAoIXhtbCB8fCB4bWwubm9kZVR5cGUgIT0gMSkgLy90YWdcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdGlmICh4bWwubG9jYWxOYW1lID09IFwibWF0cml4XCIpIHtcblx0XHRcdFx0dmFyIG1hdHJpeCA9IHRoaXMucmVhZENvbnRlbnRBc0Zsb2F0cyh4bWwpO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKFwiTm9kZW5hbWU6IFwiICsgeG1sbm9kZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSk7XG5cdFx0XHRcdC8vY29uc29sZS5sb2cobWF0cml4KTtcblx0XHRcdFx0dGhpcy50cmFuc2Zvcm1NYXRyaXgobWF0cml4LCBsZXZlbCA9PSAwKTtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhtYXRyaXgpO1xuXHRcdFx0XHRyZXR1cm4gbWF0cml4O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoeG1sLmxvY2FsTmFtZSA9PSBcInRyYW5zbGF0ZVwiKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXMgPSB0aGlzLnJlYWRDb250ZW50QXNGbG9hdHMoeG1sKTtcblx0XHRcdFx0aWYgKGZsaXAgJiYgbGV2ZWwgPiAwKSB7XG5cdFx0XHRcdFx0dmFyIHRtcCA9IHZhbHVlc1sxXTtcblx0XHRcdFx0XHR2YWx1ZXNbMV0gPSB2YWx1ZXNbMl07XG5cdFx0XHRcdFx0dmFsdWVzWzJdID0gLXRtcDsgLy9zd2FwIGNvb3Jkc1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2dsTWF0cml4Lm1hdDQudHJhbnNsYXRlKG1hdHJpeCwgbWF0cml4LCB2YWx1ZXMpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly9yb3RhdGVcblx0XHRcdGlmICh4bWwubG9jYWxOYW1lID09IFwicm90YXRlXCIpIHtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IHRoaXMucmVhZENvbnRlbnRBc0Zsb2F0cyh4bWwpO1xuXHRcdFx0XHRpZiAodmFsdWVzLmxlbmd0aCA9PSA0KSAvL3gseSx6LCBhbmdsZVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHZhciBpZCA9IHhtbC5nZXRBdHRyaWJ1dGUoXCJzaWRcIik7XG5cdFx0XHRcdFx0XHRpZiAoaWQgPT0gXCJqb2ludE9yaWVudFhcIikge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXNbM10gKz0gOTA7XG5cdFx0XHRcdFx0XHRcdGZsaXBfZml4ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vcm90YXRlWCAmIHJvdGF0ZVkgJiByb3RhdGVaIGRvbmUgYmVsb3dcblxuXHRcdFx0XHRcdFx0aWYgKGZsaXApIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRtcCA9IHZhbHVlc1sxXTtcblx0XHRcdFx0XHRcdFx0dmFsdWVzWzFdID0gdmFsdWVzWzJdO1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXNbMl0gPSAtdG1wOyAvL3N3YXAgY29vcmRzXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICh2YWx1ZXNbM10gIT0gMC4wKSB7XG5cdFx0XHRcdFx0XHRcdF9nbE1hdHJpeC5xdWF0LnNldEF4aXNBbmdsZSh0bXBxLCB2YWx1ZXMuc3ViYXJyYXkoMCwgMyksIHZhbHVlc1szXSAqIERFRzJSQUQpO1xuXHRcdFx0XHRcdFx0XHRfZ2xNYXRyaXgubWF0NC5mcm9tUXVhdCh0ZW1wLCB0bXBxKTtcblx0XHRcdFx0XHRcdFx0X2dsTWF0cml4Lm1hdDQubXVsdGlwbHkobWF0cml4LCBtYXRyaXgsIHRlbXApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vc2NhbGVcblx0XHRcdGlmICh4bWwubG9jYWxOYW1lID09IFwic2NhbGVcIikge1xuXHRcdFx0XHR2YXIgdmFsdWVzID0gdGhpcy5yZWFkQ29udGVudEFzRmxvYXRzKHhtbCk7XG5cdFx0XHRcdGlmIChmbGlwKSB7XG5cdFx0XHRcdFx0dmFyIHRtcCA9IHZhbHVlc1sxXTtcblx0XHRcdFx0XHR2YWx1ZXNbMV0gPSB2YWx1ZXNbMl07XG5cdFx0XHRcdFx0dmFsdWVzWzJdID0gLXRtcDsgLy9zd2FwIGNvb3Jkc1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9nbE1hdHJpeC5tYXQ0LnNjYWxlKG1hdHJpeCwgbWF0cml4LCB2YWx1ZXMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRyaXg7XG5cdH0sXG5cblx0cmVhZFRyYW5zZm9ybTI6IGZ1bmN0aW9uIHJlYWRUcmFuc2Zvcm0yKHhtbG5vZGUsIGxldmVsLCBmbGlwKSB7XG5cdFx0Ly9pZGVudGl0eVxuXHRcdHZhciBtYXRyaXggPSBfZ2xNYXRyaXgubWF0NC5jcmVhdGUoKTtcblx0XHR2YXIgcm90YXRpb24gPSBfZ2xNYXRyaXgucXVhdC5jcmVhdGUoKTtcblx0XHR2YXIgdG1wbWF0cml4ID0gX2dsTWF0cml4Lm1hdDQuY3JlYXRlKCk7XG5cdFx0dmFyIHRtcHEgPSBfZ2xNYXRyaXgucXVhdC5jcmVhdGUoKTtcblx0XHR2YXIgdHJhbnNsYXRlID0gdmVjMy5jcmVhdGUoKTtcblx0XHR2YXIgc2NhbGUgPSB2ZWMzLmZyb21WYWx1ZXMoMSwgMSwgMSk7XG5cblx0XHR2YXIgZmxpcF9maXggPSBmYWxzZTtcblxuXHRcdC8vc2VhcmNoIGZvciB0aGUgbWF0cml4XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWxub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB4bWwgPSB4bWxub2RlLmNoaWxkTm9kZXMuaXRlbShpKTtcblxuXHRcdFx0aWYgKHhtbC5sb2NhbE5hbWUgPT0gXCJtYXRyaXhcIikge1xuXHRcdFx0XHR2YXIgbWF0cml4ID0gdGhpcy5yZWFkQ29udGVudEFzRmxvYXRzKHhtbCk7XG5cdFx0XHRcdC8vY29uc29sZS5sb2coXCJOb2RlbmFtZTogXCIgKyB4bWxub2RlLmdldEF0dHJpYnV0ZShcImlkXCIpKTtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhtYXRyaXgpO1xuXHRcdFx0XHR0aGlzLnRyYW5zZm9ybU1hdHJpeChtYXRyaXgsIGxldmVsID09IDApO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKG1hdHJpeCk7XG5cdFx0XHRcdHJldHVybiBtYXRyaXg7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh4bWwubG9jYWxOYW1lID09IFwidHJhbnNsYXRlXCIpIHtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IHRoaXMucmVhZENvbnRlbnRBc0Zsb2F0cyh4bWwpO1xuXHRcdFx0XHR0cmFuc2xhdGUuc2V0KHZhbHVlcyk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvL3JvdGF0ZVxuXHRcdFx0aWYgKHhtbC5sb2NhbE5hbWUgPT0gXCJyb3RhdGVcIikge1xuXHRcdFx0XHR2YXIgdmFsdWVzID0gdGhpcy5yZWFkQ29udGVudEFzRmxvYXRzKHhtbCk7XG5cdFx0XHRcdGlmICh2YWx1ZXMubGVuZ3RoID09IDQpIC8veCx5LHosIGFuZ2xlXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dmFyIGlkID0geG1sLmdldEF0dHJpYnV0ZShcInNpZFwiKTtcblx0XHRcdFx0XHRcdGlmIChpZCA9PSBcImpvaW50T3JpZW50WFwiKSB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlc1szXSArPSA5MDtcblx0XHRcdFx0XHRcdFx0ZmxpcF9maXggPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly9yb3RhdGVYICYgcm90YXRlWSAmIHJvdGF0ZVogZG9uZSBiZWxvd1xuXG5cdFx0XHRcdFx0XHRpZiAoZmxpcCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdG1wID0gdmFsdWVzWzFdO1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXNbMV0gPSB2YWx1ZXNbMl07XG5cdFx0XHRcdFx0XHRcdHZhbHVlc1syXSA9IC10bXA7IC8vc3dhcCBjb29yZHNcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKHZhbHVlc1szXSAhPSAwLjApIHtcblx0XHRcdFx0XHRcdFx0X2dsTWF0cml4LnF1YXQuc2V0QXhpc0FuZ2xlKHRtcHEsIHZhbHVlcy5zdWJhcnJheSgwLCAzKSwgdmFsdWVzWzNdICogREVHMlJBRCk7XG5cdFx0XHRcdFx0XHRcdF9nbE1hdHJpeC5xdWF0Lm11bHRpcGx5KHJvdGF0aW9uLCByb3RhdGlvbiwgdG1wcSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly9zY2FsZVxuXHRcdFx0aWYgKHhtbC5sb2NhbE5hbWUgPT0gXCJzY2FsZVwiKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXMgPSB0aGlzLnJlYWRDb250ZW50QXNGbG9hdHMoeG1sKTtcblx0XHRcdFx0aWYgKGZsaXApIHtcblx0XHRcdFx0XHR2YXIgdG1wID0gdmFsdWVzWzFdO1xuXHRcdFx0XHRcdHZhbHVlc1sxXSA9IHZhbHVlc1syXTtcblx0XHRcdFx0XHR2YWx1ZXNbMl0gPSAtdG1wOyAvL3N3YXAgY29vcmRzXG5cdFx0XHRcdH1cblx0XHRcdFx0c2NhbGUuc2V0KHZhbHVlcyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGZsaXAgJiYgbGV2ZWwgPiAwKSB7XG5cdFx0XHR2YXIgdG1wID0gdHJhbnNsYXRlWzFdO1xuXHRcdFx0dHJhbnNsYXRlWzFdID0gdHJhbnNsYXRlWzJdO1xuXHRcdFx0dHJhbnNsYXRlWzJdID0gLXRtcDsgLy9zd2FwIGNvb3Jkc1xuXHRcdH1cblx0XHRfZ2xNYXRyaXgubWF0NC50cmFuc2xhdGUobWF0cml4LCBtYXRyaXgsIHRyYW5zbGF0ZSk7XG5cblx0XHRfZ2xNYXRyaXgubWF0NC5mcm9tUXVhdCh0bXBtYXRyaXgsIHJvdGF0aW9uKTtcblx0XHQvL21hdDQucm90YXRlWCh0bXBtYXRyaXgsIHRtcG1hdHJpeCwgTWF0aC5QSSAqIDAuNSk7XG5cdFx0X2dsTWF0cml4Lm1hdDQubXVsdGlwbHkobWF0cml4LCBtYXRyaXgsIHRtcG1hdHJpeCk7XG5cdFx0X2dsTWF0cml4Lm1hdDQuc2NhbGUobWF0cml4LCBtYXRyaXgsIHNjYWxlKTtcblxuXHRcdHJldHVybiBtYXRyaXg7XG5cdH0sXG5cblx0Ly9mb3IgaGVscCByZWFkIHRoaXM6IGh0dHBzOi8vd3d3Lmtocm9ub3Mub3JnL2NvbGxhZGEvd2lraS9Vc2luZ19hY2Nlc3NvcnNcblx0cmVhZEdlb21ldHJ5OiBmdW5jdGlvbiByZWFkR2VvbWV0cnkoaWQsIGZsaXAsIHNjZW5lKSB7XG5cdFx0Ly9hbHJlYWR5IHJlYWQsIGNvdWxkIGhhcHBlbmQgaWYgc2V2ZXJhbCBjb250cm9sbGVycyBwb2ludCB0byB0aGUgc2FtZSBtZXNoXG5cdFx0aWYgKHRoaXMuX2dlb21ldHJpZXNfZm91bmRbaWRdICE9PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLl9nZW9tZXRyaWVzX2ZvdW5kW2lkXTtcblxuXHRcdC8vdmFyIHhtbGdlb21ldHJ5ID0gdGhpcy5feG1scm9vdC5xdWVyeVNlbGVjdG9yKFwiZ2VvbWV0cnlcIiArIGlkKTtcblx0XHR2YXIgeG1sZ2VvbWV0cnkgPSB0aGlzLl94bWxyb290LmdldEVsZW1lbnRCeUlkKGlkLnN1YnN0cigxKSk7XG5cdFx0aWYgKCF4bWxnZW9tZXRyeSkge1xuXHRcdFx0Y29uc29sZS53YXJuKFwicmVhZEdlb21ldHJ5OiBnZW9tZXRyeSBub3QgZm91bmQ6IFwiICsgaWQpO1xuXHRcdFx0dGhpcy5fZ2VvbWV0cmllc19mb3VuZFtpZF0gPSBudWxsO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Ly9pZiB0aGUgZ2VvbWV0cnkgaGFzIG1vcnBoIHRhcmdldHMgdGhlbiBpbnN0ZWFkIG9mIHN0b3JpbmcgaXQgaW4gYSBnZW9tZXRyeSwgaXQgaXMgaW4gYSBjb250cm9sbGVyXG5cdFx0aWYgKHhtbGdlb21ldHJ5LmxvY2FsTmFtZSA9PSBcImNvbnRyb2xsZXJcIikge1xuXHRcdFx0dmFyIGdlb21ldHJ5ID0gdGhpcy5yZWFkQ29udHJvbGxlcih4bWxnZW9tZXRyeSwgZmxpcCwgc2NlbmUpO1xuXHRcdFx0dGhpcy5fZ2VvbWV0cmllc19mb3VuZFtpZF0gPSBnZW9tZXRyeTtcblx0XHRcdHJldHVybiBnZW9tZXRyeTtcblx0XHR9XG5cblx0XHRpZiAoeG1sZ2VvbWV0cnkubG9jYWxOYW1lICE9IFwiZ2VvbWV0cnlcIikge1xuXHRcdFx0Y29uc29sZS53YXJuKFwicmVhZEdlb21ldHJ5OiB0YWcgc2hvdWxkIGJlIGdlb21ldHJ5LCBpbnN0ZWFkIGl0IHdhcyBmb3VuZDogXCIgKyB4bWxnZW9tZXRyeS5sb2NhbE5hbWUpO1xuXHRcdFx0dGhpcy5fZ2VvbWV0cmllc19mb3VuZFtpZF0gPSBudWxsO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0dmFyIHhtbG1lc2ggPSB4bWxnZW9tZXRyeS5xdWVyeVNlbGVjdG9yKFwibWVzaFwiKTtcblx0XHRpZiAoIXhtbG1lc2gpIHtcblx0XHRcdGNvbnNvbGUud2FybihcInJlYWRHZW9tZXRyeTogbWVzaCBub3QgZm91bmQgaW4gZ2VvbWV0cnk6IFwiICsgaWQpO1xuXHRcdFx0dGhpcy5fZ2VvbWV0cmllc19mb3VuZFtpZF0gPSBudWxsO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Ly9nZXQgZGF0YSBzb3VyY2VzXG5cdFx0dmFyIHNvdXJjZXMgPSB7fTtcblx0XHR2YXIgeG1sc291cmNlcyA9IHhtbG1lc2gucXVlcnlTZWxlY3RvckFsbChcInNvdXJjZVwiKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB4bWxzb3VyY2UgPSB4bWxzb3VyY2VzLml0ZW0oaSk7XG5cdFx0XHRpZiAoIXhtbHNvdXJjZS5xdWVyeVNlbGVjdG9yKSBjb250aW51ZTtcblx0XHRcdHZhciBmbG9hdF9hcnJheSA9IHhtbHNvdXJjZS5xdWVyeVNlbGVjdG9yKFwiZmxvYXRfYXJyYXlcIik7XG5cdFx0XHRpZiAoIWZsb2F0X2FycmF5KSBjb250aW51ZTtcblx0XHRcdHZhciBmbG9hdHMgPSB0aGlzLnJlYWRDb250ZW50QXNGbG9hdHMoZmxvYXRfYXJyYXkpO1xuXG5cdFx0XHR2YXIgeG1sYWNjZXNzb3IgPSB4bWxzb3VyY2UucXVlcnlTZWxlY3RvcihcImFjY2Vzc29yXCIpO1xuXHRcdFx0dmFyIHN0cmlkZSA9IHBhcnNlSW50KHhtbGFjY2Vzc29yLmdldEF0dHJpYnV0ZShcInN0cmlkZVwiKSk7XG5cblx0XHRcdHNvdXJjZXNbeG1sc291cmNlLmdldEF0dHJpYnV0ZShcImlkXCIpXSA9IHsgc3RyaWRlOiBzdHJpZGUsIGRhdGE6IGZsb2F0cyB9O1xuXHRcdH1cblxuXHRcdC8vZ2V0IHN0cmVhbXNcblx0XHR2YXIgeG1sdmVydGljZXMgPSB4bWxtZXNoLnF1ZXJ5U2VsZWN0b3IoXCJ2ZXJ0aWNlcyBpbnB1dFwiKTtcblx0XHR2YXIgdmVydGljZXNfc291cmNlID0gc291cmNlc1t4bWx2ZXJ0aWNlcy5nZXRBdHRyaWJ1dGUoXCJzb3VyY2VcIikuc3Vic3RyKDEpXTtcblx0XHRzb3VyY2VzW3htbG1lc2gucXVlcnlTZWxlY3RvcihcInZlcnRpY2VzXCIpLmdldEF0dHJpYnV0ZShcImlkXCIpXSA9IHZlcnRpY2VzX3NvdXJjZTtcblxuXHRcdHZhciBtZXNoID0gbnVsbDtcblx0XHR2YXIgeG1scG9seWdvbnMgPSB4bWxtZXNoLnF1ZXJ5U2VsZWN0b3IoXCJwb2x5Z29uc1wiKTtcblx0XHRpZiAoeG1scG9seWdvbnMpIG1lc2ggPSB0aGlzLnJlYWRUcmlhbmdsZXMoeG1scG9seWdvbnMsIHNvdXJjZXMpO1xuXG5cdFx0aWYgKCFtZXNoKSB7XG5cdFx0XHR2YXIgeG1sdHJpYW5nbGVzID0geG1sbWVzaC5xdWVyeVNlbGVjdG9yQWxsKFwidHJpYW5nbGVzXCIpO1xuXHRcdFx0aWYgKHhtbHRyaWFuZ2xlcyAmJiB4bWx0cmlhbmdsZXMubGVuZ3RoKSBtZXNoID0gdGhpcy5yZWFkVHJpYW5nbGVzKHhtbHRyaWFuZ2xlcywgc291cmNlcyk7XG5cdFx0fVxuXG5cdFx0aWYgKCFtZXNoKSB7XG5cdFx0XHQvL3BvbHlsaXN0ID0gdHJ1ZTtcblx0XHRcdC8vdmFyIHZjb3VudCA9IG51bGw7XG5cdFx0XHQvL3ZhciB4bWx2Y291bnQgPSB4bWxwb2x5Z29ucy5xdWVyeVNlbGVjdG9yKFwidmNvdW50XCIpO1xuXHRcdFx0Ly92YXIgdmNvdW50ID0gdGhpcy5yZWFkQ29udGVudEFzVUludDMyKCB4bWx2Y291bnQgKTtcblx0XHRcdHZhciB4bWxwb2x5bGlzdCA9IHhtbG1lc2gucXVlcnlTZWxlY3RvcihcInBvbHlsaXN0XCIpO1xuXHRcdFx0aWYgKHhtbHBvbHlsaXN0KSBtZXNoID0gdGhpcy5yZWFkUG9seWxpc3QoeG1scG9seWxpc3QsIHNvdXJjZXMpO1xuXHRcdH1cblxuXHRcdGlmICghbWVzaCkge1xuXHRcdFx0dmFyIHhtbGxpbmVzdHJpcCA9IHhtbG1lc2gucXVlcnlTZWxlY3RvcihcImxpbmVzdHJpcHNcIik7XG5cdFx0XHRpZiAoeG1sbGluZXN0cmlwKSBtZXNoID0gdGhpcy5yZWFkTGluZVN0cmlwKHNvdXJjZXMsIHhtbGxpbmVzdHJpcCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFtZXNoKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcIm5vIHBvbHlnb25zIG9yIHRyaWFuZ2xlcyBpbiBtZXNoOiBcIiArIGlkKTtcblx0XHRcdHRoaXMuX2dlb21ldHJpZXNfZm91bmRbaWRdID0gbnVsbDtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdC8vc3dhcCBjb29yZHMgKFgsWSxaKSAtPiAoWCxaLC1ZKVxuXHRcdGlmIChmbGlwICYmICF0aGlzLm5vX2ZsaXApIHtcblx0XHRcdHZhciB0bXAgPSAwO1xuXHRcdFx0dmFyIGFycmF5ID0gbWVzaC52ZXJ0aWNlcztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArPSAzKSB7XG5cdFx0XHRcdHRtcCA9IGFycmF5W2kgKyAxXTtcblx0XHRcdFx0YXJyYXlbaSArIDFdID0gYXJyYXlbaSArIDJdO1xuXHRcdFx0XHRhcnJheVtpICsgMl0gPSAtdG1wO1xuXHRcdFx0fVxuXG5cdFx0XHRhcnJheSA9IG1lc2gubm9ybWFscztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArPSAzKSB7XG5cdFx0XHRcdHRtcCA9IGFycmF5W2kgKyAxXTtcblx0XHRcdFx0YXJyYXlbaSArIDFdID0gYXJyYXlbaSArIDJdO1xuXHRcdFx0XHRhcnJheVtpICsgMl0gPSAtdG1wO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vdHJhbnNmZXJhYmxlcyBmb3Igd29ya2VyXG5cdFx0aWYgKGlzV29ya2VyICYmIHRoaXMudXNlX3RyYW5zZmVyYWJsZXMpIHtcblx0XHRcdGZvciAodmFyIGkgaW4gbWVzaCkge1xuXHRcdFx0XHR2YXIgZGF0YSA9IG1lc2hbaV07XG5cdFx0XHRcdGlmIChkYXRhICYmIGRhdGEuYnVmZmVyICYmIGRhdGEubGVuZ3RoID4gMTAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fdHJhbnNmZXJhYmxlcy5wdXNoKGRhdGEuYnVmZmVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vZXh0cmEgaW5mb1xuXHRcdG1lc2guZmlsZW5hbWUgPSBpZDtcblx0XHRtZXNoLm9iamVjdF90eXBlID0gXCJNZXNoXCI7XG5cblx0XHR0aGlzLl9nZW9tZXRyaWVzX2ZvdW5kW2lkXSA9IG1lc2g7XG5cdFx0cmV0dXJuIG1lc2g7XG5cdH0sXG5cblx0cmVhZFRyaWFuZ2xlczogZnVuY3Rpb24gcmVhZFRyaWFuZ2xlcyh4bWx0cmlhbmdsZXMsIHNvdXJjZXMpIHtcblx0XHR2YXIgdXNlX2luZGljZXMgPSBmYWxzZTtcblxuXHRcdHZhciBncm91cHMgPSBbXTtcblx0XHR2YXIgYnVmZmVycyA9IFtdO1xuXHRcdHZhciBsYXN0X2luZGV4ID0gMDtcblx0XHR2YXIgZmFjZW1hcCA9IHt9O1xuXHRcdHZhciB2ZXJ0ZXhfcmVtYXAgPSBbXTsgLy9tYXBzIERBRSB2ZXJ0ZXggaW5kZXggdG8gTWVzaCB2ZXJ0ZXggaW5kZXggKGJlY2F1c2Ugd2hlbiBtZXNoZXMgYXJlIHRyaWFuZ3VsYXRlZCBpbmRpY2VzIGFyZSBjaGFuZ2VkXG5cdFx0dmFyIGluZGljZXNBcnJheSA9IFtdO1xuXHRcdHZhciBsYXN0X3N0YXJ0ID0gMDtcblx0XHR2YXIgZ3JvdXBfbmFtZSA9IFwiXCI7XG5cdFx0dmFyIG1hdGVyaWFsX25hbWUgPSBcIlwiO1xuXG5cdFx0Ly9mb3IgZXZlcnkgdHJpYW5nbGVzIHNldCAod2FybmluZywgc29tZSB0aW1lcyB0aGV5IGFyZSByZXBlYXRlZC4uLilcblx0XHRmb3IgKHZhciB0cmlzID0gMDsgdHJpcyA8IHhtbHRyaWFuZ2xlcy5sZW5ndGg7IHRyaXMrKykge1xuXHRcdFx0dmFyIHhtbF9zaGFwZV9yb290ID0geG1sdHJpYW5nbGVzLml0ZW0odHJpcyk7XG5cdFx0XHR2YXIgdHJpYW5nbGVzID0geG1sX3NoYXBlX3Jvb3QubG9jYWxOYW1lID09IFwidHJpYW5nbGVzXCI7XG5cblx0XHRcdG1hdGVyaWFsX25hbWUgPSB4bWxfc2hhcGVfcm9vdC5nZXRBdHRyaWJ1dGUoXCJtYXRlcmlhbFwiKTtcblxuXHRcdFx0Ly9mb3IgZWFjaCBidWZmZXIgKGlucHV0KSBidWlsZCB0aGUgc3RydWN0dXJlIGluZm9cblx0XHRcdGlmICh0cmlzID09IDApIGJ1ZmZlcnMgPSB0aGlzLnJlYWRTaGFwZUlucHV0cyh4bWxfc2hhcGVfcm9vdCwgc291cmNlcyk7XG5cblx0XHRcdC8vYXNzdW1pbmcgYnVmZmVycyBhcmUgb3JkZXJlZCBieSBvZmZzZXRcblxuXHRcdFx0Ly9pdGVyYXRlIGRhdGFcblx0XHRcdHZhciB4bWxwcyA9IHhtbF9zaGFwZV9yb290LnF1ZXJ5U2VsZWN0b3JBbGwoXCJwXCIpO1xuXHRcdFx0dmFyIG51bV9kYXRhX3ZlcnRleCA9IGJ1ZmZlcnMubGVuZ3RoOyAvL29uZSB2YWx1ZSBwZXIgaW5wdXQgYnVmZmVyXG5cblx0XHRcdC8vZm9yIGV2ZXJ5IHBvbHlnb24gKGNvdWxkIGJlIG9uZSB3aXRoIGFsbCB0aGUgaW5kaWNlcywgY291bGQgYmUgc2V2ZXJhbCwgZGVwZW5kcyBvbiB0aGUgcHJvZ3JhbSlcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1scHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIHhtbHAgPSB4bWxwcy5pdGVtKGkpO1xuXHRcdFx0XHRpZiAoIXhtbHAgfHwgIXhtbHAudGV4dENvbnRlbnQpIGJyZWFrO1xuXG5cdFx0XHRcdHZhciBkYXRhID0geG1scC50ZXh0Q29udGVudC50cmltKCkuc3BsaXQoXCIgXCIpO1xuXG5cdFx0XHRcdC8vdXNlZCBmb3IgdHJpYW5ndWxhdGUgcG9seXNcblx0XHRcdFx0dmFyIGZpcnN0X2luZGV4ID0gLTE7XG5cdFx0XHRcdHZhciBjdXJyZW50X2luZGV4ID0gLTE7XG5cdFx0XHRcdHZhciBwcmV2X2luZGV4ID0gLTE7XG5cblx0XHRcdFx0Ly9kaXNjb21tZW50IHRvIGZvcmNlIDE2Yml0cyBpbmRpY2VzXG5cdFx0XHRcdC8vaWYodXNlX2luZGljZXMgJiYgbGFzdF9pbmRleCA+PSAyNTYqMjU2KVxuXHRcdFx0XHQvL1x0YnJlYWs7XG5cblx0XHRcdFx0dmFyIG51bV92YWx1ZXNfcGVyX3ZlcnRleCA9IDE7XG5cdFx0XHRcdGZvciAodmFyIGIgaW4gYnVmZmVycykge1xuXHRcdFx0XHRcdG51bV92YWx1ZXNfcGVyX3ZlcnRleCA9IE1hdGgubWF4KG51bV92YWx1ZXNfcGVyX3ZlcnRleCwgYnVmZmVyc1tiXVs0XSArIDEpO1xuXHRcdFx0XHR9IC8vZm9yIGV2ZXJ5IHBhY2sgb2YgaW5kaWNlcyBpbiB0aGUgcG9seWdvbiAodmVydGV4LCBub3JtYWwsIHV2LCAuLi4gKVxuXHRcdFx0XHR2YXIgY3VycmVudF9kYXRhX3BvcyA9IDA7XG5cdFx0XHRcdGZvciAodmFyIGsgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGsgPCBsOyBrICs9IG51bV92YWx1ZXNfcGVyX3ZlcnRleCkge1xuXHRcdFx0XHRcdHZhciB2ZXJ0ZXhfaWQgPSBkYXRhLnNsaWNlKGssIGsgKyBudW1fdmFsdWVzX3Blcl92ZXJ0ZXgpLmpvaW4oXCIgXCIpOyAvL2dlbmVyYXRlIHVuaXF1ZSBpZFxuXG5cdFx0XHRcdFx0cHJldl9pbmRleCA9IGN1cnJlbnRfaW5kZXg7XG5cdFx0XHRcdFx0aWYgKGZhY2VtYXAuaGFzT3duUHJvcGVydHkodmVydGV4X2lkKSkgLy9hZGQgdG8gYXJyYXlzLCBrZWVwIHRoZSBpbmRleFxuXHRcdFx0XHRcdFx0Y3VycmVudF9pbmRleCA9IGZhY2VtYXBbdmVydGV4X2lkXTtlbHNlIHtcblx0XHRcdFx0XHRcdC8vZm9yIGV2ZXJ5IGRhdGEgYnVmZmVyIGFzc29jaWF0ZWQgdG8gdGhpcyB2ZXJ0ZXhcblx0XHRcdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgYnVmZmVycy5sZW5ndGg7ICsraikge1xuXHRcdFx0XHRcdFx0XHR2YXIgYnVmZmVyID0gYnVmZmVyc1tqXTtcblx0XHRcdFx0XHRcdFx0dmFyIGFycmF5ID0gYnVmZmVyWzFdOyAvL2FycmF5IHdoZXJlIHdlIGFjY3VtdWxhdGUgdGhlIGZpbmFsIGRhdGEgYXMgd2UgZXh0cmFjdCBpZiBmcm9tIHNvdXJjZXNcblx0XHRcdFx0XHRcdFx0dmFyIHNvdXJjZSA9IGJ1ZmZlclszXTsgLy93aGVyZSB0byByZWFkIHRoZSBkYXRhIGZyb21cblxuXHRcdFx0XHRcdFx0XHQvL2NvbXB1dGUgdGhlIGluZGV4IGluc2lkZSB0aGUgZGF0YSBzb3VyY2UgYXJyYXlcblx0XHRcdFx0XHRcdFx0Ly92YXIgaW5kZXggPSBwYXJzZUludChkYXRhW2sgKyBqXSk7XG5cdFx0XHRcdFx0XHRcdHZhciBpbmRleCA9IHBhcnNlSW50KGRhdGFbayArIGJ1ZmZlcls0XV0pO1xuXHRcdFx0XHRcdFx0XHQvL2N1cnJlbnRfZGF0YV9wb3MgKz0gYnVmZmVyWzRdO1xuXG5cdFx0XHRcdFx0XHRcdC8vcmVtZW1iZXIgdGhpcyBpbmRleCBpbiBjYXNlIHdlIG5lZWQgdG8gcmVtYXBcblx0XHRcdFx0XHRcdFx0aWYgKGogPT0gMCkgdmVydGV4X3JlbWFwW2FycmF5Lmxlbmd0aCAvIGJ1ZmZlclsyXV0gPSBpbmRleDsgLy9ub3Qgc3VyZSBpZiBidWZmZXJbMl0sIGl0IHNob3VsZCBiZSBudW1iZXIgb2YgZmxvYXRzIHBlciB2ZXJ0ZXggKHVzdWFsbHkgMylcblx0XHRcdFx0XHRcdFx0Ly92ZXJ0ZXhfcmVtYXBbIGFycmF5Lmxlbmd0aCAvIG51bV9kYXRhX3ZlcnRleCBdID0gaW5kZXg7XG5cblx0XHRcdFx0XHRcdFx0Ly9jb21wdXRlIHRoZSBwb3NpdGlvbiBpbnNpZGUgdGhlIHNvdXJjZSBidWZmZXIgd2hlcmUgdGhlIGZpbmFsIGRhdGEgaXMgbG9jYXRlZFxuXHRcdFx0XHRcdFx0XHRpbmRleCAqPSBidWZmZXJbMl07IC8vdGhpcyB3b3JrcyBpbiBtb3N0IERBRXMgKG5vdCBhbGwpXG5cdFx0XHRcdFx0XHRcdC8vaW5kZXggPSBpbmRleCAqIGJ1ZmZlclsyXSArIGJ1ZmZlcls0XTsgLy9zdHJpZGUoMikgb2Zmc2V0KDQpXG5cdFx0XHRcdFx0XHRcdC8vaW5kZXggKz0gYnVmZmVyWzRdOyAvL3N0cmlkZSgyKSBvZmZzZXQoNClcblx0XHRcdFx0XHRcdFx0Ly9leHRyYWN0IGV2ZXJ5IHZhbHVlIG9mIHRoaXMgZWxlbWVudCBhbmQgc3RvcmUgaXQgaW4gaXRzIGZpbmFsIGFycmF5IChldmVyeSB4LHkseiwgZXRjKVxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciB4ID0gMDsgeCA8IGJ1ZmZlclsyXTsgKyt4KSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHNvdXJjZVtpbmRleCArIHhdID09PSB1bmRlZmluZWQpIHRocm93IFwiVU5ERUZJTkVEIVwiOyAvL0RFQlVHXG5cdFx0XHRcdFx0XHRcdFx0YXJyYXkucHVzaChzb3VyY2VbaW5kZXggKyB4XSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y3VycmVudF9pbmRleCA9IGxhc3RfaW5kZXg7XG5cdFx0XHRcdFx0XHRsYXN0X2luZGV4ICs9IDE7XG5cdFx0XHRcdFx0XHRmYWNlbWFwW3ZlcnRleF9pZF0gPSBjdXJyZW50X2luZGV4O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICghdHJpYW5nbGVzKSAvL3RoZSB4bWwgZWxlbWVudCBpcyBub3QgdHJpYW5nbGVzPyB0aGVuIHNwbGl0IHBvbHlnb25zIGluIHRyaWFuZ2xlc1xuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRpZiAoayA9PSAwKSBmaXJzdF9pbmRleCA9IGN1cnJlbnRfaW5kZXg7XG5cdFx0XHRcdFx0XHRcdC8vaWYoayA+IDIgKiBudW1fZGF0YV92ZXJ0ZXgpIC8vbm90IHN1cmUgaWYgdXNlIHRoaXMgb3IgdGhlIG5leHQgbGluZSwgdGhlIG5leHQgb25lIHdvcmtzIGluIHNvbWUgREFFcyBidXQgbm90IHN1cmUgaWYgaXQgd29ya3MgaW4gYWxsXG5cdFx0XHRcdFx0XHRcdGlmIChrID4gMikgLy90cmlhbmd1bGF0ZSBwb2x5Z29uczogZW5zdXJlIHRoaXMgd29ya3Ncblx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRpbmRpY2VzQXJyYXkucHVzaChmaXJzdF9pbmRleCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpbmRpY2VzQXJyYXkucHVzaChwcmV2X2luZGV4KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpbmRpY2VzQXJyYXkucHVzaChjdXJyZW50X2luZGV4KTtcblx0XHRcdFx0fSAvL3BlciB2ZXJ0ZXhcblx0XHRcdH0gLy9wZXIgcG9seWdvblxuXG5cdFx0XHR2YXIgZ3JvdXAgPSB7XG5cdFx0XHRcdG5hbWU6IGdyb3VwX25hbWUgfHwgXCJncm91cFwiICsgdHJpcyxcblx0XHRcdFx0c3RhcnQ6IGxhc3Rfc3RhcnQsXG5cdFx0XHRcdGxlbmd0aDogaW5kaWNlc0FycmF5Lmxlbmd0aCAtIGxhc3Rfc3RhcnQsXG5cdFx0XHRcdG1hdGVyaWFsOiBtYXRlcmlhbF9uYW1lIHx8IFwiXCJcblx0XHRcdH07XG5cdFx0XHRsYXN0X3N0YXJ0ID0gaW5kaWNlc0FycmF5Lmxlbmd0aDtcblx0XHRcdGdyb3Vwcy5wdXNoKGdyb3VwKTtcblx0XHR9IC8vcGVyIHRyaWFuZ2xlcyBncm91cFxuXG5cdFx0dmFyIG1lc2ggPSB7XG5cdFx0XHR2ZXJ0aWNlczogbmV3IEZsb2F0MzJBcnJheShidWZmZXJzWzBdWzFdKSxcblx0XHRcdGluZm86IHsgZ3JvdXBzOiBncm91cHMgfSxcblx0XHRcdF9yZW1hcDogbmV3IFVpbnQzMkFycmF5KHZlcnRleF9yZW1hcClcblx0XHR9O1xuXG5cdFx0dGhpcy50cmFuc2Zvcm1NZXNoSW5mbyhtZXNoLCBidWZmZXJzLCBpbmRpY2VzQXJyYXkpO1xuXG5cdFx0cmV0dXJuIG1lc2g7XG5cdH0sXG5cblx0cmVhZFBvbHlsaXN0OiBmdW5jdGlvbiByZWFkUG9seWxpc3QoeG1sX3NoYXBlX3Jvb3QsIHNvdXJjZXMpIHtcblx0XHR2YXIgdXNlX2luZGljZXMgPSBmYWxzZTtcblxuXHRcdHZhciBncm91cHMgPSBbXTtcblx0XHR2YXIgYnVmZmVycyA9IFtdO1xuXHRcdHZhciBsYXN0X2luZGV4ID0gMDtcblx0XHR2YXIgZmFjZW1hcCA9IHt9O1xuXHRcdHZhciB2ZXJ0ZXhfcmVtYXAgPSBbXTtcblx0XHR2YXIgaW5kaWNlc0FycmF5ID0gW107XG5cdFx0dmFyIGxhc3Rfc3RhcnQgPSAwO1xuXHRcdHZhciBncm91cF9uYW1lID0gXCJcIjtcblx0XHR2YXIgbWF0ZXJpYWxfbmFtZSA9IFwiXCI7XG5cblx0XHRtYXRlcmlhbF9uYW1lID0geG1sX3NoYXBlX3Jvb3QuZ2V0QXR0cmlidXRlKFwibWF0ZXJpYWxcIik7XG5cdFx0YnVmZmVycyA9IHRoaXMucmVhZFNoYXBlSW5wdXRzKHhtbF9zaGFwZV9yb290LCBzb3VyY2VzKTtcblxuXHRcdHZhciB4bWx2Y291bnQgPSB4bWxfc2hhcGVfcm9vdC5xdWVyeVNlbGVjdG9yKFwidmNvdW50XCIpO1xuXHRcdHZhciB2Y291bnQgPSB0aGlzLnJlYWRDb250ZW50QXNVSW50MzIoeG1sdmNvdW50KTtcblxuXHRcdHZhciB4bWxwID0geG1sX3NoYXBlX3Jvb3QucXVlcnlTZWxlY3RvcihcInBcIik7XG5cdFx0dmFyIGRhdGEgPSB0aGlzLnJlYWRDb250ZW50QXNVSW50MzIoeG1scCk7XG5cblx0XHR2YXIgbnVtX2RhdGFfdmVydGV4ID0gYnVmZmVycy5sZW5ndGg7XG5cblx0XHR2YXIgcG9zID0gMDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHZjb3VudC5sZW5ndGg7IGkgPCBsOyArK2kpIHtcblx0XHRcdHZhciBudW1fdmVydGljZXMgPSB2Y291bnRbaV07XG5cblx0XHRcdHZhciBmaXJzdF9pbmRleCA9IC0xO1xuXHRcdFx0dmFyIGN1cnJlbnRfaW5kZXggPSAtMTtcblx0XHRcdHZhciBwcmV2X2luZGV4ID0gLTE7XG5cblx0XHRcdC8vaXRlcmF0ZSB2ZXJ0aWNlcyBvZiB0aGlzIHBvbHlnb25cblx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgbnVtX3ZlcnRpY2VzOyArK2spIHtcblx0XHRcdFx0dmFyIHZlcnRleF9pZCA9IGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyBudW1fZGF0YV92ZXJ0ZXgpLmpvaW4oXCIgXCIpO1xuXG5cdFx0XHRcdHByZXZfaW5kZXggPSBjdXJyZW50X2luZGV4O1xuXHRcdFx0XHRpZiAoZmFjZW1hcC5oYXNPd25Qcm9wZXJ0eSh2ZXJ0ZXhfaWQpKSAvL2FkZCB0byBhcnJheXMsIGtlZXAgdGhlIGluZGV4XG5cdFx0XHRcdFx0Y3VycmVudF9pbmRleCA9IGZhY2VtYXBbdmVydGV4X2lkXTtlbHNlIHtcblx0XHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGJ1ZmZlcnMubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0XHRcdHZhciBidWZmZXIgPSBidWZmZXJzW2pdO1xuXHRcdFx0XHRcdFx0dmFyIGluZGV4ID0gcGFyc2VJbnQoZGF0YVtwb3MgKyBqXSk7IC8vcFxuXHRcdFx0XHRcdFx0dmFyIGFycmF5ID0gYnVmZmVyWzFdOyAvL2FycmF5IHdpdGggYWxsIHRoZSBkYXRhXG5cdFx0XHRcdFx0XHR2YXIgc291cmNlID0gYnVmZmVyWzNdOyAvL3doZXJlIHRvIHJlYWQgdGhlIGRhdGEgZnJvbVxuXHRcdFx0XHRcdFx0aWYgKGogPT0gMCkgdmVydGV4X3JlbWFwW2FycmF5Lmxlbmd0aCAvIG51bV9kYXRhX3ZlcnRleF0gPSBpbmRleDtcblx0XHRcdFx0XHRcdGluZGV4ICo9IGJ1ZmZlclsyXTsgLy9zdHJpZGVcblx0XHRcdFx0XHRcdGZvciAodmFyIHggPSAwOyB4IDwgYnVmZmVyWzJdOyArK3gpIHtcblx0XHRcdFx0XHRcdFx0YXJyYXkucHVzaChzb3VyY2VbaW5kZXggKyB4XSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y3VycmVudF9pbmRleCA9IGxhc3RfaW5kZXg7XG5cdFx0XHRcdFx0bGFzdF9pbmRleCArPSAxO1xuXHRcdFx0XHRcdGZhY2VtYXBbdmVydGV4X2lkXSA9IGN1cnJlbnRfaW5kZXg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobnVtX3ZlcnRpY2VzID4gMykgLy9zcGxpdCBwb2x5Z29ucyB0aGVuXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWYgKGsgPT0gMCkgZmlyc3RfaW5kZXggPSBjdXJyZW50X2luZGV4O1xuXHRcdFx0XHRcdFx0Ly9pZihrID4gMiAqIG51bV9kYXRhX3ZlcnRleCkgLy9ub3Qgc3VyZSBpZiB1c2UgdGhpcyBvciB0aGUgbmV4dCBsaW5lLCB0aGUgbmV4dCBvbmUgd29ya3MgaW4gc29tZSBEQUVzIGJ1dCBub3Qgc3VyZSBpZiBpdCB3b3JrcyBpbiBhbGxcblx0XHRcdFx0XHRcdGlmIChrID4gMikgLy90cmlhbmd1bGF0ZSBwb2x5Z29uczogdGVzdGVkLCB0aGlzIHdvcmtzXG5cdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRpbmRpY2VzQXJyYXkucHVzaChmaXJzdF9pbmRleCk7XG5cdFx0XHRcdFx0XHRcdFx0aW5kaWNlc0FycmF5LnB1c2gocHJldl9pbmRleCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0aW5kaWNlc0FycmF5LnB1c2goY3VycmVudF9pbmRleCk7XG5cdFx0XHRcdHBvcyArPSBudW1fZGF0YV92ZXJ0ZXg7XG5cdFx0XHR9IC8vcGVyIHZlcnRleFxuXHRcdH0gLy9wZXIgcG9seWdvblxuXG5cdFx0dmFyIG1lc2ggPSB7XG5cdFx0XHR2ZXJ0aWNlczogbmV3IEZsb2F0MzJBcnJheShidWZmZXJzWzBdWzFdKSxcblx0XHRcdGluZm86IHt9LFxuXHRcdFx0X3JlbWFwOiBuZXcgVWludDMyQXJyYXkodmVydGV4X3JlbWFwKVxuXHRcdH07XG5cblx0XHR0aGlzLnRyYW5zZm9ybU1lc2hJbmZvKG1lc2gsIGJ1ZmZlcnMsIGluZGljZXNBcnJheSk7XG5cblx0XHRyZXR1cm4gbWVzaDtcblx0fSxcblxuXHRyZWFkU2hhcGVJbnB1dHM6IGZ1bmN0aW9uIHJlYWRTaGFwZUlucHV0cyh4bWxfc2hhcGVfcm9vdCwgc291cmNlcykge1xuXHRcdHZhciBidWZmZXJzID0gW107XG5cblx0XHR2YXIgeG1saW5wdXRzID0geG1sX3NoYXBlX3Jvb3QucXVlcnlTZWxlY3RvckFsbChcImlucHV0XCIpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1saW5wdXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgeG1saW5wdXQgPSB4bWxpbnB1dHMuaXRlbShpKTtcblx0XHRcdGlmICgheG1saW5wdXQuZ2V0QXR0cmlidXRlKSBjb250aW51ZTtcblx0XHRcdHZhciBzZW1hbnRpYyA9IHhtbGlucHV0LmdldEF0dHJpYnV0ZShcInNlbWFudGljXCIpLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHR2YXIgc3RyZWFtX3NvdXJjZSA9IHNvdXJjZXNbeG1saW5wdXQuZ2V0QXR0cmlidXRlKFwic291cmNlXCIpLnN1YnN0cigxKV07XG5cdFx0XHR2YXIgb2Zmc2V0ID0gcGFyc2VJbnQoeG1saW5wdXQuZ2V0QXR0cmlidXRlKFwib2Zmc2V0XCIpKTtcblx0XHRcdHZhciBkYXRhX3NldCA9IDA7XG5cdFx0XHRpZiAoeG1saW5wdXQuZ2V0QXR0cmlidXRlKFwic2V0XCIpKSBkYXRhX3NldCA9IHBhcnNlSW50KHhtbGlucHV0LmdldEF0dHJpYnV0ZShcInNldFwiKSk7XG5cdFx0XHRidWZmZXJzLnB1c2goW3NlbWFudGljLCBbXSwgc3RyZWFtX3NvdXJjZS5zdHJpZGUsIHN0cmVhbV9zb3VyY2UuZGF0YSwgb2Zmc2V0LCBkYXRhX3NldF0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBidWZmZXJzO1xuXHR9LFxuXG5cdHRyYW5zZm9ybU1lc2hJbmZvOiBmdW5jdGlvbiB0cmFuc2Zvcm1NZXNoSW5mbyhtZXNoLCBidWZmZXJzLCBpbmRpY2VzQXJyYXkpIHtcblx0XHQvL3JlbmFtZSBidWZmZXJzIChEQUUgaGFzIG90aGVyIG5hbWVzKVxuXHRcdHZhciB0cmFuc2xhdG9yID0ge1xuXHRcdFx0XCJub3JtYWxcIjogXCJub3JtYWxzXCIsXG5cdFx0XHRcInRleGNvb3JkXCI6IFwiY29vcmRzXCJcblx0XHR9O1xuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgYnVmZmVycy5sZW5ndGg7ICsraSkge1xuXHRcdFx0dmFyIG5hbWUgPSBidWZmZXJzW2ldWzBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR2YXIgZGF0YSA9IGJ1ZmZlcnNbaV1bMV07XG5cdFx0XHRpZiAoIWRhdGEubGVuZ3RoKSBjb250aW51ZTtcblxuXHRcdFx0aWYgKHRyYW5zbGF0b3JbbmFtZV0pIG5hbWUgPSB0cmFuc2xhdG9yW25hbWVdO1xuXHRcdFx0aWYgKG1lc2hbbmFtZV0pIG5hbWUgPSBuYW1lICsgYnVmZmVyc1tpXVs1XTtcblx0XHRcdG1lc2hbbmFtZV0gPSBuZXcgRmxvYXQzMkFycmF5KGRhdGEpOyAvL2FyZSB0aGV5IGFsd2F5cyBmbG9hdDMyPyBJIHRoaW5rIHNvXG5cdFx0fVxuXG5cdFx0aWYgKGluZGljZXNBcnJheSAmJiBpbmRpY2VzQXJyYXkubGVuZ3RoKSB7XG5cdFx0XHRpZiAobWVzaC52ZXJ0aWNlcy5sZW5ndGggPiAyNTYgKiAyNTYpIG1lc2gudHJpYW5nbGVzID0gbmV3IFVpbnQzMkFycmF5KGluZGljZXNBcnJheSk7ZWxzZSBtZXNoLnRyaWFuZ2xlcyA9IG5ldyBVaW50MTZBcnJheShpbmRpY2VzQXJyYXkpO1xuXHRcdH1cblxuXHRcdHJldHVybiBtZXNoO1xuXHR9LFxuXG5cdHJlYWRMaW5lU3RyaXA6IGZ1bmN0aW9uIHJlYWRMaW5lU3RyaXAoc291cmNlcywgeG1sbGluZXN0cmlwKSB7XG5cdFx0dmFyIHVzZV9pbmRpY2VzID0gZmFsc2U7XG5cblx0XHR2YXIgYnVmZmVycyA9IFtdO1xuXHRcdHZhciBsYXN0X2luZGV4ID0gMDtcblx0XHR2YXIgZmFjZW1hcCA9IHt9O1xuXHRcdHZhciB2ZXJ0ZXhfcmVtYXAgPSBbXTtcblx0XHR2YXIgaW5kaWNlc0FycmF5ID0gW107XG5cdFx0dmFyIGxhc3Rfc3RhcnQgPSAwO1xuXHRcdHZhciBncm91cF9uYW1lID0gXCJcIjtcblx0XHR2YXIgbWF0ZXJpYWxfbmFtZSA9IFwiXCI7XG5cblx0XHR2YXIgdHJpcyA9IDA7IC8vdXNlZCBpbiBjYXNlIHRoZXJlIGFyZSBzZXZlcmFsIHN0cmlwc1xuXG5cdFx0Ly9mb3IgZWFjaCBidWZmZXIgKGlucHV0KSBidWlsZCB0aGUgc3RydWN0dXJlIGluZm9cblx0XHR2YXIgeG1saW5wdXRzID0geG1sbGluZXN0cmlwLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFwiKTtcblx0XHRpZiAodHJpcyA9PSAwKSAvL2ZpcnN0IGl0ZXJhdGlvbiwgY3JlYXRlIGJ1ZmZlcnNcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1saW5wdXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciB4bWxpbnB1dCA9IHhtbGlucHV0cy5pdGVtKGkpO1xuXHRcdFx0XHRpZiAoIXhtbGlucHV0LmdldEF0dHJpYnV0ZSkgY29udGludWU7XG5cdFx0XHRcdHZhciBzZW1hbnRpYyA9IHhtbGlucHV0LmdldEF0dHJpYnV0ZShcInNlbWFudGljXCIpLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHRcdHZhciBzdHJlYW1fc291cmNlID0gc291cmNlc1t4bWxpbnB1dC5nZXRBdHRyaWJ1dGUoXCJzb3VyY2VcIikuc3Vic3RyKDEpXTtcblx0XHRcdFx0dmFyIG9mZnNldCA9IHBhcnNlSW50KHhtbGlucHV0LmdldEF0dHJpYnV0ZShcIm9mZnNldFwiKSk7XG5cdFx0XHRcdHZhciBkYXRhX3NldCA9IDA7XG5cdFx0XHRcdGlmICh4bWxpbnB1dC5nZXRBdHRyaWJ1dGUoXCJzZXRcIikpIGRhdGFfc2V0ID0gcGFyc2VJbnQoeG1saW5wdXQuZ2V0QXR0cmlidXRlKFwic2V0XCIpKTtcblxuXHRcdFx0XHRidWZmZXJzLnB1c2goW3NlbWFudGljLCBbXSwgc3RyZWFtX3NvdXJjZS5zdHJpZGUsIHN0cmVhbV9zb3VyY2UuZGF0YSwgb2Zmc2V0LCBkYXRhX3NldF0pO1xuXHRcdFx0fVxuXHRcdC8vYXNzdW1pbmcgYnVmZmVycyBhcmUgb3JkZXJlZCBieSBvZmZzZXRcblxuXHRcdC8vaXRlcmF0ZSBkYXRhXG5cdFx0dmFyIHhtbHBzID0geG1sbGluZXN0cmlwLnF1ZXJ5U2VsZWN0b3JBbGwoXCJwXCIpO1xuXHRcdHZhciBudW1fZGF0YV92ZXJ0ZXggPSBidWZmZXJzLmxlbmd0aDsgLy9vbmUgdmFsdWUgcGVyIGlucHV0IGJ1ZmZlclxuXG5cdFx0Ly9mb3IgZXZlcnkgcG9seWdvbiAoY291bGQgYmUgb25lIHdpdGggYWxsIHRoZSBpbmRpY2VzLCBjb3VsZCBiZSBzZXZlcmFsLCBkZXBlbmRzIG9uIHRoZSBwcm9ncmFtKVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1scHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB4bWxwID0geG1scHMuaXRlbShpKTtcblx0XHRcdGlmICgheG1scCB8fCAheG1scC50ZXh0Q29udGVudCkgYnJlYWs7XG5cblx0XHRcdHZhciBkYXRhID0geG1scC50ZXh0Q29udGVudC50cmltKCkuc3BsaXQoXCIgXCIpO1xuXG5cdFx0XHQvL3VzZWQgZm9yIHRyaWFuZ3VsYXRlIHBvbHlzXG5cdFx0XHR2YXIgZmlyc3RfaW5kZXggPSAtMTtcblx0XHRcdHZhciBjdXJyZW50X2luZGV4ID0gLTE7XG5cdFx0XHR2YXIgcHJldl9pbmRleCA9IC0xO1xuXG5cdFx0XHQvL2lmKHVzZV9pbmRpY2VzICYmIGxhc3RfaW5kZXggPj0gMjU2KjI1Nilcblx0XHRcdC8vXHRicmVhaztcblxuXHRcdFx0Ly9mb3IgZXZlcnkgcGFjayBvZiBpbmRpY2VzIGluIHRoZSBwb2x5Z29uICh2ZXJ0ZXgsIG5vcm1hbCwgdXYsIC4uLiApXG5cdFx0XHRmb3IgKHZhciBrID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBrIDwgbDsgayArPSBudW1fZGF0YV92ZXJ0ZXgpIHtcblx0XHRcdFx0dmFyIHZlcnRleF9pZCA9IGRhdGEuc2xpY2UoaywgayArIG51bV9kYXRhX3ZlcnRleCkuam9pbihcIiBcIik7IC8vZ2VuZXJhdGUgdW5pcXVlIGlkXG5cblx0XHRcdFx0cHJldl9pbmRleCA9IGN1cnJlbnRfaW5kZXg7XG5cdFx0XHRcdGlmIChmYWNlbWFwLmhhc093blByb3BlcnR5KHZlcnRleF9pZCkpIC8vYWRkIHRvIGFycmF5cywga2VlcCB0aGUgaW5kZXhcblx0XHRcdFx0XHRjdXJyZW50X2luZGV4ID0gZmFjZW1hcFt2ZXJ0ZXhfaWRdO2Vsc2Uge1xuXHRcdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgYnVmZmVycy5sZW5ndGg7ICsraikge1xuXHRcdFx0XHRcdFx0dmFyIGJ1ZmZlciA9IGJ1ZmZlcnNbal07XG5cdFx0XHRcdFx0XHR2YXIgaW5kZXggPSBwYXJzZUludChkYXRhW2sgKyBqXSk7XG5cdFx0XHRcdFx0XHR2YXIgYXJyYXkgPSBidWZmZXJbMV07IC8vYXJyYXkgd2l0aCBhbGwgdGhlIGRhdGFcblx0XHRcdFx0XHRcdHZhciBzb3VyY2UgPSBidWZmZXJbM107IC8vd2hlcmUgdG8gcmVhZCB0aGUgZGF0YSBmcm9tXG5cdFx0XHRcdFx0XHRpZiAoaiA9PSAwKSB2ZXJ0ZXhfcmVtYXBbYXJyYXkubGVuZ3RoIC8gbnVtX2RhdGFfdmVydGV4XSA9IGluZGV4O1xuXHRcdFx0XHRcdFx0aW5kZXggKj0gYnVmZmVyWzJdOyAvL3N0cmlkZVxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgeCA9IDA7IHggPCBidWZmZXJbMl07ICsreCkge1xuXHRcdFx0XHRcdFx0XHRhcnJheS5wdXNoKHNvdXJjZVtpbmRleCArIHhdKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjdXJyZW50X2luZGV4ID0gbGFzdF9pbmRleDtcblx0XHRcdFx0XHRsYXN0X2luZGV4ICs9IDE7XG5cdFx0XHRcdFx0ZmFjZW1hcFt2ZXJ0ZXhfaWRdID0gY3VycmVudF9pbmRleDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGluZGljZXNBcnJheS5wdXNoKGN1cnJlbnRfaW5kZXgpO1xuXHRcdFx0fSAvL3BlciB2ZXJ0ZXhcblx0XHR9IC8vcGVyIHBvbHlnb25cblxuXHRcdHZhciBtZXNoID0ge1xuXHRcdFx0cHJpbWl0aXZlOiBcImxpbmVfc3RyaXBcIixcblx0XHRcdHZlcnRpY2VzOiBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcnNbMF1bMV0pLFxuXHRcdFx0aW5mbzoge31cblx0XHR9O1xuXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtTWVzaEluZm8obWVzaCwgYnVmZmVycywgaW5kaWNlc0FycmF5KTtcblx0fSxcblxuXHQvL2xpa2UgcXVlcnlTZWxlY3RvciBidXQgYWxsb3dzIHNwYWNlcyBpbiBuYW1lcyBiZWNhdXNlIENPTExBREEgYWxsb3dzIHNwYWNlIGluIG5hbWVzXG5cdGZpbmRYTUxOb2RlQnlJZDogZnVuY3Rpb24gZmluZFhNTE5vZGVCeUlkKHJvb3QsIG5vZGVuYW1lLCBpZCkge1xuXHRcdC8vcHJlY29tcHV0ZWRcblx0XHRpZiAodGhpcy5feG1scm9vdC5fbm9kZXNfYnlfaWQpIHtcblx0XHRcdHZhciBuID0gdGhpcy5feG1scm9vdC5fbm9kZXNfYnlfaWRbaWRdO1xuXHRcdFx0aWYgKG4gJiYgbi5sb2NhbE5hbWUgPT0gbm9kZW5hbWUpIHJldHVybiBuO1xuXHRcdH0gZWxzZSAvL2ZvciB0aGUgbmF0aXZlIHBhcnNlclxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgbiA9IHRoaXMuX3htbHJvb3QuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuXHRcdFx0XHRpZiAobikgcmV0dXJuIG47XG5cdFx0XHR9XG5cblx0XHQvL3JlY3Vyc2l2ZTogc2xvd1xuXHRcdHZhciBjaGlsZHMgPSByb290LmNoaWxkTm9kZXM7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdHZhciB4bWxub2RlID0gY2hpbGRzLml0ZW0oaSk7XG5cdFx0XHRpZiAoeG1sbm9kZS5ub2RlVHlwZSAhPSAxKSAvL25vIHRhZ1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdGlmICh4bWxub2RlLmxvY2FsTmFtZSAhPSBub2RlbmFtZSkgY29udGludWU7XG5cdFx0XHR2YXIgbm9kZV9pZCA9IHhtbG5vZGUuZ2V0QXR0cmlidXRlKFwiaWRcIik7XG5cdFx0XHRpZiAobm9kZV9pZCA9PSBpZCkgcmV0dXJuIHhtbG5vZGU7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdHJlYWRJbWFnZXM6IGZ1bmN0aW9uIHJlYWRJbWFnZXMocm9vdCkge1xuXHRcdHZhciB4bWxpbWFnZXMgPSByb290LnF1ZXJ5U2VsZWN0b3IoXCJsaWJyYXJ5X2ltYWdlc1wiKTtcblx0XHRpZiAoIXhtbGltYWdlcykgcmV0dXJuIG51bGw7XG5cblx0XHR2YXIgaW1hZ2VzID0ge307XG5cblx0XHR2YXIgeG1saW1hZ2VzX2NoaWxkcyA9IHhtbGltYWdlcy5jaGlsZE5vZGVzO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1saW1hZ2VzX2NoaWxkcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0dmFyIHhtbGltYWdlID0geG1saW1hZ2VzX2NoaWxkcy5pdGVtKGkpO1xuXHRcdFx0aWYgKHhtbGltYWdlLm5vZGVUeXBlICE9IDEpIC8vbm8gdGFnXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgeG1saW5pdGZyb20gPSB4bWxpbWFnZS5xdWVyeVNlbGVjdG9yKFwiaW5pdF9mcm9tXCIpO1xuXHRcdFx0aWYgKCF4bWxpbml0ZnJvbSkgY29udGludWU7XG5cdFx0XHRpZiAoeG1saW5pdGZyb20udGV4dENvbnRlbnQpIHtcblx0XHRcdFx0dmFyIGZpbGVuYW1lID0gdGhpcy5nZXRGaWxlbmFtZSh4bWxpbml0ZnJvbS50ZXh0Q29udGVudCk7XG5cdFx0XHRcdHZhciBpZCA9IHhtbGltYWdlLmdldEF0dHJpYnV0ZShcImlkXCIpO1xuXHRcdFx0XHRpbWFnZXNbaWRdID0geyBmaWxlbmFtZTogZmlsZW5hbWUsIG1hcDogaWQsIG5hbWU6IHhtbGltYWdlLmdldEF0dHJpYnV0ZShcIm5hbWVcIiksIHBhdGg6IHhtbGluaXRmcm9tLnRleHRDb250ZW50IH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGltYWdlcztcblx0fSxcblxuXHRyZWFkQW5pbWF0aW9uczogZnVuY3Rpb24gcmVhZEFuaW1hdGlvbnMocm9vdCwgc2NlbmUpIHtcblx0XHR2YXIgeG1sYW5pbWF0aW9ucyA9IHJvb3QucXVlcnlTZWxlY3RvcihcImxpYnJhcnlfYW5pbWF0aW9uc1wiKTtcblx0XHRpZiAoIXhtbGFuaW1hdGlvbnMpIHJldHVybiBudWxsO1xuXG5cdFx0dmFyIHhtbGFuaW1hdGlvbl9jaGlsZHMgPSB4bWxhbmltYXRpb25zLmNoaWxkTm9kZXM7XG5cblx0XHR2YXIgYW5pbWF0aW9ucyA9IHtcblx0XHRcdG9iamVjdF90eXBlOiBcIkFuaW1hdGlvblwiLFxuXHRcdFx0dGFrZXM6IHt9XG5cdFx0fTtcblxuXHRcdHZhciBkZWZhdWx0X3Rha2UgPSB7IHRyYWNrczogW10gfTtcblx0XHR2YXIgdHJhY2tzID0gZGVmYXVsdF90YWtlLnRyYWNrcztcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1sYW5pbWF0aW9uX2NoaWxkcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0dmFyIHhtbGFuaW1hdGlvbiA9IHhtbGFuaW1hdGlvbl9jaGlsZHMuaXRlbShpKTtcblx0XHRcdGlmICh4bWxhbmltYXRpb24ubm9kZVR5cGUgIT0gMSB8fCB4bWxhbmltYXRpb24ubG9jYWxOYW1lICE9IFwiYW5pbWF0aW9uXCIpIC8vbm8gdGFnXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYW5pbV9pZCA9IHhtbGFuaW1hdGlvbi5nZXRBdHRyaWJ1dGUoXCJpZFwiKTtcblx0XHRcdGlmICghYW5pbV9pZCkgLy9uZXN0ZWQgYW5pbWF0aW9uIChEQUUgMS41KVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dmFyIHhtbGFuaW1hdGlvbjJfY2hpbGRzID0geG1sYW5pbWF0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoXCJhbmltYXRpb25cIik7XG5cdFx0XHRcdFx0aWYgKHhtbGFuaW1hdGlvbjJfY2hpbGRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCB4bWxhbmltYXRpb24yX2NoaWxkcy5sZW5ndGg7ICsraikge1xuXHRcdFx0XHRcdFx0XHR2YXIgeG1sYW5pbWF0aW9uMiA9IHhtbGFuaW1hdGlvbjJfY2hpbGRzLml0ZW0oaik7XG5cdFx0XHRcdFx0XHRcdHRoaXMucmVhZEFuaW1hdGlvbih4bWxhbmltYXRpb24yLCB0cmFja3MpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSAvL3NvdXJjZSB0cmFja3M/XG5cdFx0XHRcdFx0XHR0aGlzLnJlYWRBbmltYXRpb24oeG1sYW5pbWF0aW9uLCB0cmFja3MpO1xuXHRcdFx0XHR9IGVsc2UgLy9ubyBuZXN0ZWQgKERBRSAxLjQpXG5cdFx0XHRcdHRoaXMucmVhZEFuaW1hdGlvbih4bWxhbmltYXRpb24sIHRyYWNrcyk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0cmFja3MubGVuZ3RoKSByZXR1cm4gbnVsbDsgLy9lbXB0eSBhbmltYXRpb25cblxuXHRcdC8vY29tcHV0ZSBhbmltYXRpb24gZHVyYXRpb25cblx0XHR2YXIgbWF4X3RpbWUgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRpZiAobWF4X3RpbWUgPCB0cmFja3NbaV0uZHVyYXRpb24pIG1heF90aW1lID0gdHJhY2tzW2ldLmR1cmF0aW9uO1xuXHRcdH1kZWZhdWx0X3Rha2UubmFtZSA9IFwiZGVmYXVsdFwiO1xuXHRcdGRlZmF1bHRfdGFrZS5kdXJhdGlvbiA9IG1heF90aW1lO1xuXHRcdGFuaW1hdGlvbnMudGFrZXNbZGVmYXVsdF90YWtlLm5hbWVdID0gZGVmYXVsdF90YWtlO1xuXHRcdHJldHVybiBhbmltYXRpb25zO1xuXHR9LFxuXG5cdC8vYW5pbWF0aW9uIHhtbFxuXHRyZWFkQW5pbWF0aW9uOiBmdW5jdGlvbiByZWFkQW5pbWF0aW9uKHhtbGFuaW1hdGlvbiwgcmVzdWx0KSB7XG5cdFx0aWYgKHhtbGFuaW1hdGlvbi5sb2NhbE5hbWUgIT0gXCJhbmltYXRpb25cIikgcmV0dXJuIG51bGw7XG5cblx0XHQvL3RoaXMgY291bGQgYmUgbWlzc2luZyB3aGVuIHRoZXJlIGFyZSBsb3RzIG9mIGFuaW1zIHBhY2tlZCBpbiBvbmUgPGFuaW1hdGlvbj5cblx0XHR2YXIgYW5pbV9pZCA9IHhtbGFuaW1hdGlvbi5nZXRBdHRyaWJ1dGUoXCJpZFwiKTtcblxuXHRcdC8vY2hhbm5lbHMgYXJlIGxpa2UgYW5pbWF0ZWQgcHJvcGVydGllc1xuXHRcdHZhciB4bWxjaGFubmVsX2xpc3QgPSB4bWxhbmltYXRpb24ucXVlcnlTZWxlY3RvckFsbChcImNoYW5uZWxcIik7XG5cdFx0aWYgKCF4bWxjaGFubmVsX2xpc3QubGVuZ3RoKSByZXR1cm4gbnVsbDtcblxuXHRcdHZhciB0cmFja3MgPSByZXN1bHQgfHwgW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbGNoYW5uZWxfbGlzdC5sZW5ndGg7ICsraSkge1xuXHRcdFx0dmFyIGFuaW0gPSB0aGlzLnJlYWRDaGFubmVsKHhtbGNoYW5uZWxfbGlzdC5pdGVtKGkpLCB4bWxhbmltYXRpb24pO1xuXHRcdFx0aWYgKGFuaW0pIHRyYWNrcy5wdXNoKGFuaW0pO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cmFja3M7XG5cdH0sXG5cblx0cmVhZENoYW5uZWw6IGZ1bmN0aW9uIHJlYWRDaGFubmVsKHhtbGNoYW5uZWwsIHhtbGFuaW1hdGlvbikge1xuXHRcdGlmICh4bWxjaGFubmVsLmxvY2FsTmFtZSAhPSBcImNoYW5uZWxcIiB8fCB4bWxhbmltYXRpb24ubG9jYWxOYW1lICE9IFwiYW5pbWF0aW9uXCIpIHJldHVybiBudWxsO1xuXG5cdFx0dmFyIHNvdXJjZSA9IHhtbGNoYW5uZWwuZ2V0QXR0cmlidXRlKFwic291cmNlXCIpO1xuXHRcdHZhciB0YXJnZXQgPSB4bWxjaGFubmVsLmdldEF0dHJpYnV0ZShcInRhcmdldFwiKTtcblxuXHRcdC8vc2FtcGxlciwgaXMgaW4gY2hhcmdlIG9mIHRoZSBpbnRlcnBvbGF0aW9uXG5cdFx0Ly92YXIgeG1sc2FtcGxlciA9IHhtbGFuaW1hdGlvbi5xdWVyeVNlbGVjdG9yKFwic2FtcGxlclwiICsgc291cmNlKTtcblx0XHR2YXIgeG1sc2FtcGxlciA9IHRoaXMuZmluZFhNTE5vZGVCeUlkKHhtbGFuaW1hdGlvbiwgXCJzYW1wbGVyXCIsIHNvdXJjZS5zdWJzdHIoMSkpO1xuXHRcdGlmICgheG1sc2FtcGxlcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcIkVycm9yIERBRTogU2FtcGxlciBub3QgZm91bmQgaW4gXCIgKyBzb3VyY2UpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0dmFyIGlucHV0cyA9IHt9O1xuXHRcdHZhciBwYXJhbXMgPSB7fTtcblx0XHR2YXIgc291cmNlcyA9IHt9O1xuXHRcdHZhciB4bWxpbnB1dHMgPSB4bWxzYW1wbGVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFwiKTtcblxuXHRcdHZhciB0aW1lX2RhdGEgPSBudWxsO1xuXG5cdFx0Ly9pdGVyYXRlIGlucHV0czogY29sbGFkYSBzZXBhcmF0ZXMgdGhlIGtleWZyYW1lIGluZm8gaW4gaW5kZXBlbmRlbnQgc3RyZWFtcywgbGlrZSB0aW1lLCBpbnRlcnBvbGF0aW9uIG1ldGhvZCwgdmFsdWUgKVxuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgeG1saW5wdXRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHR2YXIgeG1saW5wdXQgPSB4bWxpbnB1dHMuaXRlbShqKTtcblx0XHRcdHZhciBzb3VyY2VfbmFtZSA9IHhtbGlucHV0LmdldEF0dHJpYnV0ZShcInNvdXJjZVwiKTtcblxuXHRcdFx0Ly90aGVyZSBhcmUgdGhyZWUgXG5cdFx0XHR2YXIgc2VtYW50aWMgPSB4bWxpbnB1dC5nZXRBdHRyaWJ1dGUoXCJzZW1hbnRpY1wiKTtcblxuXHRcdFx0Ly9TZWFyY2ggZm9yIHNvdXJjZVxuXHRcdFx0dmFyIHhtbHNvdXJjZSA9IHRoaXMuZmluZFhNTE5vZGVCeUlkKHhtbGFuaW1hdGlvbiwgXCJzb3VyY2VcIiwgc291cmNlX25hbWUuc3Vic3RyKDEpKTtcblx0XHRcdGlmICgheG1sc291cmNlKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIHhtbHBhcmFtID0geG1sc291cmNlLnF1ZXJ5U2VsZWN0b3IoXCJwYXJhbVwiKTtcblx0XHRcdGlmICgheG1scGFyYW0pIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgdHlwZSA9IHhtbHBhcmFtLmdldEF0dHJpYnV0ZShcInR5cGVcIik7XG5cdFx0XHRpbnB1dHNbc2VtYW50aWNdID0geyBzb3VyY2U6IHNvdXJjZV9uYW1lLCB0eXBlOiB0eXBlIH07XG5cblx0XHRcdHZhciBkYXRhX2FycmF5ID0gbnVsbDtcblxuXHRcdFx0aWYgKHR5cGUgPT0gXCJmbG9hdFwiIHx8IHR5cGUgPT0gXCJmbG9hdDR4NFwiKSB7XG5cdFx0XHRcdHZhciB4bWxmbG9hdGFycmF5ID0geG1sc291cmNlLnF1ZXJ5U2VsZWN0b3IoXCJmbG9hdF9hcnJheVwiKTtcblx0XHRcdFx0dmFyIGZsb2F0cyA9IHRoaXMucmVhZENvbnRlbnRBc0Zsb2F0cyh4bWxmbG9hdGFycmF5KTtcblx0XHRcdFx0c291cmNlc1tzb3VyY2VfbmFtZV0gPSBmbG9hdHM7XG5cdFx0XHRcdGRhdGFfYXJyYXkgPSBmbG9hdHM7XG5cdFx0XHR9IGVsc2UgLy9vbmx5IGZsb2F0cyBhbmQgbWF0cmljZXMgYXJlIHN1cHBvcnRlZCBpbiBhbmltYXRpb25cblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdHZhciBwYXJhbV9uYW1lID0geG1scGFyYW0uZ2V0QXR0cmlidXRlKFwibmFtZVwiKTtcblx0XHRcdGlmIChwYXJhbV9uYW1lID09IFwiVElNRVwiKSB0aW1lX2RhdGEgPSBkYXRhX2FycmF5O1xuXHRcdFx0aWYgKHNlbWFudGljID09IFwiT1VUUFVUXCIpIHBhcmFtX25hbWUgPSBzZW1hbnRpYztcblx0XHRcdGlmIChwYXJhbV9uYW1lKSBwYXJhbXNbcGFyYW1fbmFtZV0gPSB0eXBlO2Vsc2UgY29uc29sZS53YXJuKFwiQ29sbGFkYTogPHBhcmFtPiB3aXRob3V0IG5hbWUgYXR0cmlidXRlIGluIDxhbmltYXRpb24+XCIpO1xuXHRcdH1cblxuXHRcdGlmICghdGltZV9kYXRhKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKFwiRXJyb3IgREFFOiBubyBUSU1FIGluZm8gZm91bmQgaW4gPGNoYW5uZWw+OiBcIiArIHhtbGNoYW5uZWwuZ2V0QXR0cmlidXRlKFwic291cmNlXCIpKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdC8vY29uc3RydWN0IGFuaW1hdGlvblxuXHRcdHZhciBwYXRoID0gdGFyZ2V0LnNwbGl0KFwiL1wiKTtcblxuXHRcdHZhciBhbmltID0ge307XG5cdFx0dmFyIG5vZGVuYW1lID0gcGF0aFswXTsgLy9zYWZlU3RyaW5nID9cblx0XHR2YXIgbm9kZSA9IHRoaXMuX25vZGVzX2J5X2lkW25vZGVuYW1lXTtcblx0XHR2YXIgbG9jYXRvciA9IG5vZGUuaWQgKyBcIi9cIiArIHBhdGhbMV07XG5cdFx0Ly9hbmltLm5vZGVuYW1lID0gdGhpcy5zYWZlU3RyaW5nKCBwYXRoWzBdICk7IC8vd2hlcmUgaXQgZ29lc1xuXHRcdGFuaW0ubmFtZSA9IHBhdGhbMV07XG5cdFx0YW5pbS5wcm9wZXJ0eSA9IGxvY2F0b3I7XG5cdFx0dmFyIHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdHZhciBlbGVtZW50X3NpemUgPSAxO1xuXHRcdHZhciBwYXJhbV90eXBlID0gcGFyYW1zW1wiT1VUUFVUXCJdO1xuXHRcdHN3aXRjaCAocGFyYW1fdHlwZSkge1xuXHRcdFx0Y2FzZSBcImZsb2F0XCI6XG5cdFx0XHRcdGVsZW1lbnRfc2l6ZSA9IDE7YnJlYWs7XG5cdFx0XHRjYXNlIFwiZmxvYXQzeDNcIjpcblx0XHRcdFx0ZWxlbWVudF9zaXplID0gOTt0eXBlID0gXCJtYXQzXCI7YnJlYWs7XG5cdFx0XHRjYXNlIFwiZmxvYXQ0eDRcIjpcblx0XHRcdFx0ZWxlbWVudF9zaXplID0gMTY7dHlwZSA9IFwibWF0NFwiO2JyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0YW5pbS50eXBlID0gdHlwZTtcblx0XHRhbmltLnZhbHVlX3NpemUgPSBlbGVtZW50X3NpemU7XG5cdFx0YW5pbS5kdXJhdGlvbiA9IHRpbWVfZGF0YVt0aW1lX2RhdGEubGVuZ3RoIC0gMV07IC8vbGFzdCBzYW1wbGVcblxuXHRcdHZhciB2YWx1ZV9kYXRhID0gc291cmNlc1tpbnB1dHNbXCJPVVRQVVRcIl0uc291cmNlXTtcblx0XHRpZiAoIXZhbHVlX2RhdGEpIHJldHVybiBudWxsO1xuXG5cdFx0Ly9QYWNrIGRhdGEgKioqKioqKioqKioqKioqKlxuXHRcdHZhciBudW1fc2FtcGxlcyA9IHRpbWVfZGF0YS5sZW5ndGg7XG5cdFx0dmFyIHNhbXBsZV9zaXplID0gZWxlbWVudF9zaXplICsgMTtcblx0XHR2YXIgYW5pbV9kYXRhID0gbmV3IEZsb2F0MzJBcnJheShudW1fc2FtcGxlcyAqIHNhbXBsZV9zaXplKTtcblx0XHQvL2ZvciBldmVyeSBzYW1wbGVcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHRpbWVfZGF0YS5sZW5ndGg7ICsraikge1xuXHRcdFx0YW5pbV9kYXRhW2ogKiBzYW1wbGVfc2l6ZV0gPSB0aW1lX2RhdGFbal07IC8vc2V0IHRpbWVcblx0XHRcdHZhciB2YWx1ZSA9IHZhbHVlX2RhdGEuc3ViYXJyYXkoaiAqIGVsZW1lbnRfc2l6ZSwgKGogKyAxKSAqIGVsZW1lbnRfc2l6ZSk7XG5cdFx0XHRpZiAocGFyYW1fdHlwZSA9PSBcImZsb2F0NHg0XCIpIHtcblx0XHRcdFx0dGhpcy50cmFuc2Zvcm1NYXRyaXgodmFsdWUsIG5vZGUgPyBub2RlLl9kZXB0aCA9PSAwIDogMCk7XG5cdFx0XHRcdC8vbWF0NC50cmFuc3Bvc2UodmFsdWUsIHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdGFuaW1fZGF0YS5zZXQodmFsdWUsIGogKiBzYW1wbGVfc2l6ZSArIDEpOyAvL3NldCBkYXRhXG5cdFx0fVxuXG5cdFx0aWYgKGlzV29ya2VyICYmIHRoaXMudXNlX3RyYW5zZmVyYWJsZXMpIHtcblx0XHRcdHZhciBkYXRhID0gYW5pbV9kYXRhO1xuXHRcdFx0aWYgKGRhdGEgJiYgZGF0YS5idWZmZXIgJiYgZGF0YS5sZW5ndGggPiAxMDApIHRoaXMuX3RyYW5zZmVyYWJsZXMucHVzaChkYXRhLmJ1ZmZlcik7XG5cdFx0fVxuXG5cdFx0YW5pbS5kYXRhID0gYW5pbV9kYXRhO1xuXHRcdHJldHVybiBhbmltO1xuXHR9LFxuXG5cdGZpbmROb2RlOiBmdW5jdGlvbiBmaW5kTm9kZShyb290LCBpZCkge1xuXHRcdGlmIChyb290LmlkID09IGlkKSByZXR1cm4gcm9vdDtcblx0XHRpZiAocm9vdC5jaGlsZHJlbikgZm9yICh2YXIgaSBpbiByb290LmNoaWxkcmVuKSB7XG5cdFx0XHR2YXIgcmV0ID0gdGhpcy5maW5kTm9kZShyb290LmNoaWxkcmVuW2ldLCBpZCk7XG5cdFx0XHRpZiAocmV0KSByZXR1cm4gcmV0O1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHQvL3JlYWRzIGNvbnRyb2xsZXJzIGFuZCBzdG9yZXMgdGhlbSBpbiBcblx0cmVhZExpYnJhcnlDb250cm9sbGVyczogZnVuY3Rpb24gcmVhZExpYnJhcnlDb250cm9sbGVycyhzY2VuZSkge1xuXHRcdHZhciB4bWxsaWJyYXJ5Y29udHJvbGxlcnMgPSB0aGlzLl94bWxyb290LnF1ZXJ5U2VsZWN0b3IoXCJsaWJyYXJ5X2NvbnRyb2xsZXJzXCIpO1xuXHRcdGlmICgheG1sbGlicmFyeWNvbnRyb2xsZXJzKSByZXR1cm4gbnVsbDtcblxuXHRcdHZhciB4bWxsaWJyYXJ5Y29udHJvbGxlcnNfY2hpbGRzID0geG1sbGlicmFyeWNvbnRyb2xsZXJzLmNoaWxkTm9kZXM7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbGxpYnJhcnljb250cm9sbGVyc19jaGlsZHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdHZhciB4bWxjb250cm9sbGVyID0geG1sbGlicmFyeWNvbnRyb2xsZXJzX2NoaWxkcy5pdGVtKGkpO1xuXHRcdFx0aWYgKHhtbGNvbnRyb2xsZXIubm9kZVR5cGUgIT0gMSB8fCB4bWxjb250cm9sbGVyLmxvY2FsTmFtZSAhPSBcImNvbnRyb2xsZXJcIikgLy9ubyB0YWdcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR2YXIgaWQgPSB4bWxjb250cm9sbGVyLmdldEF0dHJpYnV0ZShcImlkXCIpO1xuXHRcdFx0Ly93ZSBoYXZlIGFscmVhZHkgcHJvY2Vzc2VkIHRoaXMgY29udHJvbGxlclxuXHRcdFx0aWYgKHRoaXMuX2NvbnRyb2xsZXJzX2ZvdW5kW2lkXSkgY29udGludWU7XG5cblx0XHRcdC8vcmVhZCBpdCAod2Ugd29udCB1c2UgdGhlIHJldHVybnMsIHdlIHdpbGwgZ2V0IGl0IGZyb20gdGhpcy5fY29udHJvbGxlcnNfZm91bmRcblx0XHRcdHRoaXMucmVhZENvbnRyb2xsZXIoeG1sY29udHJvbGxlciwgbnVsbCwgc2NlbmUpO1xuXHRcdH1cblx0fSxcblxuXHQvL3VzZWQgZm9yIHNraW5uaW5nIGFuZCBtb3JwaGluZ1xuXHRyZWFkQ29udHJvbGxlcjogZnVuY3Rpb24gcmVhZENvbnRyb2xsZXIoeG1sY29udHJvbGxlciwgZmxpcCwgc2NlbmUpIHtcblx0XHRpZiAoIXhtbGNvbnRyb2xsZXIubG9jYWxOYW1lID09IFwiY29udHJvbGxlclwiKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oXCJyZWFkQ29udHJvbGxlcjogbm90IGEgY29udHJvbGxlcjogXCIgKyB4bWxjb250cm9sbGVyLmxvY2FsTmFtZSk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHR2YXIgaWQgPSB4bWxjb250cm9sbGVyLmdldEF0dHJpYnV0ZShcImlkXCIpO1xuXHRcdC8vdXNlIGNhY2hlZFxuXHRcdGlmICh0aGlzLl9jb250cm9sbGVyc19mb3VuZFtpZF0pIHJldHVybiB0aGlzLl9jb250cm9sbGVyc19mb3VuZFtpZF07XG5cblx0XHQvL0FHVUlMQVxuXHRcdC8vVE9ETzogZG9lcyB0aGlzIHdvcms/XG5cdFx0Ly8gaWYgKHRoaXMuX2NvbnRyb2xsZXJzX2ZvdW5kWyBpZCBdKVxuXHRcdC8vIFx0cmV0dXJuIHRoaXMuX2NvbnRyb2xsZXJzX2ZvdW5kWyBpZCBdO1xuXG5cdFx0dmFyIHVzZV9pbmRpY2VzID0gZmFsc2U7XG5cdFx0dmFyIG1lc2ggPSBudWxsO1xuXHRcdHZhciB4bWxza2luID0geG1sY29udHJvbGxlci5xdWVyeVNlbGVjdG9yKFwic2tpblwiKTtcblx0XHRpZiAoeG1sc2tpbikge1xuXHRcdFx0bWVzaCA9IHRoaXMucmVhZFNraW5Db250cm9sbGVyKHhtbHNraW4sIGZsaXAsIHNjZW5lKTtcblx0XHR9XG5cblx0XHR2YXIgeG1sbW9ycGggPSB4bWxjb250cm9sbGVyLnF1ZXJ5U2VsZWN0b3IoXCJtb3JwaFwiKTtcblx0XHRpZiAoeG1sbW9ycGgpIG1lc2ggPSB0aGlzLnJlYWRNb3JwaENvbnRyb2xsZXIoeG1sbW9ycGgsIGZsaXAsIHNjZW5lLCBtZXNoKTtcblxuXHRcdC8vY2FjaGUgYW5kIHJldHVyblxuXHRcdGlmICh0aGlzLl9jb250cm9sbGVyc19mb3VuZFtpZF0pIHtcblx0XHRcdGlkICs9IFwiXzFibGFoXCI7IC8vPz8/IHRoaXMgZG9lc250IGRvIGFueXRoaW5nXG5cdFx0fSBlbHNlIHRoaXMuX2NvbnRyb2xsZXJzX2ZvdW5kW2lkXSA9IG1lc2g7XG5cblx0XHRyZXR1cm4gbWVzaDtcblx0fSxcblxuXHQvL3JlYWQgdGhpcyB0byBtb3JlIGluZm8gYWJvdXQgREFFIGFuZCBza2lubmluZyBodHRwczovL2NvbGxhZGEub3JnL21lZGlhd2lraS9pbmRleC5waHAvU2tpbm5pbmdcblx0cmVhZFNraW5Db250cm9sbGVyOiBmdW5jdGlvbiByZWFkU2tpbkNvbnRyb2xsZXIoeG1sc2tpbiwgZmxpcCwgc2NlbmUpIHtcblx0XHQvL2Jhc2UgZ2VvbWV0cnlcblx0XHR2YXIgaWRfZ2VvbWV0cnkgPSB4bWxza2luLmdldEF0dHJpYnV0ZShcInNvdXJjZVwiKTtcblxuXHRcdHZhciBtZXNoID0gdGhpcy5yZWFkR2VvbWV0cnkoaWRfZ2VvbWV0cnksIGZsaXAsIHNjZW5lKTtcblx0XHRpZiAoIW1lc2gpIHJldHVybiBudWxsO1xuXG5cdFx0dmFyIHNvdXJjZXMgPSB0aGlzLnJlYWRTb3VyY2VzKHhtbHNraW4sIGZsaXApO1xuXHRcdGlmICghc291cmNlcykgcmV0dXJuIG51bGw7XG5cblx0XHQvL21hdHJpeFxuXHRcdHZhciBiaW5kX21hdHJpeCA9IG51bGw7XG5cdFx0dmFyIHhtbGJpbmRtYXRyaXggPSB4bWxza2luLnF1ZXJ5U2VsZWN0b3IoXCJiaW5kX3NoYXBlX21hdHJpeFwiKTtcblx0XHRpZiAoeG1sYmluZG1hdHJpeCkge1xuXHRcdFx0YmluZF9tYXRyaXggPSB0aGlzLnJlYWRDb250ZW50QXNGbG9hdHMoeG1sYmluZG1hdHJpeCk7XG5cdFx0XHR0aGlzLnRyYW5zZm9ybU1hdHJpeChiaW5kX21hdHJpeCwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0fSBlbHNlIGJpbmRfbWF0cml4ID0gX2dsTWF0cml4Lm1hdDQuY3JlYXRlKCk7IC8vaWRlbnRpdHlcblxuXHRcdC8vam9pbnRzXG5cdFx0dmFyIGpvaW50cyA9IFtdO1xuXHRcdHZhciB4bWxqb2ludHMgPSB4bWxza2luLnF1ZXJ5U2VsZWN0b3IoXCJqb2ludHNcIik7XG5cdFx0aWYgKHhtbGpvaW50cykge1xuXHRcdFx0dmFyIGpvaW50c19zb3VyY2UgPSBudWxsOyAvL3doaWNoIGJvbmVzXG5cdFx0XHR2YXIgaW52X2JpbmRfc291cmNlID0gbnVsbDsgLy9iaW5kIG1hdHJpY2VzXG5cdFx0XHR2YXIgeG1saW5wdXRzID0geG1sam9pbnRzLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFwiKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1saW5wdXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciB4bWxpbnB1dCA9IHhtbGlucHV0c1tpXTtcblx0XHRcdFx0dmFyIHNlbSA9IHhtbGlucHV0LmdldEF0dHJpYnV0ZShcInNlbWFudGljXCIpLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHRcdHZhciBzcmMgPSB4bWxpbnB1dC5nZXRBdHRyaWJ1dGUoXCJzb3VyY2VcIik7XG5cdFx0XHRcdHZhciBzb3VyY2UgPSBzb3VyY2VzW3NyYy5zdWJzdHIoMSldO1xuXHRcdFx0XHRpZiAoc2VtID09IFwiSk9JTlRcIikgam9pbnRzX3NvdXJjZSA9IHNvdXJjZTtlbHNlIGlmIChzZW0gPT0gXCJJTlZfQklORF9NQVRSSVhcIikgaW52X2JpbmRfc291cmNlID0gc291cmNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvL3NhdmUgYm9uZSBuYW1lcyBhbmQgaW52IG1hdHJpeFxuXHRcdFx0aWYgKCFpbnZfYmluZF9zb3VyY2UgfHwgIWpvaW50c19zb3VyY2UpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcihcIkVycm9yIERBRTogbm8gam9pbnRzIG9yIGludl9iaW5kIHNvdXJjZXMgZm91bmRcIik7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBpIGluIGpvaW50c19zb3VyY2UpIHtcblx0XHRcdFx0Ly9nZXQgdGhlIGludmVyc2Ugb2YgdGhlIGJpbmQgcG9zZVxuXHRcdFx0XHR2YXIgaW52X21hdCA9IGludl9iaW5kX3NvdXJjZS5zdWJhcnJheShpICogMTYsIGkgKiAxNiArIDE2KTtcblx0XHRcdFx0dmFyIG5vZGVuYW1lID0gam9pbnRzX3NvdXJjZVtpXTtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLl9ub2Rlc19ieV9pZFtub2RlbmFtZV07XG5cdFx0XHRcdGlmICghbm9kZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybihcIk5vZGUgXCIgKyBub2RlbmFtZSArIFwiIG5vdCBmb3VuZFwiKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnRyYW5zZm9ybU1hdHJpeChpbnZfbWF0LCBub2RlLl9kZXB0aCA9PSAwLCB0cnVlKTtcblx0XHRcdFx0am9pbnRzLnB1c2goW25vZGVuYW1lLCBpbnZfbWF0XSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly93ZWlnaHRzXG5cdFx0dmFyIHhtbHZlcnRleHdlaWdodHMgPSB4bWxza2luLnF1ZXJ5U2VsZWN0b3IoXCJ2ZXJ0ZXhfd2VpZ2h0c1wiKTtcblx0XHRpZiAoeG1sdmVydGV4d2VpZ2h0cykge1xuXG5cdFx0XHQvL2hlcmUgd2Ugc2VlIHRoZSBvcmRlciBcblx0XHRcdHZhciB3ZWlnaHRzX2luZGV4ZWRfYXJyYXkgPSBudWxsO1xuXHRcdFx0dmFyIHhtbGlucHV0cyA9IHhtbHZlcnRleHdlaWdodHMucXVlcnlTZWxlY3RvckFsbChcImlucHV0XCIpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWxpbnB1dHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHhtbGlucHV0c1tpXS5nZXRBdHRyaWJ1dGUoXCJzZW1hbnRpY1wiKS50b1VwcGVyQ2FzZSgpID09IFwiV0VJR0hUXCIpIHdlaWdodHNfaW5kZXhlZF9hcnJheSA9IHNvdXJjZXNbeG1saW5wdXRzLml0ZW0oaSkuZ2V0QXR0cmlidXRlKFwic291cmNlXCIpLnN1YnN0cigxKV07XG5cdFx0XHR9XG5cblx0XHRcdGlmICghd2VpZ2h0c19pbmRleGVkX2FycmF5KSB0aHJvdyBcIm5vIHdlaWdodHMgZm91bmRcIjtcblxuXHRcdFx0dmFyIHhtbHZjb3VudCA9IHhtbHZlcnRleHdlaWdodHMucXVlcnlTZWxlY3RvcihcInZjb3VudFwiKTtcblx0XHRcdHZhciB2Y291bnQgPSB0aGlzLnJlYWRDb250ZW50QXNVSW50MzIoeG1sdmNvdW50KTtcblxuXHRcdFx0dmFyIHhtbHYgPSB4bWx2ZXJ0ZXh3ZWlnaHRzLnF1ZXJ5U2VsZWN0b3IoXCJ2XCIpO1xuXHRcdFx0dmFyIHYgPSB0aGlzLnJlYWRDb250ZW50QXNVSW50MzIoeG1sdik7XG5cblx0XHRcdHZhciBudW1fdmVydGljZXMgPSBtZXNoLnZlcnRpY2VzLmxlbmd0aCAvIDM7IC8vMyBjb21wb25lbnRzIHBlciB2ZXJ0ZXhcblx0XHRcdHZhciB3ZWlnaHRzX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSg0ICogbnVtX3ZlcnRpY2VzKTsgLy80IGJvbmVzIHBlciB2ZXJ0ZXhcblx0XHRcdHZhciBib25lX2luZGV4X2FycmF5ID0gbmV3IFVpbnQ4QXJyYXkoNCAqIG51bV92ZXJ0aWNlcyk7IC8vNCBib25lcyBwZXIgdmVydGV4XG5cblx0XHRcdHZhciBwb3MgPSAwO1xuXHRcdFx0dmFyIHJlbWFwID0gbWVzaC5fcmVtYXA7XG5cdFx0XHR2YXIgbWF4X2JvbmUgPSAwOyAvL21heCBib25lIGFmZmVjdGVkXG5cblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdmNvdW50Lmxlbmd0aDsgaSA8IGw7ICsraSkge1xuXHRcdFx0XHR2YXIgbnVtX2JvbmVzID0gdmNvdW50W2ldOyAvL251bSBib25lcyBpbmZsdWVuY2luZyB0aGlzIHZlcnRleFxuXG5cdFx0XHRcdC8vZmluZCA0IHdpdGggbW9yZSBpbmZsdWVuY2Vcblx0XHRcdFx0Ly92YXIgdl90dXBsZXRzID0gdi5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIG51bV9ib25lcyoyKTtcblxuXHRcdFx0XHR2YXIgb2Zmc2V0ID0gcG9zO1xuXHRcdFx0XHR2YXIgYiA9IGJvbmVfaW5kZXhfYXJyYXkuc3ViYXJyYXkoaSAqIDQsIGkgKiA0ICsgNCk7XG5cdFx0XHRcdHZhciB3ID0gd2VpZ2h0c19hcnJheS5zdWJhcnJheShpICogNCwgaSAqIDQgKyA0KTtcblxuXHRcdFx0XHR2YXIgc3VtID0gMDtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBudW1fYm9uZXMgJiYgaiA8IDQ7ICsraikge1xuXHRcdFx0XHRcdGJbal0gPSB2W29mZnNldCArIGogKiAyXTtcblx0XHRcdFx0XHRpZiAoYltqXSA+IG1heF9ib25lKSBtYXhfYm9uZSA9IGJbal07XG5cblx0XHRcdFx0XHR3W2pdID0gd2VpZ2h0c19pbmRleGVkX2FycmF5W3Zbb2Zmc2V0ICsgaiAqIDIgKyAxXV07XG5cdFx0XHRcdFx0c3VtICs9IHdbal07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL25vcm1hbGl6ZSB3ZWlnaHRzXG5cdFx0XHRcdGlmIChudW1fYm9uZXMgPiA0ICYmIHN1bSA8IDEuMCkge1xuXHRcdFx0XHRcdHZhciBpbnZfc3VtID0gMSAvIHN1bTtcblx0XHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IDQ7ICsraikge1xuXHRcdFx0XHRcdFx0d1tqXSAqPSBpbnZfc3VtO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHBvcyArPSBudW1fYm9uZXMgKiAyO1xuXHRcdFx0fVxuXG5cdFx0XHQvL3JlbWFwOiBiZWNhdXNlIHZlcnRpY2VzIG9yZGVyIGlzIG5vdyBjaGFuZ2VkIGFmdGVyIHBhcnNpbmcgdGhlIG1lc2hcblx0XHRcdHZhciBmaW5hbF93ZWlnaHRzID0gbmV3IEZsb2F0MzJBcnJheSg0ICogbnVtX3ZlcnRpY2VzKTsgLy80IGJvbmVzIHBlciB2ZXJ0ZXhcblx0XHRcdHZhciBmaW5hbF9ib25lX2luZGljZXMgPSBuZXcgVWludDhBcnJheSg0ICogbnVtX3ZlcnRpY2VzKTsgLy80IGJvbmVzIHBlciB2ZXJ0ZXhcblx0XHRcdHZhciB1c2VkX2pvaW50cyA9IFtdO1xuXG5cdFx0XHQvL2ZvciBldmVyeSB2ZXJ0ZXggaW4gdGhlIG1lc2gsIHByb2Nlc3MgYm9uZSBpbmRpY2VzIGFuZCB3ZWlnaHRzXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG51bV92ZXJ0aWNlczsgKytpKSB7XG5cdFx0XHRcdHZhciBwID0gcmVtYXBbaV0gKiA0O1xuXHRcdFx0XHR2YXIgdyA9IHdlaWdodHNfYXJyYXkuc3ViYXJyYXkocCwgcCArIDQpO1xuXHRcdFx0XHR2YXIgYiA9IGJvbmVfaW5kZXhfYXJyYXkuc3ViYXJyYXkocCwgcCArIDQpO1xuXG5cdFx0XHRcdC8vc29ydCBieSB3ZWlnaHQgc28gcmVsZXZhbnQgb25lcyBnb2VzIGZpcnN0XG5cdFx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgMzsgKytrKSB7XG5cdFx0XHRcdFx0dmFyIG1heF9wb3MgPSBrO1xuXHRcdFx0XHRcdHZhciBtYXhfdmFsdWUgPSB3W2tdO1xuXHRcdFx0XHRcdGZvciAodmFyIGogPSBrICsgMTsgaiA8IDQ7ICsraikge1xuXHRcdFx0XHRcdFx0aWYgKHdbal0gPD0gbWF4X3ZhbHVlKSBjb250aW51ZTtcblx0XHRcdFx0XHRcdG1heF9wb3MgPSBqO1xuXHRcdFx0XHRcdFx0bWF4X3ZhbHVlID0gd1tqXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG1heF9wb3MgIT0gaykge1xuXHRcdFx0XHRcdFx0dmFyIHRtcCA9IHdba107XG5cdFx0XHRcdFx0XHR3W2tdID0gd1ttYXhfcG9zXTtcblx0XHRcdFx0XHRcdHdbbWF4X3Bvc10gPSB0bXA7XG5cdFx0XHRcdFx0XHR0bXAgPSBiW2tdO1xuXHRcdFx0XHRcdFx0YltrXSA9IGJbbWF4X3Bvc107XG5cdFx0XHRcdFx0XHRiW21heF9wb3NdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vc3RvcmVcblx0XHRcdFx0ZmluYWxfd2VpZ2h0cy5zZXQodywgaSAqIDQpO1xuXHRcdFx0XHRmaW5hbF9ib25lX2luZGljZXMuc2V0KGIsIGkgKiA0KTtcblxuXHRcdFx0XHQvL21hcmsgYm9uZXMgdXNlZFxuXHRcdFx0XHRpZiAod1swXSkgdXNlZF9qb2ludHNbYlswXV0gPSB0cnVlO1xuXHRcdFx0XHRpZiAod1sxXSkgdXNlZF9qb2ludHNbYlsxXV0gPSB0cnVlO1xuXHRcdFx0XHRpZiAod1syXSkgdXNlZF9qb2ludHNbYlsyXV0gPSB0cnVlO1xuXHRcdFx0XHRpZiAod1szXSkgdXNlZF9qb2ludHNbYlszXV0gPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF4X2JvbmUgPj0gam9pbnRzLmxlbmd0aCkgY29uc29sZS53YXJuKFwiTWVzaCB1c2VzIGhpZ2hlciBib25lIGluZGV4IHRoYW4gYm9uZXMgZm91bmRcIik7XG5cblx0XHRcdC8vdHJpbSB1bnVzZWQgYm9uZXMgKGNvbGxhZGEgY291bGQgZ2l2ZSB5b3UgMTAwIGJvbmVzIGZvciBhbiBvYmplY3QgdGhhdCBvbmx5IHVzZXMgYSBmcmFjdGlvbiBvZiB0aGVtKVxuXHRcdFx0aWYgKDEpIHtcblx0XHRcdFx0dmFyIG5ld19ib25lcyA9IFtdO1xuXHRcdFx0XHR2YXIgYm9uZXNfdHJhbnNsYXRpb24gPSB7fTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB1c2VkX2pvaW50cy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdGlmICh1c2VkX2pvaW50c1tpXSkge1xuXHRcdFx0XHRcdFx0Ym9uZXNfdHJhbnNsYXRpb25baV0gPSBuZXdfYm9uZXMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0bmV3X2JvbmVzLnB1c2goam9pbnRzW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gLy9pbiBjYXNlIHRoZXJlIGFyZSBsZXNzIGJvbmVzIGluIHVzZS4uLlxuXHRcdFx0XHRpZiAobmV3X2JvbmVzLmxlbmd0aCA8IGpvaW50cy5sZW5ndGgpIHtcblx0XHRcdFx0XHQvL3JlbWFwXG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBmaW5hbF9ib25lX2luZGljZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGZpbmFsX2JvbmVfaW5kaWNlc1tpXSA9IGJvbmVzX3RyYW5zbGF0aW9uW2ZpbmFsX2JvbmVfaW5kaWNlc1tpXV07XG5cdFx0XHRcdFx0fWpvaW50cyA9IG5ld19ib25lcztcblx0XHRcdFx0fVxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKFwiQm9uZXM6IFwiLCBqb2ludHMubGVuZ3RoLCBcIiB1c2VkOlwiLCBudW1fdXNlZF9qb2ludHMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly9jb25zb2xlLmxvZyhcIkJvbmVzOiBcIiwgam9pbnRzLmxlbmd0aCwgXCJNYXggYm9uZTogXCIsIG1heF9ib25lKTtcblxuXHRcdFx0bWVzaC53ZWlnaHRzID0gZmluYWxfd2VpZ2h0cztcblx0XHRcdG1lc2guYm9uZV9pbmRpY2VzID0gZmluYWxfYm9uZV9pbmRpY2VzO1xuXHRcdFx0bWVzaC5ib25lcyA9IGpvaW50cztcblx0XHRcdG1lc2guYmluZF9tYXRyaXggPSBiaW5kX21hdHJpeDtcblxuXHRcdFx0Ly9kZWxldGUgbWVzaFtcIl9yZW1hcFwiXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWVzaDtcblx0fSxcblxuXHQvL05PVCBURVNURURcblx0cmVhZE1vcnBoQ29udHJvbGxlcjogZnVuY3Rpb24gcmVhZE1vcnBoQ29udHJvbGxlcih4bWxtb3JwaCwgZmxpcCwgc2NlbmUsIG1lc2gpIHtcblx0XHR2YXIgaWRfZ2VvbWV0cnkgPSB4bWxtb3JwaC5nZXRBdHRyaWJ1dGUoXCJzb3VyY2VcIik7XG5cdFx0dmFyIGJhc2VfbWVzaCA9IHRoaXMucmVhZEdlb21ldHJ5KGlkX2dlb21ldHJ5LCBmbGlwLCBzY2VuZSk7XG5cdFx0aWYgKCFiYXNlX21lc2gpIHJldHVybiBudWxsO1xuXG5cdFx0Ly9yZWFkIHNvdXJjZXMgd2l0aCBibGVuZCBzaGFwZXMgaW5mbyAod2hpY2ggb25lcywgYW5kIHRoZSB3ZWlnaHQpXG5cdFx0dmFyIHNvdXJjZXMgPSB0aGlzLnJlYWRTb3VyY2VzKHhtbG1vcnBoLCBmbGlwKTtcblxuXHRcdHZhciBtb3JwaHMgPSBbXTtcblxuXHRcdC8vdGFyZ2V0c1xuXHRcdHZhciB4bWx0YXJnZXRzID0geG1sbW9ycGgucXVlcnlTZWxlY3RvcihcInRhcmdldHNcIik7XG5cdFx0aWYgKCF4bWx0YXJnZXRzKSByZXR1cm4gbnVsbDtcblxuXHRcdHZhciB4bWxpbnB1dHMgPSB4bWx0YXJnZXRzLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFwiKTtcblx0XHR2YXIgdGFyZ2V0cyA9IG51bGw7XG5cdFx0dmFyIHdlaWdodHMgPSBudWxsO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWxpbnB1dHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB4bWxpbnB1dCA9IHhtbGlucHV0cy5pdGVtKGkpO1xuXHRcdFx0dmFyIHNlbWFudGljID0geG1saW5wdXQuZ2V0QXR0cmlidXRlKFwic2VtYW50aWNcIikudG9VcHBlckNhc2UoKTtcblx0XHRcdHZhciBkYXRhID0gc291cmNlc1t4bWxpbnB1dC5nZXRBdHRyaWJ1dGUoXCJzb3VyY2VcIikuc3Vic3RyKDEpXTtcblx0XHRcdGlmIChzZW1hbnRpYyA9PSBcIk1PUlBIX1RBUkdFVFwiKSB0YXJnZXRzID0gZGF0YTtlbHNlIGlmIChzZW1hbnRpYyA9PSBcIk1PUlBIX1dFSUdIVFwiKSB3ZWlnaHRzID0gZGF0YTtcblx0XHR9XG5cblx0XHRpZiAoIXRhcmdldHMgfHwgIXdlaWdodHMpIHtcblx0XHRcdGNvbnNvbGUud2FybihcIk1vcnBoIGNvbnRyb2xsZXIgd2l0aG91dCB0YXJnZXRzIG9yIHdlaWdodHMuIFNraXBwaW5nIGl0LlwiKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdC8vZ2V0IHRhcmdldHNcblx0XHRmb3IgKHZhciBpIGluIHRhcmdldHMpIHtcblx0XHRcdHZhciBpZCA9IFwiI1wiICsgdGFyZ2V0c1tpXTtcblx0XHRcdHZhciBnZW9tZXRyeSA9IHRoaXMucmVhZEdlb21ldHJ5KGlkLCBmbGlwLCBzY2VuZSk7XG5cdFx0XHRzY2VuZS5tZXNoZXNbaWRdID0gZ2VvbWV0cnk7XG5cdFx0XHRtb3JwaHMucHVzaCh7IG1lc2g6IGlkLCB3ZWlnaHQ6IHdlaWdodHNbaV0gfSk7XG5cdFx0fVxuXG5cdFx0YmFzZV9tZXNoLm1vcnBoX3RhcmdldHMgPSBtb3JwaHM7XG5cdFx0cmV0dXJuIGJhc2VfbWVzaDtcblx0fSxcblxuXHRyZWFkQmluZE1hdGVyaWFsczogZnVuY3Rpb24gcmVhZEJpbmRNYXRlcmlhbHMoeG1sYmluZF9tYXRlcmlhbCwgbWVzaCkge1xuXHRcdHZhciBtYXRlcmlhbHMgPSBbXTtcblxuXHRcdHZhciB4bWx0ZWNobmlxdWVzID0geG1sYmluZF9tYXRlcmlhbC5xdWVyeVNlbGVjdG9yQWxsKFwidGVjaG5pcXVlX2NvbW1vblwiKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbHRlY2huaXF1ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB4bWx0ZWNobmlxdWUgPSB4bWx0ZWNobmlxdWVzLml0ZW0oaSk7XG5cdFx0XHR2YXIgeG1saW5zdGFuY2VfbWF0ZXJpYWxzID0geG1sdGVjaG5pcXVlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnN0YW5jZV9tYXRlcmlhbFwiKTtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgeG1saW5zdGFuY2VfbWF0ZXJpYWxzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHZhciB4bWxpbnN0YW5jZV9tYXRlcmlhbCA9IHhtbGluc3RhbmNlX21hdGVyaWFscy5pdGVtKGopO1xuXHRcdFx0XHRpZiAoeG1saW5zdGFuY2VfbWF0ZXJpYWwpIG1hdGVyaWFscy5wdXNoKHhtbGluc3RhbmNlX21hdGVyaWFsLmdldEF0dHJpYnV0ZShcInN5bWJvbFwiKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGVyaWFscztcblx0fSxcblxuXHRyZWFkU291cmNlczogZnVuY3Rpb24gcmVhZFNvdXJjZXMoeG1sbm9kZSwgZmxpcCkge1xuXHRcdC8vZm9yIGRhdGEgc291cmNlc1xuXHRcdHZhciBzb3VyY2VzID0ge307XG5cdFx0dmFyIHhtbHNvdXJjZXMgPSB4bWxub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJzb3VyY2VcIik7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWxzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgeG1sc291cmNlID0geG1sc291cmNlcy5pdGVtKGkpO1xuXHRcdFx0aWYgKCF4bWxzb3VyY2UucXVlcnlTZWxlY3RvcikgLy8/P1xuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0dmFyIGZsb2F0X2FycmF5ID0geG1sc291cmNlLnF1ZXJ5U2VsZWN0b3IoXCJmbG9hdF9hcnJheVwiKTtcblx0XHRcdGlmIChmbG9hdF9hcnJheSkge1xuXHRcdFx0XHR2YXIgZmxvYXRzID0gdGhpcy5yZWFkQ29udGVudEFzRmxvYXRzKHhtbHNvdXJjZSk7XG5cdFx0XHRcdHNvdXJjZXNbeG1sc291cmNlLmdldEF0dHJpYnV0ZShcImlkXCIpXSA9IGZsb2F0cztcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBuYW1lX2FycmF5ID0geG1sc291cmNlLnF1ZXJ5U2VsZWN0b3IoXCJOYW1lX2FycmF5XCIpO1xuXHRcdFx0aWYgKG5hbWVfYXJyYXkpIHtcblx0XHRcdFx0dmFyIG5hbWVzID0gdGhpcy5yZWFkQ29udGVudEFzU3RyaW5nc0FycmF5KG5hbWVfYXJyYXkpO1xuXHRcdFx0XHRpZiAoIW5hbWVzKSBjb250aW51ZTtcblx0XHRcdFx0c291cmNlc1t4bWxzb3VyY2UuZ2V0QXR0cmlidXRlKFwiaWRcIildID0gbmFtZXM7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcmVmX2FycmF5ID0geG1sc291cmNlLnF1ZXJ5U2VsZWN0b3IoXCJJRFJFRl9hcnJheVwiKTtcblx0XHRcdGlmIChyZWZfYXJyYXkpIHtcblx0XHRcdFx0dmFyIG5hbWVzID0gdGhpcy5yZWFkQ29udGVudEFzU3RyaW5nc0FycmF5KHJlZl9hcnJheSk7XG5cdFx0XHRcdGlmICghbmFtZXMpIGNvbnRpbnVlO1xuXHRcdFx0XHRzb3VyY2VzW3htbHNvdXJjZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKV0gPSBuYW1lcztcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNvdXJjZXM7XG5cdH0sXG5cblx0cmVhZENvbnRlbnRBc1VJbnQzMjogZnVuY3Rpb24gcmVhZENvbnRlbnRBc1VJbnQzMih4bWxub2RlKSB7XG5cdFx0aWYgKCF4bWxub2RlKSByZXR1cm4gbnVsbDtcblx0XHR2YXIgdGV4dCA9IHhtbG5vZGUudGV4dENvbnRlbnQ7XG5cdFx0dGV4dCA9IHRleHQucmVwbGFjZSgvXFxuL2dpLCBcIiBcIik7IC8vcmVtb3ZlIGxpbmUgYnJlYWtzXG5cdFx0dGV4dCA9IHRleHQudHJpbSgpOyAvL3JlbW92ZSBlbXB0eSBzcGFjZXNcblx0XHRpZiAodGV4dC5sZW5ndGggPT0gMCkgcmV0dXJuIG51bGw7XG5cdFx0dmFyIG51bWJlcnMgPSB0ZXh0LnNwbGl0KFwiIFwiKTsgLy9jcmVhdGUgYXJyYXlcblx0XHR2YXIgZmxvYXRzID0gbmV3IFVpbnQzMkFycmF5KG51bWJlcnMubGVuZ3RoKTtcblx0XHRmb3IgKHZhciBrID0gMDsgayA8IG51bWJlcnMubGVuZ3RoOyBrKyspIHtcblx0XHRcdGZsb2F0c1trXSA9IHBhcnNlSW50KG51bWJlcnNba10pO1xuXHRcdH1yZXR1cm4gZmxvYXRzO1xuXHR9LFxuXG5cdHJlYWRDb250ZW50QXNGbG9hdHM6IGZ1bmN0aW9uIHJlYWRDb250ZW50QXNGbG9hdHMoeG1sbm9kZSkge1xuXHRcdGlmICgheG1sbm9kZSkgcmV0dXJuIG51bGw7XG5cdFx0dmFyIHRleHQgPSB4bWxub2RlLnRleHRDb250ZW50O1xuXHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcbi9naSwgXCIgXCIpOyAvL3JlbW92ZSBsaW5lIGJyZWFrc1xuXHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcc1xccysvZ2ksIFwiIFwiKTtcblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHQvZ2ksIFwiXCIpO1xuXHRcdHRleHQgPSB0ZXh0LnRyaW0oKTsgLy9yZW1vdmUgZW1wdHkgc3BhY2VzXG5cdFx0dmFyIG51bWJlcnMgPSB0ZXh0LnNwbGl0KFwiIFwiKTsgLy9jcmVhdGUgYXJyYXlcblx0XHR2YXIgY291bnQgPSB4bWxub2RlLmdldEF0dHJpYnV0ZShcImNvdW50XCIpO1xuXHRcdHZhciBsZW5ndGggPSBjb3VudCA/IHBhcnNlSW50KGNvdW50KSA6IG51bWJlcnMubGVuZ3RoO1xuXHRcdHZhciBmbG9hdHMgPSBuZXcgRmxvYXQzMkFycmF5KGxlbmd0aCk7XG5cdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBudW1iZXJzLmxlbmd0aDsgaysrKSB7XG5cdFx0XHRmbG9hdHNba10gPSBwYXJzZUZsb2F0KG51bWJlcnNba10pO1xuXHRcdH1yZXR1cm4gZmxvYXRzO1xuXHR9LFxuXG5cdHJlYWRDb250ZW50QXNTdHJpbmdzQXJyYXk6IGZ1bmN0aW9uIHJlYWRDb250ZW50QXNTdHJpbmdzQXJyYXkoeG1sbm9kZSkge1xuXHRcdGlmICgheG1sbm9kZSkgcmV0dXJuIG51bGw7XG5cdFx0dmFyIHRleHQgPSB4bWxub2RlLnRleHRDb250ZW50O1xuXHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcbi9naSwgXCIgXCIpOyAvL3JlbW92ZSBsaW5lIGJyZWFrc1xuXHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcc1xccy9naSwgXCIgXCIpO1xuXHRcdHRleHQgPSB0ZXh0LnRyaW0oKTsgLy9yZW1vdmUgZW1wdHkgc3BhY2VzXG5cdFx0dmFyIHdvcmRzID0gdGV4dC5zcGxpdChcIiBcIik7IC8vY3JlYXRlIGFycmF5XG5cdFx0Zm9yICh2YXIgayA9IDA7IGsgPCB3b3Jkcy5sZW5ndGg7IGsrKykge1xuXHRcdFx0d29yZHNba10gPSB3b3Jkc1trXS50cmltKCk7XG5cdFx0fWlmICh4bWxub2RlLmdldEF0dHJpYnV0ZShcImNvdW50XCIpICYmIHBhcnNlSW50KHhtbG5vZGUuZ2V0QXR0cmlidXRlKFwiY291bnRcIikpICE9IHdvcmRzLmxlbmd0aCkge1xuXHRcdFx0dmFyIG1lcmdlZF93b3JkcyA9IFtdO1xuXHRcdFx0dmFyIG5hbWUgPSBcIlwiO1xuXHRcdFx0Zm9yICh2YXIgaSBpbiB3b3Jkcykge1xuXHRcdFx0XHRpZiAoIW5hbWUpIG5hbWUgPSB3b3Jkc1tpXTtlbHNlIG5hbWUgKz0gXCIgXCIgKyB3b3Jkc1tpXTtcblx0XHRcdFx0aWYgKCF0aGlzLl9ub2Rlc19ieV9pZFt0aGlzLnNhZmVTdHJpbmcobmFtZSldKSBjb250aW51ZTtcblx0XHRcdFx0bWVyZ2VkX3dvcmRzLnB1c2godGhpcy5zYWZlU3RyaW5nKG5hbWUpKTtcblx0XHRcdFx0bmFtZSA9IFwiXCI7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjb3VudCA9IHBhcnNlSW50KHhtbG5vZGUuZ2V0QXR0cmlidXRlKFwiY291bnRcIikpO1xuXHRcdFx0aWYgKG1lcmdlZF93b3Jkcy5sZW5ndGggPT0gY291bnQpIHJldHVybiBtZXJnZWRfd29yZHM7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvcjogYm9uZSBuYW1lcyBoYXZlIHNwYWNlcywgYXZvaWQgdXNpbmcgc3BhY2VzIGluIG5hbWVzXCIpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiB3b3Jkcztcblx0fSxcblxuXHRtYXgzZF9tYXRyaXhfMDogbmV3IEZsb2F0MzJBcnJheShbMCwgLTEsIDAsIDAsIDAsIDAsIC0xLCAwLCAxLCAwLCAwLCAtMCwgMCwgMCwgMCwgMV0pLFxuXHQvL21heDNkX21hdHJpeF9vdGhlcjogbmV3IEZsb2F0MzJBcnJheShbMCwgLTEsIDAsIDAsIDAsIDAsIC0xLCAwLCAxLCAwLCAwLCAtMCwgMCwgMCwgMCwgMV0pLFxuXG5cdHRyYW5zZm9ybU1hdHJpeDogZnVuY3Rpb24gdHJhbnNmb3JtTWF0cml4KG1hdHJpeCwgZmlyc3RfbGV2ZWwsIGludmVydGVkKSB7XG5cdFx0X2dsTWF0cml4Lm1hdDQudHJhbnNwb3NlKG1hdHJpeCwgbWF0cml4KTtcblxuXHRcdGlmICh0aGlzLm5vX2ZsaXApIHJldHVybiBtYXRyaXg7XG5cblx0XHQvL1dBUk5JTkc6IERPIE5PVCBDSEFOR0UgVEhJUyBGVU5DVElPTiwgVEhFIFNLWSBXSUxMIEZBTExcblx0XHRpZiAoZmlyc3RfbGV2ZWwpIHtcblxuXHRcdFx0Ly9mbGlwIHJvdyB0d28gYW5kIHRyZWVcblx0XHRcdHZhciB0ZW1wID0gbmV3IEZsb2F0MzJBcnJheShtYXRyaXguc3ViYXJyYXkoNCwgOCkpOyAvL3N3YXAgcm93c1xuXHRcdFx0bWF0cml4LnNldChtYXRyaXguc3ViYXJyYXkoOCwgMTIpLCA0KTtcblx0XHRcdG1hdHJpeC5zZXQodGVtcCwgOCk7XG5cblx0XHRcdC8vcmV2ZXJzZSBaXG5cdFx0XHR0ZW1wID0gbWF0cml4LnN1YmFycmF5KDgsIDEyKTtcblx0XHRcdHZlYzQuc2NhbGUodGVtcCwgdGVtcCwgLTEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgTSA9IF9nbE1hdHJpeC5tYXQ0LmNyZWF0ZSgpO1xuXHRcdFx0dmFyIG0gPSBtYXRyaXg7XG5cblx0XHRcdC8vaWYoaW52ZXJ0ZWQpIG1hdDQuaW52ZXJ0KG0sbSk7XG5cblx0XHRcdC8qIG5vbiB0cmFzcG9zZWRcbiAgIE0uc2V0KFttWzBdLG1bOF0sLW1bNF1dLCAwKTtcbiAgIE0uc2V0KFttWzJdLG1bMTBdLC1tWzZdXSwgNCk7XG4gICBNLnNldChbLW1bMV0sLW1bOV0sbVs1XV0sIDgpO1xuICAgTS5zZXQoW21bM10sbVsxMV0sLW1bN11dLCAxMik7XG4gICAqL1xuXG5cdFx0XHRNLnNldChbbVswXSwgbVsyXSwgLW1bMV1dLCAwKTtcblx0XHRcdE0uc2V0KFttWzhdLCBtWzEwXSwgLW1bOV1dLCA0KTtcblx0XHRcdE0uc2V0KFstbVs0XSwgLW1bNl0sIG1bNV1dLCA4KTtcblx0XHRcdE0uc2V0KFttWzEyXSwgbVsxNF0sIC1tWzEzXV0sIDEyKTtcblxuXHRcdFx0bS5zZXQoTSk7XG5cblx0XHRcdC8vaWYoaW52ZXJ0ZWQpIG1hdDQuaW52ZXJ0KG0sbSk7XG5cdFx0fVxuXHRcdHJldHVybiBtYXRyaXg7XG5cdH1cbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENvbGxhZGE7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbGxhZGEuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29sbGFkYS1wYXJzZXIvbGliL0NvbGxhZGEuanNcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gR2x0ZkxvYWRlci5qc1xuXG5pbXBvcnQgeGhyIGZyb20gJy4veGhyJztcbmltcG9ydCBNZXNoIGZyb20gJy4uL01lc2gnO1xuXG5jb25zdCBBUlJBWV9DVE9SX01BUCA9IHtcblx0NTEyMDogSW50OEFycmF5LFxuXHQ1MTIxOiBVaW50OEFycmF5LFxuXHQ1MTIyOiBJbnQxNkFycmF5LFxuXHQ1MTIzOiBVaW50MTZBcnJheSxcblx0NTEyNTogVWludDMyQXJyYXksXG5cdDUxMjY6IEZsb2F0MzJBcnJheVxufTtcblxuY29uc3QgU0laRV9NQVAgPSB7XG5cdFNDQUxBUjogMSxcblx0VkVDMjogMixcblx0VkVDMzogMyxcblx0VkVDNDogNCxcblx0TUFUMjogNCxcblx0TUFUMzogOSxcblx0TUFUNDogMTZcbn07XG5cbmNvbnN0IHNlbWFudGljQXR0cmlidXRlTWFwID0ge1xuXHROT1JNQUw6ICdhTm9ybWFsJyxcblx0UE9TSVRJT046ICdhVmVydGV4UG9zaXRpb24nLFxuXHQvLyAnVEFOR0VOVCc6ICdhVGFuZ2VudCcsXG5cdFRFWENPT1JEXzA6ICdhVGV4dHVyZUNvb3JkJyxcblx0VEVYQ09PUkRfMTogJ2FUZXh0dXJlQ29vcmQxJyxcblx0V0VJR0hUU18wOiAnYVdlaWdodCcsXG5cdEpPSU5UU18wOiAnYUpvaW50Jyxcblx0Q09MT1I6ICdhQ29sb3InXG59O1xuXG5sZXQgYmFzZTtcblxuY29uc3QgbG9hZCA9IChtU291cmNlKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdGlmKCh0eXBlb2YgbVNvdXJjZSkgPT09ICdzdHJpbmcnKSB7XG5cdFx0YmFzZSA9IG1Tb3VyY2Uuc3Vic3RyaW5nKDAsIG1Tb3VyY2UubGFzdEluZGV4T2YoJy8nKSsxKTtcblx0fSBlbHNlIHtcblx0XHRiYXNlID0gJyc7XG5cdH1cblxuXHRfbG9hZEdsdGYobVNvdXJjZSlcblx0XHQudGhlbihfbG9hZEJpbilcblx0XHQudGhlbihfZ2V0QnVmZmVyVmlld0RhdGEpXG5cdFx0LnRoZW4oX2xvYWRUZXh0dXJlcylcblx0XHQudGhlbihfcGFyc2VNZXNoKVxuXHRcdC50aGVuKF9wYXJzZU5vZGVzKVxuXHRcdC50aGVuKChnbHRmSW5mbyk9Pntcblx0XHRcdHJlc29sdmUoZ2x0ZkluZm8pO1xuXHRcdH0pXG5cdFx0LmNhdGNoKGUgPT4ge1xuXHRcdFx0Y29uc29sZS5sb2coJ0Vycm9yOicsIGUpO1xuXHRcdH0pO1xufSk7XG5cblxuY29uc3QgX3BhcnNlTm9kZXMgPSAoZ2x0ZikgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRjb25zdCB7IG5vZGVzIH0gPSBnbHRmO1xuXG5cdG5vZGVzLmZvckVhY2goKG5vZGVJbmZvLCBpKSA9PiB7XG5cdFx0aWYgKG5vZGVJbmZvLmNhbWVyYSAhPSBudWxsICYmIHRoaXMuaW5jbHVkZUNhbWVyYSkge1xuXHRcdFx0Ly8gc2V0dXAgY2FtZXJhXG5cdFx0fSBlbHNlIGlmKG5vZGVJbmZvLm1lc2ggIT0gbnVsbCkge1xuXHRcdFx0Ly8gY29uc29sZS5sb2coaSwgJ01lc2ggaW5kZXggOicsIG5vZGVJbmZvLm1lc2gpO1xuXHRcdH1cblxuXHR9KTtcblx0cmVzb2x2ZShnbHRmKTtcbn0pO1xuXG5jb25zdCBfcGFyc2VNZXNoID0gKGdsdGYpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0Y29uc3QgeyBtZXNoZXMgfSA9IGdsdGY7XG5cdGdsdGYuZ2VvbWV0cmllcyA9IFtdO1xuXHRnbHRmLm91dHB1dCA9IHtcblx0XHRtZXNoZXM6W10sXG5cdFx0c2NlbmU6e31cblx0fTtcblxuXHRtZXNoZXMuZm9yRWFjaCgobWVzaCwgaSkgPT4ge1xuXHRcdGNvbnN0IHsgcHJpbWl0aXZlcyB9ID0gbWVzaDtcblx0XHRjb25zdCBnZW9tZXRyeSA9IHt9O1xuXG5cdFx0cHJpbWl0aXZlcy5mb3JFYWNoKChwcmltaXRpdmVJbmZvLCBpKSA9PiB7XG5cdFx0XHRjb25zdCBzZW1hbnRpY3MgPSBPYmplY3Qua2V5cyhwcmltaXRpdmVJbmZvLmF0dHJpYnV0ZXMpO1xuXG5cdFx0XHRzZW1hbnRpY3MuZm9yRWFjaCgoc2VtYW50aWMsIGkpID0+IHtcblx0XHRcdFx0Y29uc3QgYWNjZXNzb3JJZHggPSBwcmltaXRpdmVJbmZvLmF0dHJpYnV0ZXNbc2VtYW50aWNdO1xuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGVJbmZvID0gZ2x0Zi5hY2Nlc3NvcnNbYWNjZXNzb3JJZHhdO1xuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGVOYW1lID0gc2VtYW50aWNBdHRyaWJ1dGVNYXBbc2VtYW50aWNdO1xuXHRcdFx0XHRpZighYXR0cmlidXRlTmFtZSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zdCBzaXplID0gU0laRV9NQVBbYXR0cmlidXRlSW5mby50eXBlXTtcblx0XHRcdFx0bGV0IGF0dHJpYnV0ZUFycmF5ID0gX2dldEFjY2Vzc29yRGF0YShnbHRmLCBhY2Nlc3NvcklkeCk7XG5cdFx0XHRcdGlmIChhdHRyaWJ1dGVBcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KSB7XG5cdFx0XHRcdFx0YXR0cmlidXRlQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KGF0dHJpYnV0ZUFycmF5KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdlb21ldHJ5W2F0dHJpYnV0ZU5hbWVdID0ge1xuXHRcdFx0XHRcdHZhbHVlOmF0dHJpYnV0ZUFycmF5LFxuXHRcdFx0XHRcdHNpemUsXG5cdFx0XHRcdH07XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdhdHRyaWJ1dGUnLCBhdHRyaWJ1dGVOYW1lLCBnZW9tZXRyeVthdHRyaWJ1dGVOYW1lXSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly9cdHBhcnNlIGluZGV4XG5cdFx0XHRpZiAocHJpbWl0aXZlSW5mby5pbmRpY2VzICE9IG51bGwpIHtcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlQXJyYXkgPSBfZ2V0QWNjZXNzb3JEYXRhKGdsdGYsIHByaW1pdGl2ZUluZm8uaW5kaWNlcywgdHJ1ZSk7XG5cdFx0XHRcdGdlb21ldHJ5LmluZGljZXMgPSB7XG5cdFx0XHRcdFx0dmFsdWU6YXR0cmlidXRlQXJyYXksXG5cdFx0XHRcdFx0c2l6ZToxXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IG0gPSBuZXcgTWVzaCgpO1xuXG5cdFx0XHRmb3IoY29uc3QgcyBpbiBnZW9tZXRyeSkge1xuXHRcdFx0XHRjb25zdCBkYXRhID0gZ2VvbWV0cnlbc107XG5cdFx0XHRcdGlmKHMgIT09ICdpbmRpY2VzJykge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKHMsIGRhdGEpO1xuXHRcdFx0XHRcdG0uYnVmZmVyRmxhdHRlbkRhdGEoZGF0YS52YWx1ZSwgcywgZGF0YS5zaXplKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhkYXRhLnZhbHVlKTtcblx0XHRcdFx0XHRtLmJ1ZmZlckluZGV4KGRhdGEudmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRnbHRmLm91dHB1dC5tZXNoZXMucHVzaChtKTtcblx0XHRcdGdsdGYuZ2VvbWV0cmllcy5wdXNoKGdlb21ldHJ5KTtcblx0XHR9KTtcblx0fSk7XG5cblx0cmVzb2x2ZShnbHRmKTtcbn0pO1xuXG5cbmNvbnN0IF9nZXRCdWZmZXJWaWV3RGF0YSA9IChnbHRmSW5mbykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRjb25zdCB7IGJ1ZmZlclZpZXdzLCBidWZmZXJzIH0gPSBnbHRmSW5mbztcblxuXHRidWZmZXJWaWV3cy5mb3JFYWNoKChidWZmZXJWaWV3SW5mbywgaSkgPT4ge1xuXHRcdGNvbnN0IGJ1ZmZlciA9IGJ1ZmZlcnNbYnVmZmVyVmlld0luZm8uYnVmZmVyXS5kYXRhO1xuXHRcdGJ1ZmZlclZpZXdJbmZvLmRhdGEgPSBidWZmZXIuc2xpY2UoYnVmZmVyVmlld0luZm8uYnl0ZU9mZnNldCB8fCAwLCAoYnVmZmVyVmlld0luZm8uYnl0ZU9mZnNldCB8fCAwKSArIChidWZmZXJWaWV3SW5mby5ieXRlTGVuZ3RoIHx8IDApKTtcblx0fSk7XG5cdHJlc29sdmUoZ2x0ZkluZm8pO1xufSk7XG5cbmNvbnN0IF9sb2FkR2x0ZiA9IChtU291cmNlKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdGlmKCh0eXBlb2YgbVNvdXJjZSkgIT09ICdzdHJpbmcnKSB7XG5cdFx0cmVzb2x2ZShtU291cmNlKTtcblx0fSBlbHNlIHtcblx0XHR4aHIobVNvdXJjZSkudGhlbigobyk9Pntcblx0XHRcdHJlc29sdmUoSlNPTi5wYXJzZShvKSk7XG5cdFx0fSwgKGUpPT4ge1xuXHRcdFx0cmVqZWN0KGUpO1xuXHRcdH0pO1xuXHR9XG59KTtcblxuXG5jb25zdCBfbG9hZEJpbiA9IChnbHRmSW5mbykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcblx0aWYoZ2x0ZkluZm8uYnVmZmVycykge1xuXHRcdGxldCBjb3VudCA9IGdsdGZJbmZvLmJ1ZmZlcnMubGVuZ3RoO1xuXG5cdFx0Z2x0ZkluZm8uYnVmZmVycy5mb3JFYWNoKGJ1ZmZlciA9PiB7XG5cblx0XHRcdGNvbnN0IHVybEJpbiA9IGAke2Jhc2V9JHtnbHRmSW5mby5idWZmZXJzWzBdLnVyaX1gO1xuXHRcdFx0eGhyKHVybEJpbiwgdHJ1ZSkudGhlbigobyk9PiB7XG5cdFx0XHRcdGJ1ZmZlci5kYXRhID0gbztcblxuXHRcdFx0XHRjb3VudCAtLTtcblx0XHRcdFx0aWYoY291bnQgPT09IDApIHtcblx0XHRcdFx0XHRyZXNvbHZlKGdsdGZJbmZvKTtcdFxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0fSwgZSA9PiB7XG5cdFx0XHRcdHJlamVjdChlKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdFxuXHR9IGVsc2Uge1xuXHRcdHJlc29sdmUoZ2x0ZkluZm8pO1x0XG5cdH1cblx0XG59KTtcblxuY29uc3QgX2xvYWRUZXh0dXJlcyA9IChnbHRmSW5mbykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRjb25zb2xlLmxvZygnVE9ETyA6IExvYWRpbmcgdGV4dHVyZXMnKTtcblx0cmVzb2x2ZShnbHRmSW5mbyk7XG59KTtcblxuY29uc3QgcGFyc2UgPSAobUdsdGZJbmZvLCBtQmluKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdHJlc29sdmUobVNvdXJjZSk7XG59KTtcblxuXG5jb25zdCBfZ2V0QWNjZXNzb3JEYXRhID0gKGdsdGYsIGFjY2Vzc29ySWR4LCBpc0luZGljZXMgPSBmYWxzZSkgPT4ge1xuXHRjb25zdCBhY2Nlc3NvckluZm8gPSBnbHRmLmFjY2Vzc29yc1thY2Nlc3NvcklkeF07XG5cdGNvbnN0IGJ1ZmZlciA9IGdsdGYuYnVmZmVyVmlld3NbYWNjZXNzb3JJbmZvLmJ1ZmZlclZpZXddLmRhdGE7XG5cdGNvbnN0IGJ5dGVPZmZzZXQgPSBhY2Nlc3NvckluZm8uYnl0ZU9mZnNldCB8fCAwO1xuXHRjb25zdCBBcnJheUN0b3IgPSBBUlJBWV9DVE9SX01BUFthY2Nlc3NvckluZm8uY29tcG9uZW50VHlwZV0gfHwgRmxvYXQzMkFycmF5O1xuXHRsZXQgc2l6ZSA9IFNJWkVfTUFQW2FjY2Vzc29ySW5mby50eXBlXTtcblx0aWYgKHNpemUgPT0gbnVsbCAmJiBpc0luZGljZXMpIHtcblx0XHRzaXplID0gMTtcblx0fVxuXHRsZXQgYXJyID0gbmV3IEFycmF5Q3RvcihidWZmZXIsIGJ5dGVPZmZzZXQsIHNpemUgKiBhY2Nlc3NvckluZm8uY291bnQpO1xuXHRjb25zdCBxdWFudGl6ZUV4dGVuc2lvbiA9IGFjY2Vzc29ySW5mby5leHRlbnNpb25zICYmIGFjY2Vzc29ySW5mby5leHRlbnNpb25zWydXRUIzRF9xdWFudGl6ZWRfYXR0cmlidXRlcyddO1xuXHRpZiAocXVhbnRpemVFeHRlbnNpb24pIHtcblx0XHRjb25zdCBkZWNvZGVkQXJyID0gbmV3IEZsb2F0MzJBcnJheShzaXplICogYWNjZXNzb3JJbmZvLmNvdW50KTtcblx0XHRjb25zdCBkZWNvZGVNYXRyaXggPSBxdWFudGl6ZUV4dGVuc2lvbi5kZWNvZGVNYXRyaXg7XG5cdFx0Y29uc3QgZGVjb2RlT2Zmc2V0ID0gbmV3IEFycmF5KHNpemUpO1xuXHRcdGNvbnN0IGRlY29kZVNjYWxlID0gbmV3IEFycmF5KHNpemUpO1xuXHRcdGZvciAobGV0IGsgPSAwOyBrIDwgc2l6ZTsgaysrKSB7XG5cdFx0XHRkZWNvZGVPZmZzZXRba10gPSBkZWNvZGVNYXRyaXhbc2l6ZSAqIChzaXplICsgMSkgKyBrXTtcblx0XHRcdGRlY29kZVNjYWxlW2tdID0gZGVjb2RlTWF0cml4W2sgKiAoc2l6ZSArIDEpICsga107XG5cdFx0fVxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYWNjZXNzb3JJbmZvLmNvdW50OyBpKyspIHtcblx0XHRcdGZvciAobGV0IGsgPSAwOyBrIDwgc2l6ZTsgaysrKSB7XG5cdFx0XHRcdGRlY29kZWRBcnJbaSAqIHNpemUgKyBrXSA9IGFycltpICogc2l6ZSArIGtdICogZGVjb2RlU2NhbGVba10gKyBkZWNvZGVPZmZzZXRba107XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YXJyID0gZGVjb2RlZEFycjtcblx0fVxuXG5cdC8vIGNvbnNvbGUubG9nKHtidWZmZXIsIGJ5dGVPZmZzZXQsIEFycmF5Q3Rvciwgc2l6ZSwgYXJyfSk7XG5cblx0cmV0dXJuIGFycjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcblx0bG9hZCxcblx0cGFyc2Vcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvbG9hZGVycy9HbHRmTG9hZGVyLmpzIiwiLy8geGhyLmpzXG5cbmNvbnN0IGxvYWQgPSAobVBhdGgsIGlzQXJyYXlCdWZmZXIpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0Y29uc3QgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdHJlcS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKGUpID0+IHtcblx0XHRyZXNvbHZlKHJlcS5yZXNwb25zZSk7XG5cdH0pO1xuXG5cdHJlcS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChlKSA9PiB7XG5cdFx0cmVqZWN0KGUpO1xuXHR9KTtcblxuXHRpZihpc0FycmF5QnVmZmVyKSB7XG5cdFx0cmVxLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cdH1cblxuXHRyZXEub3BlbignR0VUJywgbVBhdGgpO1xuXHRyZXEuc2VuZCgpO1xuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgbG9hZDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9sb2FkZXJzL3hoci5qcyIsIi8vIEVmZmVjdENvbXBvc2VyLmpzXG5cbmltcG9ydCBQYXNzIGZyb20gJy4vUGFzcyc7XG5pbXBvcnQgR0wgZnJvbSAnLi4vR0xUb29sJztcbmltcG9ydCBHZW9tIGZyb20gJy4uL0dlb20nO1xuaW1wb3J0IEZyYW1lQnVmZmVyIGZyb20gJy4uL0ZyYW1lQnVmZmVyJztcblxuY2xhc3MgRWZmZWN0Q29tcG9zZXIge1xuXHRjb25zdHJ1Y3RvcihtV2lkdGgsIG1IZWlnaHQsIG1QYXJtYXMgPSB7fSkge1xuXHRcdHRoaXMuX3dpZHRoID0gbVdpZHRoIHx8IEdMLndpZHRoO1xuXHRcdHRoaXMuX2hlaWdodCA9IG1IZWlnaHQgfHwgR0wuaGVpZ2h0O1xuXG5cdFx0dGhpcy5fcGFyYW1zID0ge307XG5cdFx0dGhpcy5zZXRTaXplKG1XaWR0aCwgbUhlaWdodCk7XG5cdFx0dGhpcy5fbWVzaCA9IEdlb20uYmlnVHJpYW5nbGUoKTtcblx0XHR0aGlzLl9wYXNzZXMgPSBbXTtcblx0XHR0aGlzLl9yZXR1cm5UZXh0dXJlO1xuXHR9XG5cblxuXHRhZGRQYXNzKHBhc3MpIHtcblx0XHRpZihwYXNzLnBhc3Nlcykge1xuXHRcdFx0dGhpcy5hZGRQYXNzKHBhc3MucGFzc2VzKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKHBhc3MubGVuZ3RoKSB7XG5cdFx0XHRmb3IobGV0IGkgPSAwOyBpIDwgcGFzcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLl9wYXNzZXMucHVzaChwYXNzW2ldKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcGFzc2VzLnB1c2gocGFzcyk7XG5cdFx0fVxuXHR9XG5cblx0cmVuZGVyKG1Tb3VyY2UpIHtcblx0XHRsZXQgc291cmNlID0gbVNvdXJjZTtcblx0XHRsZXQgZmJvVGFyZ2V0O1xuXG5cdFx0dGhpcy5fcGFzc2VzLmZvckVhY2goKHBhc3MpID0+IHtcblxuXHRcdFx0Ly9cdGdldCB0YXJnZXRcblx0XHRcdGlmKHBhc3MuaGFzRmJvKSB7XG5cdFx0XHRcdGZib1RhcmdldCA9IHBhc3MuZmJvO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZmJvVGFyZ2V0ID0gdGhpcy5fZmJvVGFyZ2V0O1xuXHRcdFx0fVxuXG5cdFx0XHQvL1x0cmVuZGVyXG5cdFx0XHRmYm9UYXJnZXQuYmluZCgpO1xuXHRcdFx0R0wuY2xlYXIoMCwgMCwgMCwgMCk7XG5cdFx0XHRwYXNzLnJlbmRlcihzb3VyY2UpO1xuXHRcdFx0R0wuZHJhdyh0aGlzLl9tZXNoKTtcblx0XHRcdGZib1RhcmdldC51bmJpbmQoKTtcblxuXHRcdFx0Ly9cdHJlc2V0IHNvdXJjZVxuXHRcdFx0aWYocGFzcy5oYXNGYm8pIHtcblx0XHRcdFx0c291cmNlID0gcGFzcy5mYm8uZ2V0VGV4dHVyZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fc3dhcCgpO1x0XG5cdFx0XHRcdHNvdXJjZSA9IHRoaXMuX2Zib0N1cnJlbnQuZ2V0VGV4dHVyZSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5fcmV0dXJuVGV4dHVyZSA9IHNvdXJjZTtcblxuXHRcdHJldHVybiBzb3VyY2U7XG5cdH1cblxuXG5cdF9zd2FwKCkge1xuXHRcdGNvbnN0IHRtcCA9IHRoaXMuX2Zib0N1cnJlbnQ7XG5cdFx0dGhpcy5fZmJvQ3VycmVudCA9IHRoaXMuX2Zib1RhcmdldDtcblx0XHR0aGlzLl9mYm9UYXJnZXQgPSB0bXA7XG5cblx0XHR0aGlzLl9jdXJyZW50ID0gdGhpcy5fZmJvQ3VycmVudDtcblx0XHR0aGlzLl90YXJnZXQgPSB0aGlzLl9mYm9UYXJnZXQ7XG5cdH1cblxuXHRzZXRTaXplKG1XaWR0aCwgbUhlaWdodCkge1xuXHRcdHRoaXMuX3dpZHRoID0gbVdpZHRoO1xuXHRcdHRoaXMuX2hlaWdodCA9IG1IZWlnaHQ7XG5cdFx0dGhpcy5fZmJvQ3VycmVudCA9IG5ldyBGcmFtZUJ1ZmZlcih0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0LCB0aGlzLl9wYXJhbXMpO1xuXHRcdHRoaXMuX2Zib1RhcmdldCA9IG5ldyBGcmFtZUJ1ZmZlcih0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0LCB0aGlzLl9wYXJhbXMpO1xuXHR9XG5cblx0Z2V0IHBhc3NlcygpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFzc2VzO1xuXHR9XG5cblx0Z2V0VGV4dHVyZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmV0dXJuVGV4dHVyZTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBFZmZlY3RDb21wb3NlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9wb3N0L0VmZmVjdENvbXBvc2VyLmpzIiwiLy8gUGFzc0JsdXIuanNcblxuaW1wb3J0IFBhc3NWQmx1ciBmcm9tICcuL1Bhc3NWQmx1cic7XG5pbXBvcnQgUGFzc0hCbHVyIGZyb20gJy4vUGFzc0hCbHVyJztcbmltcG9ydCBQYXNzTWFjcm8gZnJvbSAnLi9QYXNzTWFjcm8nO1xuXG5jbGFzcyBQYXNzQmx1ciBleHRlbmRzIFBhc3NNYWNybyB7XG5cdGNvbnN0cnVjdG9yKG1RdWFsaXR5ID0gOSwgbVdpZHRoLCBtSGVpZ2h0LCBtUGFyYW1zKSB7XG5cdFx0c3VwZXIoKTtcblx0XHRjb25zdCB2Qmx1ciA9IG5ldyBQYXNzVkJsdXIobVF1YWxpdHksIG1XaWR0aCwgbUhlaWdodCwgbVBhcmFtcyk7XG5cdFx0Y29uc3QgaEJsdXIgPSBuZXcgUGFzc0hCbHVyKG1RdWFsaXR5LCBtV2lkdGgsIG1IZWlnaHQsIG1QYXJhbXMpO1xuXG5cdFx0dGhpcy5hZGRQYXNzKHZCbHVyKTtcblx0XHR0aGlzLmFkZFBhc3MoaEJsdXIpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhc3NCbHVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvcG9zdC9QYXNzQmx1ci5qcyIsIm1vZHVsZS5leHBvcnRzID0gXCIvLyBibHVyNS5mcmFnXFxuLy8gc291cmNlICA6IGh0dHBzOi8vZ2l0aHViLmNvbS9KYW0zL2dsc2wtZmFzdC1nYXVzc2lhbi1ibHVyXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBCTFVSXzVcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlO1xcbnVuaWZvcm0gdmVjMiB1RGlyZWN0aW9uO1xcbnVuaWZvcm0gdmVjMiB1UmVzb2x1dGlvbjtcXG5cXG52ZWM0IGJsdXI1KHNhbXBsZXIyRCBpbWFnZSwgdmVjMiB1diwgdmVjMiByZXNvbHV0aW9uLCB2ZWMyIGRpcmVjdGlvbikge1xcblxcdHZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XFxuXFx0dmVjMiBvZmYxID0gdmVjMigxLjMzMzMzMzMzMzMzMzMzMzMpICogZGlyZWN0aW9uO1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYpICogMC4yOTQxMTc2NDcwNTg4MjM1NDtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2ICsgKG9mZjEgLyByZXNvbHV0aW9uKSkgKiAwLjM1Mjk0MTE3NjQ3MDU4ODI2O1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgLSAob2ZmMSAvIHJlc29sdXRpb24pKSAqIDAuMzUyOTQxMTc2NDcwNTg4MjY7XFxuXFx0cmV0dXJuIGNvbG9yOyBcXG59XFxuXFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gYmx1cjUodGV4dHVyZSwgdlRleHR1cmVDb29yZCwgdVJlc29sdXRpb24sIHVEaXJlY3Rpb24pO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9ibHVyNS5mcmFnXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0gXCIvLyBibHVyOS5mcmFnXFxuLy8gc291cmNlICA6IGh0dHBzOi8vZ2l0aHViLmNvbS9KYW0zL2dsc2wtZmFzdC1nYXVzc2lhbi1ibHVyXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBCTFVSXzlcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlO1xcbnVuaWZvcm0gdmVjMiB1RGlyZWN0aW9uO1xcbnVuaWZvcm0gdmVjMiB1UmVzb2x1dGlvbjtcXG5cXG52ZWM0IGJsdXI5KHNhbXBsZXIyRCBpbWFnZSwgdmVjMiB1diwgdmVjMiByZXNvbHV0aW9uLCB2ZWMyIGRpcmVjdGlvbikge1xcblxcdHZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XFxuXFx0dmVjMiBvZmYxID0gdmVjMigxLjM4NDYxNTM4NDYpICogZGlyZWN0aW9uO1xcblxcdHZlYzIgb2ZmMiA9IHZlYzIoMy4yMzA3NjkyMzA4KSAqIGRpcmVjdGlvbjtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2KSAqIDAuMjI3MDI3MDI3MDtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2ICsgKG9mZjEgLyByZXNvbHV0aW9uKSkgKiAwLjMxNjIxNjIxNjI7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diAtIChvZmYxIC8gcmVzb2x1dGlvbikpICogMC4zMTYyMTYyMTYyO1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgKyAob2ZmMiAvIHJlc29sdXRpb24pKSAqIDAuMDcwMjcwMjcwMztcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2IC0gKG9mZjIgLyByZXNvbHV0aW9uKSkgKiAwLjA3MDI3MDI3MDM7XFxuXFx0cmV0dXJuIGNvbG9yO1xcbn1cXG5cXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSBibHVyOSh0ZXh0dXJlLCB2VGV4dHVyZUNvb3JkLCB1UmVzb2x1dGlvbiwgdURpcmVjdGlvbik7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9zaGFkZXJzL2JsdXI5LmZyYWdcbi8vIG1vZHVsZSBpZCA9IDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vIGJsdXIxMy5mcmFnXFxuLy8gc291cmNlICA6IGh0dHBzOi8vZ2l0aHViLmNvbS9KYW0zL2dsc2wtZmFzdC1nYXVzc2lhbi1ibHVyXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBCTFVSXzEzXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcXG51bmlmb3JtIHZlYzIgdURpcmVjdGlvbjtcXG51bmlmb3JtIHZlYzIgdVJlc29sdXRpb247XFxuXFxudmVjNCBibHVyMTMoc2FtcGxlcjJEIGltYWdlLCB2ZWMyIHV2LCB2ZWMyIHJlc29sdXRpb24sIHZlYzIgZGlyZWN0aW9uKSB7XFxuXFx0dmVjNCBjb2xvciA9IHZlYzQoMC4wKTtcXG5cXHR2ZWMyIG9mZjEgPSB2ZWMyKDEuNDExNzY0NzA1ODgyMzUzKSAqIGRpcmVjdGlvbjtcXG5cXHR2ZWMyIG9mZjIgPSB2ZWMyKDMuMjk0MTE3NjQ3MDU4ODIzNCkgKiBkaXJlY3Rpb247XFxuXFx0dmVjMiBvZmYzID0gdmVjMig1LjE3NjQ3MDU4ODIzNTI5NCkgKiBkaXJlY3Rpb247XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1dikgKiAwLjE5NjQ4MjU1MDE1MTE0MDQ7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diArIChvZmYxIC8gcmVzb2x1dGlvbikpICogMC4yOTY5MDY5NjQ2NzI4MzQ0O1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgLSAob2ZmMSAvIHJlc29sdXRpb24pKSAqIDAuMjk2OTA2OTY0NjcyODM0NDtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2ICsgKG9mZjIgLyByZXNvbHV0aW9uKSkgKiAwLjA5NDQ3MDM5Nzg1MDQ0NzMyO1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgLSAob2ZmMiAvIHJlc29sdXRpb24pKSAqIDAuMDk0NDcwMzk3ODUwNDQ3MzI7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diArIChvZmYzIC8gcmVzb2x1dGlvbikpICogMC4wMTAzODEzNjI0MDExNDgwNTc7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diAtIChvZmYzIC8gcmVzb2x1dGlvbikpICogMC4wMTAzODEzNjI0MDExNDgwNTc7XFxuXFx0cmV0dXJuIGNvbG9yO1xcbn1cXG5cXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSBibHVyMTModGV4dHVyZSwgdlRleHR1cmVDb29yZCwgdVJlc29sdXRpb24sIHVEaXJlY3Rpb24pO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9ibHVyMTMuZnJhZ1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBQYXNzRnhhYS5qc1xuXG5pbXBvcnQgR0wgZnJvbSAnLi4vR0xUb29sJztcbmltcG9ydCBQYXNzIGZyb20gJy4vUGFzcyc7XG5pbXBvcnQgZnNGeGFhIGZyb20gJy4uL3NoYWRlcnMvZnhhYS5mcmFnJztcblxuY2xhc3MgUGFzc0Z4YWEgZXh0ZW5kcyBQYXNzIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoZnNGeGFhKTtcblx0XHR0aGlzLnVuaWZvcm0oJ3VSZXNvbHV0aW9uJywgWzEvR0wud2lkdGgsIDEvR0wuaGVpZ2h0XSk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFzc0Z4YWE7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvcG9zdC9QYXNzRnhhYS5qcyIsIi8vIEJhdGNoQ29weS5qc1xuXG5pbXBvcnQgR2VvbSBmcm9tICcuLi9HZW9tJztcbmltcG9ydCBHTFNoYWRlciBmcm9tICcuLi9HTFNoYWRlcic7XG5pbXBvcnQgQmF0Y2ggZnJvbSAnLi4vQmF0Y2gnO1xuXG5jb25zdCB2cyA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvYmlnVHJpYW5nbGUudmVydCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9zaGFkZXJzL2NvcHkuZnJhZycpO1xuXG5jbGFzcyBCYXRjaENvcHkgZXh0ZW5kcyBCYXRjaCB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0Y29uc3QgbWVzaCA9IEdlb20uYmlnVHJpYW5nbGUoKTtcblx0XHRjb25zdCBzaGFkZXIgPSBuZXcgR0xTaGFkZXIodnMsIGZzKTtcblx0XHRzdXBlcihtZXNoLCBzaGFkZXIpO1xuXG5cdFx0c2hhZGVyLmJpbmQoKTtcblx0XHRzaGFkZXIudW5pZm9ybSgndGV4dHVyZScsICd1bmlmb3JtMWknLCAwKTtcblx0fVxuXG5cblx0ZHJhdyh0ZXh0dXJlKSB7XG5cdFx0dGhpcy5zaGFkZXIuYmluZCgpO1xuXHRcdHRleHR1cmUuYmluZCgwKTtcblx0XHRzdXBlci5kcmF3KCk7XG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXRjaENvcHk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvaGVscGVycy9CYXRjaENvcHkuanMiLCIvLyBCYXRjaEF4aXMuanNcblxuaW1wb3J0IEdMIGZyb20gJy4uL0dMVG9vbCc7XG5pbXBvcnQgTWVzaCBmcm9tICcuLi9NZXNoJztcbmltcG9ydCBHTFNoYWRlciBmcm9tICcuLi9HTFNoYWRlcic7XG5pbXBvcnQgQmF0Y2ggZnJvbSAnLi4vQmF0Y2gnO1xuXG5jb25zdCB2cyA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvYXhpcy52ZXJ0Jyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvYXhpcy5mcmFnJyk7XG5cblxuY2xhc3MgQmF0Y2hBeGlzIGV4dGVuZHMgQmF0Y2gge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuXHRcdGNvbnN0IGNvbG9ycyA9IFtdO1xuXHRcdGNvbnN0IGluZGljZXMgPSBbMCwgMSwgMiwgMywgNCwgNV07XG5cdFx0Y29uc3QgciA9IDk5OTk7XG5cblx0XHRwb3NpdGlvbnMucHVzaChbLXIsICAwLCAgMF0pO1xuXHRcdHBvc2l0aW9ucy5wdXNoKFtyLCAgMCwgIDBdKTtcblx0XHRwb3NpdGlvbnMucHVzaChbMCwgLXIsICAwXSk7XG5cdFx0cG9zaXRpb25zLnB1c2goWzAsICByLCAgMF0pO1xuXHRcdHBvc2l0aW9ucy5wdXNoKFswLCAgMCwgLXJdKTtcblx0XHRwb3NpdGlvbnMucHVzaChbMCwgIDAsICByXSk7XG5cblxuXHRcdGNvbG9ycy5wdXNoKFsxLCAwLCAwXSk7XG5cdFx0Y29sb3JzLnB1c2goWzEsIDAsIDBdKTtcblx0XHRjb2xvcnMucHVzaChbMCwgMSwgMF0pO1xuXHRcdGNvbG9ycy5wdXNoKFswLCAxLCAwXSk7XG5cdFx0Y29sb3JzLnB1c2goWzAsIDAsIDFdKTtcblx0XHRjb2xvcnMucHVzaChbMCwgMCwgMV0pO1xuXG5cdFx0Y29uc3QgbWVzaCA9IG5ldyBNZXNoKEdMLkxJTkVTKTtcblx0XHRtZXNoLmJ1ZmZlclZlcnRleChwb3NpdGlvbnMpO1xuXHRcdG1lc2guYnVmZmVySW5kZXgoaW5kaWNlcyk7XG5cdFx0bWVzaC5idWZmZXJEYXRhKGNvbG9ycywgJ2FDb2xvcicsIDMpO1xuXG5cdFx0Y29uc3Qgc2hhZGVyID0gbmV3IEdMU2hhZGVyKHZzLCBmcyk7XG5cblx0XHRzdXBlcihtZXNoLCBzaGFkZXIpO1xuXG5cdH1cblxuXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgQmF0Y2hBeGlzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hBeGlzLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vIGF4aXMudmVydFxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgQkFTSUNfVkVSVEVYXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuYXR0cmlidXRlIHZlYzMgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMzIGFDb2xvcjtcXG5hdHRyaWJ1dGUgdmVjMyBhTm9ybWFsO1xcblxcbnVuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVWaWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzMgdkNvbG9yO1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb25NYXRyaXggKiB1Vmlld01hdHJpeCAqIHVNb2RlbE1hdHJpeCAqIHZlYzQoYVZlcnRleFBvc2l0aW9uLCAxLjApO1xcbiAgICB2Q29sb3IgPSBhQ29sb3I7XFxuICAgIHZOb3JtYWwgPSBhTm9ybWFsO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9heGlzLnZlcnRcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vIGF4aXMuZnJhZ1xcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgU0lNUExFX1RFWFRVUkVcXG5cXG5wcmVjaXNpb24gbG93cCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbnZhcnlpbmcgdmVjMyB2Q29sb3I7XFxudmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG5cXHQvLyB2ZWMzIGNvbG9yID0gdk5vcm1hbDtcXG5cXHR2ZWMzIGNvbG9yID0gdkNvbG9yICsgdk5vcm1hbCAqIDAuMDAwMTtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4wKTtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3NoYWRlcnMvYXhpcy5mcmFnXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIEJhdGNoQmFsbC5qc1xuXG5pbXBvcnQgR2VvbSBmcm9tICcuLi9HZW9tJztcbmltcG9ydCBHTFNoYWRlciBmcm9tICcuLi9HTFNoYWRlcic7XG5pbXBvcnQgQmF0Y2ggZnJvbSAnLi4vQmF0Y2gnO1xuXG5jb25zdCB2cyA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvZ2VuZXJhbC52ZXJ0Jyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvc2ltcGxlQ29sb3IuZnJhZycpO1xuXG5jbGFzcyBCYXRjaEJhbGwgZXh0ZW5kcyBCYXRjaCB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0Y29uc3QgbWVzaCA9IEdlb20uc3BoZXJlKDEsIDI0KTtcblx0XHRjb25zdCBzaGFkZXIgPSBuZXcgR0xTaGFkZXIodnMsIGZzKTtcblx0XHRzdXBlcihtZXNoLCBzaGFkZXIpO1xuXHR9XG5cblxuXHRkcmF3KHBvc2l0aW9uID0gWzAsIDAsIDBdLCBzY2FsZSA9IFsxLCAxLCAxXSwgY29sb3IgPSBbMSwgMSwgMV0sIG9wYWNpdHkgPSAxKSB7XG5cdFx0dGhpcy5zaGFkZXIuYmluZCgpO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oJ3Bvc2l0aW9uJywgJ3VuaWZvcm0zZnYnLCBwb3NpdGlvbik7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgnc2NhbGUnLCAndW5pZm9ybTNmdicsIHNjYWxlKTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKCdjb2xvcicsICd1bmlmb3JtM2Z2JywgY29sb3IpO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oJ29wYWNpdHknLCAndW5pZm9ybTFmJywgb3BhY2l0eSk7XG5cdFx0c3VwZXIuZHJhdygpO1xuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmF0Y2hCYWxsO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hCYWxsLmpzIiwiLy8gQmF0Y2hEb3RzUGxhbmUuanNcblxuaW1wb3J0IEdMIGZyb20gJy4uL0dMVG9vbCc7XG5pbXBvcnQgTWVzaCBmcm9tICcuLi9NZXNoJztcbmltcG9ydCBHTFNoYWRlciBmcm9tICcuLi9HTFNoYWRlcic7XG5pbXBvcnQgQmF0Y2ggZnJvbSAnLi4vQmF0Y2gnO1xuXG5jb25zdCB2cyA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvZG90c1BsYW5lLnZlcnQnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vc2hhZGVycy9zaW1wbGVDb2xvci5mcmFnJyk7XG5cbmNsYXNzIEJhdGNoRG90c1BsYW5lIGV4dGVuZHMgQmF0Y2gge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuXHRcdGNvbnN0IGluZGljZXMgICA9IFtdO1xuXHRcdGxldCBpbmRleCAgICAgICA9IDA7XG5cdFx0Y29uc3Qgc2l6ZSAgICAgID0gMTAwO1xuXHRcdGxldCBpLCBqO1xuXG5cdFx0Zm9yKGkgPSAtc2l6ZTsgaSA8IHNpemU7IGkgKz0gMSkge1xuXHRcdFx0Zm9yKGogPSAtc2l6ZTsgaiA8IHNpemU7IGogKz0gMSkge1xuXHRcdFx0XHRwb3NpdGlvbnMucHVzaChbaSwgaiwgMF0pO1xuXHRcdFx0XHRpbmRpY2VzLnB1c2goaW5kZXgpO1xuXHRcdFx0XHRpbmRleCsrO1xuXG5cdFx0XHRcdHBvc2l0aW9ucy5wdXNoKFtpLCAwLCBqXSk7XG5cdFx0XHRcdGluZGljZXMucHVzaChpbmRleCk7XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdGNvbnN0IG1lc2ggICAgID0gbmV3IE1lc2goR0wuUE9JTlRTKTtcblx0XHRtZXNoLmJ1ZmZlclZlcnRleChwb3NpdGlvbnMpO1xuXHRcdG1lc2guYnVmZmVySW5kZXgoaW5kaWNlcyk7XG5cdFx0XG5cdFx0Y29uc3Qgc2hhZGVyICAgPSBuZXcgR0xTaGFkZXIodnMsIGZzKTtcblx0XHRcblx0XHRzdXBlcihtZXNoLCBzaGFkZXIpO1xuXHRcdFxuXHRcdHRoaXMuY29sb3IgICA9IFsxLCAxLCAxXTtcblx0XHR0aGlzLm9wYWNpdHkgPSAwLjU7XG5cdH1cblxuXG5cdGRyYXcoKSB7XG5cdFx0dGhpcy5zaGFkZXIuYmluZCgpO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oJ2NvbG9yJywgJ3VuaWZvcm0zZnYnLCB0aGlzLmNvbG9yKTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKCdvcGFjaXR5JywgJ3VuaWZvcm0xZicsIHRoaXMub3BhY2l0eSk7XG5cdFx0Ly8gR0wuZHJhdyh0aGlzLm1lc2gpO1xuXHRcdHN1cGVyLmRyYXcoKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXRjaERvdHNQbGFuZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL0JhdGNoRG90c1BsYW5lLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vIGJhc2ljLnZlcnRcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIERPVFNfUExBTkVfVkVSVEVYXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuYXR0cmlidXRlIHZlYzMgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMzIGFOb3JtYWw7XFxuXFxudW5pZm9ybSBtYXQ0IHVNb2RlbE1hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xcblxcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb25NYXRyaXggKiB1Vmlld01hdHJpeCAqIHVNb2RlbE1hdHJpeCAqIHZlYzQoYVZlcnRleFBvc2l0aW9uICsgYU5vcm1hbCAqIDAuMDAwMDAxLCAxLjApO1xcbiAgICBnbF9Qb2ludFNpemUgPSAxLjA7XFxuICAgIHZOb3JtYWwgPSBhTm9ybWFsO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9kb3RzUGxhbmUudmVydFxuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBCYXRjaExpbmUuanNcblxuXG5pbXBvcnQgR0wgZnJvbSAnLi4vR0xUb29sJztcbmltcG9ydCBNZXNoIGZyb20gJy4uL01lc2gnO1xuaW1wb3J0IEdMU2hhZGVyIGZyb20gJy4uL0dMU2hhZGVyJztcbmltcG9ydCBCYXRjaCBmcm9tICcuLi9CYXRjaCc7XG5cbmNvbnN0IHZzID0gcmVxdWlyZSgnLi4vc2hhZGVycy9iYXNpYy52ZXJ0Jyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvc2ltcGxlQ29sb3IuZnJhZycpO1xuXG5cblxuY2xhc3MgQmF0Y2hBeGlzIGV4dGVuZHMgQmF0Y2gge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuXHRcdGNvbnN0IGluZGljZXMgPSBbMCwgMV07XG5cdFx0Y29uc3QgY29vcmRzID0gW1swLCAwXSwgWzEsIDFdXTtcblx0XHRwb3NpdGlvbnMucHVzaChbMCwgIDAsICAwXSk7XG5cdFx0cG9zaXRpb25zLnB1c2goWzAsICAwLCAgMF0pO1xuXG5cdFx0Y29uc3QgbWVzaCA9IG5ldyBNZXNoKEdMLkxJTkVTKTtcblx0XHRtZXNoLmJ1ZmZlclZlcnRleChwb3NpdGlvbnMpO1xuXHRcdG1lc2guYnVmZmVyVGV4Q29vcmQoY29vcmRzKTtcblx0XHRtZXNoLmJ1ZmZlckluZGV4KGluZGljZXMpO1xuXG5cdFx0Y29uc3Qgc2hhZGVyID0gbmV3IEdMU2hhZGVyKHZzLCBmcyk7XG5cblx0XHRzdXBlcihtZXNoLCBzaGFkZXIpO1xuXHR9XG5cblxuXHRkcmF3KG1Qb3NpdGlvbkEsIG1Qb3NpdGlvbkIsIGNvbG9yID0gWzEsIDEsIDFdLCBvcGFjaXR5ID0gMS4wKSB7XG5cdFx0dGhpcy5fbWVzaC5idWZmZXJWZXJ0ZXgoW21Qb3NpdGlvbkEsIG1Qb3NpdGlvbkJdKTtcblxuXHRcdHRoaXMuX3NoYWRlci5iaW5kKCk7XG5cdFx0dGhpcy5fc2hhZGVyLnVuaWZvcm0oJ2NvbG9yJywgJ3ZlYzMnLCBjb2xvcik7XG5cdFx0dGhpcy5fc2hhZGVyLnVuaWZvcm0oJ29wYWNpdHknLCAnZmxvYXQnLCBvcGFjaXR5KTtcblx0XHRzdXBlci5kcmF3KCk7XG5cdH1cblxuXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgQmF0Y2hBeGlzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hMaW5lLmpzIiwiLy8gQmF0Y2hTa3lib3guanNcblxuaW1wb3J0IEdlb20gZnJvbSAnLi4vR2VvbSc7XG5pbXBvcnQgR0xTaGFkZXIgZnJvbSAnLi4vR0xTaGFkZXInO1xuaW1wb3J0IEJhdGNoIGZyb20gJy4uL0JhdGNoJztcblxuY29uc3QgdnMgPSByZXF1aXJlKCcuLi9zaGFkZXJzL3NreWJveC52ZXJ0Jyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvc2t5Ym94LmZyYWcnKTtcblxuXG5jbGFzcyBCYXRjaFNreWJveCBleHRlbmRzIEJhdGNoIHtcblxuXHRjb25zdHJ1Y3RvcihzaXplID0gMjApIHtcblx0XHRjb25zdCBtZXNoID0gR2VvbS5za3lib3goc2l6ZSk7XG5cdFx0Y29uc3Qgc2hhZGVyID0gbmV3IEdMU2hhZGVyKHZzLCBmcyk7XG5cblx0XHRzdXBlcihtZXNoLCBzaGFkZXIpO1xuXHR9XG5cblx0ZHJhdyh0ZXh0dXJlKSB7XG5cdFx0dGhpcy5zaGFkZXIuYmluZCgpO1xuXHRcdHRleHR1cmUuYmluZCgwKTtcblx0XHRzdXBlci5kcmF3KCk7XG5cdH1cblxuXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgQmF0Y2hTa3lib3g7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvaGVscGVycy9CYXRjaFNreWJveC5qcyIsIi8vIEJhdGNoU2t5LmpzXG5cbmltcG9ydCBHZW9tIGZyb20gJy4uL0dlb20nO1xuaW1wb3J0IEdMU2hhZGVyIGZyb20gJy4uL0dMU2hhZGVyJztcbmltcG9ydCBCYXRjaCBmcm9tICcuLi9CYXRjaCc7XG5cbmNvbnN0IHZzID0gcmVxdWlyZSgnLi4vc2hhZGVycy9za3kudmVydCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9zaGFkZXJzL2NvcHkuZnJhZycpO1xuXG5cbmNsYXNzIEJhdGNoU2t5IGV4dGVuZHMgQmF0Y2gge1xuXG5cdGNvbnN0cnVjdG9yKHNpemUgPSA1MCwgc2VnID0gMjQpIHtcblx0XHRjb25zdCBtZXNoID0gR2VvbS5zcGhlcmUoc2l6ZSwgc2VnLCB0cnVlKTtcblx0XHRjb25zdCBzaGFkZXIgPSBuZXcgR0xTaGFkZXIodnMsIGZzKTtcblxuXHRcdHN1cGVyKG1lc2gsIHNoYWRlcik7XG5cdH1cblxuXHRkcmF3KHRleHR1cmUpIHtcblx0XHR0aGlzLnNoYWRlci5iaW5kKCk7XG5cdFx0dGV4dHVyZS5iaW5kKDApO1xuXHRcdHN1cGVyLmRyYXcoKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXRjaFNreTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL0JhdGNoU2t5LmpzIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vIHNreS52ZXJ0XFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuYXR0cmlidXRlIHZlYzMgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuYXR0cmlidXRlIHZlYzMgYU5vcm1hbDtcXG5cXG51bmlmb3JtIG1hdDQgdU1vZGVsTWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1Vmlld01hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVByb2plY3Rpb25NYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG5cXHRtYXQ0IG1hdFZpZXcgPSB1Vmlld01hdHJpeDtcXG5cXHRtYXRWaWV3WzNdWzBdID0gMC4wO1xcblxcdG1hdFZpZXdbM11bMV0gPSAwLjA7XFxuXFx0bWF0Vmlld1szXVsyXSA9IDAuMDtcXG5cXHRcXG4gICAgZ2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIG1hdFZpZXcgKiB1TW9kZWxNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKTtcXG4gICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxuICAgIHZOb3JtYWwgPSBhTm9ybWFsO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9za3kudmVydFxuLy8gbW9kdWxlIGlkID0gOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBCYXRjaEZYQUEuanNcbmltcG9ydCBHTCBmcm9tICcuLi9HTFRvb2wnO1xuaW1wb3J0IEdlb20gZnJvbSAnLi4vR2VvbSc7XG5pbXBvcnQgR0xTaGFkZXIgZnJvbSAnLi4vR0xTaGFkZXInO1xuaW1wb3J0IEJhdGNoIGZyb20gJy4uL0JhdGNoJztcblxuY29uc3QgdnMgPSByZXF1aXJlKCcuLi9zaGFkZXJzL2JpZ1RyaWFuZ2xlLnZlcnQnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vc2hhZGVycy9meGFhLmZyYWcnKTtcblxuY2xhc3MgQmF0Y2hGWEFBIGV4dGVuZHMgQmF0Y2gge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdGNvbnN0IG1lc2ggPSBHZW9tLmJpZ1RyaWFuZ2xlKCk7XG5cdFx0Y29uc3Qgc2hhZGVyID0gbmV3IEdMU2hhZGVyKHZzLCBmcyk7XG5cdFx0c3VwZXIobWVzaCwgc2hhZGVyKTtcblxuXHRcdHNoYWRlci5iaW5kKCk7XG5cdFx0c2hhZGVyLnVuaWZvcm0oJ3RleHR1cmUnLCAndW5pZm9ybTFpJywgMCk7XG5cdH1cblxuXG5cdGRyYXcodGV4dHVyZSkge1xuXHRcdHRoaXMuc2hhZGVyLmJpbmQoKTtcblx0XHR0ZXh0dXJlLmJpbmQoMCk7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgndVJlc29sdXRpb24nLCAndmVjMicsIFsxL0dMLndpZHRoLCAxL0dMLmhlaWdodF0pO1xuXHRcdHN1cGVyLmRyYXcoKTtcblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhdGNoRlhBQTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL0JhdGNoRlhBQS5qcyIsIi8vIFNjZW5lLmpzXG5cbmltcG9ydCBTY2hlZHVsZXIgZnJvbSAnc2NoZWR1bGluZyc7XG5pbXBvcnQgR0wgZnJvbSAnLi4vR0xUb29sJztcbmltcG9ydCBDYW1lcmFQZXJzcGVjdGl2ZSBmcm9tICcuLi9jYW1lcmFzL0NhbWVyYVBlcnNwZWN0aXZlJztcbmltcG9ydCBDYW1lcmFPcnRobyBmcm9tICcuLi9jYW1lcmFzL0NhbWVyYU9ydGhvJztcbmltcG9ydCBPcmJpdGFsQ29udHJvbCBmcm9tICcuLi91dGlscy9PcmJpdGFsQ29udHJvbCc7XG5cblxuY2xhc3MgU2NlbmUge1xuXG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5fY2hpbGRyZW4gPSBbXTtcblx0XHR0aGlzLl9tYXRyaXhJZGVudGl0eSA9IG1hdDQuY3JlYXRlKCk7XG5cdFx0R0wuZW5hYmxlQWxwaGFCbGVuZGluZygpO1xuXG5cdFx0dGhpcy5faW5pdCgpO1xuXHRcdHRoaXMuX2luaXRUZXh0dXJlcygpO1xuXHRcdHRoaXMuX2luaXRWaWV3cygpO1xuXG5cdFx0dGhpcy5fZWZJbmRleCA9IFNjaGVkdWxlci5hZGRFRigoKT0+dGhpcy5fbG9vcCgpKTtcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgKCk9PnRoaXMucmVzaXplKCkpO1xuXHR9XG5cblxuXHRcblx0Ly9cdFBVQkxJQyBNRVRIT0RTXG5cblx0dXBkYXRlKCkge1xuXG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cblx0fVxuXG5cblx0c3RvcCgpIHtcblx0XHRpZih0aGlzLl9lZkluZGV4ID09PSAtMSkge1x0cmV0dXJuOyB9XG5cdFx0dGhpcy5fZWZJbmRleCA9IFNjaGVkdWxlci5yZW1vdmVFRih0aGlzLl9lZkluZGV4KTtcblx0fVxuXG5cblx0c3RhcnQoKSB7XG5cdFx0aWYodGhpcy5fZWZJbmRleCAhPT0gLTEpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IFxuXG5cdFx0dGhpcy5fZWZJbmRleCA9IFNjaGVkdWxlci5hZGRFRigoKT0+dGhpcy5fbG9vcCgpKTtcblx0fVxuXG5cblx0cmVzaXplKCkge1xuXHRcdEdMLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG5cdFx0dGhpcy5jYW1lcmEuc2V0QXNwZWN0UmF0aW8oR0wuYXNwZWN0UmF0aW8pO1xuXHR9XG5cblxuXHRhZGRDaGlsZChtQ2hpbGQpIHtcblx0XHR0aGlzLl9jaGlsZHJlbi5wdXNoKG1DaGlsZCk7XG5cdH1cblxuXHRyZW1vdmVDaGlsZChtQ2hpbGQpIHtcblx0XHRjb25zdCBpbmRleCA9IHRoaXMuX2NoaWxkcmVuLmluZGV4T2YobUNoaWxkKTtcblx0XHRpZihpbmRleCA9PSAtMSkge1x0Y29uc29sZS53YXJuKCdDaGlsZCBubyBleGlzdCcpOyByZXR1cm47XHR9XG5cblx0XHR0aGlzLl9jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuXHR9XG5cblxuXHQvL1x0UFJPVEVDVEVEIE1FVEhPRFMgVE8gQkUgT1ZFUlJJREVOIEJZIENISUxEUkVOXG5cblx0X2luaXRUZXh0dXJlcygpIHtcblxuXHR9XG5cblxuXHRfaW5pdFZpZXdzKCkge1xuXG5cdH1cblxuXG5cdF9yZW5kZXJDaGlsZHJlbigpIHtcblx0XHRsZXQgY2hpbGQ7XG5cdFx0Zm9yKGxldCBpPTA7IGk8dGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG5cdFx0XHRjaGlsZC50b1JlbmRlcigpO1xuXHRcdH1cblxuXHRcdEdMLnJvdGF0ZSh0aGlzLl9tYXRyaXhJZGVudGl0eSk7XG5cdH1cblxuXHQvL1x0UFJJVkFURSBNRVRIT0RTXG5cblx0X2luaXQoKSB7XG5cdFx0dGhpcy5jYW1lcmEgICAgICAgICAgICAgICAgID0gbmV3IENhbWVyYVBlcnNwZWN0aXZlKCk7XG5cdFx0dGhpcy5jYW1lcmEuc2V0UGVyc3BlY3RpdmUoNDUgKiBNYXRoLlBJIC8gMTgwLCBHTC5hc3BlY3RSYXRpbywgMC4xLCAxMDApO1xuXHRcdHRoaXMub3JiaXRhbENvbnRyb2wgICAgICAgICAgPSBuZXcgT3JiaXRhbENvbnRyb2wodGhpcy5jYW1lcmEsIHdpbmRvdywgMTUpO1xuXHRcdHRoaXMub3JiaXRhbENvbnRyb2wucmFkaXVzLnZhbHVlID0gMTA7XG5cdFx0XG5cdFx0dGhpcy5jYW1lcmFPcnRobyAgICAgICAgICAgID0gbmV3IENhbWVyYU9ydGhvKCk7XG5cdH1cblxuXHRfbG9vcCgpIHtcblxuXHRcdC8vXHRSRVNFVCBWSUVXUE9SVFxuXHRcdEdMLnZpZXdwb3J0KDAsIDAsIEdMLndpZHRoLCBHTC5oZWlnaHQpO1xuXG5cdFx0Ly9cdFJFU0VUIENBTUVSQVxuXHRcdEdMLnNldE1hdHJpY2VzKHRoaXMuY2FtZXJhKTtcblxuXHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0dGhpcy5fcmVuZGVyQ2hpbGRyZW4oKTtcblx0XHR0aGlzLnJlbmRlcigpO1xuXHR9XG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBTY2VuZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL1NjZW5lLmpzIiwiLy8gVmlldy5qc1xuXG5pbXBvcnQgR0xTaGFkZXIgZnJvbSAnLi4vR0xTaGFkZXInO1xuXG5jbGFzcyBWaWV3IHtcblx0Y29uc3RydWN0b3IobVN0clZlcnRleCwgbVN0ckZyYWcpIHtcblx0XHR0aGlzLnNoYWRlciA9IG5ldyBHTFNoYWRlcihtU3RyVmVydGV4LCBtU3RyRnJhZyk7XG5cblx0XHR0aGlzLl9pbml0KCk7XG5cdH1cblxuXG5cdC8vXHRQUk9URUNURUQgTUVUSE9EU1xuXG5cdF9pbml0KCkge1xuXG5cdH1cblxuXHQvLyBcdFBVQkxJQyBNRVRIT0RTXG5cblx0cmVuZGVyKCkge1xuXG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVmlldztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL1ZpZXcuanMiLCIvLyBWaWV3M0QuanNcblxuaW1wb3J0IE9iamVjdDNEIGZyb20gJy4uL29iamVjdHMvT2JqZWN0M0QnO1xuaW1wb3J0IEdMU2hhZGVyIGZyb20gJy4uL0dMU2hhZGVyJztcbmltcG9ydCBHTCBmcm9tICcuLi9HTFRvb2wnO1xuXG5jbGFzcyBWaWV3M0QgZXh0ZW5kcyBPYmplY3QzRCB7XG5cdGNvbnN0cnVjdG9yKG1TdHJWZXJ0ZXgsIG1TdHJGcmFnKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuX2NoaWxkcmVuID0gW107XG5cdFx0dGhpcy5zaGFkZXIgPSBuZXcgR0xTaGFkZXIobVN0clZlcnRleCwgbVN0ckZyYWcpO1xuXHRcdHRoaXMuX2luaXQoKTtcblx0XHR0aGlzLl9tYXRyaXhUZW1wID0gbWF0NC5jcmVhdGUoKTtcblx0fVxuXG5cblx0Ly9cdFBST1RFQ1RFRCBNRVRIT0RTXG5cblx0X2luaXQoKSB7XG5cblx0fVxuXG5cdC8vIFx0UFVCTElDIE1FVEhPRFNcblxuXHRhZGRDaGlsZChtQ2hpbGQpIHtcblx0XHR0aGlzLl9jaGlsZHJlbi5wdXNoKG1DaGlsZCk7XG5cdH1cblxuXHRyZW1vdmVDaGlsZChtQ2hpbGQpIHtcblx0XHRjb25zdCBpbmRleCA9IHRoaXMuX2NoaWxkcmVuLmluZGV4T2YobUNoaWxkKTtcblx0XHRpZihpbmRleCA9PSAtMSkge1x0Y29uc29sZS53YXJuKCdDaGlsZCBubyBleGlzdCcpOyByZXR1cm47XHR9XG5cblx0XHR0aGlzLl9jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuXHR9XG5cblxuXHR0b1JlbmRlcihtYXRyaXgpIHtcblx0XHRpZihtYXRyaXggPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0bWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcblx0XHR9XG5cdFx0bWF0NC5tdWwodGhpcy5fbWF0cml4VGVtcCwgbWF0cml4LCB0aGlzLm1hdHJpeCk7XG5cdFx0R0wucm90YXRlKHRoaXMuX21hdHJpeFRlbXApO1xuXHRcdHRoaXMucmVuZGVyKCk7XG5cblx0XHRmb3IobGV0IGk9MDsgaTx0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcblx0XHRcdGNoaWxkLnRvUmVuZGVyKHRoaXMubWF0cml4KTtcblx0XHR9XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cblx0fVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IFZpZXczRDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL1ZpZXczRC5qcyIsIi8vIGRlYnVnLmpzXG5pbXBvcnQgZGF0IGZyb20gJ2RhdC1ndWknO1xuaW1wb3J0IFN0YXRzIGZyb20gJ3N0YXRzLmpzJztcbmltcG9ydCBhbGZyaWQsIHsgR0wgfSBmcm9tICdhbGZyaWQnO1xuXG5cbi8vXHRJTklUIERBVC1HVUlcbndpbmRvdy5ndWkgPSBuZXcgZGF0LkdVSSh7IHdpZHRoOjMwMCB9KTtcbmNvbnN0IGRpdiA9IGRvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvcignLmRnLmFjJyk7XG5kaXYuc3R5bGUuekluZGV4ID0gJzk5OSc7XG5cbi8vXHRTVEFUU1xuY29uc3Qgc3RhdHMgPSBuZXcgU3RhdHMoKTtcbmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3RhdHMuZG9tRWxlbWVudCk7XG5hbGZyaWQuU2NoZWR1bGVyLmFkZEVGKCgpPT5zdGF0cy51cGRhdGUoKSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2RlYnVnL2RlYnVnLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3ZlbmRvci9kYXQuZ3VpJylcbm1vZHVsZS5leHBvcnRzLmNvbG9yID0gcmVxdWlyZSgnLi92ZW5kb3IvZGF0LmNvbG9yJylcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kYXQtZ3VpL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLyoqXG4gKiBkYXQtZ3VpIEphdmFTY3JpcHQgQ29udHJvbGxlciBMaWJyYXJ5XG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZGF0LWd1aVxuICpcbiAqIENvcHlyaWdodCAyMDExIERhdGEgQXJ0cyBUZWFtLCBHb29nbGUgQ3JlYXRpdmUgTGFiXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbi8qKiBAbmFtZXNwYWNlICovXG52YXIgZGF0ID0gbW9kdWxlLmV4cG9ydHMgPSBkYXQgfHwge307XG5cbi8qKiBAbmFtZXNwYWNlICovXG5kYXQuZ3VpID0gZGF0Lmd1aSB8fCB7fTtcblxuLyoqIEBuYW1lc3BhY2UgKi9cbmRhdC51dGlscyA9IGRhdC51dGlscyB8fCB7fTtcblxuLyoqIEBuYW1lc3BhY2UgKi9cbmRhdC5jb250cm9sbGVycyA9IGRhdC5jb250cm9sbGVycyB8fCB7fTtcblxuLyoqIEBuYW1lc3BhY2UgKi9cbmRhdC5kb20gPSBkYXQuZG9tIHx8IHt9O1xuXG4vKiogQG5hbWVzcGFjZSAqL1xuZGF0LmNvbG9yID0gZGF0LmNvbG9yIHx8IHt9O1xuXG5kYXQudXRpbHMuY3NzID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICBsb2FkOiBmdW5jdGlvbiAodXJsLCBkb2MpIHtcbiAgICAgIGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcbiAgICAgIHZhciBsaW5rID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcbiAgICAgIGxpbmsudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgICBsaW5rLnJlbCA9ICdzdHlsZXNoZWV0JztcbiAgICAgIGxpbmsuaHJlZiA9IHVybDtcbiAgICAgIGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGxpbmspO1xuICAgIH0sXG4gICAgaW5qZWN0OiBmdW5jdGlvbihjc3MsIGRvYykge1xuICAgICAgZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuICAgICAgdmFyIGluamVjdGVkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgIGluamVjdGVkLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgICAgaW5qZWN0ZWQuaW5uZXJIVE1MID0gY3NzO1xuICAgICAgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoaW5qZWN0ZWQpO1xuICAgIH1cbiAgfVxufSkoKTtcblxuXG5kYXQudXRpbHMuY29tbW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgXG4gIHZhciBBUlJfRUFDSCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xuICB2YXIgQVJSX1NMSUNFID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gIC8qKlxuICAgKiBCYW5kLWFpZCBtZXRob2RzIGZvciB0aGluZ3MgdGhhdCBzaG91bGQgYmUgYSBsb3QgZWFzaWVyIGluIEphdmFTY3JpcHQuXG4gICAqIEltcGxlbWVudGF0aW9uIGFuZCBzdHJ1Y3R1cmUgaW5zcGlyZWQgYnkgdW5kZXJzY29yZS5qc1xuICAgKiBodHRwOi8vZG9jdW1lbnRjbG91ZC5naXRodWIuY29tL3VuZGVyc2NvcmUvXG4gICAqL1xuXG4gIHJldHVybiB7IFxuICAgIFxuICAgIEJSRUFLOiB7fSxcbiAgXG4gICAgZXh0ZW5kOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIFxuICAgICAgdGhpcy5lYWNoKEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iailcbiAgICAgICAgICBpZiAoIXRoaXMuaXNVbmRlZmluZWQob2JqW2tleV0pKSBcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIFxuICAgICAgfSwgdGhpcyk7XG4gICAgICBcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICBcbiAgICB9LFxuICAgIFxuICAgIGRlZmF1bHRzOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIFxuICAgICAgdGhpcy5lYWNoKEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iailcbiAgICAgICAgICBpZiAodGhpcy5pc1VuZGVmaW5lZCh0YXJnZXRba2V5XSkpIFxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICBcbiAgICB9LFxuICAgIFxuICAgIGNvbXBvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRvQ2FsbCA9IEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBhcmdzID0gQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRvQ2FsbC5sZW5ndGggLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgYXJncyA9IFt0b0NhbGxbaV0uYXBwbHkodGhpcywgYXJncyldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgICAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgZWFjaDogZnVuY3Rpb24ob2JqLCBpdHIsIHNjb3BlKSB7XG5cbiAgICAgIFxuICAgICAgaWYgKEFSUl9FQUNIICYmIG9iai5mb3JFYWNoID09PSBBUlJfRUFDSCkgeyBcbiAgICAgICAgXG4gICAgICAgIG9iai5mb3JFYWNoKGl0ciwgc2NvcGUpO1xuICAgICAgICBcbiAgICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gb2JqLmxlbmd0aCArIDApIHsgLy8gSXMgbnVtYmVyIGJ1dCBub3QgTmFOXG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBrZXkgPSAwLCBsID0gb2JqLmxlbmd0aDsga2V5IDwgbDsga2V5KyspXG4gICAgICAgICAgaWYgKGtleSBpbiBvYmogJiYgaXRyLmNhbGwoc2NvcGUsIG9ialtrZXldLCBrZXkpID09PSB0aGlzLkJSRUFLKSBcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIFxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBcbiAgICAgICAgICBpZiAoaXRyLmNhbGwoc2NvcGUsIG9ialtrZXldLCBrZXkpID09PSB0aGlzLkJSRUFLKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgXG4gICAgICB9XG4gICAgICAgICAgICBcbiAgICB9LFxuICAgIFxuICAgIGRlZmVyOiBmdW5jdGlvbihmbmMpIHtcbiAgICAgIHNldFRpbWVvdXQoZm5jLCAwKTtcbiAgICB9LFxuICAgIFxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgaWYgKG9iai50b0FycmF5KSByZXR1cm4gb2JqLnRvQXJyYXkoKTtcbiAgICAgIHJldHVybiBBUlJfU0xJQ0UuY2FsbChvYmopO1xuICAgIH0sXG5cbiAgICBpc1VuZGVmaW5lZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBcbiAgICBpc051bGw6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgICB9LFxuICAgIFxuICAgIGlzTmFOOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogIT09IG9iajtcbiAgICB9LFxuICAgIFxuICAgIGlzQXJyYXk6IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqLmNvbnN0cnVjdG9yID09PSBBcnJheTtcbiAgICB9LFxuICAgIFxuICAgIGlzT2JqZWN0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IE9iamVjdChvYmopO1xuICAgIH0sXG4gICAgXG4gICAgaXNOdW1iZXI6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gb2JqKzA7XG4gICAgfSxcbiAgICBcbiAgICBpc1N0cmluZzogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBvYmorJyc7XG4gICAgfSxcbiAgICBcbiAgICBpc0Jvb2xlYW46IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gZmFsc2UgfHwgb2JqID09PSB0cnVlO1xuICAgIH0sXG4gICAgXG4gICAgaXNGdW5jdGlvbjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfVxuICBcbiAgfTtcbiAgICBcbn0pKCk7XG5cblxuZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKGNvbW1vbikge1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgQW4gXCJhYnN0cmFjdFwiIGNsYXNzIHRoYXQgcmVwcmVzZW50cyBhIGdpdmVuIHByb3BlcnR5IG9mIGFuIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICpcbiAgICogQG1lbWJlciBkYXQuY29udHJvbGxlcnNcbiAgICovXG4gIHZhciBDb250cm9sbGVyID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuXG4gICAgdGhpcy5pbml0aWFsVmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuXG4gICAgLyoqXG4gICAgICogVGhvc2Ugd2hvIGV4dGVuZCB0aGlzIGNsYXNzIHdpbGwgcHV0IHRoZWlyIERPTSBlbGVtZW50cyBpbiBoZXJlLlxuICAgICAqIEB0eXBlIHtET01FbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9iamVjdCB0byBtYW5pcHVsYXRlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBtYW5pcHVsYXRlXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGNoYW5nZS5cbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX19vbkNoYW5nZSA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gZmluaXNoaW5nIGNoYW5nZS5cbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZSA9IHVuZGVmaW5lZDtcblxuICB9O1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIENvbnRyb2xsZXIucHJvdG90eXBlLFxuXG4gICAgICAvKiogQGxlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyLnByb3RvdHlwZSAqL1xuICAgICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZ5IHRoYXQgYSBmdW5jdGlvbiBmaXJlIGV2ZXJ5IHRpbWUgc29tZW9uZSBjaGFuZ2VzIHRoZSB2YWx1ZSB3aXRoXG4gICAgICAgICAqIHRoaXMgQ29udHJvbGxlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5jIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIHZhbHVlXG4gICAgICAgICAqIGlzIG1vZGlmaWVkIHZpYSB0aGlzIENvbnRyb2xsZXIuXG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcn0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uKGZuYykge1xuICAgICAgICAgIHRoaXMuX19vbkNoYW5nZSA9IGZuYztcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmeSB0aGF0IGEgZnVuY3Rpb24gZmlyZSBldmVyeSB0aW1lIHNvbWVvbmUgXCJmaW5pc2hlc1wiIGNoYW5naW5nXG4gICAgICAgICAqIHRoZSB2YWx1ZSB3aWggdGhpcyBDb250cm9sbGVyLiBVc2VmdWwgZm9yIHZhbHVlcyB0aGF0IGNoYW5nZVxuICAgICAgICAgKiBpbmNyZW1lbnRhbGx5IGxpa2UgbnVtYmVycyBvciBzdHJpbmdzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbmMgVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlclxuICAgICAgICAgKiBzb21lb25lIFwiZmluaXNoZXNcIiBjaGFuZ2luZyB0aGUgdmFsdWUgdmlhIHRoaXMgQ29udHJvbGxlci5cbiAgICAgICAgICogQHJldHVybnMge2RhdC5jb250cm9sbGVycy5Db250cm9sbGVyfSB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBvbkZpbmlzaENoYW5nZTogZnVuY3Rpb24oZm5jKSB7XG4gICAgICAgICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlID0gZm5jO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGFuZ2UgdGhlIHZhbHVlIG9mIDxjb2RlPm9iamVjdFtwcm9wZXJ0eV08L2NvZGU+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIG9mIDxjb2RlPm9iamVjdFtwcm9wZXJ0eV08L2NvZGU+XG4gICAgICAgICAqL1xuICAgICAgICBzZXRWYWx1ZTogZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICAgICAgICB0aGlzLm9iamVjdFt0aGlzLnByb3BlcnR5XSA9IG5ld1ZhbHVlO1xuICAgICAgICAgIGlmICh0aGlzLl9fb25DaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX19vbkNoYW5nZS5jYWxsKHRoaXMsIG5ld1ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIHZhbHVlIG9mIDxjb2RlPm9iamVjdFtwcm9wZXJ0eV08L2NvZGU+XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBjdXJyZW50IHZhbHVlIG9mIDxjb2RlPm9iamVjdFtwcm9wZXJ0eV08L2NvZGU+XG4gICAgICAgICAqL1xuICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0W3RoaXMucHJvcGVydHldO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZyZXNoZXMgdGhlIHZpc3VhbCBkaXNwbGF5IG9mIGEgQ29udHJvbGxlciBpbiBvcmRlciB0byBrZWVwIHN5bmNcbiAgICAgICAgICogd2l0aCB0aGUgb2JqZWN0J3MgY3VycmVudCB2YWx1ZS5cbiAgICAgICAgICogQHJldHVybnMge2RhdC5jb250cm9sbGVycy5Db250cm9sbGVyfSB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVEaXNwbGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhlIHZhbHVlIGhhcyBkZXZpYXRlZCBmcm9tIGluaXRpYWxWYWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNNb2RpZmllZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbFZhbHVlICE9PSB0aGlzLmdldFZhbHVlKClcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgKTtcblxuICByZXR1cm4gQ29udHJvbGxlcjtcblxuXG59KShkYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuZG9tLmRvbSA9IChmdW5jdGlvbiAoY29tbW9uKSB7XG5cbiAgdmFyIEVWRU5UX01BUCA9IHtcbiAgICAnSFRNTEV2ZW50cyc6IFsnY2hhbmdlJ10sXG4gICAgJ01vdXNlRXZlbnRzJzogWydjbGljaycsJ21vdXNlbW92ZScsJ21vdXNlZG93bicsJ21vdXNldXAnLCAnbW91c2VvdmVyJ10sXG4gICAgJ0tleWJvYXJkRXZlbnRzJzogWydrZXlkb3duJ11cbiAgfTtcblxuICB2YXIgRVZFTlRfTUFQX0lOViA9IHt9O1xuICBjb21tb24uZWFjaChFVkVOVF9NQVAsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICBjb21tb24uZWFjaCh2LCBmdW5jdGlvbihlKSB7XG4gICAgICBFVkVOVF9NQVBfSU5WW2VdID0gaztcbiAgICB9KTtcbiAgfSk7XG5cbiAgdmFyIENTU19WQUxVRV9QSVhFTFMgPSAvKFxcZCsoXFwuXFxkKyk/KXB4LztcblxuICBmdW5jdGlvbiBjc3NWYWx1ZVRvUGl4ZWxzKHZhbCkge1xuXG4gICAgaWYgKHZhbCA9PT0gJzAnIHx8IGNvbW1vbi5pc1VuZGVmaW5lZCh2YWwpKSByZXR1cm4gMDtcblxuICAgIHZhciBtYXRjaCA9IHZhbC5tYXRjaChDU1NfVkFMVUVfUElYRUxTKTtcblxuICAgIGlmICghY29tbW9uLmlzTnVsbChtYXRjaCkpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIC4uLmVtcz8gJT9cblxuICAgIHJldHVybiAwO1xuXG4gIH1cblxuICAvKipcbiAgICogQG5hbWVzcGFjZVxuICAgKiBAbWVtYmVyIGRhdC5kb21cbiAgICovXG4gIHZhciBkb20gPSB7XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqIEBwYXJhbSBzZWxlY3RhYmxlXG4gICAgICovXG4gICAgbWFrZVNlbGVjdGFibGU6IGZ1bmN0aW9uKGVsZW0sIHNlbGVjdGFibGUpIHtcblxuICAgICAgaWYgKGVsZW0gPT09IHVuZGVmaW5lZCB8fCBlbGVtLnN0eWxlID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgICAgZWxlbS5vbnNlbGVjdHN0YXJ0ID0gc2VsZWN0YWJsZSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IDogZnVuY3Rpb24oKSB7XG4gICAgICB9O1xuXG4gICAgICBlbGVtLnN0eWxlLk1velVzZXJTZWxlY3QgPSBzZWxlY3RhYmxlID8gJ2F1dG8nIDogJ25vbmUnO1xuICAgICAgZWxlbS5zdHlsZS5LaHRtbFVzZXJTZWxlY3QgPSBzZWxlY3RhYmxlID8gJ2F1dG8nIDogJ25vbmUnO1xuICAgICAgZWxlbS51bnNlbGVjdGFibGUgPSBzZWxlY3RhYmxlID8gJ29uJyA6ICdvZmYnO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKiBAcGFyYW0gaG9yaXpvbnRhbFxuICAgICAqIEBwYXJhbSB2ZXJ0aWNhbFxuICAgICAqL1xuICAgIG1ha2VGdWxsc2NyZWVuOiBmdW5jdGlvbihlbGVtLCBob3Jpem9udGFsLCB2ZXJ0aWNhbCkge1xuXG4gICAgICBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKGhvcml6b250YWwpKSBob3Jpem9udGFsID0gdHJ1ZTtcbiAgICAgIGlmIChjb21tb24uaXNVbmRlZmluZWQodmVydGljYWwpKSB2ZXJ0aWNhbCA9IHRydWU7XG5cbiAgICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXG4gICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICBlbGVtLnN0eWxlLmxlZnQgPSAwO1xuICAgICAgICBlbGVtLnN0eWxlLnJpZ2h0ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICBlbGVtLnN0eWxlLnRvcCA9IDA7XG4gICAgICAgIGVsZW0uc3R5bGUuYm90dG9tID0gMDtcbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICogQHBhcmFtIGV2ZW50VHlwZVxuICAgICAqIEBwYXJhbSBwYXJhbXNcbiAgICAgKi9cbiAgICBmYWtlRXZlbnQ6IGZ1bmN0aW9uKGVsZW0sIGV2ZW50VHlwZSwgcGFyYW1zLCBhdXgpIHtcbiAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgIHZhciBjbGFzc05hbWUgPSBFVkVOVF9NQVBfSU5WW2V2ZW50VHlwZV07XG4gICAgICBpZiAoIWNsYXNzTmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50IHR5cGUgJyArIGV2ZW50VHlwZSArICcgbm90IHN1cHBvcnRlZC4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChjbGFzc05hbWUpO1xuICAgICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgICAgY2FzZSAnTW91c2VFdmVudHMnOlxuICAgICAgICAgIHZhciBjbGllbnRYID0gcGFyYW1zLnggfHwgcGFyYW1zLmNsaWVudFggfHwgMDtcbiAgICAgICAgICB2YXIgY2xpZW50WSA9IHBhcmFtcy55IHx8IHBhcmFtcy5jbGllbnRZIHx8IDA7XG4gICAgICAgICAgZXZ0LmluaXRNb3VzZUV2ZW50KGV2ZW50VHlwZSwgcGFyYW1zLmJ1YmJsZXMgfHwgZmFsc2UsXG4gICAgICAgICAgICAgIHBhcmFtcy5jYW5jZWxhYmxlIHx8IHRydWUsIHdpbmRvdywgcGFyYW1zLmNsaWNrQ291bnQgfHwgMSxcbiAgICAgICAgICAgICAgMCwgLy9zY3JlZW4gWFxuICAgICAgICAgICAgICAwLCAvL3NjcmVlbiBZXG4gICAgICAgICAgICAgIGNsaWVudFgsIC8vY2xpZW50IFhcbiAgICAgICAgICAgICAgY2xpZW50WSwgLy9jbGllbnQgWVxuICAgICAgICAgICAgICBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0tleWJvYXJkRXZlbnRzJzpcbiAgICAgICAgICB2YXIgaW5pdCA9IGV2dC5pbml0S2V5Ym9hcmRFdmVudCB8fCBldnQuaW5pdEtleUV2ZW50OyAvLyB3ZWJraXQgfHwgbW96XG4gICAgICAgICAgY29tbW9uLmRlZmF1bHRzKHBhcmFtcywge1xuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGN0cmxLZXk6IGZhbHNlLFxuICAgICAgICAgICAgYWx0S2V5OiBmYWxzZSxcbiAgICAgICAgICAgIHNoaWZ0S2V5OiBmYWxzZSxcbiAgICAgICAgICAgIG1ldGFLZXk6IGZhbHNlLFxuICAgICAgICAgICAga2V5Q29kZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2hhckNvZGU6IHVuZGVmaW5lZFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGluaXQoZXZlbnRUeXBlLCBwYXJhbXMuYnViYmxlcyB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgcGFyYW1zLmNhbmNlbGFibGUsIHdpbmRvdyxcbiAgICAgICAgICAgICAgcGFyYW1zLmN0cmxLZXksIHBhcmFtcy5hbHRLZXksXG4gICAgICAgICAgICAgIHBhcmFtcy5zaGlmdEtleSwgcGFyYW1zLm1ldGFLZXksXG4gICAgICAgICAgICAgIHBhcmFtcy5rZXlDb2RlLCBwYXJhbXMuY2hhckNvZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGV2dC5pbml0RXZlbnQoZXZlbnRUeXBlLCBwYXJhbXMuYnViYmxlcyB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgcGFyYW1zLmNhbmNlbGFibGUgfHwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb21tb24uZGVmYXVsdHMoZXZ0LCBhdXgpO1xuICAgICAgZWxlbS5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKiBAcGFyYW0gZnVuY1xuICAgICAqIEBwYXJhbSBib29sXG4gICAgICovXG4gICAgYmluZDogZnVuY3Rpb24oZWxlbSwgZXZlbnQsIGZ1bmMsIGJvb2wpIHtcbiAgICAgIGJvb2wgPSBib29sIHx8IGZhbHNlO1xuICAgICAgaWYgKGVsZW0uYWRkRXZlbnRMaXN0ZW5lcilcbiAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmdW5jLCBib29sKTtcbiAgICAgIGVsc2UgaWYgKGVsZW0uYXR0YWNoRXZlbnQpXG4gICAgICAgIGVsZW0uYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBmdW5jKTtcbiAgICAgIHJldHVybiBkb207XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKiBAcGFyYW0gZnVuY1xuICAgICAqIEBwYXJhbSBib29sXG4gICAgICovXG4gICAgdW5iaW5kOiBmdW5jdGlvbihlbGVtLCBldmVudCwgZnVuYywgYm9vbCkge1xuICAgICAgYm9vbCA9IGJvb2wgfHwgZmFsc2U7XG4gICAgICBpZiAoZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKVxuICAgICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGZ1bmMsIGJvb2wpO1xuICAgICAgZWxzZSBpZiAoZWxlbS5kZXRhY2hFdmVudClcbiAgICAgICAgZWxlbS5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGZ1bmMpO1xuICAgICAgcmV0dXJuIGRvbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqIEBwYXJhbSBjbGFzc05hbWVcbiAgICAgKi9cbiAgICBhZGRDbGFzczogZnVuY3Rpb24oZWxlbSwgY2xhc3NOYW1lKSB7XG4gICAgICBpZiAoZWxlbS5jbGFzc05hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbS5jbGFzc05hbWUgIT09IGNsYXNzTmFtZSkge1xuICAgICAgICB2YXIgY2xhc3NlcyA9IGVsZW0uY2xhc3NOYW1lLnNwbGl0KC8gKy8pO1xuICAgICAgICBpZiAoY2xhc3Nlcy5pbmRleE9mKGNsYXNzTmFtZSkgPT0gLTEpIHtcbiAgICAgICAgICBjbGFzc2VzLnB1c2goY2xhc3NOYW1lKTtcbiAgICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbignICcpLnJlcGxhY2UoL15cXHMrLywgJycpLnJlcGxhY2UoL1xccyskLywgJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZG9tO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICogQHBhcmFtIGNsYXNzTmFtZVxuICAgICAqL1xuICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbihlbGVtLCBjbGFzc05hbWUpIHtcbiAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgaWYgKGVsZW0uY2xhc3NOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtLmNsYXNzTmFtZSA9PT0gY2xhc3NOYW1lKSB7XG4gICAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNsYXNzZXMgPSBlbGVtLmNsYXNzTmFtZS5zcGxpdCgvICsvKTtcbiAgICAgICAgICB2YXIgaW5kZXggPSBjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKTtcbiAgICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcbiAgICAgICAgICAgIGNsYXNzZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGVsZW0uY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkb207XG4gICAgfSxcblxuICAgIGhhc0NsYXNzOiBmdW5jdGlvbihlbGVtLCBjbGFzc05hbWUpIHtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKCcoPzpefFxcXFxzKyknICsgY2xhc3NOYW1lICsgJyg/OlxcXFxzK3wkKScpLnRlc3QoZWxlbS5jbGFzc05hbWUpIHx8IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICovXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKGVsZW0pIHtcblxuICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcblxuICAgICAgcmV0dXJuIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci1sZWZ0LXdpZHRoJ10pICtcbiAgICAgICAgICBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydib3JkZXItcmlnaHQtd2lkdGgnXSkgK1xuICAgICAgICAgIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3BhZGRpbmctbGVmdCddKSArXG4gICAgICAgICAgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy1yaWdodCddKSArXG4gICAgICAgICAgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnd2lkdGgnXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKi9cbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKGVsZW0pIHtcblxuICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcblxuICAgICAgcmV0dXJuIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci10b3Atd2lkdGgnXSkgK1xuICAgICAgICAgIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci1ib3R0b20td2lkdGgnXSkgK1xuICAgICAgICAgIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3BhZGRpbmctdG9wJ10pICtcbiAgICAgICAgICBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydwYWRkaW5nLWJvdHRvbSddKSArXG4gICAgICAgICAgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnaGVpZ2h0J10pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICovXG4gICAgZ2V0T2Zmc2V0OiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0ge2xlZnQ6IDAsIHRvcDowfTtcbiAgICAgIGlmIChlbGVtLm9mZnNldFBhcmVudCkge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgb2Zmc2V0LmxlZnQgKz0gZWxlbS5vZmZzZXRMZWZ0O1xuICAgICAgICAgIG9mZnNldC50b3AgKz0gZWxlbS5vZmZzZXRUb3A7XG4gICAgICAgIH0gd2hpbGUgKGVsZW0gPSBlbGVtLm9mZnNldFBhcmVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH0sXG5cbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcG9zdHMvMjY4NDU2MS9yZXZpc2lvbnNcbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqL1xuICAgIGlzQWN0aXZlOiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICByZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgKTtcbiAgICB9XG5cbiAgfTtcblxuICByZXR1cm4gZG9tO1xuXG59KShkYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuY29udHJvbGxlcnMuT3B0aW9uQ29udHJvbGxlciA9IChmdW5jdGlvbiAoQ29udHJvbGxlciwgZG9tLCBjb21tb24pIHtcblxuICAvKipcbiAgICogQGNsYXNzIFByb3ZpZGVzIGEgc2VsZWN0IGlucHV0IHRvIGFsdGVyIHRoZSBwcm9wZXJ0eSBvZiBhbiBvYmplY3QsIHVzaW5nIGFcbiAgICogbGlzdCBvZiBhY2NlcHRlZCB2YWx1ZXMuXG4gICAqXG4gICAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ1tdfSBvcHRpb25zIEEgbWFwIG9mIGxhYmVscyB0byBhY2NlcHRhYmxlIHZhbHVlcywgb3JcbiAgICogYSBsaXN0IG9mIGFjY2VwdGFibGUgc3RyaW5nIHZhbHVlcy5cbiAgICpcbiAgICogQG1lbWJlciBkYXQuY29udHJvbGxlcnNcbiAgICovXG4gIHZhciBPcHRpb25Db250cm9sbGVyID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgb3B0aW9ucykge1xuXG4gICAgT3B0aW9uQ29udHJvbGxlci5zdXBlcmNsYXNzLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRyb3AgZG93biBtZW51XG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuX19zZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcblxuICAgIGlmIChjb21tb24uaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgdmFyIG1hcCA9IHt9O1xuICAgICAgY29tbW9uLmVhY2gob3B0aW9ucywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICBtYXBbZWxlbWVudF0gPSBlbGVtZW50O1xuICAgICAgfSk7XG4gICAgICBvcHRpb25zID0gbWFwO1xuICAgIH1cblxuICAgIGNvbW1vbi5lYWNoKG9wdGlvbnMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblxuICAgICAgdmFyIG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgb3B0LmlubmVySFRNTCA9IGtleTtcbiAgICAgIG9wdC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgdmFsdWUpO1xuICAgICAgX3RoaXMuX19zZWxlY3QuYXBwZW5kQ2hpbGQob3B0KTtcblxuICAgIH0pO1xuXG4gICAgLy8gQWNrbm93bGVkZ2Ugb3JpZ2luYWwgdmFsdWVcbiAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblxuICAgIGRvbS5iaW5kKHRoaXMuX19zZWxlY3QsICdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkZXNpcmVkVmFsdWUgPSB0aGlzLm9wdGlvbnNbdGhpcy5zZWxlY3RlZEluZGV4XS52YWx1ZTtcbiAgICAgIF90aGlzLnNldFZhbHVlKGRlc2lyZWRWYWx1ZSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX3NlbGVjdCk7XG5cbiAgfTtcblxuICBPcHRpb25Db250cm9sbGVyLnN1cGVyY2xhc3MgPSBDb250cm9sbGVyO1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIE9wdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLFxuICAgICAgQ29udHJvbGxlci5wcm90b3R5cGUsXG5cbiAgICAgIHtcblxuICAgICAgICBzZXRWYWx1ZTogZnVuY3Rpb24odikge1xuICAgICAgICAgIHZhciB0b1JldHVybiA9IE9wdGlvbkNvbnRyb2xsZXIuc3VwZXJjbGFzcy5wcm90b3R5cGUuc2V0VmFsdWUuY2FsbCh0aGlzLCB2KTtcbiAgICAgICAgICBpZiAodGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbCh0aGlzLCB0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdG9SZXR1cm47XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlRGlzcGxheTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5fX3NlbGVjdC52YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uQ29udHJvbGxlci5zdXBlcmNsYXNzLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5LmNhbGwodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICk7XG5cbiAgcmV0dXJuIE9wdGlvbkNvbnRyb2xsZXI7XG5cbn0pKGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyLFxuZGF0LmRvbS5kb20sXG5kYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlciA9IChmdW5jdGlvbiAoQ29udHJvbGxlciwgY29tbW9uKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBSZXByZXNlbnRzIGEgZ2l2ZW4gcHJvcGVydHkgb2YgYW4gb2JqZWN0IHRoYXQgaXMgYSBudW1iZXIuXG4gICAqXG4gICAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLm1pbl0gTWluaW11bSBhbGxvd2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLm1heF0gTWF4aW11bSBhbGxvd2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLnN0ZXBdIEluY3JlbWVudCBieSB3aGljaCB0byBjaGFuZ2UgdmFsdWVcbiAgICpcbiAgICogQG1lbWJlciBkYXQuY29udHJvbGxlcnNcbiAgICovXG4gIHZhciBOdW1iZXJDb250cm9sbGVyID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSB7XG5cbiAgICBOdW1iZXJDb250cm9sbGVyLnN1cGVyY2xhc3MuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuICAgIHRoaXMuX19taW4gPSBwYXJhbXMubWluO1xuICAgIHRoaXMuX19tYXggPSBwYXJhbXMubWF4O1xuICAgIHRoaXMuX19zdGVwID0gcGFyYW1zLnN0ZXA7XG5cbiAgICBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKHRoaXMuX19zdGVwKSkge1xuXG4gICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWUgPT0gMCkge1xuICAgICAgICB0aGlzLl9faW1wbGllZFN0ZXAgPSAxOyAvLyBXaGF0IGFyZSB3ZSwgcHN5Y2hpY3M/XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIZXkgRG91ZywgY2hlY2sgdGhpcyBvdXQuXG4gICAgICAgIHRoaXMuX19pbXBsaWVkU3RlcCA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nKHRoaXMuaW5pdGlhbFZhbHVlKS9NYXRoLkxOMTApKS8xMDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHRoaXMuX19pbXBsaWVkU3RlcCA9IHRoaXMuX19zdGVwO1xuXG4gICAgfVxuXG4gICAgdGhpcy5fX3ByZWNpc2lvbiA9IG51bURlY2ltYWxzKHRoaXMuX19pbXBsaWVkU3RlcCk7XG5cblxuICB9O1xuXG4gIE51bWJlckNvbnRyb2xsZXIuc3VwZXJjbGFzcyA9IENvbnRyb2xsZXI7XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgTnVtYmVyQ29udHJvbGxlci5wcm90b3R5cGUsXG4gICAgICBDb250cm9sbGVyLnByb3RvdHlwZSxcblxuICAgICAgLyoqIEBsZW5kcyBkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlci5wcm90b3R5cGUgKi9cbiAgICAgIHtcblxuICAgICAgICBzZXRWYWx1ZTogZnVuY3Rpb24odikge1xuXG4gICAgICAgICAgaWYgKHRoaXMuX19taW4gIT09IHVuZGVmaW5lZCAmJiB2IDwgdGhpcy5fX21pbikge1xuICAgICAgICAgICAgdiA9IHRoaXMuX19taW47XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9fbWF4ICE9PSB1bmRlZmluZWQgJiYgdiA+IHRoaXMuX19tYXgpIHtcbiAgICAgICAgICAgIHYgPSB0aGlzLl9fbWF4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLl9fc3RlcCAhPT0gdW5kZWZpbmVkICYmIHYgJSB0aGlzLl9fc3RlcCAhPSAwKSB7XG4gICAgICAgICAgICB2ID0gTWF0aC5yb3VuZCh2IC8gdGhpcy5fX3N0ZXApICogdGhpcy5fX3N0ZXA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXIuc3VwZXJjbGFzcy5wcm90b3R5cGUuc2V0VmFsdWUuY2FsbCh0aGlzLCB2KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZ5IGEgbWluaW11bSB2YWx1ZSBmb3IgPGNvZGU+b2JqZWN0W3Byb3BlcnR5XTwvY29kZT4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtaW5WYWx1ZSBUaGUgbWluaW11bSB2YWx1ZSBmb3JcbiAgICAgICAgICogPGNvZGU+b2JqZWN0W3Byb3BlcnR5XTwvY29kZT5cbiAgICAgICAgICogQHJldHVybnMge2RhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyfSB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBtaW46IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB0aGlzLl9fbWluID0gdjtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmeSBhIG1heGltdW0gdmFsdWUgZm9yIDxjb2RlPm9iamVjdFtwcm9wZXJ0eV08L2NvZGU+LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbWF4VmFsdWUgVGhlIG1heGltdW0gdmFsdWUgZm9yXG4gICAgICAgICAqIDxjb2RlPm9iamVjdFtwcm9wZXJ0eV08L2NvZGU+XG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlcn0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgbWF4OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdGhpcy5fX21heCA9IHY7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZnkgYSBzdGVwIHZhbHVlIHRoYXQgZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJcbiAgICAgICAgICogaW5jcmVtZW50cyBieS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXBWYWx1ZSBUaGUgc3RlcCB2YWx1ZSBmb3JcbiAgICAgICAgICogZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJcbiAgICAgICAgICogQGRlZmF1bHQgaWYgbWluaW11bSBhbmQgbWF4aW11bSBzcGVjaWZpZWQgaW5jcmVtZW50IGlzIDElIG9mIHRoZVxuICAgICAgICAgKiBkaWZmZXJlbmNlIG90aGVyd2lzZSBzdGVwVmFsdWUgaXMgMVxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJ9IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIHN0ZXA6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB0aGlzLl9fc3RlcCA9IHY7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICk7XG5cbiAgZnVuY3Rpb24gbnVtRGVjaW1hbHMoeCkge1xuICAgIHggPSB4LnRvU3RyaW5nKCk7XG4gICAgaWYgKHguaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgIHJldHVybiB4Lmxlbmd0aCAtIHguaW5kZXhPZignLicpIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXI7XG5cbn0pKGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyLFxuZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJCb3ggPSAoZnVuY3Rpb24gKE51bWJlckNvbnRyb2xsZXIsIGRvbSwgY29tbW9uKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBSZXByZXNlbnRzIGEgZ2l2ZW4gcHJvcGVydHkgb2YgYW4gb2JqZWN0IHRoYXQgaXMgYSBudW1iZXIgYW5kXG4gICAqIHByb3ZpZGVzIGFuIGlucHV0IGVsZW1lbnQgd2l0aCB3aGljaCB0byBtYW5pcHVsYXRlIGl0LlxuICAgKlxuICAgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlclxuICAgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5taW5dIE1pbmltdW0gYWxsb3dlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5tYXhdIE1heGltdW0gYWxsb3dlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5zdGVwXSBJbmNyZW1lbnQgYnkgd2hpY2ggdG8gY2hhbmdlIHZhbHVlXG4gICAqXG4gICAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG4gICAqL1xuICB2YXIgTnVtYmVyQ29udHJvbGxlckJveCA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHksIHBhcmFtcykge1xuXG4gICAgdGhpcy5fX3RydW5jYXRpb25TdXNwZW5kZWQgPSBmYWxzZTtcblxuICAgIE51bWJlckNvbnRyb2xsZXJCb3guc3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHksIHBhcmFtcyk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLyoqXG4gICAgICoge051bWJlcn0gUHJldmlvdXMgbW91c2UgeSBwb3NpdGlvblxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB2YXIgcHJldl95O1xuXG4gICAgdGhpcy5fX2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICB0aGlzLl9faW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKTtcblxuICAgIC8vIE1ha2VzIGl0IHNvIG1hbnVhbGx5IHNwZWNpZmllZCB2YWx1ZXMgYXJlIG5vdCB0cnVuY2F0ZWQuXG5cbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAnYmx1cicsIG9uQmx1cik7XG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG5cbiAgICAgIC8vIFdoZW4gcHJlc3NpbmcgZW50aXJlLCB5b3UgY2FuIGJlIGFzIHByZWNpc2UgYXMgeW91IHdhbnQuXG4gICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICBfdGhpcy5fX3RydW5jYXRpb25TdXNwZW5kZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmJsdXIoKTtcbiAgICAgICAgX3RoaXMuX190cnVuY2F0aW9uU3VzcGVuZGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICAgICAgdmFyIGF0dGVtcHRlZCA9IHBhcnNlRmxvYXQoX3RoaXMuX19pbnB1dC52YWx1ZSk7XG4gICAgICBpZiAoIWNvbW1vbi5pc05hTihhdHRlbXB0ZWQpKSBfdGhpcy5zZXRWYWx1ZShhdHRlbXB0ZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgICAgcHJldl95ID0gZS5jbGllbnRZO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTW91c2VEcmFnKGUpIHtcblxuICAgICAgdmFyIGRpZmYgPSBwcmV2X3kgLSBlLmNsaWVudFk7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5nZXRWYWx1ZSgpICsgZGlmZiAqIF90aGlzLl9faW1wbGllZFN0ZXApO1xuXG4gICAgICBwcmV2X3kgPSBlLmNsaWVudFk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1vdXNlVXAoKSB7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX2lucHV0KTtcblxuICB9O1xuXG4gIE51bWJlckNvbnRyb2xsZXJCb3guc3VwZXJjbGFzcyA9IE51bWJlckNvbnRyb2xsZXI7XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgTnVtYmVyQ29udHJvbGxlckJveC5wcm90b3R5cGUsXG4gICAgICBOdW1iZXJDb250cm9sbGVyLnByb3RvdHlwZSxcblxuICAgICAge1xuXG4gICAgICAgIHVwZGF0ZURpc3BsYXk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgdGhpcy5fX2lucHV0LnZhbHVlID0gdGhpcy5fX3RydW5jYXRpb25TdXNwZW5kZWQgPyB0aGlzLmdldFZhbHVlKCkgOiByb3VuZFRvRGVjaW1hbCh0aGlzLmdldFZhbHVlKCksIHRoaXMuX19wcmVjaXNpb24pO1xuICAgICAgICAgIHJldHVybiBOdW1iZXJDb250cm9sbGVyQm94LnN1cGVyY2xhc3MucHJvdG90eXBlLnVwZGF0ZURpc3BsYXkuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgKTtcblxuICBmdW5jdGlvbiByb3VuZFRvRGVjaW1hbCh2YWx1ZSwgZGVjaW1hbHMpIHtcbiAgICB2YXIgdGVuVG8gPSBNYXRoLnBvdygxMCwgZGVjaW1hbHMpO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogdGVuVG8pIC8gdGVuVG87XG4gIH1cblxuICByZXR1cm4gTnVtYmVyQ29udHJvbGxlckJveDtcblxufSkoZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXIsXG5kYXQuZG9tLmRvbSxcbmRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyU2xpZGVyID0gKGZ1bmN0aW9uIChOdW1iZXJDb250cm9sbGVyLCBkb20sIGNzcywgY29tbW9uLCBzdHlsZVNoZWV0KSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBSZXByZXNlbnRzIGEgZ2l2ZW4gcHJvcGVydHkgb2YgYW4gb2JqZWN0IHRoYXQgaXMgYSBudW1iZXIsIGNvbnRhaW5zXG4gICAqIGEgbWluaW11bSBhbmQgbWF4aW11bSwgYW5kIHByb3ZpZGVzIGEgc2xpZGVyIGVsZW1lbnQgd2l0aCB3aGljaCB0b1xuICAgKiBtYW5pcHVsYXRlIGl0LiBJdCBzaG91bGQgYmUgbm90ZWQgdGhhdCB0aGUgc2xpZGVyIGVsZW1lbnQgaXMgbWFkZSB1cCBvZlxuICAgKiA8Y29kZT4mbHQ7ZGl2Jmd0OzwvY29kZT4gdGFncywgPHN0cm9uZz5ub3Q8L3N0cm9uZz4gdGhlIGh0bWw1XG4gICAqIDxjb2RlPiZsdDtzbGlkZXImZ3Q7PC9jb2RlPiBlbGVtZW50LlxuICAgKlxuICAgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlclxuICAgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlclxuICAgKiBcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1pblZhbHVlIE1pbmltdW0gYWxsb3dlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gbWF4VmFsdWUgTWF4aW11bSBhbGxvd2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwVmFsdWUgSW5jcmVtZW50IGJ5IHdoaWNoIHRvIGNoYW5nZSB2YWx1ZVxuICAgKlxuICAgKiBAbWVtYmVyIGRhdC5jb250cm9sbGVyc1xuICAgKi9cbiAgdmFyIE51bWJlckNvbnRyb2xsZXJTbGlkZXIgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5LCBtaW4sIG1heCwgc3RlcCkge1xuXG4gICAgTnVtYmVyQ29udHJvbGxlclNsaWRlci5zdXBlcmNsYXNzLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSwgeyBtaW46IG1pbiwgbWF4OiBtYXgsIHN0ZXA6IHN0ZXAgfSk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5fX2JhY2tncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9fZm9yZWdyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIFxuXG5cbiAgICBkb20uYmluZCh0aGlzLl9fYmFja2dyb3VuZCwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICBcbiAgICBkb20uYWRkQ2xhc3ModGhpcy5fX2JhY2tncm91bmQsICdzbGlkZXInKTtcbiAgICBkb20uYWRkQ2xhc3ModGhpcy5fX2ZvcmVncm91bmQsICdzbGlkZXItZmcnKTtcblxuICAgIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcblxuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIG9uTW91c2VVcCk7XG5cbiAgICAgIG9uTW91c2VEcmFnKGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTW91c2VEcmFnKGUpIHtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB2YXIgb2Zmc2V0ID0gZG9tLmdldE9mZnNldChfdGhpcy5fX2JhY2tncm91bmQpO1xuICAgICAgdmFyIHdpZHRoID0gZG9tLmdldFdpZHRoKF90aGlzLl9fYmFja2dyb3VuZCk7XG4gICAgICBcbiAgICAgIF90aGlzLnNldFZhbHVlKFxuICAgICAgICBtYXAoZS5jbGllbnRYLCBvZmZzZXQubGVmdCwgb2Zmc2V0LmxlZnQgKyB3aWR0aCwgX3RoaXMuX19taW4sIF90aGlzLl9fbWF4KVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Nb3VzZVVwKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgICAgaWYgKF90aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgX3RoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKF90aGlzLCBfdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblxuICAgIHRoaXMuX19iYWNrZ3JvdW5kLmFwcGVuZENoaWxkKHRoaXMuX19mb3JlZ3JvdW5kKTtcbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX2JhY2tncm91bmQpO1xuXG4gIH07XG5cbiAgTnVtYmVyQ29udHJvbGxlclNsaWRlci5zdXBlcmNsYXNzID0gTnVtYmVyQ29udHJvbGxlcjtcblxuICAvKipcbiAgICogSW5qZWN0cyBkZWZhdWx0IHN0eWxlc2hlZXQgZm9yIHNsaWRlciBlbGVtZW50cy5cbiAgICovXG4gIE51bWJlckNvbnRyb2xsZXJTbGlkZXIudXNlRGVmYXVsdFN0eWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIGNzcy5pbmplY3Qoc3R5bGVTaGVldCk7XG4gIH07XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgTnVtYmVyQ29udHJvbGxlclNsaWRlci5wcm90b3R5cGUsXG4gICAgICBOdW1iZXJDb250cm9sbGVyLnByb3RvdHlwZSxcblxuICAgICAge1xuXG4gICAgICAgIHVwZGF0ZURpc3BsYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwY3QgPSAodGhpcy5nZXRWYWx1ZSgpIC0gdGhpcy5fX21pbikvKHRoaXMuX19tYXggLSB0aGlzLl9fbWluKTtcbiAgICAgICAgICB0aGlzLl9fZm9yZWdyb3VuZC5zdHlsZS53aWR0aCA9IHBjdCoxMDArJyUnO1xuICAgICAgICAgIHJldHVybiBOdW1iZXJDb250cm9sbGVyU2xpZGVyLnN1cGVyY2xhc3MucHJvdG90eXBlLnVwZGF0ZURpc3BsYXkuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cblxuXG4gICk7XG5cbiAgZnVuY3Rpb24gbWFwKHYsIGkxLCBpMiwgbzEsIG8yKSB7XG4gICAgcmV0dXJuIG8xICsgKG8yIC0gbzEpICogKCh2IC0gaTEpIC8gKGkyIC0gaTEpKTtcbiAgfVxuXG4gIHJldHVybiBOdW1iZXJDb250cm9sbGVyU2xpZGVyO1xuICBcbn0pKGRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyLFxuZGF0LmRvbS5kb20sXG5kYXQudXRpbHMuY3NzLFxuZGF0LnV0aWxzLmNvbW1vbixcblwiLnNsaWRlciB7XFxuICBib3gtc2hhZG93OiBpbnNldCAwIDJweCA0cHggcmdiYSgwLDAsMCwwLjE1KTtcXG4gIGhlaWdodDogMWVtO1xcbiAgYm9yZGVyLXJhZGl1czogMWVtO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcXG4gIHBhZGRpbmc6IDAgMC41ZW07XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG5cXG4uc2xpZGVyLWZnIHtcXG4gIHBhZGRpbmc6IDFweCAwIDJweCAwO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2FhYTtcXG4gIGhlaWdodDogMWVtO1xcbiAgbWFyZ2luLWxlZnQ6IC0wLjVlbTtcXG4gIHBhZGRpbmctcmlnaHQ6IDAuNWVtO1xcbiAgYm9yZGVyLXJhZGl1czogMWVtIDAgMCAxZW07XFxufVxcblxcbi5zbGlkZXItZmc6YWZ0ZXIge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgYm9yZGVyLXJhZGl1czogMWVtO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIGJvcmRlcjogIDFweCBzb2xpZCAjYWFhO1xcbiAgY29udGVudDogJyc7XFxuICBmbG9hdDogcmlnaHQ7XFxuICBtYXJnaW4tcmlnaHQ6IC0xZW07XFxuICBtYXJnaW4tdG9wOiAtMXB4O1xcbiAgaGVpZ2h0OiAwLjllbTtcXG4gIHdpZHRoOiAwLjllbTtcXG59XCIpO1xuXG5cbmRhdC5jb250cm9sbGVycy5GdW5jdGlvbkNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKENvbnRyb2xsZXIsIGRvbSwgY29tbW9uKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBQcm92aWRlcyBhIEdVSSBpbnRlcmZhY2UgdG8gZmlyZSBhIHNwZWNpZmllZCBtZXRob2QsIGEgcHJvcGVydHkgb2YgYW4gb2JqZWN0LlxuICAgKlxuICAgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBtYW5pcHVsYXRlZFxuICAgKlxuICAgKiBAbWVtYmVyIGRhdC5jb250cm9sbGVyc1xuICAgKi9cbiAgdmFyIEZ1bmN0aW9uQ29udHJvbGxlciA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHksIHRleHQpIHtcblxuICAgIEZ1bmN0aW9uQ29udHJvbGxlci5zdXBlcmNsYXNzLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5fX2J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX19idXR0b24uaW5uZXJIVE1MID0gdGV4dCA9PT0gdW5kZWZpbmVkID8gJ0ZpcmUnIDogdGV4dDtcbiAgICBkb20uYmluZCh0aGlzLl9fYnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBfdGhpcy5maXJlKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICBkb20uYWRkQ2xhc3ModGhpcy5fX2J1dHRvbiwgJ2J1dHRvbicpO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19idXR0b24pO1xuXG5cbiAgfTtcblxuICBGdW5jdGlvbkNvbnRyb2xsZXIuc3VwZXJjbGFzcyA9IENvbnRyb2xsZXI7XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgRnVuY3Rpb25Db250cm9sbGVyLnByb3RvdHlwZSxcbiAgICAgIENvbnRyb2xsZXIucHJvdG90eXBlLFxuICAgICAge1xuICAgICAgICBcbiAgICAgICAgZmlyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX19vbkNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5fX29uQ2hhbmdlLmNhbGwodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZ2V0VmFsdWUoKS5jYWxsKHRoaXMub2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICk7XG5cbiAgcmV0dXJuIEZ1bmN0aW9uQ29udHJvbGxlcjtcblxufSkoZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXIsXG5kYXQuZG9tLmRvbSxcbmRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5jb250cm9sbGVycy5Cb29sZWFuQ29udHJvbGxlciA9IChmdW5jdGlvbiAoQ29udHJvbGxlciwgZG9tLCBjb21tb24pIHtcblxuICAvKipcbiAgICogQGNsYXNzIFByb3ZpZGVzIGEgY2hlY2tib3ggaW5wdXQgdG8gYWx0ZXIgdGhlIGJvb2xlYW4gcHJvcGVydHkgb2YgYW4gb2JqZWN0LlxuICAgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBtYW5pcHVsYXRlZFxuICAgKlxuICAgKiBAbWVtYmVyIGRhdC5jb250cm9sbGVyc1xuICAgKi9cbiAgdmFyIEJvb2xlYW5Db250cm9sbGVyID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuXG4gICAgQm9vbGVhbkNvbnRyb2xsZXIuc3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLl9fcHJldiA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuICAgIHRoaXMuX19jaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgdGhpcy5fX2NoZWNrYm94LnNldEF0dHJpYnV0ZSgndHlwZScsICdjaGVja2JveCcpO1xuXG5cbiAgICBkb20uYmluZCh0aGlzLl9fY2hlY2tib3gsICdjaGFuZ2UnLCBvbkNoYW5nZSwgZmFsc2UpO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19jaGVja2JveCk7XG5cbiAgICAvLyBNYXRjaCBvcmlnaW5hbCB2YWx1ZVxuICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuXG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICBfdGhpcy5zZXRWYWx1ZSghX3RoaXMuX19wcmV2KTtcbiAgICB9XG5cbiAgfTtcblxuICBCb29sZWFuQ29udHJvbGxlci5zdXBlcmNsYXNzID0gQ29udHJvbGxlcjtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBCb29sZWFuQ29udHJvbGxlci5wcm90b3R5cGUsXG4gICAgICBDb250cm9sbGVyLnByb3RvdHlwZSxcblxuICAgICAge1xuXG4gICAgICAgIHNldFZhbHVlOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdmFyIHRvUmV0dXJuID0gQm9vbGVhbkNvbnRyb2xsZXIuc3VwZXJjbGFzcy5wcm90b3R5cGUuc2V0VmFsdWUuY2FsbCh0aGlzLCB2KTtcbiAgICAgICAgICBpZiAodGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbCh0aGlzLCB0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9fcHJldiA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgICByZXR1cm4gdG9SZXR1cm47XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlRGlzcGxheTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHRoaXMuZ2V0VmFsdWUoKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5fX2NoZWNrYm94LnNldEF0dHJpYnV0ZSgnY2hlY2tlZCcsICdjaGVja2VkJyk7XG4gICAgICAgICAgICB0aGlzLl9fY2hlY2tib3guY2hlY2tlZCA9IHRydWU7ICAgIFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX19jaGVja2JveC5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIEJvb2xlYW5Db250cm9sbGVyLnN1cGVyY2xhc3MucHJvdG90eXBlLnVwZGF0ZURpc3BsYXkuY2FsbCh0aGlzKTtcblxuICAgICAgICB9XG5cblxuICAgICAgfVxuXG4gICk7XG5cbiAgcmV0dXJuIEJvb2xlYW5Db250cm9sbGVyO1xuXG59KShkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcixcbmRhdC5kb20uZG9tLFxuZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LmNvbG9yLnRvU3RyaW5nID0gKGZ1bmN0aW9uIChjb21tb24pIHtcblxuICByZXR1cm4gZnVuY3Rpb24oY29sb3IpIHtcblxuICAgIGlmIChjb2xvci5hID09IDEgfHwgY29tbW9uLmlzVW5kZWZpbmVkKGNvbG9yLmEpKSB7XG5cbiAgICAgIHZhciBzID0gY29sb3IuaGV4LnRvU3RyaW5nKDE2KTtcbiAgICAgIHdoaWxlIChzLmxlbmd0aCA8IDYpIHtcbiAgICAgICAgcyA9ICcwJyArIHM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnIycgKyBzO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgcmV0dXJuICdyZ2JhKCcgKyBNYXRoLnJvdW5kKGNvbG9yLnIpICsgJywnICsgTWF0aC5yb3VuZChjb2xvci5nKSArICcsJyArIE1hdGgucm91bmQoY29sb3IuYikgKyAnLCcgKyBjb2xvci5hICsgJyknO1xuXG4gICAgfVxuXG4gIH1cblxufSkoZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LmNvbG9yLmludGVycHJldCA9IChmdW5jdGlvbiAodG9TdHJpbmcsIGNvbW1vbikge1xuXG4gIHZhciByZXN1bHQsIHRvUmV0dXJuO1xuXG4gIHZhciBpbnRlcnByZXQgPSBmdW5jdGlvbigpIHtcblxuICAgIHRvUmV0dXJuID0gZmFsc2U7XG5cbiAgICB2YXIgb3JpZ2luYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGNvbW1vbi50b0FycmF5KGFyZ3VtZW50cykgOiBhcmd1bWVudHNbMF07XG5cbiAgICBjb21tb24uZWFjaChJTlRFUlBSRVRBVElPTlMsIGZ1bmN0aW9uKGZhbWlseSkge1xuXG4gICAgICBpZiAoZmFtaWx5LmxpdG11cyhvcmlnaW5hbCkpIHtcblxuICAgICAgICBjb21tb24uZWFjaChmYW1pbHkuY29udmVyc2lvbnMsIGZ1bmN0aW9uKGNvbnZlcnNpb24sIGNvbnZlcnNpb25OYW1lKSB7XG5cbiAgICAgICAgICByZXN1bHQgPSBjb252ZXJzaW9uLnJlYWQob3JpZ2luYWwpO1xuXG4gICAgICAgICAgaWYgKHRvUmV0dXJuID09PSBmYWxzZSAmJiByZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0b1JldHVybiA9IHJlc3VsdDtcbiAgICAgICAgICAgIHJlc3VsdC5jb252ZXJzaW9uTmFtZSA9IGNvbnZlcnNpb25OYW1lO1xuICAgICAgICAgICAgcmVzdWx0LmNvbnZlcnNpb24gPSBjb252ZXJzaW9uO1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1vbi5CUkVBSztcblxuICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY29tbW9uLkJSRUFLO1xuXG4gICAgICB9XG5cbiAgICB9KTtcblxuICAgIHJldHVybiB0b1JldHVybjtcblxuICB9O1xuXG4gIHZhciBJTlRFUlBSRVRBVElPTlMgPSBbXG5cbiAgICAvLyBTdHJpbmdzXG4gICAge1xuXG4gICAgICBsaXRtdXM6IGNvbW1vbi5pc1N0cmluZyxcblxuICAgICAgY29udmVyc2lvbnM6IHtcblxuICAgICAgICBUSFJFRV9DSEFSX0hFWDoge1xuXG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXiMoW0EtRjAtOV0pKFtBLUYwLTldKShbQS1GMC05XSkkL2kpO1xuICAgICAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgICAgICBoZXg6IHBhcnNlSW50KFxuICAgICAgICAgICAgICAgICAgJzB4JyArXG4gICAgICAgICAgICAgICAgICAgICAgdGVzdFsxXS50b1N0cmluZygpICsgdGVzdFsxXS50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXN0WzJdLnRvU3RyaW5nKCkgKyB0ZXN0WzJdLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICAgICAgIHRlc3RbM10udG9TdHJpbmcoKSArIHRlc3RbM10udG9TdHJpbmcoKSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IHRvU3RyaW5nXG5cbiAgICAgICAgfSxcblxuICAgICAgICBTSVhfQ0hBUl9IRVg6IHtcblxuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG5cbiAgICAgICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL14jKFtBLUYwLTldezZ9KSQvaSk7XG4gICAgICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgICAgIGhleDogcGFyc2VJbnQoJzB4JyArIHRlc3RbMV0udG9TdHJpbmcoKSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IHRvU3RyaW5nXG5cbiAgICAgICAgfSxcblxuICAgICAgICBDU1NfUkdCOiB7XG5cbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuXG4gICAgICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9ecmdiXFwoXFxzKiguKylcXHMqLFxccyooLispXFxzKixcXHMqKC4rKVxccypcXCkvKTtcbiAgICAgICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgcjogcGFyc2VGbG9hdCh0ZXN0WzFdKSxcbiAgICAgICAgICAgICAgZzogcGFyc2VGbG9hdCh0ZXN0WzJdKSxcbiAgICAgICAgICAgICAgYjogcGFyc2VGbG9hdCh0ZXN0WzNdKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogdG9TdHJpbmdcblxuICAgICAgICB9LFxuXG4gICAgICAgIENTU19SR0JBOiB7XG5cbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuXG4gICAgICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9ecmdiYVxcKFxccyooLispXFxzKixcXHMqKC4rKVxccyosXFxzKiguKylcXHMqXFwsXFxzKiguKylcXHMqXFwpLyk7XG4gICAgICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgIHI6IHBhcnNlRmxvYXQodGVzdFsxXSksXG4gICAgICAgICAgICAgIGc6IHBhcnNlRmxvYXQodGVzdFsyXSksXG4gICAgICAgICAgICAgIGI6IHBhcnNlRmxvYXQodGVzdFszXSksXG4gICAgICAgICAgICAgIGE6IHBhcnNlRmxvYXQodGVzdFs0XSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IHRvU3RyaW5nXG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLy8gTnVtYmVyc1xuICAgIHtcblxuICAgICAgbGl0bXVzOiBjb21tb24uaXNOdW1iZXIsXG5cbiAgICAgIGNvbnZlcnNpb25zOiB7XG5cbiAgICAgICAgSEVYOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnSEVYJyxcbiAgICAgICAgICAgICAgaGV4OiBvcmlnaW5hbCxcbiAgICAgICAgICAgICAgY29udmVyc2lvbk5hbWU6ICdIRVgnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbG9yLmhleDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8vIEFycmF5c1xuICAgIHtcblxuICAgICAgbGl0bXVzOiBjb21tb24uaXNBcnJheSxcblxuICAgICAgY29udmVyc2lvbnM6IHtcblxuICAgICAgICBSR0JfQVJSQVk6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsLmxlbmd0aCAhPSAzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgIHI6IG9yaWdpbmFsWzBdLFxuICAgICAgICAgICAgICBnOiBvcmlnaW5hbFsxXSxcbiAgICAgICAgICAgICAgYjogb3JpZ2luYWxbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIFtjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICBSR0JBX0FSUkFZOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGggIT0gNCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICByOiBvcmlnaW5hbFswXSxcbiAgICAgICAgICAgICAgZzogb3JpZ2luYWxbMV0sXG4gICAgICAgICAgICAgIGI6IG9yaWdpbmFsWzJdLFxuICAgICAgICAgICAgICBhOiBvcmlnaW5hbFszXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gW2NvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIsIGNvbG9yLmFdO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvLyBPYmplY3RzXG4gICAge1xuXG4gICAgICBsaXRtdXM6IGNvbW1vbi5pc09iamVjdCxcblxuICAgICAgY29udmVyc2lvbnM6IHtcblxuICAgICAgICBSR0JBX09CSjoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnIpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmcpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmIpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmEpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICAgIHI6IG9yaWdpbmFsLnIsXG4gICAgICAgICAgICAgICAgZzogb3JpZ2luYWwuZyxcbiAgICAgICAgICAgICAgICBiOiBvcmlnaW5hbC5iLFxuICAgICAgICAgICAgICAgIGE6IG9yaWdpbmFsLmFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHI6IGNvbG9yLnIsXG4gICAgICAgICAgICAgIGc6IGNvbG9yLmcsXG4gICAgICAgICAgICAgIGI6IGNvbG9yLmIsXG4gICAgICAgICAgICAgIGE6IGNvbG9yLmFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgUkdCX09CSjoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnIpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmcpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICAgIHI6IG9yaWdpbmFsLnIsXG4gICAgICAgICAgICAgICAgZzogb3JpZ2luYWwuZyxcbiAgICAgICAgICAgICAgICBiOiBvcmlnaW5hbC5iXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICByOiBjb2xvci5yLFxuICAgICAgICAgICAgICBnOiBjb2xvci5nLFxuICAgICAgICAgICAgICBiOiBjb2xvci5iXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIEhTVkFfT0JKOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuaCkgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwucykgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwudikgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzcGFjZTogJ0hTVicsXG4gICAgICAgICAgICAgICAgaDogb3JpZ2luYWwuaCxcbiAgICAgICAgICAgICAgICBzOiBvcmlnaW5hbC5zLFxuICAgICAgICAgICAgICAgIHY6IG9yaWdpbmFsLnYsXG4gICAgICAgICAgICAgICAgYTogb3JpZ2luYWwuYVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaDogY29sb3IuaCxcbiAgICAgICAgICAgICAgczogY29sb3IucyxcbiAgICAgICAgICAgICAgdjogY29sb3IudixcbiAgICAgICAgICAgICAgYTogY29sb3IuYVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBIU1ZfT0JKOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuaCkgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwucykgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwudikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzcGFjZTogJ0hTVicsXG4gICAgICAgICAgICAgICAgaDogb3JpZ2luYWwuaCxcbiAgICAgICAgICAgICAgICBzOiBvcmlnaW5hbC5zLFxuICAgICAgICAgICAgICAgIHY6IG9yaWdpbmFsLnZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGg6IGNvbG9yLmgsXG4gICAgICAgICAgICAgIHM6IGNvbG9yLnMsXG4gICAgICAgICAgICAgIHY6IGNvbG9yLnZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cblxuICBdO1xuXG4gIHJldHVybiBpbnRlcnByZXQ7XG5cblxufSkoZGF0LmNvbG9yLnRvU3RyaW5nLFxuZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LkdVSSA9IGRhdC5ndWkuR1VJID0gKGZ1bmN0aW9uIChjc3MsIHNhdmVEaWFsb2d1ZUNvbnRlbnRzLCBzdHlsZVNoZWV0LCBjb250cm9sbGVyRmFjdG9yeSwgQ29udHJvbGxlciwgQm9vbGVhbkNvbnRyb2xsZXIsIEZ1bmN0aW9uQ29udHJvbGxlciwgTnVtYmVyQ29udHJvbGxlckJveCwgTnVtYmVyQ29udHJvbGxlclNsaWRlciwgT3B0aW9uQ29udHJvbGxlciwgQ29sb3JDb250cm9sbGVyLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIENlbnRlcmVkRGl2LCBkb20sIGNvbW1vbikge1xuXG4gIGNzcy5pbmplY3Qoc3R5bGVTaGVldCk7XG5cbiAgLyoqIE91dGVyLW1vc3QgY2xhc3NOYW1lIGZvciBHVUkncyAqL1xuICB2YXIgQ1NTX05BTUVTUEFDRSA9ICdkZyc7XG5cbiAgdmFyIEhJREVfS0VZX0NPREUgPSA3MjtcblxuICAvKiogVGhlIG9ubHkgdmFsdWUgc2hhcmVkIGJldHdlZW4gdGhlIEpTIGFuZCBTQ1NTLiBVc2UgY2F1dGlvbi4gKi9cbiAgdmFyIENMT1NFX0JVVFRPTl9IRUlHSFQgPSAyMDtcblxuICB2YXIgREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FID0gJ0RlZmF1bHQnO1xuXG4gIHZhciBTVVBQT1JUU19MT0NBTF9TVE9SQUdFID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gJ2xvY2FsU3RvcmFnZScgaW4gd2luZG93ICYmIHdpbmRvd1snbG9jYWxTdG9yYWdlJ10gIT09IG51bGw7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSkoKTtcblxuICB2YXIgU0FWRV9ESUFMT0dVRTtcblxuICAvKiogSGF2ZSB3ZSB5ZXQgdG8gY3JlYXRlIGFuIGF1dG9QbGFjZSBHVUk/ICovXG4gIHZhciBhdXRvX3BsYWNlX3ZpcmdpbiA9IHRydWU7XG5cbiAgLyoqIEZpeGVkIHBvc2l0aW9uIGRpdiB0aGF0IGF1dG8gcGxhY2UgR1VJJ3MgZ28gaW5zaWRlICovXG4gIHZhciBhdXRvX3BsYWNlX2NvbnRhaW5lcjtcblxuICAvKiogQXJlIHdlIGhpZGluZyB0aGUgR1VJJ3MgPyAqL1xuICB2YXIgaGlkZSA9IGZhbHNlO1xuXG4gIC8qKiBHVUkncyB3aGljaCBzaG91bGQgYmUgaGlkZGVuICovXG4gIHZhciBoaWRlYWJsZV9ndWlzID0gW107XG5cbiAgLyoqXG4gICAqIEEgbGlnaHR3ZWlnaHQgY29udHJvbGxlciBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0LiBJdCBhbGxvd3MgeW91IHRvIGVhc2lseVxuICAgKiBtYW5pcHVsYXRlIHZhcmlhYmxlcyBhbmQgZmlyZSBmdW5jdGlvbnMgb24gdGhlIGZseS5cbiAgICogQGNsYXNzXG4gICAqXG4gICAqIEBtZW1iZXIgZGF0Lmd1aVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc11cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMubmFtZV0gVGhlIG5hbWUgb2YgdGhpcyBHVUkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zLmxvYWRdIEpTT04gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc2F2ZWQgc3RhdGUgb2ZcbiAgICogdGhpcyBHVUkuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy5hdXRvPXRydWVdXG4gICAqIEBwYXJhbSB7ZGF0Lmd1aS5HVUl9IFtwYXJhbXMucGFyZW50XSBUaGUgR1VJIEknbSBuZXN0ZWQgaW4uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy5jbG9zZWRdIElmIHRydWUsIHN0YXJ0cyBjbG9zZWRcbiAgICovXG4gIHZhciBHVUkgPSBmdW5jdGlvbihwYXJhbXMpIHtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvKipcbiAgICAgKiBPdXRlcm1vc3QgRE9NIEVsZW1lbnRcbiAgICAgKiBAdHlwZSBET01FbGVtZW50XG4gICAgICovXG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX3VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX3VsKTtcblxuICAgIGRvbS5hZGRDbGFzcyh0aGlzLmRvbUVsZW1lbnQsIENTU19OQU1FU1BBQ0UpO1xuXG4gICAgLyoqXG4gICAgICogTmVzdGVkIEdVSSdzIGJ5IG5hbWVcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fX2ZvbGRlcnMgPSB7fTtcblxuICAgIHRoaXMuX19jb250cm9sbGVycyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBvYmplY3RzIEknbSByZW1lbWJlcmluZyBmb3Igc2F2ZSwgb25seSB1c2VkIGluIHRvcCBsZXZlbCBHVUlcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBNYXBzIHRoZSBpbmRleCBvZiByZW1lbWJlcmVkIG9iamVjdHMgdG8gYSBtYXAgb2YgY29udHJvbGxlcnMsIG9ubHkgdXNlZFxuICAgICAqIGluIHRvcCBsZXZlbCBHVUkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpZ25vcmVcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogW1xuICAgICAqICB7XG4gICAgICogICAgcHJvcGVydHlOYW1lOiBDb250cm9sbGVyLFxuICAgICAqICAgIGFub3RoZXJQcm9wZXJ0eU5hbWU6IENvbnRyb2xsZXJcbiAgICAgKiAgfSxcbiAgICAgKiAge1xuICAgICAqICAgIHByb3BlcnR5TmFtZTogQ29udHJvbGxlclxuICAgICAqICB9XG4gICAgICogXVxuICAgICAqL1xuICAgIHRoaXMuX19yZW1lbWJlcmVkT2JqZWN0SW5kZWNlc1RvQ29udHJvbGxlcnMgPSBbXTtcblxuICAgIHRoaXMuX19saXN0ZW5pbmcgPSBbXTtcblxuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuICAgIC8vIERlZmF1bHQgcGFyYW1ldGVyc1xuICAgIHBhcmFtcyA9IGNvbW1vbi5kZWZhdWx0cyhwYXJhbXMsIHtcbiAgICAgIGF1dG9QbGFjZTogdHJ1ZSxcbiAgICAgIHdpZHRoOiBHVUkuREVGQVVMVF9XSURUSFxuICAgIH0pO1xuXG4gICAgcGFyYW1zID0gY29tbW9uLmRlZmF1bHRzKHBhcmFtcywge1xuICAgICAgcmVzaXphYmxlOiBwYXJhbXMuYXV0b1BsYWNlLFxuICAgICAgaGlkZWFibGU6IHBhcmFtcy5hdXRvUGxhY2VcbiAgICB9KTtcblxuXG4gICAgaWYgKCFjb21tb24uaXNVbmRlZmluZWQocGFyYW1zLmxvYWQpKSB7XG5cbiAgICAgIC8vIEV4cGxpY2l0IHByZXNldFxuICAgICAgaWYgKHBhcmFtcy5wcmVzZXQpIHBhcmFtcy5sb2FkLnByZXNldCA9IHBhcmFtcy5wcmVzZXQ7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBwYXJhbXMubG9hZCA9IHsgcHJlc2V0OiBERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUUgfTtcblxuICAgIH1cblxuICAgIGlmIChjb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkgJiYgcGFyYW1zLmhpZGVhYmxlKSB7XG4gICAgICBoaWRlYWJsZV9ndWlzLnB1c2godGhpcyk7XG4gICAgfVxuXG4gICAgLy8gT25seSByb290IGxldmVsIEdVSSdzIGFyZSByZXNpemFibGUuXG4gICAgcGFyYW1zLnJlc2l6YWJsZSA9IGNvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSAmJiBwYXJhbXMucmVzaXphYmxlO1xuXG5cbiAgICBpZiAocGFyYW1zLmF1dG9QbGFjZSAmJiBjb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnNjcm9sbGFibGUpKSB7XG4gICAgICBwYXJhbXMuc2Nyb2xsYWJsZSA9IHRydWU7XG4gICAgfVxuLy8gICAgcGFyYW1zLnNjcm9sbGFibGUgPSBjb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkgJiYgcGFyYW1zLnNjcm9sbGFibGUgPT09IHRydWU7XG5cbiAgICAvLyBOb3QgcGFydCBvZiBwYXJhbXMgYmVjYXVzZSBJIGRvbid0IHdhbnQgcGVvcGxlIHBhc3NpbmcgdGhpcyBpbiB2aWFcbiAgICAvLyBjb25zdHJ1Y3Rvci4gU2hvdWxkIGJlIGEgJ3JlbWVtYmVyZWQnIHZhbHVlLlxuICAgIHZhciB1c2VfbG9jYWxfc3RvcmFnZSA9XG4gICAgICAgIFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UgJiZcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2godGhpcywgJ2lzTG9jYWwnKSkgPT09ICd0cnVlJztcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsXG5cbiAgICAgICAgLyoqIEBsZW5kcyBkYXQuZ3VpLkdVSS5wcm90b3R5cGUgKi9cbiAgICAgICAge1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIHBhcmVudCA8Y29kZT5HVUk8L2NvZGU+XG4gICAgICAgICAgICogQHR5cGUgZGF0Lmd1aS5HVUlcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJhbXMucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBzY3JvbGxhYmxlOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zLnNjcm9sbGFibGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEhhbmRsZXMgPGNvZGU+R1VJPC9jb2RlPidzIGVsZW1lbnQgcGxhY2VtZW50IGZvciB5b3VcbiAgICAgICAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICAgICAgICovXG4gICAgICAgICAgYXV0b1BsYWNlOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zLmF1dG9QbGFjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIGlkZW50aWZpZXIgZm9yIGEgc2V0IG9mIHNhdmVkIHZhbHVlc1xuICAgICAgICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAgICAgICAqL1xuICAgICAgICAgIHByZXNldDoge1xuXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAoX3RoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldFJvb3QoKS5wcmVzZXQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5sb2FkLnByZXNldDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgIGlmIChfdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5nZXRSb290KCkucHJlc2V0ID0gdjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMubG9hZC5wcmVzZXQgPSB2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNldFByZXNldFNlbGVjdEluZGV4KHRoaXMpO1xuICAgICAgICAgICAgICBfdGhpcy5yZXZlcnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgd2lkdGggb2YgPGNvZGU+R1VJPC9jb2RlPiBlbGVtZW50XG4gICAgICAgICAgICogQHR5cGUgTnVtYmVyXG4gICAgICAgICAgICovXG4gICAgICAgICAgd2lkdGg6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJhbXMud2lkdGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgIHBhcmFtcy53aWR0aCA9IHY7XG4gICAgICAgICAgICAgIHNldFdpZHRoKF90aGlzLCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIG5hbWUgb2YgPGNvZGU+R1VJPC9jb2RlPi4gVXNlZCBmb3IgZm9sZGVycy4gaS5lXG4gICAgICAgICAgICogYSBmb2xkZXIncyBuYW1lXG4gICAgICAgICAgICogQHR5cGUgU3RyaW5nXG4gICAgICAgICAgICovXG4gICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5uYW1lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAvLyBUT0RPIENoZWNrIGZvciBjb2xsaXNpb25zIGFtb25nIHNpYmxpbmcgZm9sZGVyc1xuICAgICAgICAgICAgICBwYXJhbXMubmFtZSA9IHY7XG4gICAgICAgICAgICAgIGlmICh0aXRsZV9yb3dfbmFtZSkge1xuICAgICAgICAgICAgICAgIHRpdGxlX3Jvd19uYW1lLmlubmVySFRNTCA9IHBhcmFtcy5uYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFdoZXRoZXIgdGhlIDxjb2RlPkdVSTwvY29kZT4gaXMgY29sbGFwc2VkIG9yIG5vdFxuICAgICAgICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBjbG9zZWQ6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJhbXMuY2xvc2VkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICBwYXJhbXMuY2xvc2VkID0gdjtcbiAgICAgICAgICAgICAgaWYgKHBhcmFtcy5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBkb20uYWRkQ2xhc3MoX3RoaXMuX191bCwgR1VJLkNMQVNTX0NMT1NFRCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKF90aGlzLl9fdWwsIEdVSS5DTEFTU19DTE9TRUQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIEZvciBicm93c2VycyB0aGF0IGFyZW4ndCBnb2luZyB0byByZXNwZWN0IHRoZSBDU1MgdHJhbnNpdGlvbixcbiAgICAgICAgICAgICAgLy8gTGV0cyBqdXN0IGNoZWNrIG91ciBoZWlnaHQgYWdhaW5zdCB0aGUgd2luZG93IGhlaWdodCByaWdodCBvZmZcbiAgICAgICAgICAgICAgLy8gdGhlIGJhdC5cbiAgICAgICAgICAgICAgdGhpcy5vblJlc2l6ZSgpO1xuXG4gICAgICAgICAgICAgIGlmIChfdGhpcy5fX2Nsb3NlQnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX19jbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSB2ID8gR1VJLlRFWFRfT1BFTiA6IEdVSS5URVhUX0NMT1NFRDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBDb250YWlucyBhbGwgcHJlc2V0c1xuICAgICAgICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAgICAgICAqL1xuICAgICAgICAgIGxvYWQ6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJhbXMubG9hZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0byB1c2UgPGEgaHJlZj1cImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS9TdG9yYWdlI2xvY2FsU3RvcmFnZVwiPmxvY2FsU3RvcmFnZTwvYT4gYXMgdGhlIG1lYW5zIGZvclxuICAgICAgICAgICAqIDxjb2RlPnJlbWVtYmVyPC9jb2RlPmluZ1xuICAgICAgICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICB1c2VMb2NhbFN0b3JhZ2U6IHtcblxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVzZV9sb2NhbF9zdG9yYWdlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oYm9vbCkge1xuICAgICAgICAgICAgICBpZiAoU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSkge1xuICAgICAgICAgICAgICAgIHVzZV9sb2NhbF9zdG9yYWdlID0gYm9vbDtcbiAgICAgICAgICAgICAgICBpZiAoYm9vbCkge1xuICAgICAgICAgICAgICAgICAgZG9tLmJpbmQod2luZG93LCAndW5sb2FkJywgc2F2ZVRvTG9jYWxTdG9yYWdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZG9tLnVuYmluZCh3aW5kb3csICd1bmxvYWQnLCBzYXZlVG9Mb2NhbFN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKF90aGlzLCAnaXNMb2NhbCcpLCBib29sKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgLy8gQXJlIHdlIGEgcm9vdCBsZXZlbCBHVUk/XG4gICAgaWYgKGNvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSkge1xuXG4gICAgICBwYXJhbXMuY2xvc2VkID0gZmFsc2U7XG5cbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLmRvbUVsZW1lbnQsIEdVSS5DTEFTU19NQUlOKTtcbiAgICAgIGRvbS5tYWtlU2VsZWN0YWJsZSh0aGlzLmRvbUVsZW1lbnQsIGZhbHNlKTtcblxuICAgICAgLy8gQXJlIHdlIHN1cHBvc2VkIHRvIGJlIGxvYWRpbmcgbG9jYWxseT9cbiAgICAgIGlmIChTVVBQT1JUU19MT0NBTF9TVE9SQUdFKSB7XG5cbiAgICAgICAgaWYgKHVzZV9sb2NhbF9zdG9yYWdlKSB7XG5cbiAgICAgICAgICBfdGhpcy51c2VMb2NhbFN0b3JhZ2UgPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHNhdmVkX2d1aSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2godGhpcywgJ2d1aScpKTtcblxuICAgICAgICAgIGlmIChzYXZlZF9ndWkpIHtcbiAgICAgICAgICAgIHBhcmFtcy5sb2FkID0gSlNPTi5wYXJzZShzYXZlZF9ndWkpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgdGhpcy5fX2Nsb3NlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLl9fY2xvc2VCdXR0b24uaW5uZXJIVE1MID0gR1VJLlRFWFRfQ0xPU0VEO1xuICAgICAgZG9tLmFkZENsYXNzKHRoaXMuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0NMT1NFX0JVVFRPTik7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX2Nsb3NlQnV0dG9uKTtcblxuICAgICAgZG9tLmJpbmQodGhpcy5fX2Nsb3NlQnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcblxuICAgICAgICBfdGhpcy5jbG9zZWQgPSAhX3RoaXMuY2xvc2VkO1xuXG5cbiAgICAgIH0pO1xuXG5cbiAgICAgIC8vIE9oLCB5b3UncmUgYSBuZXN0ZWQgR1VJIVxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGlmIChwYXJhbXMuY2xvc2VkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyYW1zLmNsb3NlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB0aXRsZV9yb3dfbmFtZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHBhcmFtcy5uYW1lKTtcbiAgICAgIGRvbS5hZGRDbGFzcyh0aXRsZV9yb3dfbmFtZSwgJ2NvbnRyb2xsZXItbmFtZScpO1xuXG4gICAgICB2YXIgdGl0bGVfcm93ID0gYWRkUm93KF90aGlzLCB0aXRsZV9yb3dfbmFtZSk7XG5cbiAgICAgIHZhciBvbl9jbGlja190aXRsZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBfdGhpcy5jbG9zZWQgPSAhX3RoaXMuY2xvc2VkO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICBkb20uYWRkQ2xhc3ModGhpcy5fX3VsLCBHVUkuQ0xBU1NfQ0xPU0VEKTtcblxuICAgICAgZG9tLmFkZENsYXNzKHRpdGxlX3JvdywgJ3RpdGxlJyk7XG4gICAgICBkb20uYmluZCh0aXRsZV9yb3csICdjbGljaycsIG9uX2NsaWNrX3RpdGxlKTtcblxuICAgICAgaWYgKCFwYXJhbXMuY2xvc2VkKSB7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmF1dG9QbGFjZSkge1xuXG4gICAgICBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpKSB7XG5cbiAgICAgICAgaWYgKGF1dG9fcGxhY2VfdmlyZ2luKSB7XG4gICAgICAgICAgYXV0b19wbGFjZV9jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICBkb20uYWRkQ2xhc3MoYXV0b19wbGFjZV9jb250YWluZXIsIENTU19OQU1FU1BBQ0UpO1xuICAgICAgICAgIGRvbS5hZGRDbGFzcyhhdXRvX3BsYWNlX2NvbnRhaW5lciwgR1VJLkNMQVNTX0FVVE9fUExBQ0VfQ09OVEFJTkVSKTtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGF1dG9fcGxhY2VfY29udGFpbmVyKTtcbiAgICAgICAgICBhdXRvX3BsYWNlX3ZpcmdpbiA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHV0IGl0IGluIHRoZSBkb20gZm9yIHlvdS5cbiAgICAgICAgYXV0b19wbGFjZV9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb21FbGVtZW50KTtcblxuICAgICAgICAvLyBBcHBseSB0aGUgYXV0byBzdHlsZXNcbiAgICAgICAgZG9tLmFkZENsYXNzKHRoaXMuZG9tRWxlbWVudCwgR1VJLkNMQVNTX0FVVE9fUExBQ0UpO1xuXG4gICAgICB9XG5cblxuICAgICAgLy8gTWFrZSBpdCBub3QgZWxhc3RpYy5cbiAgICAgIGlmICghdGhpcy5wYXJlbnQpIHNldFdpZHRoKF90aGlzLCBwYXJhbXMud2lkdGgpO1xuXG4gICAgfVxuXG4gICAgZG9tLmJpbmQod2luZG93LCAncmVzaXplJywgZnVuY3Rpb24oKSB7IF90aGlzLm9uUmVzaXplKCkgfSk7XG4gICAgZG9tLmJpbmQodGhpcy5fX3VsLCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uKCkgeyBfdGhpcy5vblJlc2l6ZSgpOyB9KTtcbiAgICBkb20uYmluZCh0aGlzLl9fdWwsICd0cmFuc2l0aW9uZW5kJywgZnVuY3Rpb24oKSB7IF90aGlzLm9uUmVzaXplKCkgfSk7XG4gICAgZG9tLmJpbmQodGhpcy5fX3VsLCAnb1RyYW5zaXRpb25FbmQnLCBmdW5jdGlvbigpIHsgX3RoaXMub25SZXNpemUoKSB9KTtcbiAgICB0aGlzLm9uUmVzaXplKCk7XG5cblxuICAgIGlmIChwYXJhbXMucmVzaXphYmxlKSB7XG4gICAgICBhZGRSZXNpemVIYW5kbGUodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2F2ZVRvTG9jYWxTdG9yYWdlKCkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaChfdGhpcywgJ2d1aScpLCBKU09OLnN0cmluZ2lmeShfdGhpcy5nZXRTYXZlT2JqZWN0KCkpKTtcbiAgICB9XG5cbiAgICB2YXIgcm9vdCA9IF90aGlzLmdldFJvb3QoKTtcbiAgICBmdW5jdGlvbiByZXNldFdpZHRoKCkge1xuICAgICAgICB2YXIgcm9vdCA9IF90aGlzLmdldFJvb3QoKTtcbiAgICAgICAgcm9vdC53aWR0aCArPSAxO1xuICAgICAgICBjb21tb24uZGVmZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcm9vdC53aWR0aCAtPSAxO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYXJhbXMucGFyZW50KSB7XG4gICAgICAgIHJlc2V0V2lkdGgoKTtcbiAgICAgIH1cblxuICB9O1xuXG4gIEdVSS50b2dnbGVIaWRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICBoaWRlID0gIWhpZGU7XG4gICAgY29tbW9uLmVhY2goaGlkZWFibGVfZ3VpcywgZnVuY3Rpb24oZ3VpKSB7XG4gICAgICBndWkuZG9tRWxlbWVudC5zdHlsZS56SW5kZXggPSBoaWRlID8gLTk5OSA6IDk5OTtcbiAgICAgIGd1aS5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHkgPSBoaWRlID8gMCA6IDE7XG4gICAgfSk7XG4gIH07XG5cbiAgR1VJLkNMQVNTX0FVVE9fUExBQ0UgPSAnYSc7XG4gIEdVSS5DTEFTU19BVVRPX1BMQUNFX0NPTlRBSU5FUiA9ICdhYyc7XG4gIEdVSS5DTEFTU19NQUlOID0gJ21haW4nO1xuICBHVUkuQ0xBU1NfQ09OVFJPTExFUl9ST1cgPSAnY3InO1xuICBHVUkuQ0xBU1NfVE9PX1RBTEwgPSAndGFsbGVyLXRoYW4td2luZG93JztcbiAgR1VJLkNMQVNTX0NMT1NFRCA9ICdjbG9zZWQnO1xuICBHVUkuQ0xBU1NfQ0xPU0VfQlVUVE9OID0gJ2Nsb3NlLWJ1dHRvbic7XG4gIEdVSS5DTEFTU19EUkFHID0gJ2RyYWcnO1xuXG4gIEdVSS5ERUZBVUxUX1dJRFRIID0gMjQ1O1xuICBHVUkuVEVYVF9DTE9TRUQgPSAnQ2xvc2UgQ29udHJvbHMnO1xuICBHVUkuVEVYVF9PUEVOID0gJ09wZW4gQ29udHJvbHMnO1xuXG4gIGRvbS5iaW5kKHdpbmRvdywgJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG5cbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudC50eXBlICE9PSAndGV4dCcgJiZcbiAgICAgICAgKGUud2hpY2ggPT09IEhJREVfS0VZX0NPREUgfHwgZS5rZXlDb2RlID09IEhJREVfS0VZX0NPREUpKSB7XG4gICAgICBHVUkudG9nZ2xlSGlkZSgpO1xuICAgIH1cblxuICB9LCBmYWxzZSk7XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgR1VJLnByb3RvdHlwZSxcblxuICAgICAgLyoqIEBsZW5kcyBkYXQuZ3VpLkdVSSAqL1xuICAgICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eVxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJ9IFRoZSBuZXcgY29udHJvbGxlciB0aGF0IHdhcyBhZGRlZC5cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcblxuICAgICAgICAgIHJldHVybiBhZGQoXG4gICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmYWN0b3J5QXJnczogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eVxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0LmNvbnRyb2xsZXJzLkNvbG9yQ29udHJvbGxlcn0gVGhlIG5ldyBjb250cm9sbGVyIHRoYXQgd2FzIGFkZGVkLlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIGFkZENvbG9yOiBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG5cbiAgICAgICAgICByZXR1cm4gYWRkKFxuICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29sb3I6IHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGNvbnRyb2xsZXJcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKGNvbnRyb2xsZXIpIHtcblxuICAgICAgICAgIC8vIFRPRE8gbGlzdGVuaW5nP1xuICAgICAgICAgIHRoaXMuX191bC5yZW1vdmVDaGlsZChjb250cm9sbGVyLl9fbGkpO1xuICAgICAgICAgIHRoaXMuX19jb250cm9sbGVycy5zbGljZSh0aGlzLl9fY29udHJvbGxlcnMuaW5kZXhPZihjb250cm9sbGVyKSwgMSk7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBjb21tb24uZGVmZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBfdGhpcy5vblJlc2l6ZSgpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICBpZiAodGhpcy5hdXRvUGxhY2UpIHtcbiAgICAgICAgICAgIGF1dG9fcGxhY2VfY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuZG9tRWxlbWVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuZ3VpLkdVSX0gVGhlIG5ldyBmb2xkZXIuXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGlzIEdVSSBhbHJlYWR5IGhhcyBhIGZvbGRlciBieSB0aGUgc3BlY2lmaWVkXG4gICAgICAgICAqIG5hbWVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBhZGRGb2xkZXI6IGZ1bmN0aW9uKG5hbWUpIHtcblxuICAgICAgICAgIC8vIFdlIGhhdmUgdG8gcHJldmVudCBjb2xsaXNpb25zIG9uIG5hbWVzIGluIG9yZGVyIHRvIGhhdmUgYSBrZXlcbiAgICAgICAgICAvLyBieSB3aGljaCB0byByZW1lbWJlciBzYXZlZCB2YWx1ZXNcbiAgICAgICAgICBpZiAodGhpcy5fX2ZvbGRlcnNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgYWxyZWFkeSBoYXZlIGEgZm9sZGVyIGluIHRoaXMgR1VJIGJ5IHRoZScgK1xuICAgICAgICAgICAgICAgICcgbmFtZSBcIicgKyBuYW1lICsgJ1wiJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5ld19ndWlfcGFyYW1zID0geyBuYW1lOiBuYW1lLCBwYXJlbnQ6IHRoaXMgfTtcblxuICAgICAgICAgIC8vIFdlIG5lZWQgdG8gcGFzcyBkb3duIHRoZSBhdXRvUGxhY2UgdHJhaXQgc28gdGhhdCB3ZSBjYW5cbiAgICAgICAgICAvLyBhdHRhY2ggZXZlbnQgbGlzdGVuZXJzIHRvIG9wZW4vY2xvc2UgZm9sZGVyIGFjdGlvbnMgdG9cbiAgICAgICAgICAvLyBlbnN1cmUgdGhhdCBhIHNjcm9sbGJhciBhcHBlYXJzIGlmIHRoZSB3aW5kb3cgaXMgdG9vIHNob3J0LlxuICAgICAgICAgIG5ld19ndWlfcGFyYW1zLmF1dG9QbGFjZSA9IHRoaXMuYXV0b1BsYWNlO1xuXG4gICAgICAgICAgLy8gRG8gd2UgaGF2ZSBzYXZlZCBhcHBlYXJhbmNlIGRhdGEgZm9yIHRoaXMgZm9sZGVyP1xuXG4gICAgICAgICAgaWYgKHRoaXMubG9hZCAmJiAvLyBBbnl0aGluZyBsb2FkZWQ/XG4gICAgICAgICAgICAgIHRoaXMubG9hZC5mb2xkZXJzICYmIC8vIFdhcyBteSBwYXJlbnQgYSBkZWFkLWVuZD9cbiAgICAgICAgICAgICAgdGhpcy5sb2FkLmZvbGRlcnNbbmFtZV0pIHsgLy8gRGlkIGRhZGR5IHJlbWVtYmVyIG1lP1xuXG4gICAgICAgICAgICAvLyBTdGFydCBtZSBjbG9zZWQgaWYgSSB3YXMgY2xvc2VkXG4gICAgICAgICAgICBuZXdfZ3VpX3BhcmFtcy5jbG9zZWQgPSB0aGlzLmxvYWQuZm9sZGVyc1tuYW1lXS5jbG9zZWQ7XG5cbiAgICAgICAgICAgIC8vIFBhc3MgZG93biB0aGUgbG9hZGVkIGRhdGFcbiAgICAgICAgICAgIG5ld19ndWlfcGFyYW1zLmxvYWQgPSB0aGlzLmxvYWQuZm9sZGVyc1tuYW1lXTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBndWkgPSBuZXcgR1VJKG5ld19ndWlfcGFyYW1zKTtcbiAgICAgICAgICB0aGlzLl9fZm9sZGVyc1tuYW1lXSA9IGd1aTtcblxuICAgICAgICAgIHZhciBsaSA9IGFkZFJvdyh0aGlzLCBndWkuZG9tRWxlbWVudCk7XG4gICAgICAgICAgZG9tLmFkZENsYXNzKGxpLCAnZm9sZGVyJyk7XG4gICAgICAgICAgcmV0dXJuIGd1aTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIG9wZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblJlc2l6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMuZ2V0Um9vdCgpO1xuXG4gICAgICAgICAgaWYgKHJvb3Quc2Nyb2xsYWJsZSkge1xuXG4gICAgICAgICAgICB2YXIgdG9wID0gZG9tLmdldE9mZnNldChyb290Ll9fdWwpLnRvcDtcbiAgICAgICAgICAgIHZhciBoID0gMDtcblxuICAgICAgICAgICAgY29tbW9uLmVhY2gocm9vdC5fX3VsLmNoaWxkTm9kZXMsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgaWYgKCEgKHJvb3QuYXV0b1BsYWNlICYmIG5vZGUgPT09IHJvb3QuX19zYXZlX3JvdykpXG4gICAgICAgICAgICAgICAgaCArPSBkb20uZ2V0SGVpZ2h0KG5vZGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICh3aW5kb3cuaW5uZXJIZWlnaHQgLSB0b3AgLSBDTE9TRV9CVVRUT05fSEVJR0hUIDwgaCkge1xuICAgICAgICAgICAgICBkb20uYWRkQ2xhc3Mocm9vdC5kb21FbGVtZW50LCBHVUkuQ0xBU1NfVE9PX1RBTEwpO1xuICAgICAgICAgICAgICByb290Ll9fdWwuc3R5bGUuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC0gdG9wIC0gQ0xPU0VfQlVUVE9OX0hFSUdIVCArICdweCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3Mocm9vdC5kb21FbGVtZW50LCBHVUkuQ0xBU1NfVE9PX1RBTEwpO1xuICAgICAgICAgICAgICByb290Ll9fdWwuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJvb3QuX19yZXNpemVfaGFuZGxlKSB7XG4gICAgICAgICAgICBjb21tb24uZGVmZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJvb3QuX19yZXNpemVfaGFuZGxlLnN0eWxlLmhlaWdodCA9IHJvb3QuX191bC5vZmZzZXRIZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJvb3QuX19jbG9zZUJ1dHRvbikge1xuICAgICAgICAgICAgcm9vdC5fX2Nsb3NlQnV0dG9uLnN0eWxlLndpZHRoID0gcm9vdC53aWR0aCArICdweCc7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmsgb2JqZWN0cyBmb3Igc2F2aW5nLiBUaGUgb3JkZXIgb2YgdGhlc2Ugb2JqZWN0cyBjYW5ub3QgY2hhbmdlIGFzXG4gICAgICAgICAqIHRoZSBHVUkgZ3Jvd3MuIFdoZW4gcmVtZW1iZXJpbmcgbmV3IG9iamVjdHMsIGFwcGVuZCB0aGVtIHRvIHRoZSBlbmRcbiAgICAgICAgICogb2YgdGhlIGxpc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0Li4ufSBvYmplY3RzXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiBub3QgY2FsbGVkIG9uIGEgdG9wIGxldmVsIEdVSS5cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICByZW1lbWJlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKFNBVkVfRElBTE9HVUUpKSB7XG4gICAgICAgICAgICBTQVZFX0RJQUxPR1VFID0gbmV3IENlbnRlcmVkRGl2KCk7XG4gICAgICAgICAgICBTQVZFX0RJQUxPR1VFLmRvbUVsZW1lbnQuaW5uZXJIVE1MID0gc2F2ZURpYWxvZ3VlQ29udGVudHM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2FuIG9ubHkgY2FsbCByZW1lbWJlciBvbiBhIHRvcCBsZXZlbCBHVUkuXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgICBjb21tb24uZWFjaChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLCBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgIGFkZFNhdmVNZW51KF90aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzLmluZGV4T2Yob2JqZWN0KSA9PSAtMSkge1xuICAgICAgICAgICAgICBfdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzLnB1c2gob2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0aGlzLmF1dG9QbGFjZSkge1xuICAgICAgICAgICAgLy8gU2V0IHNhdmUgcm93IHdpZHRoXG4gICAgICAgICAgICBzZXRXaWR0aCh0aGlzLCB0aGlzLndpZHRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge2RhdC5ndWkuR1VJfSB0aGUgdG9wbW9zdCBwYXJlbnQgR1VJIG9mIGEgbmVzdGVkIEdVSS5cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRSb290OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZ3VpID0gdGhpcztcbiAgICAgICAgICB3aGlsZSAoZ3VpLnBhcmVudCkge1xuICAgICAgICAgICAgZ3VpID0gZ3VpLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGd1aTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gYSBKU09OIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgc3RhdGUgb2ZcbiAgICAgICAgICogdGhpcyBHVUkgYXMgd2VsbCBhcyBpdHMgcmVtZW1iZXJlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIGdldFNhdmVPYmplY3Q6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgdmFyIHRvUmV0dXJuID0gdGhpcy5sb2FkO1xuXG4gICAgICAgICAgdG9SZXR1cm4uY2xvc2VkID0gdGhpcy5jbG9zZWQ7XG5cbiAgICAgICAgICAvLyBBbSBJIHJlbWVtYmVyaW5nIGFueSB2YWx1ZXM/XG4gICAgICAgICAgaWYgKHRoaXMuX19yZW1lbWJlcmVkT2JqZWN0cy5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgICAgIHRvUmV0dXJuLnByZXNldCA9IHRoaXMucHJlc2V0O1xuXG4gICAgICAgICAgICBpZiAoIXRvUmV0dXJuLnJlbWVtYmVyZWQpIHtcbiAgICAgICAgICAgICAgdG9SZXR1cm4ucmVtZW1iZXJlZCA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b1JldHVybi5yZW1lbWJlcmVkW3RoaXMucHJlc2V0XSA9IGdldEN1cnJlbnRQcmVzZXQodGhpcyk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b1JldHVybi5mb2xkZXJzID0ge307XG4gICAgICAgICAgY29tbW9uLmVhY2godGhpcy5fX2ZvbGRlcnMsIGZ1bmN0aW9uKGVsZW1lbnQsIGtleSkge1xuICAgICAgICAgICAgdG9SZXR1cm4uZm9sZGVyc1trZXldID0gZWxlbWVudC5nZXRTYXZlT2JqZWN0KCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gdG9SZXR1cm47XG5cbiAgICAgICAgfSxcblxuICAgICAgICBzYXZlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIGlmICghdGhpcy5sb2FkLnJlbWVtYmVyZWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkID0ge307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWRbdGhpcy5wcmVzZXRdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzKTtcbiAgICAgICAgICBtYXJrUHJlc2V0TW9kaWZpZWQodGhpcywgZmFsc2UpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2F2ZUFzOiBmdW5jdGlvbihwcmVzZXROYW1lKSB7XG5cbiAgICAgICAgICBpZiAoIXRoaXMubG9hZC5yZW1lbWJlcmVkKSB7XG5cbiAgICAgICAgICAgIC8vIFJldGFpbiBkZWZhdWx0IHZhbHVlcyB1cG9uIGZpcnN0IHNhdmVcbiAgICAgICAgICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkID0ge307XG4gICAgICAgICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZFtERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUVdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzLCB0cnVlKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkW3ByZXNldE5hbWVdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnByZXNldCA9IHByZXNldE5hbWU7XG4gICAgICAgICAgYWRkUHJlc2V0T3B0aW9uKHRoaXMsIHByZXNldE5hbWUsIHRydWUpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgcmV2ZXJ0OiBmdW5jdGlvbihndWkpIHtcblxuICAgICAgICAgIGNvbW1vbi5lYWNoKHRoaXMuX19jb250cm9sbGVycywgZnVuY3Rpb24oY29udHJvbGxlcikge1xuICAgICAgICAgICAgLy8gTWFrZSByZXZlcnQgd29yayBvbiBEZWZhdWx0LlxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldFJvb3QoKS5sb2FkLnJlbWVtYmVyZWQpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5zZXRWYWx1ZShjb250cm9sbGVyLmluaXRpYWxWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWNhbGxTYXZlZFZhbHVlKGd1aSB8fCB0aGlzLmdldFJvb3QoKSwgY29udHJvbGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICBjb21tb24uZWFjaCh0aGlzLl9fZm9sZGVycywgZnVuY3Rpb24oZm9sZGVyKSB7XG4gICAgICAgICAgICBmb2xkZXIucmV2ZXJ0KGZvbGRlcik7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIWd1aSkge1xuICAgICAgICAgICAgbWFya1ByZXNldE1vZGlmaWVkKHRoaXMuZ2V0Um9vdCgpLCBmYWxzZSk7XG4gICAgICAgICAgfVxuXG5cbiAgICAgICAgfSxcblxuICAgICAgICBsaXN0ZW46IGZ1bmN0aW9uKGNvbnRyb2xsZXIpIHtcblxuICAgICAgICAgIHZhciBpbml0ID0gdGhpcy5fX2xpc3RlbmluZy5sZW5ndGggPT0gMDtcbiAgICAgICAgICB0aGlzLl9fbGlzdGVuaW5nLnB1c2goY29udHJvbGxlcik7XG4gICAgICAgICAgaWYgKGluaXQpIHVwZGF0ZURpc3BsYXlzKHRoaXMuX19saXN0ZW5pbmcpO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICk7XG5cbiAgZnVuY3Rpb24gYWRkKGd1aSwgb2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSB7XG5cbiAgICBpZiAob2JqZWN0W3Byb3BlcnR5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3QgXCIgKyBvYmplY3QgKyBcIiBoYXMgbm8gcHJvcGVydHkgXFxcIlwiICsgcHJvcGVydHkgKyBcIlxcXCJcIik7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRyb2xsZXI7XG5cbiAgICBpZiAocGFyYW1zLmNvbG9yKSB7XG5cbiAgICAgIGNvbnRyb2xsZXIgPSBuZXcgQ29sb3JDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgdmFyIGZhY3RvcnlBcmdzID0gW29iamVjdCxwcm9wZXJ0eV0uY29uY2F0KHBhcmFtcy5mYWN0b3J5QXJncyk7XG4gICAgICBjb250cm9sbGVyID0gY29udHJvbGxlckZhY3RvcnkuYXBwbHkoZ3VpLCBmYWN0b3J5QXJncyk7XG5cbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmJlZm9yZSBpbnN0YW5jZW9mIENvbnRyb2xsZXIpIHtcbiAgICAgIHBhcmFtcy5iZWZvcmUgPSBwYXJhbXMuYmVmb3JlLl9fbGk7XG4gICAgfVxuXG4gICAgcmVjYWxsU2F2ZWRWYWx1ZShndWksIGNvbnRyb2xsZXIpO1xuXG4gICAgZG9tLmFkZENsYXNzKGNvbnRyb2xsZXIuZG9tRWxlbWVudCwgJ2MnKTtcblxuICAgIHZhciBuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGRvbS5hZGRDbGFzcyhuYW1lLCAncHJvcGVydHktbmFtZScpO1xuICAgIG5hbWUuaW5uZXJIVE1MID0gY29udHJvbGxlci5wcm9wZXJ0eTtcblxuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobmFtZSk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRyb2xsZXIuZG9tRWxlbWVudCk7XG5cbiAgICB2YXIgbGkgPSBhZGRSb3coZ3VpLCBjb250YWluZXIsIHBhcmFtcy5iZWZvcmUpO1xuXG4gICAgZG9tLmFkZENsYXNzKGxpLCBHVUkuQ0xBU1NfQ09OVFJPTExFUl9ST1cpO1xuICAgIGRvbS5hZGRDbGFzcyhsaSwgdHlwZW9mIGNvbnRyb2xsZXIuZ2V0VmFsdWUoKSk7XG5cbiAgICBhdWdtZW50Q29udHJvbGxlcihndWksIGxpLCBjb250cm9sbGVyKTtcblxuICAgIGd1aS5fX2NvbnRyb2xsZXJzLnB1c2goY29udHJvbGxlcik7XG5cbiAgICByZXR1cm4gY29udHJvbGxlcjtcblxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHJvdyB0byB0aGUgZW5kIG9mIHRoZSBHVUkgb3IgYmVmb3JlIGFub3RoZXIgcm93LlxuICAgKlxuICAgKiBAcGFyYW0gZ3VpXG4gICAqIEBwYXJhbSBbZG9tXSBJZiBzcGVjaWZpZWQsIGluc2VydHMgdGhlIGRvbSBjb250ZW50IGluIHRoZSBuZXcgcm93XG4gICAqIEBwYXJhbSBbbGlCZWZvcmVdIElmIHNwZWNpZmllZCwgcGxhY2VzIHRoZSBuZXcgcm93IGJlZm9yZSBhbm90aGVyIHJvd1xuICAgKi9cbiAgZnVuY3Rpb24gYWRkUm93KGd1aSwgZG9tLCBsaUJlZm9yZSkge1xuICAgIHZhciBsaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgaWYgKGRvbSkgbGkuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICBpZiAobGlCZWZvcmUpIHtcbiAgICAgIGd1aS5fX3VsLmluc2VydEJlZm9yZShsaSwgcGFyYW1zLmJlZm9yZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGd1aS5fX3VsLmFwcGVuZENoaWxkKGxpKTtcbiAgICB9XG4gICAgZ3VpLm9uUmVzaXplKCk7XG4gICAgcmV0dXJuIGxpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXVnbWVudENvbnRyb2xsZXIoZ3VpLCBsaSwgY29udHJvbGxlcikge1xuXG4gICAgY29udHJvbGxlci5fX2xpID0gbGk7XG4gICAgY29udHJvbGxlci5fX2d1aSA9IGd1aTtcblxuICAgIGNvbW1vbi5leHRlbmQoY29udHJvbGxlciwge1xuXG4gICAgICBvcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgY29udHJvbGxlci5yZW1vdmUoKTtcblxuICAgICAgICAgIHJldHVybiBhZGQoXG4gICAgICAgICAgICAgIGd1aSxcbiAgICAgICAgICAgICAgY29udHJvbGxlci5vYmplY3QsXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIucHJvcGVydHksXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiZWZvcmU6IGNvbnRyb2xsZXIuX19saS5uZXh0RWxlbWVudFNpYmxpbmcsXG4gICAgICAgICAgICAgICAgZmFjdG9yeUFyZ3M6IFtjb21tb24udG9BcnJheShhcmd1bWVudHMpXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbW1vbi5pc0FycmF5KG9wdGlvbnMpIHx8IGNvbW1vbi5pc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICAgIGNvbnRyb2xsZXIucmVtb3ZlKCk7XG5cbiAgICAgICAgICByZXR1cm4gYWRkKFxuICAgICAgICAgICAgICBndWksXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIub2JqZWN0LFxuICAgICAgICAgICAgICBjb250cm9sbGVyLnByb3BlcnR5LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmVmb3JlOiBjb250cm9sbGVyLl9fbGkubmV4dEVsZW1lbnRTaWJsaW5nLFxuICAgICAgICAgICAgICAgIGZhY3RvcnlBcmdzOiBbb3B0aW9uc11cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9LFxuXG4gICAgICBuYW1lOiBmdW5jdGlvbih2KSB7XG4gICAgICAgIGNvbnRyb2xsZXIuX19saS5maXJzdEVsZW1lbnRDaGlsZC5maXJzdEVsZW1lbnRDaGlsZC5pbm5lckhUTUwgPSB2O1xuICAgICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICAgIH0sXG5cbiAgICAgIGxpc3RlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuX19ndWkubGlzdGVuKGNvbnRyb2xsZXIpO1xuICAgICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICAgIH0sXG5cbiAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuX19ndWkucmVtb3ZlKGNvbnRyb2xsZXIpO1xuICAgICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgLy8gQWxsIHNsaWRlcnMgc2hvdWxkIGJlIGFjY29tcGFuaWVkIGJ5IGEgYm94LlxuICAgIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgTnVtYmVyQ29udHJvbGxlclNsaWRlcikge1xuXG4gICAgICB2YXIgYm94ID0gbmV3IE51bWJlckNvbnRyb2xsZXJCb3goY29udHJvbGxlci5vYmplY3QsIGNvbnRyb2xsZXIucHJvcGVydHksXG4gICAgICAgICAgeyBtaW46IGNvbnRyb2xsZXIuX19taW4sIG1heDogY29udHJvbGxlci5fX21heCwgc3RlcDogY29udHJvbGxlci5fX3N0ZXAgfSk7XG5cbiAgICAgIGNvbW1vbi5lYWNoKFsndXBkYXRlRGlzcGxheScsICdvbkNoYW5nZScsICdvbkZpbmlzaENoYW5nZSddLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgdmFyIHBjID0gY29udHJvbGxlclttZXRob2RdO1xuICAgICAgICB2YXIgcGIgPSBib3hbbWV0aG9kXTtcbiAgICAgICAgY29udHJvbGxlclttZXRob2RdID0gYm94W21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgcGMuYXBwbHkoY29udHJvbGxlciwgYXJncyk7XG4gICAgICAgICAgcmV0dXJuIHBiLmFwcGx5KGJveCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBkb20uYWRkQ2xhc3MobGksICdoYXMtc2xpZGVyJyk7XG4gICAgICBjb250cm9sbGVyLmRvbUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGJveC5kb21FbGVtZW50LCBjb250cm9sbGVyLmRvbUVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpO1xuXG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBOdW1iZXJDb250cm9sbGVyQm94KSB7XG5cbiAgICAgIHZhciByID0gZnVuY3Rpb24ocmV0dXJuZWQpIHtcblxuICAgICAgICAvLyBIYXZlIHdlIGRlZmluZWQgYm90aCBib3VuZGFyaWVzP1xuICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKGNvbnRyb2xsZXIuX19taW4pICYmIGNvbW1vbi5pc051bWJlcihjb250cm9sbGVyLl9fbWF4KSkge1xuXG4gICAgICAgICAgLy8gV2VsbCwgdGhlbiBsZXRzIGp1c3QgcmVwbGFjZSB0aGlzIHdpdGggYSBzbGlkZXIuXG4gICAgICAgICAgY29udHJvbGxlci5yZW1vdmUoKTtcbiAgICAgICAgICByZXR1cm4gYWRkKFxuICAgICAgICAgICAgICBndWksXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIub2JqZWN0LFxuICAgICAgICAgICAgICBjb250cm9sbGVyLnByb3BlcnR5LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmVmb3JlOiBjb250cm9sbGVyLl9fbGkubmV4dEVsZW1lbnRTaWJsaW5nLFxuICAgICAgICAgICAgICAgIGZhY3RvcnlBcmdzOiBbY29udHJvbGxlci5fX21pbiwgY29udHJvbGxlci5fX21heCwgY29udHJvbGxlci5fX3N0ZXBdXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0dXJuZWQ7XG5cbiAgICAgIH07XG5cbiAgICAgIGNvbnRyb2xsZXIubWluID0gY29tbW9uLmNvbXBvc2UociwgY29udHJvbGxlci5taW4pO1xuICAgICAgY29udHJvbGxlci5tYXggPSBjb21tb24uY29tcG9zZShyLCBjb250cm9sbGVyLm1heCk7XG5cbiAgICB9XG4gICAgZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIEJvb2xlYW5Db250cm9sbGVyKSB7XG5cbiAgICAgIGRvbS5iaW5kKGxpLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZG9tLmZha2VFdmVudChjb250cm9sbGVyLl9fY2hlY2tib3gsICdjbGljaycpO1xuICAgICAgfSk7XG5cbiAgICAgIGRvbS5iaW5kKGNvbnRyb2xsZXIuX19jaGVja2JveCwgJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpOyAvLyBQcmV2ZW50cyBkb3VibGUtdG9nZ2xlXG4gICAgICB9KVxuXG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBGdW5jdGlvbkNvbnRyb2xsZXIpIHtcblxuICAgICAgZG9tLmJpbmQobGksICdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICBkb20uZmFrZUV2ZW50KGNvbnRyb2xsZXIuX19idXR0b24sICdjbGljaycpO1xuICAgICAgfSk7XG5cbiAgICAgIGRvbS5iaW5kKGxpLCAnbW91c2VvdmVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvbS5hZGRDbGFzcyhjb250cm9sbGVyLl9fYnV0dG9uLCAnaG92ZXInKTtcbiAgICAgIH0pO1xuXG4gICAgICBkb20uYmluZChsaSwgJ21vdXNlb3V0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcyhjb250cm9sbGVyLl9fYnV0dG9uLCAnaG92ZXInKTtcbiAgICAgIH0pO1xuXG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBDb2xvckNvbnRyb2xsZXIpIHtcblxuICAgICAgZG9tLmFkZENsYXNzKGxpLCAnY29sb3InKTtcbiAgICAgIGNvbnRyb2xsZXIudXBkYXRlRGlzcGxheSA9IGNvbW1vbi5jb21wb3NlKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgbGkuc3R5bGUuYm9yZGVyTGVmdENvbG9yID0gY29udHJvbGxlci5fX2NvbG9yLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfSwgY29udHJvbGxlci51cGRhdGVEaXNwbGF5KTtcblxuICAgICAgY29udHJvbGxlci51cGRhdGVEaXNwbGF5KCk7XG5cbiAgICB9XG5cbiAgICBjb250cm9sbGVyLnNldFZhbHVlID0gY29tbW9uLmNvbXBvc2UoZnVuY3Rpb24ocikge1xuICAgICAgaWYgKGd1aS5nZXRSb290KCkuX19wcmVzZXRfc2VsZWN0ICYmIGNvbnRyb2xsZXIuaXNNb2RpZmllZCgpKSB7XG4gICAgICAgIG1hcmtQcmVzZXRNb2RpZmllZChndWkuZ2V0Um9vdCgpLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH0sIGNvbnRyb2xsZXIuc2V0VmFsdWUpO1xuXG4gIH1cblxuICBmdW5jdGlvbiByZWNhbGxTYXZlZFZhbHVlKGd1aSwgY29udHJvbGxlcikge1xuXG4gICAgLy8gRmluZCB0aGUgdG9wbW9zdCBHVUksIHRoYXQncyB3aGVyZSByZW1lbWJlcmVkIG9iamVjdHMgbGl2ZS5cbiAgICB2YXIgcm9vdCA9IGd1aS5nZXRSb290KCk7XG5cbiAgICAvLyBEb2VzIHRoZSBvYmplY3Qgd2UncmUgY29udHJvbGxpbmcgbWF0Y2ggYW55dGhpbmcgd2UndmUgYmVlbiB0b2xkIHRvXG4gICAgLy8gcmVtZW1iZXI/XG4gICAgdmFyIG1hdGNoZWRfaW5kZXggPSByb290Ll9fcmVtZW1iZXJlZE9iamVjdHMuaW5kZXhPZihjb250cm9sbGVyLm9iamVjdCk7XG5cbiAgICAvLyBXaHkgeWVzLCBpdCBkb2VzIVxuICAgIGlmIChtYXRjaGVkX2luZGV4ICE9IC0xKSB7XG5cbiAgICAgIC8vIExldCBtZSBmZXRjaCBhIG1hcCBvZiBjb250cm9sbGVycyBmb3IgdGhjb21tb24uaXNPYmplY3QuXG4gICAgICB2YXIgY29udHJvbGxlcl9tYXAgPVxuICAgICAgICAgIHJvb3QuX19yZW1lbWJlcmVkT2JqZWN0SW5kZWNlc1RvQ29udHJvbGxlcnNbbWF0Y2hlZF9pbmRleF07XG5cbiAgICAgIC8vIE9ocCwgSSBiZWxpZXZlIHRoaXMgaXMgdGhlIGZpcnN0IGNvbnRyb2xsZXIgd2UndmUgY3JlYXRlZCBmb3IgdGhpc1xuICAgICAgLy8gb2JqZWN0LiBMZXRzIG1ha2UgdGhlIG1hcCBmcmVzaC5cbiAgICAgIGlmIChjb250cm9sbGVyX21hcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRyb2xsZXJfbWFwID0ge307XG4gICAgICAgIHJvb3QuX19yZW1lbWJlcmVkT2JqZWN0SW5kZWNlc1RvQ29udHJvbGxlcnNbbWF0Y2hlZF9pbmRleF0gPVxuICAgICAgICAgICAgY29udHJvbGxlcl9tYXA7XG4gICAgICB9XG5cbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhpcyBjb250cm9sbGVyXG4gICAgICBjb250cm9sbGVyX21hcFtjb250cm9sbGVyLnByb3BlcnR5XSA9IGNvbnRyb2xsZXI7XG5cbiAgICAgIC8vIE9rYXksIG5vdyBoYXZlIHdlIHNhdmVkIGFueSB2YWx1ZXMgZm9yIHRoaXMgY29udHJvbGxlcj9cbiAgICAgIGlmIChyb290LmxvYWQgJiYgcm9vdC5sb2FkLnJlbWVtYmVyZWQpIHtcblxuICAgICAgICB2YXIgcHJlc2V0X21hcCA9IHJvb3QubG9hZC5yZW1lbWJlcmVkO1xuXG4gICAgICAgIC8vIFdoaWNoIHByZXNldCBhcmUgd2UgdHJ5aW5nIHRvIGxvYWQ/XG4gICAgICAgIHZhciBwcmVzZXQ7XG5cbiAgICAgICAgaWYgKHByZXNldF9tYXBbZ3VpLnByZXNldF0pIHtcblxuICAgICAgICAgIHByZXNldCA9IHByZXNldF9tYXBbZ3VpLnByZXNldF07XG5cbiAgICAgICAgfSBlbHNlIGlmIChwcmVzZXRfbWFwW0RFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRV0pIHtcblxuICAgICAgICAgIC8vIFVoaCwgeW91IGNhbiBoYXZlIHRoZSBkZWZhdWx0IGluc3RlYWQ/XG4gICAgICAgICAgcHJlc2V0ID0gcHJlc2V0X21hcFtERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUVdO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAvLyBOYWRhLlxuXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIERpZCB0aGUgbG9hZGVkIG9iamVjdCByZW1lbWJlciB0aGNvbW1vbi5pc09iamVjdD9cbiAgICAgICAgaWYgKHByZXNldFttYXRjaGVkX2luZGV4XSAmJlxuXG4gICAgICAgICAgLy8gRGlkIHdlIHJlbWVtYmVyIHRoaXMgcGFydGljdWxhciBwcm9wZXJ0eT9cbiAgICAgICAgICAgIHByZXNldFttYXRjaGVkX2luZGV4XVtjb250cm9sbGVyLnByb3BlcnR5XSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAvLyBXZSBkaWQgcmVtZW1iZXIgc29tZXRoaW5nIGZvciB0aGlzIGd1eSAuLi5cbiAgICAgICAgICB2YXIgdmFsdWUgPSBwcmVzZXRbbWF0Y2hlZF9pbmRleF1bY29udHJvbGxlci5wcm9wZXJ0eV07XG5cbiAgICAgICAgICAvLyBBbmQgdGhhdCdzIHdoYXQgaXQgaXMuXG4gICAgICAgICAgY29udHJvbGxlci5pbml0aWFsVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBjb250cm9sbGVyLnNldFZhbHVlKHZhbHVlKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TG9jYWxTdG9yYWdlSGFzaChndWksIGtleSkge1xuICAgIC8vIFRPRE8gaG93IGRvZXMgdGhpcyBkZWFsIHdpdGggbXVsdGlwbGUgR1VJJ3M/XG4gICAgcmV0dXJuIGRvY3VtZW50LmxvY2F0aW9uLmhyZWYgKyAnLicgKyBrZXk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFNhdmVNZW51KGd1aSkge1xuXG4gICAgdmFyIGRpdiA9IGd1aS5fX3NhdmVfcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcblxuICAgIGRvbS5hZGRDbGFzcyhndWkuZG9tRWxlbWVudCwgJ2hhcy1zYXZlJyk7XG5cbiAgICBndWkuX191bC5pbnNlcnRCZWZvcmUoZGl2LCBndWkuX191bC5maXJzdENoaWxkKTtcblxuICAgIGRvbS5hZGRDbGFzcyhkaXYsICdzYXZlLXJvdycpO1xuXG4gICAgdmFyIGdlYXJzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGdlYXJzLmlubmVySFRNTCA9ICcmbmJzcDsnO1xuICAgIGRvbS5hZGRDbGFzcyhnZWFycywgJ2J1dHRvbiBnZWFycycpO1xuXG4gICAgLy8gVE9ETyByZXBsYWNlIHdpdGggRnVuY3Rpb25Db250cm9sbGVyXG4gICAgdmFyIGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBidXR0b24uaW5uZXJIVE1MID0gJ1NhdmUnO1xuICAgIGRvbS5hZGRDbGFzcyhidXR0b24sICdidXR0b24nKTtcbiAgICBkb20uYWRkQ2xhc3MoYnV0dG9uLCAnc2F2ZScpO1xuXG4gICAgdmFyIGJ1dHRvbjIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgYnV0dG9uMi5pbm5lckhUTUwgPSAnTmV3JztcbiAgICBkb20uYWRkQ2xhc3MoYnV0dG9uMiwgJ2J1dHRvbicpO1xuICAgIGRvbS5hZGRDbGFzcyhidXR0b24yLCAnc2F2ZS1hcycpO1xuXG4gICAgdmFyIGJ1dHRvbjMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgYnV0dG9uMy5pbm5lckhUTUwgPSAnUmV2ZXJ0JztcbiAgICBkb20uYWRkQ2xhc3MoYnV0dG9uMywgJ2J1dHRvbicpO1xuICAgIGRvbS5hZGRDbGFzcyhidXR0b24zLCAncmV2ZXJ0Jyk7XG5cbiAgICB2YXIgc2VsZWN0ID0gZ3VpLl9fcHJlc2V0X3NlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuXG4gICAgaWYgKGd1aS5sb2FkICYmIGd1aS5sb2FkLnJlbWVtYmVyZWQpIHtcblxuICAgICAgY29tbW9uLmVhY2goZ3VpLmxvYWQucmVtZW1iZXJlZCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICBhZGRQcmVzZXRPcHRpb24oZ3VpLCBrZXksIGtleSA9PSBndWkucHJlc2V0KTtcbiAgICAgIH0pO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZFByZXNldE9wdGlvbihndWksIERFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGRvbS5iaW5kKHNlbGVjdCwgJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xuXG5cbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBndWkuX19wcmVzZXRfc2VsZWN0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBndWkuX19wcmVzZXRfc2VsZWN0W2luZGV4XS5pbm5lckhUTUwgPSBndWkuX19wcmVzZXRfc2VsZWN0W2luZGV4XS52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgZ3VpLnByZXNldCA9IHRoaXMudmFsdWU7XG5cbiAgICB9KTtcblxuICAgIGRpdi5hcHBlbmRDaGlsZChzZWxlY3QpO1xuICAgIGRpdi5hcHBlbmRDaGlsZChnZWFycyk7XG4gICAgZGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgZGl2LmFwcGVuZENoaWxkKGJ1dHRvbjIpO1xuICAgIGRpdi5hcHBlbmRDaGlsZChidXR0b24zKTtcblxuICAgIGlmIChTVVBQT1JUU19MT0NBTF9TVE9SQUdFKSB7XG5cbiAgICAgIHZhciBzYXZlTG9jYWxseSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZy1zYXZlLWxvY2FsbHknKTtcbiAgICAgIHZhciBleHBsYWluID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLWxvY2FsLWV4cGxhaW4nKTtcblxuICAgICAgc2F2ZUxvY2FsbHkuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICAgIHZhciBsb2NhbFN0b3JhZ2VDaGVja0JveCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZy1sb2NhbC1zdG9yYWdlJyk7XG5cbiAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZ2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKGd1aSwgJ2lzTG9jYWwnKSkgPT09ICd0cnVlJykge1xuICAgICAgICBsb2NhbFN0b3JhZ2VDaGVja0JveC5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCAnY2hlY2tlZCcpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzaG93SGlkZUV4cGxhaW4oKSB7XG4gICAgICAgIGV4cGxhaW4uc3R5bGUuZGlzcGxheSA9IGd1aS51c2VMb2NhbFN0b3JhZ2UgPyAnYmxvY2snIDogJ25vbmUnO1xuICAgICAgfVxuXG4gICAgICBzaG93SGlkZUV4cGxhaW4oKTtcblxuICAgICAgLy8gVE9ETzogVXNlIGEgYm9vbGVhbiBjb250cm9sbGVyLCBmb29sIVxuICAgICAgZG9tLmJpbmQobG9jYWxTdG9yYWdlQ2hlY2tCb3gsICdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZ3VpLnVzZUxvY2FsU3RvcmFnZSA9ICFndWkudXNlTG9jYWxTdG9yYWdlO1xuICAgICAgICBzaG93SGlkZUV4cGxhaW4oKTtcbiAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgdmFyIG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctbmV3LWNvbnN0cnVjdG9yJyk7XG5cbiAgICBkb20uYmluZChuZXdDb25zdHJ1Y3RvclRleHRBcmVhLCAna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLm1ldGFLZXkgJiYgKGUud2hpY2ggPT09IDY3IHx8IGUua2V5Q29kZSA9PSA2NykpIHtcbiAgICAgICAgU0FWRV9ESUFMT0dVRS5oaWRlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBkb20uYmluZChnZWFycywgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICBuZXdDb25zdHJ1Y3RvclRleHRBcmVhLmlubmVySFRNTCA9IEpTT04uc3RyaW5naWZ5KGd1aS5nZXRTYXZlT2JqZWN0KCksIHVuZGVmaW5lZCwgMik7XG4gICAgICBTQVZFX0RJQUxPR1VFLnNob3coKTtcbiAgICAgIG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEuZm9jdXMoKTtcbiAgICAgIG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEuc2VsZWN0KCk7XG4gICAgfSk7XG5cbiAgICBkb20uYmluZChidXR0b24sICdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgZ3VpLnNhdmUoKTtcbiAgICB9KTtcblxuICAgIGRvbS5iaW5kKGJ1dHRvbjIsICdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHByZXNldE5hbWUgPSBwcm9tcHQoJ0VudGVyIGEgbmV3IHByZXNldCBuYW1lLicpO1xuICAgICAgaWYgKHByZXNldE5hbWUpIGd1aS5zYXZlQXMocHJlc2V0TmFtZSk7XG4gICAgfSk7XG5cbiAgICBkb20uYmluZChidXR0b24zLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgIGd1aS5yZXZlcnQoKTtcbiAgICB9KTtcblxuLy8gICAgZGl2LmFwcGVuZENoaWxkKGJ1dHRvbjIpO1xuXG4gIH1cblxuICBmdW5jdGlvbiBhZGRSZXNpemVIYW5kbGUoZ3VpKSB7XG5cbiAgICBndWkuX19yZXNpemVfaGFuZGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBjb21tb24uZXh0ZW5kKGd1aS5fX3Jlc2l6ZV9oYW5kbGUuc3R5bGUsIHtcblxuICAgICAgd2lkdGg6ICc2cHgnLFxuICAgICAgbWFyZ2luTGVmdDogJy0zcHgnLFxuICAgICAgaGVpZ2h0OiAnMjAwcHgnLFxuICAgICAgY3Vyc29yOiAnZXctcmVzaXplJyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4vLyAgICAgIGJvcmRlcjogJzFweCBzb2xpZCBibHVlJ1xuXG4gICAgfSk7XG5cbiAgICB2YXIgcG1vdXNlWDtcblxuICAgIGRvbS5iaW5kKGd1aS5fX3Jlc2l6ZV9oYW5kbGUsICdtb3VzZWRvd24nLCBkcmFnU3RhcnQpO1xuICAgIGRvbS5iaW5kKGd1aS5fX2Nsb3NlQnV0dG9uLCAnbW91c2Vkb3duJywgZHJhZ1N0YXJ0KTtcblxuICAgIGd1aS5kb21FbGVtZW50Lmluc2VydEJlZm9yZShndWkuX19yZXNpemVfaGFuZGxlLCBndWkuZG9tRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCk7XG5cbiAgICBmdW5jdGlvbiBkcmFnU3RhcnQoZSkge1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHBtb3VzZVggPSBlLmNsaWVudFg7XG5cbiAgICAgIGRvbS5hZGRDbGFzcyhndWkuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0RSQUcpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgZHJhZyk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgZHJhZ1N0b3ApO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcmFnKGUpIHtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBndWkud2lkdGggKz0gcG1vdXNlWCAtIGUuY2xpZW50WDtcbiAgICAgIGd1aS5vblJlc2l6ZSgpO1xuICAgICAgcG1vdXNlWCA9IGUuY2xpZW50WDtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhZ1N0b3AoKSB7XG5cbiAgICAgIGRvbS5yZW1vdmVDbGFzcyhndWkuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0RSQUcpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBkcmFnKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIGRyYWdTdG9wKTtcblxuICAgIH1cblxuICB9XG5cbiAgZnVuY3Rpb24gc2V0V2lkdGgoZ3VpLCB3KSB7XG4gICAgZ3VpLmRvbUVsZW1lbnQuc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgICAvLyBBdXRvIHBsYWNlZCBzYXZlLXJvd3MgYXJlIHBvc2l0aW9uIGZpeGVkLCBzbyB3ZSBoYXZlIHRvXG4gICAgLy8gc2V0IHRoZSB3aWR0aCBtYW51YWxseSBpZiB3ZSB3YW50IGl0IHRvIGJsZWVkIHRvIHRoZSBlZGdlXG4gICAgaWYgKGd1aS5fX3NhdmVfcm93ICYmIGd1aS5hdXRvUGxhY2UpIHtcbiAgICAgIGd1aS5fX3NhdmVfcm93LnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gICAgfWlmIChndWkuX19jbG9zZUJ1dHRvbikge1xuICAgICAgZ3VpLl9fY2xvc2VCdXR0b24uc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDdXJyZW50UHJlc2V0KGd1aSwgdXNlSW5pdGlhbFZhbHVlcykge1xuXG4gICAgdmFyIHRvUmV0dXJuID0ge307XG5cbiAgICAvLyBGb3IgZWFjaCBvYmplY3QgSSdtIHJlbWVtYmVyaW5nXG4gICAgY29tbW9uLmVhY2goZ3VpLl9fcmVtZW1iZXJlZE9iamVjdHMsIGZ1bmN0aW9uKHZhbCwgaW5kZXgpIHtcblxuICAgICAgdmFyIHNhdmVkX3ZhbHVlcyA9IHt9O1xuXG4gICAgICAvLyBUaGUgY29udHJvbGxlcnMgSSd2ZSBtYWRlIGZvciB0aGNvbW1vbi5pc09iamVjdCBieSBwcm9wZXJ0eVxuICAgICAgdmFyIGNvbnRyb2xsZXJfbWFwID1cbiAgICAgICAgICBndWkuX19yZW1lbWJlcmVkT2JqZWN0SW5kZWNlc1RvQ29udHJvbGxlcnNbaW5kZXhdO1xuXG4gICAgICAvLyBSZW1lbWJlciBlYWNoIHZhbHVlIGZvciBlYWNoIHByb3BlcnR5XG4gICAgICBjb21tb24uZWFjaChjb250cm9sbGVyX21hcCwgZnVuY3Rpb24oY29udHJvbGxlciwgcHJvcGVydHkpIHtcbiAgICAgICAgc2F2ZWRfdmFsdWVzW3Byb3BlcnR5XSA9IHVzZUluaXRpYWxWYWx1ZXMgPyBjb250cm9sbGVyLmluaXRpYWxWYWx1ZSA6IGNvbnRyb2xsZXIuZ2V0VmFsdWUoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTYXZlIHRoZSB2YWx1ZXMgZm9yIHRoY29tbW9uLmlzT2JqZWN0XG4gICAgICB0b1JldHVybltpbmRleF0gPSBzYXZlZF92YWx1ZXM7XG5cbiAgICB9KTtcblxuICAgIHJldHVybiB0b1JldHVybjtcblxuICB9XG5cbiAgZnVuY3Rpb24gYWRkUHJlc2V0T3B0aW9uKGd1aSwgbmFtZSwgc2V0U2VsZWN0ZWQpIHtcbiAgICB2YXIgb3B0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgb3B0LmlubmVySFRNTCA9IG5hbWU7XG4gICAgb3B0LnZhbHVlID0gbmFtZTtcbiAgICBndWkuX19wcmVzZXRfc2VsZWN0LmFwcGVuZENoaWxkKG9wdCk7XG4gICAgaWYgKHNldFNlbGVjdGVkKSB7XG4gICAgICBndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXggPSBndWkuX19wcmVzZXRfc2VsZWN0Lmxlbmd0aCAtIDE7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0UHJlc2V0U2VsZWN0SW5kZXgoZ3VpKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGd1aS5fX3ByZXNldF9zZWxlY3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBpZiAoZ3VpLl9fcHJlc2V0X3NlbGVjdFtpbmRleF0udmFsdWUgPT0gZ3VpLnByZXNldCkge1xuICAgICAgICBndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXggPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrUHJlc2V0TW9kaWZpZWQoZ3VpLCBtb2RpZmllZCkge1xuICAgIHZhciBvcHQgPSBndWkuX19wcmVzZXRfc2VsZWN0W2d1aS5fX3ByZXNldF9zZWxlY3Quc2VsZWN0ZWRJbmRleF07XG4vLyAgICBjb25zb2xlLmxvZygnbWFyaycsIG1vZGlmaWVkLCBvcHQpO1xuICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgb3B0LmlubmVySFRNTCA9IG9wdC52YWx1ZSArIFwiKlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHQuaW5uZXJIVE1MID0gb3B0LnZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXlzKGNvbnRyb2xsZXJBcnJheSkge1xuXG5cbiAgICBpZiAoY29udHJvbGxlckFycmF5Lmxlbmd0aCAhPSAwKSB7XG5cbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgdXBkYXRlRGlzcGxheXMoY29udHJvbGxlckFycmF5KTtcbiAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgY29tbW9uLmVhY2goY29udHJvbGxlckFycmF5LCBmdW5jdGlvbihjKSB7XG4gICAgICBjLnVwZGF0ZURpc3BsYXkoKTtcbiAgICB9KTtcblxuICB9XG5cbiAgcmV0dXJuIEdVSTtcblxufSkoZGF0LnV0aWxzLmNzcyxcblwiPGRpdiBpZD1cXFwiZGctc2F2ZVxcXCIgY2xhc3M9XFxcImRnIGRpYWxvZ3VlXFxcIj5cXG5cXG4gIEhlcmUncyB0aGUgbmV3IGxvYWQgcGFyYW1ldGVyIGZvciB5b3VyIDxjb2RlPkdVSTwvY29kZT4ncyBjb25zdHJ1Y3RvcjpcXG5cXG4gIDx0ZXh0YXJlYSBpZD1cXFwiZGctbmV3LWNvbnN0cnVjdG9yXFxcIj48L3RleHRhcmVhPlxcblxcbiAgPGRpdiBpZD1cXFwiZGctc2F2ZS1sb2NhbGx5XFxcIj5cXG5cXG4gICAgPGlucHV0IGlkPVxcXCJkZy1sb2NhbC1zdG9yYWdlXFxcIiB0eXBlPVxcXCJjaGVja2JveFxcXCIvPiBBdXRvbWF0aWNhbGx5IHNhdmVcXG4gICAgdmFsdWVzIHRvIDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gb24gZXhpdC5cXG5cXG4gICAgPGRpdiBpZD1cXFwiZGctbG9jYWwtZXhwbGFpblxcXCI+VGhlIHZhbHVlcyBzYXZlZCB0byA8Y29kZT5sb2NhbFN0b3JhZ2U8L2NvZGU+IHdpbGxcXG4gICAgICBvdmVycmlkZSB0aG9zZSBwYXNzZWQgdG8gPGNvZGU+ZGF0LkdVSTwvY29kZT4ncyBjb25zdHJ1Y3Rvci4gVGhpcyBtYWtlcyBpdFxcbiAgICAgIGVhc2llciB0byB3b3JrIGluY3JlbWVudGFsbHksIGJ1dCA8Y29kZT5sb2NhbFN0b3JhZ2U8L2NvZGU+IGlzIGZyYWdpbGUsXFxuICAgICAgYW5kIHlvdXIgZnJpZW5kcyBtYXkgbm90IHNlZSB0aGUgc2FtZSB2YWx1ZXMgeW91IGRvLlxcbiAgICAgIFxcbiAgICA8L2Rpdj5cXG4gICAgXFxuICA8L2Rpdj5cXG5cXG48L2Rpdj5cIixcblwiLmRnIHVse2xpc3Qtc3R5bGU6bm9uZTttYXJnaW46MDtwYWRkaW5nOjA7d2lkdGg6MTAwJTtjbGVhcjpib3RofS5kZy5hY3twb3NpdGlvbjpmaXhlZDt0b3A6MDtsZWZ0OjA7cmlnaHQ6MDtoZWlnaHQ6MDt6LWluZGV4OjB9LmRnOm5vdCguYWMpIC5tYWlue292ZXJmbG93OmhpZGRlbn0uZGcubWFpbnstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAwLjFzIGxpbmVhcjstby10cmFuc2l0aW9uOm9wYWNpdHkgMC4xcyBsaW5lYXI7LW1vei10cmFuc2l0aW9uOm9wYWNpdHkgMC4xcyBsaW5lYXI7dHJhbnNpdGlvbjpvcGFjaXR5IDAuMXMgbGluZWFyfS5kZy5tYWluLnRhbGxlci10aGFuLXdpbmRvd3tvdmVyZmxvdy15OmF1dG99LmRnLm1haW4udGFsbGVyLXRoYW4td2luZG93IC5jbG9zZS1idXR0b257b3BhY2l0eToxO21hcmdpbi10b3A6LTFweDtib3JkZXItdG9wOjFweCBzb2xpZCAjMmMyYzJjfS5kZy5tYWluIHVsLmNsb3NlZCAuY2xvc2UtYnV0dG9ue29wYWNpdHk6MSAhaW1wb3J0YW50fS5kZy5tYWluOmhvdmVyIC5jbG9zZS1idXR0b24sLmRnLm1haW4gLmNsb3NlLWJ1dHRvbi5kcmFne29wYWNpdHk6MX0uZGcubWFpbiAuY2xvc2UtYnV0dG9uey13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IDAuMXMgbGluZWFyOy1vLXRyYW5zaXRpb246b3BhY2l0eSAwLjFzIGxpbmVhcjstbW96LXRyYW5zaXRpb246b3BhY2l0eSAwLjFzIGxpbmVhcjt0cmFuc2l0aW9uOm9wYWNpdHkgMC4xcyBsaW5lYXI7Ym9yZGVyOjA7cG9zaXRpb246YWJzb2x1dGU7bGluZS1oZWlnaHQ6MTlweDtoZWlnaHQ6MjBweDtjdXJzb3I6cG9pbnRlcjt0ZXh0LWFsaWduOmNlbnRlcjtiYWNrZ3JvdW5kLWNvbG9yOiMwMDB9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMxMTF9LmRnLmF7ZmxvYXQ6cmlnaHQ7bWFyZ2luLXJpZ2h0OjE1cHg7b3ZlcmZsb3cteDpoaWRkZW59LmRnLmEuaGFzLXNhdmUgdWx7bWFyZ2luLXRvcDoyN3B4fS5kZy5hLmhhcy1zYXZlIHVsLmNsb3NlZHttYXJnaW4tdG9wOjB9LmRnLmEgLnNhdmUtcm93e3Bvc2l0aW9uOmZpeGVkO3RvcDowO3otaW5kZXg6MTAwMn0uZGcgbGl7LXdlYmtpdC10cmFuc2l0aW9uOmhlaWdodCAwLjFzIGVhc2Utb3V0Oy1vLXRyYW5zaXRpb246aGVpZ2h0IDAuMXMgZWFzZS1vdXQ7LW1vei10cmFuc2l0aW9uOmhlaWdodCAwLjFzIGVhc2Utb3V0O3RyYW5zaXRpb246aGVpZ2h0IDAuMXMgZWFzZS1vdXR9LmRnIGxpOm5vdCguZm9sZGVyKXtjdXJzb3I6YXV0bztoZWlnaHQ6MjdweDtsaW5lLWhlaWdodDoyN3B4O292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjAgNHB4IDAgNXB4fS5kZyBsaS5mb2xkZXJ7cGFkZGluZzowO2JvcmRlci1sZWZ0OjRweCBzb2xpZCByZ2JhKDAsMCwwLDApfS5kZyBsaS50aXRsZXtjdXJzb3I6cG9pbnRlcjttYXJnaW4tbGVmdDotNHB4fS5kZyAuY2xvc2VkIGxpOm5vdCgudGl0bGUpLC5kZyAuY2xvc2VkIHVsIGxpLC5kZyAuY2xvc2VkIHVsIGxpID4gKntoZWlnaHQ6MDtvdmVyZmxvdzpoaWRkZW47Ym9yZGVyOjB9LmRnIC5jcntjbGVhcjpib3RoO3BhZGRpbmctbGVmdDozcHg7aGVpZ2h0OjI3cHh9LmRnIC5wcm9wZXJ0eS1uYW1le2N1cnNvcjpkZWZhdWx0O2Zsb2F0OmxlZnQ7Y2xlYXI6bGVmdDt3aWR0aDo0MCU7b3ZlcmZsb3c6aGlkZGVuO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXN9LmRnIC5je2Zsb2F0OmxlZnQ7d2lkdGg6NjAlfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRde2JvcmRlcjowO21hcmdpbi10b3A6NHB4O3BhZGRpbmc6M3B4O3dpZHRoOjEwMCU7ZmxvYXQ6cmlnaHR9LmRnIC5oYXMtc2xpZGVyIGlucHV0W3R5cGU9dGV4dF17d2lkdGg6MzAlO21hcmdpbi1sZWZ0OjB9LmRnIC5zbGlkZXJ7ZmxvYXQ6bGVmdDt3aWR0aDo2NiU7bWFyZ2luLWxlZnQ6LTVweDttYXJnaW4tcmlnaHQ6MDtoZWlnaHQ6MTlweDttYXJnaW4tdG9wOjRweH0uZGcgLnNsaWRlci1mZ3toZWlnaHQ6MTAwJX0uZGcgLmMgaW5wdXRbdHlwZT1jaGVja2JveF17bWFyZ2luLXRvcDo5cHh9LmRnIC5jIHNlbGVjdHttYXJnaW4tdG9wOjVweH0uZGcgLmNyLmZ1bmN0aW9uLC5kZyAuY3IuZnVuY3Rpb24gLnByb3BlcnR5LW5hbWUsLmRnIC5jci5mdW5jdGlvbiAqLC5kZyAuY3IuYm9vbGVhbiwuZGcgLmNyLmJvb2xlYW4gKntjdXJzb3I6cG9pbnRlcn0uZGcgLnNlbGVjdG9ye2Rpc3BsYXk6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZTttYXJnaW4tbGVmdDotOXB4O21hcmdpbi10b3A6MjNweDt6LWluZGV4OjEwfS5kZyAuYzpob3ZlciAuc2VsZWN0b3IsLmRnIC5zZWxlY3Rvci5kcmFne2Rpc3BsYXk6YmxvY2t9LmRnIGxpLnNhdmUtcm93e3BhZGRpbmc6MH0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbntkaXNwbGF5OmlubGluZS1ibG9jaztwYWRkaW5nOjBweCA2cHh9LmRnLmRpYWxvZ3Vle2JhY2tncm91bmQtY29sb3I6IzIyMjt3aWR0aDo0NjBweDtwYWRkaW5nOjE1cHg7Zm9udC1zaXplOjEzcHg7bGluZS1oZWlnaHQ6MTVweH0jZGctbmV3LWNvbnN0cnVjdG9ye3BhZGRpbmc6MTBweDtjb2xvcjojMjIyO2ZvbnQtZmFtaWx5Ok1vbmFjbywgbW9ub3NwYWNlO2ZvbnQtc2l6ZToxMHB4O2JvcmRlcjowO3Jlc2l6ZTpub25lO2JveC1zaGFkb3c6aW5zZXQgMXB4IDFweCAxcHggIzg4ODt3b3JkLXdyYXA6YnJlYWstd29yZDttYXJnaW46MTJweCAwO2Rpc3BsYXk6YmxvY2s7d2lkdGg6NDQwcHg7b3ZlcmZsb3cteTpzY3JvbGw7aGVpZ2h0OjEwMHB4O3Bvc2l0aW9uOnJlbGF0aXZlfSNkZy1sb2NhbC1leHBsYWlue2Rpc3BsYXk6bm9uZTtmb250LXNpemU6MTFweDtsaW5lLWhlaWdodDoxN3B4O2JvcmRlci1yYWRpdXM6M3B4O2JhY2tncm91bmQtY29sb3I6IzMzMztwYWRkaW5nOjhweDttYXJnaW4tdG9wOjEwcHh9I2RnLWxvY2FsLWV4cGxhaW4gY29kZXtmb250LXNpemU6MTBweH0jZGF0LWd1aS1zYXZlLWxvY2FsbHl7ZGlzcGxheTpub25lfS5kZ3tjb2xvcjojZWVlO2ZvbnQ6MTFweCAnTHVjaWRhIEdyYW5kZScsIHNhbnMtc2VyaWY7dGV4dC1zaGFkb3c6MCAtMXB4IDAgIzExMX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXJ7d2lkdGg6NXB4O2JhY2tncm91bmQ6IzFhMWExYX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXItY29ybmVye2hlaWdodDowO2Rpc3BsYXk6bm9uZX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWJ7Ym9yZGVyLXJhZGl1czo1cHg7YmFja2dyb3VuZDojNjc2NzY3fS5kZyBsaTpub3QoLmZvbGRlcil7YmFja2dyb3VuZDojMWExYTFhO2JvcmRlci1ib3R0b206MXB4IHNvbGlkICMyYzJjMmN9LmRnIGxpLnNhdmUtcm93e2xpbmUtaGVpZ2h0OjI1cHg7YmFja2dyb3VuZDojZGFkNWNiO2JvcmRlcjowfS5kZyBsaS5zYXZlLXJvdyBzZWxlY3R7bWFyZ2luLWxlZnQ6NXB4O3dpZHRoOjEwOHB4fS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9ue21hcmdpbi1sZWZ0OjVweDttYXJnaW4tdG9wOjFweDtib3JkZXItcmFkaXVzOjJweDtmb250LXNpemU6OXB4O2xpbmUtaGVpZ2h0OjdweDtwYWRkaW5nOjRweCA0cHggNXB4IDRweDtiYWNrZ3JvdW5kOiNjNWJkYWQ7Y29sb3I6I2ZmZjt0ZXh0LXNoYWRvdzowIDFweCAwICNiMGE1OGY7Ym94LXNoYWRvdzowIC0xcHggMCAjYjBhNThmO2N1cnNvcjpwb2ludGVyfS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9uLmdlYXJze2JhY2tncm91bmQ6I2M1YmRhZCB1cmwoZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBc0FBQUFOQ0FZQUFBQi85WlE3QUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUFRSkpSRUZVZU5waVlLQVUvUC8vUHdHSUMvQXBDQUJpQlNBVytJOEFDbEFjZ0t4UTRUOWhvTUFFVXJ4eDJRU0dONitlZ0RYKy92V1Q0ZTdOODJBTVlvUEF4L2V2d1dvWW9TWWJBQ1gyczdLeEN4emNzZXpEaDNldkZvREVCWVRFRXF5Y2dnV0F6QTlBdVVTUVFnZVlQYTlmUHY2L1lXbS9BY3g1SVBiN3R5L2Z3K1FaYmx3Njd2RHM4UjBZSHlRaGdPYngreUFKa0JxbUc1ZFBQRGgxYVBPR1IvZXVnVzBHNHZsSW9USWZ5RmNBK1Fla2hoSEpoUGRReGJpQUlndU1CVFFaclBENzEwOE02cm9XWURGUWlJQUF2NkFvdy8xYkZ3WGdpcytmMkxVQXlud29JYU5jejhYTngzRGw3TUVKVURHUXB4OWd0UThZQ3VlQitEMjZPRUNBQVFEYWR0N2U0NkQ0MlFBQUFBQkpSVTVFcmtKZ2dnPT0pIDJweCAxcHggbm8tcmVwZWF0O2hlaWdodDo3cHg7d2lkdGg6OHB4fS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2JhYjE5ZTtib3gtc2hhZG93OjAgLTFweCAwICNiMGE1OGZ9LmRnIGxpLmZvbGRlcntib3JkZXItYm90dG9tOjB9LmRnIGxpLnRpdGxle3BhZGRpbmctbGVmdDoxNnB4O2JhY2tncm91bmQ6IzAwMCB1cmwoZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQlFBRkFKRUFBUC8vLy9QejgvLy8vLy8vL3lINUJBRUFBQUlBTEFBQUFBQUZBQVVBQUFJSWxJK2hLZ0Z4b0NnQU93PT0pIDZweCAxMHB4IG5vLXJlcGVhdDtjdXJzb3I6cG9pbnRlcjtib3JkZXItYm90dG9tOjFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LDAuMil9LmRnIC5jbG9zZWQgbGkudGl0bGV7YmFja2dyb3VuZC1pbWFnZTp1cmwoZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQlFBRkFKRUFBUC8vLy9QejgvLy8vLy8vL3lINUJBRUFBQUlBTEFBQUFBQUZBQVVBQUFJSWxHSVdxTUNiV0FFQU93PT0pfS5kZyAuY3IuYm9vbGVhbntib3JkZXItbGVmdDozcHggc29saWQgIzgwNjc4N30uZGcgLmNyLmZ1bmN0aW9ue2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjZTYxZDVmfS5kZyAuY3IubnVtYmVye2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjMmZhMWQ2fS5kZyAuY3IubnVtYmVyIGlucHV0W3R5cGU9dGV4dF17Y29sb3I6IzJmYTFkNn0uZGcgLmNyLnN0cmluZ3tib3JkZXItbGVmdDozcHggc29saWQgIzFlZDM2Zn0uZGcgLmNyLnN0cmluZyBpbnB1dFt0eXBlPXRleHRde2NvbG9yOiMxZWQzNmZ9LmRnIC5jci5mdW5jdGlvbjpob3ZlciwuZGcgLmNyLmJvb2xlYW46aG92ZXJ7YmFja2dyb3VuZDojMTExfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRde2JhY2tncm91bmQ6IzMwMzAzMDtvdXRsaW5lOm5vbmV9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF06aG92ZXJ7YmFja2dyb3VuZDojM2MzYzNjfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRdOmZvY3Vze2JhY2tncm91bmQ6IzQ5NDk0OTtjb2xvcjojZmZmfS5kZyAuYyAuc2xpZGVye2JhY2tncm91bmQ6IzMwMzAzMDtjdXJzb3I6ZXctcmVzaXplfS5kZyAuYyAuc2xpZGVyLWZne2JhY2tncm91bmQ6IzJmYTFkNn0uZGcgLmMgLnNsaWRlcjpob3ZlcntiYWNrZ3JvdW5kOiMzYzNjM2N9LmRnIC5jIC5zbGlkZXI6aG92ZXIgLnNsaWRlci1mZ3tiYWNrZ3JvdW5kOiM0NGFiZGF9XFxuXCIsXG5kYXQuY29udHJvbGxlcnMuZmFjdG9yeSA9IChmdW5jdGlvbiAoT3B0aW9uQ29udHJvbGxlciwgTnVtYmVyQ29udHJvbGxlckJveCwgTnVtYmVyQ29udHJvbGxlclNsaWRlciwgU3RyaW5nQ29udHJvbGxlciwgRnVuY3Rpb25Db250cm9sbGVyLCBCb29sZWFuQ29udHJvbGxlciwgY29tbW9uKSB7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG5cbiAgICAgICAgdmFyIGluaXRpYWxWYWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG5cbiAgICAgICAgLy8gUHJvdmlkaW5nIG9wdGlvbnM/XG4gICAgICAgIGlmIChjb21tb24uaXNBcnJheShhcmd1bWVudHNbMl0pIHx8IGNvbW1vbi5pc09iamVjdChhcmd1bWVudHNbMl0pKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBPcHRpb25Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcm92aWRpbmcgYSBtYXA/XG5cbiAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihpbml0aWFsVmFsdWUpKSB7XG5cbiAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKGFyZ3VtZW50c1syXSkgJiYgY29tbW9uLmlzTnVtYmVyKGFyZ3VtZW50c1szXSkpIHtcblxuICAgICAgICAgICAgLy8gSGFzIG1pbiBhbmQgbWF4LlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyU2xpZGVyKG9iamVjdCwgcHJvcGVydHksIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTtcblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgTnVtYmVyQ29udHJvbGxlckJveChvYmplY3QsIHByb3BlcnR5LCB7IG1pbjogYXJndW1lbnRzWzJdLCBtYXg6IGFyZ3VtZW50c1szXSB9KTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbW1vbi5pc1N0cmluZyhpbml0aWFsVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbW1vbi5pc0Z1bmN0aW9uKGluaXRpYWxWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5LCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tbW9uLmlzQm9vbGVhbihpbml0aWFsVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCb29sZWFuQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9KShkYXQuY29udHJvbGxlcnMuT3B0aW9uQ29udHJvbGxlcixcbmRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyQm94LFxuZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJTbGlkZXIsXG5kYXQuY29udHJvbGxlcnMuU3RyaW5nQ29udHJvbGxlciA9IChmdW5jdGlvbiAoQ29udHJvbGxlciwgZG9tLCBjb21tb24pIHtcblxuICAvKipcbiAgICogQGNsYXNzIFByb3ZpZGVzIGEgdGV4dCBpbnB1dCB0byBhbHRlciB0aGUgc3RyaW5nIHByb3BlcnR5IG9mIGFuIG9iamVjdC5cbiAgICpcbiAgICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICpcbiAgICogQG1lbWJlciBkYXQuY29udHJvbGxlcnNcbiAgICovXG4gIHZhciBTdHJpbmdDb250cm9sbGVyID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuXG4gICAgU3RyaW5nQ29udHJvbGxlci5zdXBlcmNsYXNzLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5fX2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICB0aGlzLl9faW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKTtcblxuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ2tleXVwJywgb25DaGFuZ2UpO1xuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdibHVyJywgb25CbHVyKTtcbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgdGhpcy5ibHVyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG5cbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9faW5wdXQudmFsdWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX2lucHV0KTtcblxuICB9O1xuXG4gIFN0cmluZ0NvbnRyb2xsZXIuc3VwZXJjbGFzcyA9IENvbnRyb2xsZXI7XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgU3RyaW5nQ29udHJvbGxlci5wcm90b3R5cGUsXG4gICAgICBDb250cm9sbGVyLnByb3RvdHlwZSxcblxuICAgICAge1xuXG4gICAgICAgIHVwZGF0ZURpc3BsYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIFN0b3BzIHRoZSBjYXJldCBmcm9tIG1vdmluZyBvbiBhY2NvdW50IG9mOlxuICAgICAgICAgIC8vIGtleXVwIC0+IHNldFZhbHVlIC0+IHVwZGF0ZURpc3BsYXlcbiAgICAgICAgICBpZiAoIWRvbS5pc0FjdGl2ZSh0aGlzLl9faW5wdXQpKSB7XG4gICAgICAgICAgICB0aGlzLl9faW5wdXQudmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBTdHJpbmdDb250cm9sbGVyLnN1cGVyY2xhc3MucHJvdG90eXBlLnVwZGF0ZURpc3BsYXkuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgKTtcblxuICByZXR1cm4gU3RyaW5nQ29udHJvbGxlcjtcblxufSkoZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXIsXG5kYXQuZG9tLmRvbSxcbmRhdC51dGlscy5jb21tb24pLFxuZGF0LmNvbnRyb2xsZXJzLkZ1bmN0aW9uQ29udHJvbGxlcixcbmRhdC5jb250cm9sbGVycy5Cb29sZWFuQ29udHJvbGxlcixcbmRhdC51dGlscy5jb21tb24pLFxuZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXIsXG5kYXQuY29udHJvbGxlcnMuQm9vbGVhbkNvbnRyb2xsZXIsXG5kYXQuY29udHJvbGxlcnMuRnVuY3Rpb25Db250cm9sbGVyLFxuZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJCb3gsXG5kYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlclNsaWRlcixcbmRhdC5jb250cm9sbGVycy5PcHRpb25Db250cm9sbGVyLFxuZGF0LmNvbnRyb2xsZXJzLkNvbG9yQ29udHJvbGxlciA9IChmdW5jdGlvbiAoQ29udHJvbGxlciwgZG9tLCBDb2xvciwgaW50ZXJwcmV0LCBjb21tb24pIHtcblxuICB2YXIgQ29sb3JDb250cm9sbGVyID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuXG4gICAgQ29sb3JDb250cm9sbGVyLnN1cGVyY2xhc3MuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIHRoaXMuX19jb2xvciA9IG5ldyBDb2xvcih0aGlzLmdldFZhbHVlKCkpO1xuICAgIHRoaXMuX190ZW1wID0gbmV3IENvbG9yKDApO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgZG9tLm1ha2VTZWxlY3RhYmxlKHRoaXMuZG9tRWxlbWVudCwgZmFsc2UpO1xuXG4gICAgdGhpcy5fX3NlbGVjdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX3NlbGVjdG9yLmNsYXNzTmFtZSA9ICdzZWxlY3Rvcic7XG5cbiAgICB0aGlzLl9fc2F0dXJhdGlvbl9maWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX19zYXR1cmF0aW9uX2ZpZWxkLmNsYXNzTmFtZSA9ICdzYXR1cmF0aW9uLWZpZWxkJztcblxuICAgIHRoaXMuX19maWVsZF9rbm9iID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX2ZpZWxkX2tub2IuY2xhc3NOYW1lID0gJ2ZpZWxkLWtub2InO1xuICAgIHRoaXMuX19maWVsZF9rbm9iX2JvcmRlciA9ICcycHggc29saWQgJztcblxuICAgIHRoaXMuX19odWVfa25vYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX19odWVfa25vYi5jbGFzc05hbWUgPSAnaHVlLWtub2InO1xuXG4gICAgdGhpcy5fX2h1ZV9maWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX19odWVfZmllbGQuY2xhc3NOYW1lID0gJ2h1ZS1maWVsZCc7XG5cbiAgICB0aGlzLl9faW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIHRoaXMuX19pbnB1dC50eXBlID0gJ3RleHQnO1xuICAgIHRoaXMuX19pbnB1dF90ZXh0U2hhZG93ID0gJzAgMXB4IDFweCAnO1xuXG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7IC8vIG9uIGVudGVyXG4gICAgICAgIG9uQmx1ci5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAnYmx1cicsIG9uQmx1cik7XG5cbiAgICBkb20uYmluZCh0aGlzLl9fc2VsZWN0b3IsICdtb3VzZWRvd24nLCBmdW5jdGlvbihlKSB7XG5cbiAgICAgIGRvbVxuICAgICAgICAuYWRkQ2xhc3ModGhpcywgJ2RyYWcnKVxuICAgICAgICAuYmluZCh3aW5kb3csICdtb3VzZXVwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhfdGhpcy5fX3NlbGVjdG9yLCAnZHJhZycpO1xuICAgICAgICB9KTtcblxuICAgIH0pO1xuXG4gICAgdmFyIHZhbHVlX2ZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBjb21tb24uZXh0ZW5kKHRoaXMuX19zZWxlY3Rvci5zdHlsZSwge1xuICAgICAgd2lkdGg6ICcxMjJweCcsXG4gICAgICBoZWlnaHQ6ICcxMDJweCcsXG4gICAgICBwYWRkaW5nOiAnM3B4JyxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogJyMyMjInLFxuICAgICAgYm94U2hhZG93OiAnMHB4IDFweCAzcHggcmdiYSgwLDAsMCwwLjMpJ1xuICAgIH0pO1xuXG4gICAgY29tbW9uLmV4dGVuZCh0aGlzLl9fZmllbGRfa25vYi5zdHlsZSwge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB3aWR0aDogJzEycHgnLFxuICAgICAgaGVpZ2h0OiAnMTJweCcsXG4gICAgICBib3JkZXI6IHRoaXMuX19maWVsZF9rbm9iX2JvcmRlciArICh0aGlzLl9fY29sb3IudiA8IC41ID8gJyNmZmYnIDogJyMwMDAnKSxcbiAgICAgIGJveFNoYWRvdzogJzBweCAxcHggM3B4IHJnYmEoMCwwLDAsMC41KScsXG4gICAgICBib3JkZXJSYWRpdXM6ICcxMnB4JyxcbiAgICAgIHpJbmRleDogMVxuICAgIH0pO1xuICAgIFxuICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX2h1ZV9rbm9iLnN0eWxlLCB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHdpZHRoOiAnMTVweCcsXG4gICAgICBoZWlnaHQ6ICcycHgnLFxuICAgICAgYm9yZGVyUmlnaHQ6ICc0cHggc29saWQgI2ZmZicsXG4gICAgICB6SW5kZXg6IDFcbiAgICB9KTtcblxuICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX3NhdHVyYXRpb25fZmllbGQuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiAnMTAwcHgnLFxuICAgICAgaGVpZ2h0OiAnMTAwcHgnLFxuICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICM1NTUnLFxuICAgICAgbWFyZ2luUmlnaHQ6ICczcHgnLFxuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgIH0pO1xuXG4gICAgY29tbW9uLmV4dGVuZCh2YWx1ZV9maWVsZC5zdHlsZSwge1xuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgYmFja2dyb3VuZDogJ25vbmUnXG4gICAgfSk7XG4gICAgXG4gICAgbGluZWFyR3JhZGllbnQodmFsdWVfZmllbGQsICd0b3AnLCAncmdiYSgwLDAsMCwwKScsICcjMDAwJyk7XG5cbiAgICBjb21tb24uZXh0ZW5kKHRoaXMuX19odWVfZmllbGQuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiAnMTVweCcsXG4gICAgICBoZWlnaHQ6ICcxMDBweCcsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGJvcmRlcjogJzFweCBzb2xpZCAjNTU1JyxcbiAgICAgIGN1cnNvcjogJ25zLXJlc2l6ZSdcbiAgICB9KTtcblxuICAgIGh1ZUdyYWRpZW50KHRoaXMuX19odWVfZmllbGQpO1xuXG4gICAgY29tbW9uLmV4dGVuZCh0aGlzLl9faW5wdXQuc3R5bGUsIHtcbiAgICAgIG91dGxpbmU6ICdub25lJyxcbi8vICAgICAgd2lkdGg6ICcxMjBweCcsXG4gICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuLy8gICAgICBwYWRkaW5nOiAnNHB4Jyxcbi8vICAgICAgbWFyZ2luQm90dG9tOiAnNnB4JyxcbiAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICBib3JkZXI6IDAsXG4gICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgICB0ZXh0U2hhZG93OiB0aGlzLl9faW5wdXRfdGV4dFNoYWRvdyArICdyZ2JhKDAsMCwwLDAuNyknXG4gICAgfSk7XG5cbiAgICBkb20uYmluZCh0aGlzLl9fc2F0dXJhdGlvbl9maWVsZCwgJ21vdXNlZG93bicsIGZpZWxkRG93bik7XG4gICAgZG9tLmJpbmQodGhpcy5fX2ZpZWxkX2tub2IsICdtb3VzZWRvd24nLCBmaWVsZERvd24pO1xuXG4gICAgZG9tLmJpbmQodGhpcy5fX2h1ZV9maWVsZCwgJ21vdXNlZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHNldEgoZSk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRIKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCB1bmJpbmRIKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGZpZWxkRG93bihlKSB7XG4gICAgICBzZXRTVihlKTtcbiAgICAgIC8vIGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gJ25vbmUnO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgc2V0U1YpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIHVuYmluZFNWKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bmJpbmRTVigpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgc2V0U1YpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgdW5iaW5kU1YpO1xuICAgICAgLy8gZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xuICAgICAgdmFyIGkgPSBpbnRlcnByZXQodGhpcy52YWx1ZSk7XG4gICAgICBpZiAoaSAhPT0gZmFsc2UpIHtcbiAgICAgICAgX3RoaXMuX19jb2xvci5fX3N0YXRlID0gaTtcbiAgICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19jb2xvci50b09yaWdpbmFsKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IF90aGlzLl9fY29sb3IudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bmJpbmRIKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRIKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIHVuYmluZEgpO1xuICAgIH1cblxuICAgIHRoaXMuX19zYXR1cmF0aW9uX2ZpZWxkLmFwcGVuZENoaWxkKHZhbHVlX2ZpZWxkKTtcbiAgICB0aGlzLl9fc2VsZWN0b3IuYXBwZW5kQ2hpbGQodGhpcy5fX2ZpZWxkX2tub2IpO1xuICAgIHRoaXMuX19zZWxlY3Rvci5hcHBlbmRDaGlsZCh0aGlzLl9fc2F0dXJhdGlvbl9maWVsZCk7XG4gICAgdGhpcy5fX3NlbGVjdG9yLmFwcGVuZENoaWxkKHRoaXMuX19odWVfZmllbGQpO1xuICAgIHRoaXMuX19odWVfZmllbGQuYXBwZW5kQ2hpbGQodGhpcy5fX2h1ZV9rbm9iKTtcblxuICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9faW5wdXQpO1xuICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fc2VsZWN0b3IpO1xuXG4gICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cbiAgICBmdW5jdGlvbiBzZXRTVihlKSB7XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdmFyIHcgPSBkb20uZ2V0V2lkdGgoX3RoaXMuX19zYXR1cmF0aW9uX2ZpZWxkKTtcbiAgICAgIHZhciBvID0gZG9tLmdldE9mZnNldChfdGhpcy5fX3NhdHVyYXRpb25fZmllbGQpO1xuICAgICAgdmFyIHMgPSAoZS5jbGllbnRYIC0gby5sZWZ0ICsgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0KSAvIHc7XG4gICAgICB2YXIgdiA9IDEgLSAoZS5jbGllbnRZIC0gby50b3AgKyBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCkgLyB3O1xuXG4gICAgICBpZiAodiA+IDEpIHYgPSAxO1xuICAgICAgZWxzZSBpZiAodiA8IDApIHYgPSAwO1xuXG4gICAgICBpZiAocyA+IDEpIHMgPSAxO1xuICAgICAgZWxzZSBpZiAocyA8IDApIHMgPSAwO1xuXG4gICAgICBfdGhpcy5fX2NvbG9yLnYgPSB2O1xuICAgICAgX3RoaXMuX19jb2xvci5zID0gcztcblxuICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19jb2xvci50b09yaWdpbmFsKCkpO1xuXG5cbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEgoZSkge1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHZhciBzID0gZG9tLmdldEhlaWdodChfdGhpcy5fX2h1ZV9maWVsZCk7XG4gICAgICB2YXIgbyA9IGRvbS5nZXRPZmZzZXQoX3RoaXMuX19odWVfZmllbGQpO1xuICAgICAgdmFyIGggPSAxIC0gKGUuY2xpZW50WSAtIG8udG9wICsgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3ApIC8gcztcblxuICAgICAgaWYgKGggPiAxKSBoID0gMTtcbiAgICAgIGVsc2UgaWYgKGggPCAwKSBoID0gMDtcblxuICAgICAgX3RoaXMuX19jb2xvci5oID0gaCAqIDM2MDtcblxuICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19jb2xvci50b09yaWdpbmFsKCkpO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB9XG5cbiAgfTtcblxuICBDb2xvckNvbnRyb2xsZXIuc3VwZXJjbGFzcyA9IENvbnRyb2xsZXI7XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgQ29sb3JDb250cm9sbGVyLnByb3RvdHlwZSxcbiAgICAgIENvbnRyb2xsZXIucHJvdG90eXBlLFxuXG4gICAgICB7XG5cbiAgICAgICAgdXBkYXRlRGlzcGxheTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICB2YXIgaSA9IGludGVycHJldCh0aGlzLmdldFZhbHVlKCkpO1xuXG4gICAgICAgICAgaWYgKGkgIT09IGZhbHNlKSB7XG5cbiAgICAgICAgICAgIHZhciBtaXNtYXRjaCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgbWlzbWF0Y2ggb24gdGhlIGludGVycHJldGVkIHZhbHVlLlxuXG4gICAgICAgICAgICBjb21tb24uZWFjaChDb2xvci5DT01QT05FTlRTLCBmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgaWYgKCFjb21tb24uaXNVbmRlZmluZWQoaVtjb21wb25lbnRdKSAmJlxuICAgICAgICAgICAgICAgICAgIWNvbW1vbi5pc1VuZGVmaW5lZCh0aGlzLl9fY29sb3IuX19zdGF0ZVtjb21wb25lbnRdKSAmJlxuICAgICAgICAgICAgICAgICAgaVtjb21wb25lbnRdICE9PSB0aGlzLl9fY29sb3IuX19zdGF0ZVtjb21wb25lbnRdKSB7XG4gICAgICAgICAgICAgICAgbWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB7fTsgLy8gYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIC8vIElmIG5vdGhpbmcgZGl2ZXJnZXMsIHdlIGtlZXAgb3VyIHByZXZpb3VzIHZhbHVlc1xuICAgICAgICAgICAgLy8gZm9yIHN0YXRlZnVsbmVzcywgb3RoZXJ3aXNlIHdlIHJlY2FsY3VsYXRlIGZyZXNoXG4gICAgICAgICAgICBpZiAobWlzbWF0Y2gpIHtcbiAgICAgICAgICAgICAgY29tbW9uLmV4dGVuZCh0aGlzLl9fY29sb3IuX19zdGF0ZSwgaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb21tb24uZXh0ZW5kKHRoaXMuX190ZW1wLl9fc3RhdGUsIHRoaXMuX19jb2xvci5fX3N0YXRlKTtcblxuICAgICAgICAgIHRoaXMuX190ZW1wLmEgPSAxO1xuXG4gICAgICAgICAgdmFyIGZsaXAgPSAodGhpcy5fX2NvbG9yLnYgPCAuNSB8fCB0aGlzLl9fY29sb3IucyA+IC41KSA/IDI1NSA6IDA7XG4gICAgICAgICAgdmFyIF9mbGlwID0gMjU1IC0gZmxpcDtcblxuICAgICAgICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX2ZpZWxkX2tub2Iuc3R5bGUsIHtcbiAgICAgICAgICAgIG1hcmdpbkxlZnQ6IDEwMCAqIHRoaXMuX19jb2xvci5zIC0gNyArICdweCcsXG4gICAgICAgICAgICBtYXJnaW5Ub3A6IDEwMCAqICgxIC0gdGhpcy5fX2NvbG9yLnYpIC0gNyArICdweCcsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuX190ZW1wLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBib3JkZXI6IHRoaXMuX19maWVsZF9rbm9iX2JvcmRlciArICdyZ2IoJyArIGZsaXAgKyAnLCcgKyBmbGlwICsgJywnICsgZmxpcCArJyknXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aGlzLl9faHVlX2tub2Iuc3R5bGUubWFyZ2luVG9wID0gKDEgLSB0aGlzLl9fY29sb3IuaCAvIDM2MCkgKiAxMDAgKyAncHgnXG5cbiAgICAgICAgICB0aGlzLl9fdGVtcC5zID0gMTtcbiAgICAgICAgICB0aGlzLl9fdGVtcC52ID0gMTtcblxuICAgICAgICAgIGxpbmVhckdyYWRpZW50KHRoaXMuX19zYXR1cmF0aW9uX2ZpZWxkLCAnbGVmdCcsICcjZmZmJywgdGhpcy5fX3RlbXAudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgICBjb21tb24uZXh0ZW5kKHRoaXMuX19pbnB1dC5zdHlsZSwge1xuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLl9faW5wdXQudmFsdWUgPSB0aGlzLl9fY29sb3IudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGNvbG9yOiAncmdiKCcgKyBmbGlwICsgJywnICsgZmxpcCArICcsJyArIGZsaXAgKycpJyxcbiAgICAgICAgICAgIHRleHRTaGFkb3c6IHRoaXMuX19pbnB1dF90ZXh0U2hhZG93ICsgJ3JnYmEoJyArIF9mbGlwICsgJywnICsgX2ZsaXAgKyAnLCcgKyBfZmxpcCArJywuNyknXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgKTtcbiAgXG4gIHZhciB2ZW5kb3JzID0gWyctbW96LScsJy1vLScsJy13ZWJraXQtJywnLW1zLScsJyddO1xuICBcbiAgZnVuY3Rpb24gbGluZWFyR3JhZGllbnQoZWxlbSwgeCwgYSwgYikge1xuICAgIGVsZW0uc3R5bGUuYmFja2dyb3VuZCA9ICcnO1xuICAgIGNvbW1vbi5lYWNoKHZlbmRvcnMsIGZ1bmN0aW9uKHZlbmRvcikge1xuICAgICAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAnICsgdmVuZG9yICsgJ2xpbmVhci1ncmFkaWVudCgnK3grJywgJythKycgMCUsICcgKyBiICsgJyAxMDAlKTsgJztcbiAgICB9KTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gaHVlR3JhZGllbnQoZWxlbSkge1xuICAgIGVsZW0uc3R5bGUuYmFja2dyb3VuZCA9ICcnO1xuICAgIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogLW1vei1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwgI2ZmMDBmZiAxNyUsICMwMDAwZmYgMzQlLCAjMDBmZmZmIDUwJSwgIzAwZmYwMCA2NyUsICNmZmZmMDAgODQlLCAjZmYwMDAwIDEwMCUpOydcbiAgICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IC13ZWJraXQtbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsI2ZmMDBmZiAxNyUsIzAwMDBmZiAzNCUsIzAwZmZmZiA1MCUsIzAwZmYwMCA2NyUsI2ZmZmYwMCA4NCUsI2ZmMDAwMCAxMDAlKTsnXG4gICAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtby1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOydcbiAgICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IC1tcy1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOydcbiAgICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7J1xuICB9XG5cblxuICByZXR1cm4gQ29sb3JDb250cm9sbGVyO1xuXG59KShkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcixcbmRhdC5kb20uZG9tLFxuZGF0LmNvbG9yLkNvbG9yID0gKGZ1bmN0aW9uIChpbnRlcnByZXQsIG1hdGgsIHRvU3RyaW5nLCBjb21tb24pIHtcblxuICB2YXIgQ29sb3IgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuX19zdGF0ZSA9IGludGVycHJldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93ICdGYWlsZWQgdG8gaW50ZXJwcmV0IGNvbG9yIGFyZ3VtZW50cyc7XG4gICAgfVxuXG4gICAgdGhpcy5fX3N0YXRlLmEgPSB0aGlzLl9fc3RhdGUuYSB8fCAxO1xuXG5cbiAgfTtcblxuICBDb2xvci5DT01QT05FTlRTID0gWydyJywnZycsJ2InLCdoJywncycsJ3YnLCdoZXgnLCdhJ107XG5cbiAgY29tbW9uLmV4dGVuZChDb2xvci5wcm90b3R5cGUsIHtcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyh0aGlzKTtcbiAgICB9LFxuXG4gICAgdG9PcmlnaW5hbDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmNvbnZlcnNpb24ud3JpdGUodGhpcyk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIGRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdyJywgMik7XG4gIGRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdnJywgMSk7XG4gIGRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdiJywgMCk7XG5cbiAgZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ2gnKTtcbiAgZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ3MnKTtcbiAgZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ3YnKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3IucHJvdG90eXBlLCAnYScsIHtcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmE7XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgdGhpcy5fX3N0YXRlLmEgPSB2O1xuICAgIH1cblxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3IucHJvdG90eXBlLCAnaGV4Jywge1xuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKCF0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdIRVgnKSB7XG4gICAgICAgIHRoaXMuX19zdGF0ZS5oZXggPSBtYXRoLnJnYl90b19oZXgodGhpcy5yLCB0aGlzLmcsIHRoaXMuYik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGUuaGV4O1xuXG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24odikge1xuXG4gICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSEVYJztcbiAgICAgIHRoaXMuX19zdGF0ZS5oZXggPSB2O1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGRlZmluZVJHQkNvbXBvbmVudCh0YXJnZXQsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbXBvbmVudCwge1xuXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgPT09ICdSR0InKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjYWxjdWxhdGVSR0IodGhpcywgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuXG4gICAgICB9LFxuXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcblxuICAgICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlICE9PSAnUkdCJykge1xuICAgICAgICAgIHJlY2FsY3VsYXRlUkdCKHRoaXMsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpO1xuICAgICAgICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdSR0InO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX3N0YXRlW2NvbXBvbmVudF0gPSB2O1xuXG4gICAgICB9XG5cbiAgICB9KTtcblxuICB9XG5cbiAgZnVuY3Rpb24gZGVmaW5lSFNWQ29tcG9uZW50KHRhcmdldCwgY29tcG9uZW50KSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb21wb25lbnQsIHtcblxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlID09PSAnSFNWJylcbiAgICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG5cbiAgICAgICAgcmVjYWxjdWxhdGVIU1YodGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuXG4gICAgICB9LFxuXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcblxuICAgICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlICE9PSAnSFNWJykge1xuICAgICAgICAgIHJlY2FsY3VsYXRlSFNWKHRoaXMpO1xuICAgICAgICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdIU1YnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX3N0YXRlW2NvbXBvbmVudF0gPSB2O1xuXG4gICAgICB9XG5cbiAgICB9KTtcblxuICB9XG5cbiAgZnVuY3Rpb24gcmVjYWxjdWxhdGVSR0IoY29sb3IsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpIHtcblxuICAgIGlmIChjb2xvci5fX3N0YXRlLnNwYWNlID09PSAnSEVYJykge1xuXG4gICAgICBjb2xvci5fX3N0YXRlW2NvbXBvbmVudF0gPSBtYXRoLmNvbXBvbmVudF9mcm9tX2hleChjb2xvci5fX3N0YXRlLmhleCwgY29tcG9uZW50SGV4SW5kZXgpO1xuXG4gICAgfSBlbHNlIGlmIChjb2xvci5fX3N0YXRlLnNwYWNlID09PSAnSFNWJykge1xuXG4gICAgICBjb21tb24uZXh0ZW5kKGNvbG9yLl9fc3RhdGUsIG1hdGguaHN2X3RvX3JnYihjb2xvci5fX3N0YXRlLmgsIGNvbG9yLl9fc3RhdGUucywgY29sb3IuX19zdGF0ZS52KSk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB0aHJvdyAnQ29ycnVwdGVkIGNvbG9yIHN0YXRlJztcblxuICAgIH1cblxuICB9XG5cbiAgZnVuY3Rpb24gcmVjYWxjdWxhdGVIU1YoY29sb3IpIHtcblxuICAgIHZhciByZXN1bHQgPSBtYXRoLnJnYl90b19oc3YoY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG5cbiAgICBjb21tb24uZXh0ZW5kKGNvbG9yLl9fc3RhdGUsXG4gICAgICAgIHtcbiAgICAgICAgICBzOiByZXN1bHQucyxcbiAgICAgICAgICB2OiByZXN1bHQudlxuICAgICAgICB9XG4gICAgKTtcblxuICAgIGlmICghY29tbW9uLmlzTmFOKHJlc3VsdC5oKSkge1xuICAgICAgY29sb3IuX19zdGF0ZS5oID0gcmVzdWx0Lmg7XG4gICAgfSBlbHNlIGlmIChjb21tb24uaXNVbmRlZmluZWQoY29sb3IuX19zdGF0ZS5oKSkge1xuICAgICAgY29sb3IuX19zdGF0ZS5oID0gMDtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBDb2xvcjtcblxufSkoZGF0LmNvbG9yLmludGVycHJldCxcbmRhdC5jb2xvci5tYXRoID0gKGZ1bmN0aW9uICgpIHtcblxuICB2YXIgdG1wQ29tcG9uZW50O1xuXG4gIHJldHVybiB7XG5cbiAgICBoc3ZfdG9fcmdiOiBmdW5jdGlvbihoLCBzLCB2KSB7XG5cbiAgICAgIHZhciBoaSA9IE1hdGguZmxvb3IoaCAvIDYwKSAlIDY7XG5cbiAgICAgIHZhciBmID0gaCAvIDYwIC0gTWF0aC5mbG9vcihoIC8gNjApO1xuICAgICAgdmFyIHAgPSB2ICogKDEuMCAtIHMpO1xuICAgICAgdmFyIHEgPSB2ICogKDEuMCAtIChmICogcykpO1xuICAgICAgdmFyIHQgPSB2ICogKDEuMCAtICgoMS4wIC0gZikgKiBzKSk7XG4gICAgICB2YXIgYyA9IFtcbiAgICAgICAgW3YsIHQsIHBdLFxuICAgICAgICBbcSwgdiwgcF0sXG4gICAgICAgIFtwLCB2LCB0XSxcbiAgICAgICAgW3AsIHEsIHZdLFxuICAgICAgICBbdCwgcCwgdl0sXG4gICAgICAgIFt2LCBwLCBxXVxuICAgICAgXVtoaV07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHI6IGNbMF0gKiAyNTUsXG4gICAgICAgIGc6IGNbMV0gKiAyNTUsXG4gICAgICAgIGI6IGNbMl0gKiAyNTVcbiAgICAgIH07XG5cbiAgICB9LFxuXG4gICAgcmdiX3RvX2hzdjogZnVuY3Rpb24ociwgZywgYikge1xuXG4gICAgICB2YXIgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICAgICAgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgICAgICAgZGVsdGEgPSBtYXggLSBtaW4sXG4gICAgICAgICAgaCwgcztcblxuICAgICAgaWYgKG1heCAhPSAwKSB7XG4gICAgICAgIHMgPSBkZWx0YSAvIG1heDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaDogTmFOLFxuICAgICAgICAgIHM6IDAsXG4gICAgICAgICAgdjogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAociA9PSBtYXgpIHtcbiAgICAgICAgaCA9IChnIC0gYikgLyBkZWx0YTtcbiAgICAgIH0gZWxzZSBpZiAoZyA9PSBtYXgpIHtcbiAgICAgICAgaCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoID0gNCArIChyIC0gZykgLyBkZWx0YTtcbiAgICAgIH1cbiAgICAgIGggLz0gNjtcbiAgICAgIGlmIChoIDwgMCkge1xuICAgICAgICBoICs9IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGg6IGggKiAzNjAsXG4gICAgICAgIHM6IHMsXG4gICAgICAgIHY6IG1heCAvIDI1NVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgcmdiX3RvX2hleDogZnVuY3Rpb24ociwgZywgYikge1xuICAgICAgdmFyIGhleCA9IHRoaXMuaGV4X3dpdGhfY29tcG9uZW50KDAsIDIsIHIpO1xuICAgICAgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoaGV4LCAxLCBnKTtcbiAgICAgIGhleCA9IHRoaXMuaGV4X3dpdGhfY29tcG9uZW50KGhleCwgMCwgYik7XG4gICAgICByZXR1cm4gaGV4O1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRfZnJvbV9oZXg6IGZ1bmN0aW9uKGhleCwgY29tcG9uZW50SW5kZXgpIHtcbiAgICAgIHJldHVybiAoaGV4ID4+IChjb21wb25lbnRJbmRleCAqIDgpKSAmIDB4RkY7XG4gICAgfSxcblxuICAgIGhleF93aXRoX2NvbXBvbmVudDogZnVuY3Rpb24oaGV4LCBjb21wb25lbnRJbmRleCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8PCAodG1wQ29tcG9uZW50ID0gY29tcG9uZW50SW5kZXggKiA4KSB8IChoZXggJiB+ICgweEZGIDw8IHRtcENvbXBvbmVudCkpO1xuICAgIH1cblxuICB9XG5cbn0pKCksXG5kYXQuY29sb3IudG9TdHJpbmcsXG5kYXQudXRpbHMuY29tbW9uKSxcbmRhdC5jb2xvci5pbnRlcnByZXQsXG5kYXQudXRpbHMuY29tbW9uKSxcbmRhdC51dGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSAoZnVuY3Rpb24gKCkge1xuXG4gIC8qKlxuICAgKiByZXF1aXJlanMgdmVyc2lvbiBvZiBQYXVsIElyaXNoJ3MgUmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAqIGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXG4gICAqL1xuXG4gIHJldHVybiB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICBmdW5jdGlvbihjYWxsYmFjaywgZWxlbWVudCkge1xuXG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuXG4gICAgICB9O1xufSkoKSxcbmRhdC5kb20uQ2VudGVyZWREaXYgPSAoZnVuY3Rpb24gKGRvbSwgY29tbW9uKSB7XG5cblxuICB2YXIgQ2VudGVyZWREaXYgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb21tb24uZXh0ZW5kKHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUsIHtcbiAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC44KScsXG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgZGlzcGxheTogJ25vbmUnLFxuICAgICAgekluZGV4OiAnMTAwMCcsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgV2Via2l0VHJhbnNpdGlvbjogJ29wYWNpdHkgMC4ycyBsaW5lYXInXG4gICAgfSk7XG5cbiAgICBkb20ubWFrZUZ1bGxzY3JlZW4odGhpcy5iYWNrZ3JvdW5kRWxlbWVudCk7XG4gICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb21tb24uZXh0ZW5kKHRoaXMuZG9tRWxlbWVudC5zdHlsZSwge1xuICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgICB6SW5kZXg6ICcxMDAxJyxcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICBXZWJraXRUcmFuc2l0aW9uOiAnLXdlYmtpdC10cmFuc2Zvcm0gMC4ycyBlYXNlLW91dCwgb3BhY2l0eSAwLjJzIGxpbmVhcidcbiAgICB9KTtcblxuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmJhY2tncm91bmRFbGVtZW50KTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZG9tRWxlbWVudCk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGRvbS5iaW5kKHRoaXMuYmFja2dyb3VuZEVsZW1lbnQsICdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgX3RoaXMuaGlkZSgpO1xuICAgIH0pO1xuXG5cbiAgfTtcblxuICBDZW50ZXJlZERpdi5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBcblxuXG4gICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4vLyAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUudG9wID0gJzUyJSc7XG4gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgxLjEpJztcblxuICAgIHRoaXMubGF5b3V0KCk7XG5cbiAgICBjb21tb24uZGVmZXIoZnVuY3Rpb24oKSB7XG4gICAgICBfdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgIF90aGlzLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICBfdGhpcy5kb21FbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgxKSc7XG4gICAgfSk7XG5cbiAgfTtcblxuICBDZW50ZXJlZERpdi5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBoaWRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgIF90aGlzLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIF90aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgIGRvbS51bmJpbmQoX3RoaXMuZG9tRWxlbWVudCwgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBoaWRlKTtcbiAgICAgIGRvbS51bmJpbmQoX3RoaXMuZG9tRWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnLCBoaWRlKTtcbiAgICAgIGRvbS51bmJpbmQoX3RoaXMuZG9tRWxlbWVudCwgJ29UcmFuc2l0aW9uRW5kJywgaGlkZSk7XG5cbiAgICB9O1xuXG4gICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuICAgIGRvbS5iaW5kKHRoaXMuZG9tRWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnLCBoaWRlKTtcbiAgICBkb20uYmluZCh0aGlzLmRvbUVsZW1lbnQsICdvVHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuXG4gICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMDtcbi8vICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS50b3AgPSAnNDglJztcbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgxLjEpJztcblxuICB9O1xuXG4gIENlbnRlcmVkRGl2LnByb3RvdHlwZS5sYXlvdXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUubGVmdCA9IHdpbmRvdy5pbm5lcldpZHRoLzIgLSBkb20uZ2V0V2lkdGgodGhpcy5kb21FbGVtZW50KSAvIDIgKyAncHgnO1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS50b3AgPSB3aW5kb3cuaW5uZXJIZWlnaHQvMiAtIGRvbS5nZXRIZWlnaHQodGhpcy5kb21FbGVtZW50KSAvIDIgKyAncHgnO1xuICB9O1xuICBcbiAgZnVuY3Rpb24gbG9ja1Njcm9sbChlKSB7XG4gICAgY29uc29sZS5sb2coZSk7XG4gIH1cblxuICByZXR1cm4gQ2VudGVyZWREaXY7XG5cbn0pKGRhdC5kb20uZG9tLFxuZGF0LnV0aWxzLmNvbW1vbiksXG5kYXQuZG9tLmRvbSxcbmRhdC51dGlscy5jb21tb24pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RhdC1ndWkvdmVuZG9yL2RhdC5ndWkuanNcbi8vIG1vZHVsZSBpZCA9IDEyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCIvKipcbiAqIGRhdC1ndWkgSmF2YVNjcmlwdCBDb250cm9sbGVyIExpYnJhcnlcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9kYXQtZ3VpXG4gKlxuICogQ29weXJpZ2h0IDIwMTEgRGF0YSBBcnRzIFRlYW0sIEdvb2dsZSBDcmVhdGl2ZSBMYWJcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuLyoqIEBuYW1lc3BhY2UgKi9cbnZhciBkYXQgPSBtb2R1bGUuZXhwb3J0cyA9IGRhdCB8fCB7fTtcblxuLyoqIEBuYW1lc3BhY2UgKi9cbmRhdC5jb2xvciA9IGRhdC5jb2xvciB8fCB7fTtcblxuLyoqIEBuYW1lc3BhY2UgKi9cbmRhdC51dGlscyA9IGRhdC51dGlscyB8fCB7fTtcblxuZGF0LnV0aWxzLmNvbW1vbiA9IChmdW5jdGlvbiAoKSB7XG4gIFxuICB2YXIgQVJSX0VBQ0ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcbiAgdmFyIEFSUl9TTElDRSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAvKipcbiAgICogQmFuZC1haWQgbWV0aG9kcyBmb3IgdGhpbmdzIHRoYXQgc2hvdWxkIGJlIGEgbG90IGVhc2llciBpbiBKYXZhU2NyaXB0LlxuICAgKiBJbXBsZW1lbnRhdGlvbiBhbmQgc3RydWN0dXJlIGluc3BpcmVkIGJ5IHVuZGVyc2NvcmUuanNcbiAgICogaHR0cDovL2RvY3VtZW50Y2xvdWQuZ2l0aHViLmNvbS91bmRlcnNjb3JlL1xuICAgKi9cblxuICByZXR1cm4geyBcbiAgICBcbiAgICBCUkVBSzoge30sXG4gIFxuICAgIGV4dGVuZDogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICBcbiAgICAgIHRoaXMuZWFjaChBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopXG4gICAgICAgICAgaWYgKCF0aGlzLmlzVW5kZWZpbmVkKG9ialtrZXldKSkgXG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICBcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgXG4gICAgfSxcbiAgICBcbiAgICBkZWZhdWx0czogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICBcbiAgICAgIHRoaXMuZWFjaChBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopXG4gICAgICAgICAgaWYgKHRoaXMuaXNVbmRlZmluZWQodGFyZ2V0W2tleV0pKSBcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIFxuICAgICAgfSwgdGhpcyk7XG4gICAgICBcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgXG4gICAgfSxcbiAgICBcbiAgICBjb21wb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0b0NhbGwgPSBBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgYXJncyA9IEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0b0NhbGwubGVuZ3RoIC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBbdG9DYWxsW2ldLmFwcGx5KHRoaXMsIGFyZ3MpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gYXJnc1swXTtcbiAgICAgICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIGVhY2g6IGZ1bmN0aW9uKG9iaiwgaXRyLCBzY29wZSkge1xuXG4gICAgICBcbiAgICAgIGlmIChBUlJfRUFDSCAmJiBvYmouZm9yRWFjaCA9PT0gQVJSX0VBQ0gpIHsgXG4gICAgICAgIFxuICAgICAgICBvYmouZm9yRWFjaChpdHIsIHNjb3BlKTtcbiAgICAgICAgXG4gICAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09IG9iai5sZW5ndGggKyAwKSB7IC8vIElzIG51bWJlciBidXQgbm90IE5hTlxuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIga2V5ID0gMCwgbCA9IG9iai5sZW5ndGg7IGtleSA8IGw7IGtleSsrKVxuICAgICAgICAgIGlmIChrZXkgaW4gb2JqICYmIGl0ci5jYWxsKHNjb3BlLCBvYmpba2V5XSwga2V5KSA9PT0gdGhpcy5CUkVBSykgXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikgXG4gICAgICAgICAgaWYgKGl0ci5jYWxsKHNjb3BlLCBvYmpba2V5XSwga2V5KSA9PT0gdGhpcy5CUkVBSylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIFxuICAgICAgfVxuICAgICAgICAgICAgXG4gICAgfSxcbiAgICBcbiAgICBkZWZlcjogZnVuY3Rpb24oZm5jKSB7XG4gICAgICBzZXRUaW1lb3V0KGZuYywgMCk7XG4gICAgfSxcbiAgICBcbiAgICB0b0FycmF5OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvYmoudG9BcnJheSkgcmV0dXJuIG9iai50b0FycmF5KCk7XG4gICAgICByZXR1cm4gQVJSX1NMSUNFLmNhbGwob2JqKTtcbiAgICB9LFxuXG4gICAgaXNVbmRlZmluZWQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgXG4gICAgaXNOdWxsOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gICAgfSxcbiAgICBcbiAgICBpc05hTjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICE9PSBvYmo7XG4gICAgfSxcbiAgICBcbiAgICBpc0FycmF5OiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iai5jb25zdHJ1Y3RvciA9PT0gQXJyYXk7XG4gICAgfSxcbiAgICBcbiAgICBpc09iamVjdDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbiAgICB9LFxuICAgIFxuICAgIGlzTnVtYmVyOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IG9iaiswO1xuICAgIH0sXG4gICAgXG4gICAgaXNTdHJpbmc6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gb2JqKycnO1xuICAgIH0sXG4gICAgXG4gICAgaXNCb29sZWFuOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gdHJ1ZTtcbiAgICB9LFxuICAgIFxuICAgIGlzRnVuY3Rpb246IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgIH1cbiAgXG4gIH07XG4gICAgXG59KSgpO1xuXG5cbmRhdC5jb2xvci50b1N0cmluZyA9IChmdW5jdGlvbiAoY29tbW9uKSB7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbG9yKSB7XG5cbiAgICBpZiAoY29sb3IuYSA9PSAxIHx8IGNvbW1vbi5pc1VuZGVmaW5lZChjb2xvci5hKSkge1xuXG4gICAgICB2YXIgcyA9IGNvbG9yLmhleC50b1N0cmluZygxNik7XG4gICAgICB3aGlsZSAocy5sZW5ndGggPCA2KSB7XG4gICAgICAgIHMgPSAnMCcgKyBzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJyMnICsgcztcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHJldHVybiAncmdiYSgnICsgTWF0aC5yb3VuZChjb2xvci5yKSArICcsJyArIE1hdGgucm91bmQoY29sb3IuZykgKyAnLCcgKyBNYXRoLnJvdW5kKGNvbG9yLmIpICsgJywnICsgY29sb3IuYSArICcpJztcblxuICAgIH1cblxuICB9XG5cbn0pKGRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5Db2xvciA9IGRhdC5jb2xvci5Db2xvciA9IChmdW5jdGlvbiAoaW50ZXJwcmV0LCBtYXRoLCB0b1N0cmluZywgY29tbW9uKSB7XG5cbiAgdmFyIENvbG9yID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLl9fc3RhdGUgPSBpbnRlcnByZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyAnRmFpbGVkIHRvIGludGVycHJldCBjb2xvciBhcmd1bWVudHMnO1xuICAgIH1cblxuICAgIHRoaXMuX19zdGF0ZS5hID0gdGhpcy5fX3N0YXRlLmEgfHwgMTtcblxuXG4gIH07XG5cbiAgQ29sb3IuQ09NUE9ORU5UUyA9IFsncicsJ2cnLCdiJywnaCcsJ3MnLCd2JywnaGV4JywnYSddO1xuXG4gIGNvbW1vbi5leHRlbmQoQ29sb3IucHJvdG90eXBlLCB7XG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcodGhpcyk7XG4gICAgfSxcblxuICAgIHRvT3JpZ2luYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5jb252ZXJzaW9uLndyaXRlKHRoaXMpO1xuICAgIH1cblxuICB9KTtcblxuICBkZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAncicsIDIpO1xuICBkZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnZycsIDEpO1xuICBkZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnYicsIDApO1xuXG4gIGRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdoJyk7XG4gIGRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdzJyk7XG4gIGRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICd2Jyk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yLnByb3RvdHlwZSwgJ2EnLCB7XG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5hO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHRoaXMuX19zdGF0ZS5hID0gdjtcbiAgICB9XG5cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yLnByb3RvdHlwZSwgJ2hleCcsIHtcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIGlmICghdGhpcy5fX3N0YXRlLnNwYWNlICE9PSAnSEVYJykge1xuICAgICAgICB0aGlzLl9fc3RhdGUuaGV4ID0gbWF0aC5yZ2JfdG9faGV4KHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmhleDtcblxuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcblxuICAgICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ0hFWCc7XG4gICAgICB0aGlzLl9fc3RhdGUuaGV4ID0gdjtcblxuICAgIH1cblxuICB9KTtcblxuICBmdW5jdGlvbiBkZWZpbmVSR0JDb21wb25lbnQodGFyZ2V0LCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb21wb25lbnQsIHtcblxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlID09PSAnUkdCJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY2FsY3VsYXRlUkdCKHRoaXMsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcblxuICAgICAgfSxcblxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ1JHQicpIHtcbiAgICAgICAgICByZWNhbGN1bGF0ZVJHQih0aGlzLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KTtcbiAgICAgICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnUkdCJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdID0gdjtcblxuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmluZUhTVkNvbXBvbmVudCh0YXJnZXQsIGNvbXBvbmVudCkge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29tcG9uZW50LCB7XG5cbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSA9PT0gJ0hTVicpXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuXG4gICAgICAgIHJlY2FsY3VsYXRlSFNWKHRoaXMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcblxuICAgICAgfSxcblxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ0hTVicpIHtcbiAgICAgICAgICByZWNhbGN1bGF0ZUhTVih0aGlzKTtcbiAgICAgICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSFNWJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdID0gdjtcblxuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsY3VsYXRlUkdCKGNvbG9yLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KSB7XG5cbiAgICBpZiAoY29sb3IuX19zdGF0ZS5zcGFjZSA9PT0gJ0hFWCcpIHtcblxuICAgICAgY29sb3IuX19zdGF0ZVtjb21wb25lbnRdID0gbWF0aC5jb21wb25lbnRfZnJvbV9oZXgoY29sb3IuX19zdGF0ZS5oZXgsIGNvbXBvbmVudEhleEluZGV4KTtcblxuICAgIH0gZWxzZSBpZiAoY29sb3IuX19zdGF0ZS5zcGFjZSA9PT0gJ0hTVicpIHtcblxuICAgICAgY29tbW9uLmV4dGVuZChjb2xvci5fX3N0YXRlLCBtYXRoLmhzdl90b19yZ2IoY29sb3IuX19zdGF0ZS5oLCBjb2xvci5fX3N0YXRlLnMsIGNvbG9yLl9fc3RhdGUudikpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgdGhyb3cgJ0NvcnJ1cHRlZCBjb2xvciBzdGF0ZSc7XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsY3VsYXRlSFNWKGNvbG9yKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gbWF0aC5yZ2JfdG9faHN2KGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuXG4gICAgY29tbW9uLmV4dGVuZChjb2xvci5fX3N0YXRlLFxuICAgICAgICB7XG4gICAgICAgICAgczogcmVzdWx0LnMsXG4gICAgICAgICAgdjogcmVzdWx0LnZcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBpZiAoIWNvbW1vbi5pc05hTihyZXN1bHQuaCkpIHtcbiAgICAgIGNvbG9yLl9fc3RhdGUuaCA9IHJlc3VsdC5oO1xuICAgIH0gZWxzZSBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKGNvbG9yLl9fc3RhdGUuaCkpIHtcbiAgICAgIGNvbG9yLl9fc3RhdGUuaCA9IDA7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gQ29sb3I7XG5cbn0pKGRhdC5jb2xvci5pbnRlcnByZXQgPSAoZnVuY3Rpb24gKHRvU3RyaW5nLCBjb21tb24pIHtcblxuICB2YXIgcmVzdWx0LCB0b1JldHVybjtcblxuICB2YXIgaW50ZXJwcmV0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0b1JldHVybiA9IGZhbHNlO1xuXG4gICAgdmFyIG9yaWdpbmFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBjb21tb24udG9BcnJheShhcmd1bWVudHMpIDogYXJndW1lbnRzWzBdO1xuXG4gICAgY29tbW9uLmVhY2goSU5URVJQUkVUQVRJT05TLCBmdW5jdGlvbihmYW1pbHkpIHtcblxuICAgICAgaWYgKGZhbWlseS5saXRtdXMob3JpZ2luYWwpKSB7XG5cbiAgICAgICAgY29tbW9uLmVhY2goZmFtaWx5LmNvbnZlcnNpb25zLCBmdW5jdGlvbihjb252ZXJzaW9uLCBjb252ZXJzaW9uTmFtZSkge1xuXG4gICAgICAgICAgcmVzdWx0ID0gY29udmVyc2lvbi5yZWFkKG9yaWdpbmFsKTtcblxuICAgICAgICAgIGlmICh0b1JldHVybiA9PT0gZmFsc2UgJiYgcmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdG9SZXR1cm4gPSByZXN1bHQ7XG4gICAgICAgICAgICByZXN1bHQuY29udmVyc2lvbk5hbWUgPSBjb252ZXJzaW9uTmFtZTtcbiAgICAgICAgICAgIHJlc3VsdC5jb252ZXJzaW9uID0gY29udmVyc2lvbjtcbiAgICAgICAgICAgIHJldHVybiBjb21tb24uQlJFQUs7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbW1vbi5CUkVBSztcblxuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdG9SZXR1cm47XG5cbiAgfTtcblxuICB2YXIgSU5URVJQUkVUQVRJT05TID0gW1xuXG4gICAgLy8gU3RyaW5nc1xuICAgIHtcblxuICAgICAgbGl0bXVzOiBjb21tb24uaXNTdHJpbmcsXG5cbiAgICAgIGNvbnZlcnNpb25zOiB7XG5cbiAgICAgICAgVEhSRUVfQ0hBUl9IRVg6IHtcblxuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG5cbiAgICAgICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL14jKFtBLUYwLTldKShbQS1GMC05XSkoW0EtRjAtOV0pJC9pKTtcbiAgICAgICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnSEVYJyxcbiAgICAgICAgICAgICAgaGV4OiBwYXJzZUludChcbiAgICAgICAgICAgICAgICAgICcweCcgK1xuICAgICAgICAgICAgICAgICAgICAgIHRlc3RbMV0udG9TdHJpbmcoKSArIHRlc3RbMV0udG9TdHJpbmcoKSArXG4gICAgICAgICAgICAgICAgICAgICAgdGVzdFsyXS50b1N0cmluZygpICsgdGVzdFsyXS50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXN0WzNdLnRvU3RyaW5nKCkgKyB0ZXN0WzNdLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiB0b1N0cmluZ1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgU0lYX0NIQVJfSEVYOiB7XG5cbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuXG4gICAgICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9eIyhbQS1GMC05XXs2fSkkL2kpO1xuICAgICAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgICAgICBoZXg6IHBhcnNlSW50KCcweCcgKyB0ZXN0WzFdLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiB0b1N0cmluZ1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgQ1NTX1JHQjoge1xuXG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXnJnYlxcKFxccyooLispXFxzKixcXHMqKC4rKVxccyosXFxzKiguKylcXHMqXFwpLyk7XG4gICAgICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgIHI6IHBhcnNlRmxvYXQodGVzdFsxXSksXG4gICAgICAgICAgICAgIGc6IHBhcnNlRmxvYXQodGVzdFsyXSksXG4gICAgICAgICAgICAgIGI6IHBhcnNlRmxvYXQodGVzdFszXSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IHRvU3RyaW5nXG5cbiAgICAgICAgfSxcblxuICAgICAgICBDU1NfUkdCQToge1xuXG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXnJnYmFcXChcXHMqKC4rKVxccyosXFxzKiguKylcXHMqLFxccyooLispXFxzKlxcLFxccyooLispXFxzKlxcKS8pO1xuICAgICAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICByOiBwYXJzZUZsb2F0KHRlc3RbMV0pLFxuICAgICAgICAgICAgICBnOiBwYXJzZUZsb2F0KHRlc3RbMl0pLFxuICAgICAgICAgICAgICBiOiBwYXJzZUZsb2F0KHRlc3RbM10pLFxuICAgICAgICAgICAgICBhOiBwYXJzZUZsb2F0KHRlc3RbNF0pXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiB0b1N0cmluZ1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8vIE51bWJlcnNcbiAgICB7XG5cbiAgICAgIGxpdG11czogY29tbW9uLmlzTnVtYmVyLFxuXG4gICAgICBjb252ZXJzaW9uczoge1xuXG4gICAgICAgIEhFWDoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgICAgIGhleDogb3JpZ2luYWwsXG4gICAgICAgICAgICAgIGNvbnZlcnNpb25OYW1lOiAnSEVYJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xvci5oZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvLyBBcnJheXNcbiAgICB7XG5cbiAgICAgIGxpdG11czogY29tbW9uLmlzQXJyYXksXG5cbiAgICAgIGNvbnZlcnNpb25zOiB7XG5cbiAgICAgICAgUkdCX0FSUkFZOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGggIT0gMykgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICByOiBvcmlnaW5hbFswXSxcbiAgICAgICAgICAgICAgZzogb3JpZ2luYWxbMV0sXG4gICAgICAgICAgICAgIGI6IG9yaWdpbmFsWzJdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBbY29sb3IuciwgY29sb3IuZywgY29sb3IuYl07XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgUkdCQV9BUlJBWToge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwubGVuZ3RoICE9IDQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgcjogb3JpZ2luYWxbMF0sXG4gICAgICAgICAgICAgIGc6IG9yaWdpbmFsWzFdLFxuICAgICAgICAgICAgICBiOiBvcmlnaW5hbFsyXSxcbiAgICAgICAgICAgICAgYTogb3JpZ2luYWxbM11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIFtjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCBjb2xvci5hXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLy8gT2JqZWN0c1xuICAgIHtcblxuICAgICAgbGl0bXVzOiBjb21tb24uaXNPYmplY3QsXG5cbiAgICAgIGNvbnZlcnNpb25zOiB7XG5cbiAgICAgICAgUkdCQV9PQko6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5yKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5nKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5iKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5hKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgICByOiBvcmlnaW5hbC5yLFxuICAgICAgICAgICAgICAgIGc6IG9yaWdpbmFsLmcsXG4gICAgICAgICAgICAgICAgYjogb3JpZ2luYWwuYixcbiAgICAgICAgICAgICAgICBhOiBvcmlnaW5hbC5hXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICByOiBjb2xvci5yLFxuICAgICAgICAgICAgICBnOiBjb2xvci5nLFxuICAgICAgICAgICAgICBiOiBjb2xvci5iLFxuICAgICAgICAgICAgICBhOiBjb2xvci5hXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIFJHQl9PQko6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5yKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5nKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5iKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgICByOiBvcmlnaW5hbC5yLFxuICAgICAgICAgICAgICAgIGc6IG9yaWdpbmFsLmcsXG4gICAgICAgICAgICAgICAgYjogb3JpZ2luYWwuYlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcjogY29sb3IucixcbiAgICAgICAgICAgICAgZzogY29sb3IuZyxcbiAgICAgICAgICAgICAgYjogY29sb3IuYlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBIU1ZBX09CSjoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmgpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnMpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnYpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmEpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3BhY2U6ICdIU1YnLFxuICAgICAgICAgICAgICAgIGg6IG9yaWdpbmFsLmgsXG4gICAgICAgICAgICAgICAgczogb3JpZ2luYWwucyxcbiAgICAgICAgICAgICAgICB2OiBvcmlnaW5hbC52LFxuICAgICAgICAgICAgICAgIGE6IG9yaWdpbmFsLmFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGg6IGNvbG9yLmgsXG4gICAgICAgICAgICAgIHM6IGNvbG9yLnMsXG4gICAgICAgICAgICAgIHY6IGNvbG9yLnYsXG4gICAgICAgICAgICAgIGE6IGNvbG9yLmFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgSFNWX09CSjoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmgpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnMpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnYpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3BhY2U6ICdIU1YnLFxuICAgICAgICAgICAgICAgIGg6IG9yaWdpbmFsLmgsXG4gICAgICAgICAgICAgICAgczogb3JpZ2luYWwucyxcbiAgICAgICAgICAgICAgICB2OiBvcmlnaW5hbC52XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBoOiBjb2xvci5oLFxuICAgICAgICAgICAgICBzOiBjb2xvci5zLFxuICAgICAgICAgICAgICB2OiBjb2xvci52XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG5cbiAgXTtcblxuICByZXR1cm4gaW50ZXJwcmV0O1xuXG5cbn0pKGRhdC5jb2xvci50b1N0cmluZyxcbmRhdC51dGlscy5jb21tb24pLFxuZGF0LmNvbG9yLm1hdGggPSAoZnVuY3Rpb24gKCkge1xuXG4gIHZhciB0bXBDb21wb25lbnQ7XG5cbiAgcmV0dXJuIHtcblxuICAgIGhzdl90b19yZ2I6IGZ1bmN0aW9uKGgsIHMsIHYpIHtcblxuICAgICAgdmFyIGhpID0gTWF0aC5mbG9vcihoIC8gNjApICUgNjtcblxuICAgICAgdmFyIGYgPSBoIC8gNjAgLSBNYXRoLmZsb29yKGggLyA2MCk7XG4gICAgICB2YXIgcCA9IHYgKiAoMS4wIC0gcyk7XG4gICAgICB2YXIgcSA9IHYgKiAoMS4wIC0gKGYgKiBzKSk7XG4gICAgICB2YXIgdCA9IHYgKiAoMS4wIC0gKCgxLjAgLSBmKSAqIHMpKTtcbiAgICAgIHZhciBjID0gW1xuICAgICAgICBbdiwgdCwgcF0sXG4gICAgICAgIFtxLCB2LCBwXSxcbiAgICAgICAgW3AsIHYsIHRdLFxuICAgICAgICBbcCwgcSwgdl0sXG4gICAgICAgIFt0LCBwLCB2XSxcbiAgICAgICAgW3YsIHAsIHFdXG4gICAgICBdW2hpXTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcjogY1swXSAqIDI1NSxcbiAgICAgICAgZzogY1sxXSAqIDI1NSxcbiAgICAgICAgYjogY1syXSAqIDI1NVxuICAgICAgfTtcblxuICAgIH0sXG5cbiAgICByZ2JfdG9faHN2OiBmdW5jdGlvbihyLCBnLCBiKSB7XG5cbiAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgICAgICBkZWx0YSA9IG1heCAtIG1pbixcbiAgICAgICAgICBoLCBzO1xuXG4gICAgICBpZiAobWF4ICE9IDApIHtcbiAgICAgICAgcyA9IGRlbHRhIC8gbWF4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoOiBOYU4sXG4gICAgICAgICAgczogMCxcbiAgICAgICAgICB2OiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChyID09IG1heCkge1xuICAgICAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICAgICAgfSBlbHNlIGlmIChnID09IG1heCkge1xuICAgICAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuICAgICAgfVxuICAgICAgaCAvPSA2O1xuICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgIGggKz0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaDogaCAqIDM2MCxcbiAgICAgICAgczogcyxcbiAgICAgICAgdjogbWF4IC8gMjU1XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICByZ2JfdG9faGV4OiBmdW5jdGlvbihyLCBnLCBiKSB7XG4gICAgICB2YXIgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoMCwgMiwgcik7XG4gICAgICBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudChoZXgsIDEsIGcpO1xuICAgICAgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoaGV4LCAwLCBiKTtcbiAgICAgIHJldHVybiBoZXg7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudF9mcm9tX2hleDogZnVuY3Rpb24oaGV4LCBjb21wb25lbnRJbmRleCkge1xuICAgICAgcmV0dXJuIChoZXggPj4gKGNvbXBvbmVudEluZGV4ICogOCkpICYgMHhGRjtcbiAgICB9LFxuXG4gICAgaGV4X3dpdGhfY29tcG9uZW50OiBmdW5jdGlvbihoZXgsIGNvbXBvbmVudEluZGV4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIDw8ICh0bXBDb21wb25lbnQgPSBjb21wb25lbnRJbmRleCAqIDgpIHwgKGhleCAmIH4gKDB4RkYgPDwgdG1wQ29tcG9uZW50KSk7XG4gICAgfVxuXG4gIH1cblxufSkoKSxcbmRhdC5jb2xvci50b1N0cmluZyxcbmRhdC51dGlscy5jb21tb24pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RhdC1ndWkvdmVuZG9yL2RhdC5jb2xvci5qc1xuLy8gbW9kdWxlIGlkID0gMTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIi8vIHN0YXRzLmpzIC0gaHR0cDovL2dpdGh1Yi5jb20vbXJkb29iL3N0YXRzLmpzXG4oZnVuY3Rpb24oZixlKXtcIm9iamVjdFwiPT09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPWUoKTpcImZ1bmN0aW9uXCI9PT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShlKTpmLlN0YXRzPWUoKX0pKHRoaXMsZnVuY3Rpb24oKXt2YXIgZj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoYSl7Yy5hcHBlbmRDaGlsZChhLmRvbSk7cmV0dXJuIGF9ZnVuY3Rpb24gdShhKXtmb3IodmFyIGQ9MDtkPGMuY2hpbGRyZW4ubGVuZ3RoO2QrKyljLmNoaWxkcmVuW2RdLnN0eWxlLmRpc3BsYXk9ZD09PWE/XCJibG9ja1wiOlwibm9uZVwiO2w9YX12YXIgbD0wLGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtjLnN0eWxlLmNzc1RleHQ9XCJwb3NpdGlvbjpmaXhlZDt0b3A6MDtsZWZ0OjA7Y3Vyc29yOnBvaW50ZXI7b3BhY2l0eTowLjk7ei1pbmRleDoxMDAwMFwiO2MuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsZnVuY3Rpb24oYSl7YS5wcmV2ZW50RGVmYXVsdCgpO1xudSgrK2wlYy5jaGlsZHJlbi5sZW5ndGgpfSwhMSk7dmFyIGs9KHBlcmZvcm1hbmNlfHxEYXRlKS5ub3coKSxnPWssYT0wLHI9ZShuZXcgZi5QYW5lbChcIkZQU1wiLFwiIzBmZlwiLFwiIzAwMlwiKSksaD1lKG5ldyBmLlBhbmVsKFwiTVNcIixcIiMwZjBcIixcIiMwMjBcIikpO2lmKHNlbGYucGVyZm9ybWFuY2UmJnNlbGYucGVyZm9ybWFuY2UubWVtb3J5KXZhciB0PWUobmV3IGYuUGFuZWwoXCJNQlwiLFwiI2YwOFwiLFwiIzIwMVwiKSk7dSgwKTtyZXR1cm57UkVWSVNJT046MTYsZG9tOmMsYWRkUGFuZWw6ZSxzaG93UGFuZWw6dSxiZWdpbjpmdW5jdGlvbigpe2s9KHBlcmZvcm1hbmNlfHxEYXRlKS5ub3coKX0sZW5kOmZ1bmN0aW9uKCl7YSsrO3ZhciBjPShwZXJmb3JtYW5jZXx8RGF0ZSkubm93KCk7aC51cGRhdGUoYy1rLDIwMCk7aWYoYz5nKzFFMyYmKHIudXBkYXRlKDFFMyphLyhjLWcpLDEwMCksZz1jLGE9MCx0KSl7dmFyIGQ9cGVyZm9ybWFuY2UubWVtb3J5O3QudXBkYXRlKGQudXNlZEpTSGVhcFNpemUvXG4xMDQ4NTc2LGQuanNIZWFwU2l6ZUxpbWl0LzEwNDg1NzYpfXJldHVybiBjfSx1cGRhdGU6ZnVuY3Rpb24oKXtrPXRoaXMuZW5kKCl9LGRvbUVsZW1lbnQ6YyxzZXRNb2RlOnV9fTtmLlBhbmVsPWZ1bmN0aW9uKGUsZixsKXt2YXIgYz1JbmZpbml0eSxrPTAsZz1NYXRoLnJvdW5kLGE9Zyh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb3x8MSkscj04MCphLGg9NDgqYSx0PTMqYSx2PTIqYSxkPTMqYSxtPTE1KmEsbj03NCphLHA9MzAqYSxxPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7cS53aWR0aD1yO3EuaGVpZ2h0PWg7cS5zdHlsZS5jc3NUZXh0PVwid2lkdGg6ODBweDtoZWlnaHQ6NDhweFwiO3ZhciBiPXEuZ2V0Q29udGV4dChcIjJkXCIpO2IuZm9udD1cImJvbGQgXCIrOSphK1wicHggSGVsdmV0aWNhLEFyaWFsLHNhbnMtc2VyaWZcIjtiLnRleHRCYXNlbGluZT1cInRvcFwiO2IuZmlsbFN0eWxlPWw7Yi5maWxsUmVjdCgwLDAscixoKTtiLmZpbGxTdHlsZT1mO2IuZmlsbFRleHQoZSx0LHYpO1xuYi5maWxsUmVjdChkLG0sbixwKTtiLmZpbGxTdHlsZT1sO2IuZ2xvYmFsQWxwaGE9Ljk7Yi5maWxsUmVjdChkLG0sbixwKTtyZXR1cm57ZG9tOnEsdXBkYXRlOmZ1bmN0aW9uKGgsdyl7Yz1NYXRoLm1pbihjLGgpO2s9TWF0aC5tYXgoayxoKTtiLmZpbGxTdHlsZT1sO2IuZ2xvYmFsQWxwaGE9MTtiLmZpbGxSZWN0KDAsMCxyLG0pO2IuZmlsbFN0eWxlPWY7Yi5maWxsVGV4dChnKGgpK1wiIFwiK2UrXCIgKFwiK2coYykrXCItXCIrZyhrKStcIilcIix0LHYpO2IuZHJhd0ltYWdlKHEsZCthLG0sbi1hLHAsZCxtLG4tYSxwKTtiLmZpbGxSZWN0KGQrbi1hLG0sYSxwKTtiLmZpbGxTdHlsZT1sO2IuZ2xvYmFsQWxwaGE9Ljk7Yi5maWxsUmVjdChkK24tYSxtLGEsZygoMS1oL3cpKnApKX19fTtyZXR1cm4gZn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc3RhdHMuanMvYnVpbGQvc3RhdHMubWluLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sInNvdXJjZVJvb3QiOiIifQ==